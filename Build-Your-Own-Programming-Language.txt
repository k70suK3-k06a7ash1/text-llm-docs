├── LICENSE
├── README.md
├── ch11
    ├── Op.icn
    ├── Op.java
    ├── hello.j0
    ├── hello.java
    ├── j0machine.icn
    ├── j0machine.java
    ├── j0x.icn
    ├── j0x.java
    ├── makefile
    └── writehello.icn
├── ch12
    ├── Op.icn
    ├── Op.java
    ├── address.icn
    ├── address.java
    ├── arraytype.java
    ├── byc.icn
    ├── byc.java
    ├── classtype.java
    ├── hello.icn
    ├── hello.j0
    ├── hello.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.y
    ├── j0machine.icn
    ├── j0machine.java
    ├── j0x.icn
    ├── j0x.java
    ├── javalex.l
    ├── makefile
    ├── methodtype.java
    ├── parameter.java
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── tac.icn
    ├── tac.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── typeinfo.icn
    ├── typeinfo.java
    ├── yyerror.icn
    └── yyerror.java
├── ch13
    ├── Op.icn
    ├── Op.java
    ├── RegUse.java
    ├── address.icn
    ├── address.java
    ├── arraytype.java
    ├── byc.icn
    ├── byc.java
    ├── classtype.java
    ├── hello.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.y
    ├── j0machine.icn
    ├── j0machine.java
    ├── j0x.icn
    ├── j0x.java
    ├── javalex.l
    ├── makefile
    ├── methodtype.java
    ├── parameter.java
    ├── reguse.icn
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── tac.icn
    ├── tac.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── typeinfo.icn
    ├── typeinfo.java
    ├── x64.icn
    ├── x64.java
    ├── x64loc.icn
    ├── x64loc.java
    ├── yyerror.icn
    └── yyerror.java
├── ch3
    ├── dorrie.in
    ├── dorrie2.in
    ├── hello.java
    ├── j0.icn
    ├── j0.java
    ├── j0go.icn
    ├── j0go.java
    ├── javalex.l
    ├── nnws-tok.l
    ├── nnws.l
    ├── parser.java
    ├── simple.icn
    ├── simple.java
    ├── simple2.icn
    ├── simple2.java
    └── token.java
├── ch4
    ├── Parser.java
    ├── Yylex.java
    ├── dorrie3.in
    ├── hello.java
    ├── helloerror.java
    ├── j0.icn
    ├── j0.java
    ├── j0go.icn
    ├── j0go.java
    ├── j0gram.icn
    ├── j0gram.y
    ├── j0gram_tab.icn
    ├── javalex.icn
    ├── javalex.l
    ├── jzero.java
    ├── lexer.java
    ├── nameseq.y
    ├── nnws.l
    ├── ns.icn
    ├── ns.y
    ├── ns_tab.icn
    ├── parserTokens.java
    ├── parserVal.java
    ├── token.java
    ├── trivial.icn
    ├── trivial.java
    ├── yyerror.icn
    └── yyerror.java
├── ch5
    ├── Yylex.java
    ├── cereal.icn
    ├── hello.java
    ├── helloerror.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.icn
    ├── j0gram.y
    ├── j0gram_tab.icn
    ├── javalex.icn
    ├── javalex.l
    ├── makefile
    ├── parser.java
    ├── parserVal.java
    ├── prodrule.java
    ├── serial.icn
    ├── serial.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── xy5.java
    ├── yyerror.icn
    └── yyerror.java
├── ch6
    ├── hello.java
    ├── helloerror.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.y
    ├── javalex.l
    ├── makefile
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── xy5.java
    ├── yyerror.icn
    └── yyerror.java
├── ch7
    ├── Yylex.java
    ├── arraytype.java
    ├── classtype.java
    ├── hello.java
    ├── helloerror.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.icn
    ├── j0gram.y
    ├── j0gram_tab.icn
    ├── javalex.icn
    ├── javalex.l
    ├── makefile
    ├── methodtype.java
    ├── parameter.java
    ├── parserVal.java
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── typeinfo.icn
    ├── typeinfo.java
    ├── xy5.java
    ├── yyerror.icn
    └── yyerror.java
├── ch8
    ├── arraytype.java
    ├── arrtst.java
    ├── classtype.java
    ├── clstest.java
    ├── funtest.java
    ├── hello.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.y
    ├── javalex.l
    ├── makefile
    ├── methodtype.java
    ├── parameter.java
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── typeinfo.icn
    ├── typeinfo.java
    ├── xy5.java
    ├── yyerror.icn
    └── yyerror.java
└── ch9
    ├── Yylex.java
    ├── address.icn
    ├── address.java
    ├── arraytype.java
    ├── arrtst.java
    ├── classtype.java
    ├── clstest.java
    ├── funtest.java
    ├── hello.java
    ├── helloerror.java
    ├── j0.icn
    ├── j0.java
    ├── j0gram.icn
    ├── j0gram.y
    ├── j0gram_tab.icn
    ├── javalex.icn
    ├── javalex.l
    ├── makefile
    ├── methodtype.java
    ├── parameter.java
    ├── parser.java
    ├── parserVal.java
    ├── serial.icn
    ├── serial.java
    ├── symtab.icn
    ├── symtab.java
    ├── symtab_entry.icn
    ├── symtab_entry.java
    ├── tac.icn
    ├── tac.java
    ├── token.icn
    ├── token.java
    ├── tree.icn
    ├── tree.java
    ├── typeinfo.icn
    ├── typeinfo.java
    ├── xy5.java
    ├── yyerror.icn
    └── yyerror.java


/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2020 Packt
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
 1 | 
 2 | 
 3 | 
 4 | # Build Your Own Programming Language 
 5 | 
 6 | <a href="https://www.packtpub.com/programming/build-your-own-programming-language?utm_source=github&utm_medium=repository&utm_campaign=9781800204805"><img src="https://static.packt-cdn.com/products/9781800204805/cover/smaller" alt="Build Your Own Programming Language " height="256px" align="right"></a>
 7 | 
 8 | This is the code repository for [Build Your Own Programming Language ](https://www.packtpub.com/programming/build-your-own-programming-language?utm_source=github&utm_medium=repository&utm_campaign=9781800204805), published by Packt.
 9 | 
10 | **A programmer's guide to designing compilers, interpreters, and DSLs for solving modern computing problems**
11 | 
12 | ## What is this book about?
13 | The need for different types of computer languages is growing rapidly and developers prefer creating domain-specific languages for solving specific application domain problems. Building your own programming language has its advantages. It can be your antidote to the ever-increasing size and complexity of software. However, creating a custom language isn't easy. 
14 | 
15 | This book covers the following exciting features:
16 | - Perform requirements analysis for the new language and design language syntax and semantics.
17 | - Write lexical and context-free grammar rules for common expressions and control structures.
18 | - Develop a scanner that reads source code and generate a parser that checks syntax.
19 | - Build key data structures in a compiler and use your compiler to build a syntax-coloring code editor.
20 | - Implement a bytecode interpreter and run bytecode generated by your compiler.
21 | - Write tree traversals that insert information into the syntax tree.
22 | - Implement garbage collection in your language.
23 | 
24 | If you feel this book is for you, get your [copy](https://www.amazon.com/dp/1800204809) today!
25 | 
26 | 
27 | ## Instructions and Navigations
28 | All of the code is organized into folders. For example, Chapter02.
29 | 
30 | The code will look like the following:
31 | ```
32 | procedure main(argv)
33 |     simple := simple()
34 |     yyin := open(argv[1])
35 |     while i := yylex() do
36 |         write(yytext, ": ", i)
37 | end
38 | ```
39 | 
40 | **Following is what you need for this book:**
41 | This book is for software developers interested in the idea of inventing their own language or developing a domain-specific language. Computer science students taking compiler construction courses will also find this book highly useful as a practical guide to language implementation to supplement more theoretical textbooks. Intermediate-level knowledge and experience working with a high-level language such as Java or the C++ language are expected to help you get the most out of this book.
42 | 
43 | With the following software and hardware list you can run all code files present in the book (Chapter 1-17).
44 | ### Software and Hardware List
45 | | Chapter | Software required | OS required |
46 | | -------- | ------------------------------------ | ----------------------------------- |
47 | | 3-16 | Uflex, Jflex, Unicon, Java | Windows, Mac OS X, and Linux (Any) |
48 | 
49 | We also provide a PDF file that has color images of the screenshots/diagrams used in this book. [Click here to download it](https://static.packt-cdn.com/downloads/9781800204805_ColorImages.pdf).
50 | 
51 | ## Code in Action
52 | The Code in Action videos for this book can be viewed at https://bit.ly/3njc15D.
53 | 
54 | ### Related products
55 | * Supercharge Your Applications with GraalVM  [[Packt]](https://www.packtpub.com/product/supercharge-your-applications-with-graalvm/9781800564909?utm_source=github&utm_medium=repository&utm_campaign=9781800564909) [[Amazon]](https://www.amazon.com/dp/1800564902)
56 | 
57 | * Learn LLVM 12  [[Packt]](https://www.packtpub.com/product/learn-llvm-12/9781839213502?utm_source=github&utm_medium=repository&utm_campaign=9781839213502) [[Amazon]](https://www.amazon.com/dp/1839213507)
58 | 
59 | * LLVM Techniques, Tips, and Best Practices Clang and Middle-End Libraries  [[Packt]](https://www.packtpub.com/product/llvm-techniques-tips-and-best-practices-clang-and-middle-end-libraries/9781838824952?utm_source=github&utm_medium=repository&utm_campaign=9781838824952) [[Amazon]](https://www.amazon.com/dp/1838824952)
60 | 
61 | 
62 | ## Get to Know the Author
63 | **Clinton L. Jeffery**
64 | is Professor and Chair of the Department of Computer Science and Engineering at New Mexico Institute of Mining and Technology. He received his B.S. from the University of Washington, and M.S. and Ph.D. degrees from the University of Arizona, all in computer science. He has conducted research and written many books and papers on programming languages, program monitoring, debugging, graphics, virtual environments, and visualization. With colleagues, he invented the Unicon programming language, hosted on the Unicon website.
65 | 
66 | ### Download a free PDF
67 | 
68 |  <i>If you have already purchased a print or Kindle version of this book, you can get a DRM-free PDF version at no cost.<br>Simply click on the link to claim your free PDF.</i>
69 | <p align="center"> <a href="https://packt.link/free-ebook/9781800204805">https://packt.link/free-ebook/9781800204805 </a> </p>


--------------------------------------------------------------------------------
/ch11/Op.icn:
--------------------------------------------------------------------------------
 1 | class Op(HALT, NOOP, ADD, SUB, MUL, DIV, MOD, NEG, PUSH, POP, CALL, RETURN, GOTO, BIF,
 2 | 	 LT, LE, GT, GE, EQ, NEQ, LOCAL, LOAD, STORE, R_NONE, R_ABS, R_IMM, R_STACK, R_HEAP)
 3 | initially
 4 |   HALT := 1;  NOOP := 2; ADD := 3; SUB := 4; MUL := 5
 5 |   DIV := 6; MOD := 7; NEG := 8; PUSH := 9; POP := 10
 6 |   CALL := 11; RETURN := 12; GOTO := 13; BIF := 14; LT := 15
 7 |   LE := 16; GT := 17; GE := 18; EQ := 19; NEQ := 20;
 8 |   LOCAL := 21; LOAD := 22; STORE := 23
 9 |   R_NONE := 0; R_ABS := 1; R_IMM := 2
10 |   R_STACK := 3; R_HEAP := 4
11 |   Op := self
12 | end
13 | 
14 | procedure OpStr(i)
15 |    if type(Op)~=="Op__state" then Op()
16 |    case i of {
17 |        Op.HALT: return "HALT"
18 |        Op.NOOP: return "NOOP"
19 |        Op.ADD:  return "ADD"
20 |        Op.SUB:  return "SUB"
21 |        Op.MUL:  return "MUL"
22 |        Op.DIV:  return "DIV"
23 |        Op.MOD:  return "MOD"
24 |        Op.NEG:  return "NEG"
25 |        Op.PUSH: return "PUSH"
26 |        Op.POP:  return "POP"
27 |        Op.CALL: return "CALL"
28 |        Op.RETURN: return "RETURN"
29 |        Op.GOTO: return "GOTO"
30 |        Op.BIF: return "BIF"
31 |        Op.LT: return "LT"
32 |        Op.LE: return "LE"
33 |        Op.GT: return "GT"
34 |        Op.GE: return "GE"
35 |        Op.EQ: return "EQ"
36 |        Op.NEQ: return "NEQ"
37 |        Op.LOCAL: return "LOCAL"
38 |        Op.LOAD: return "LOAD"
39 |        Op.STORE: return "STORE"
40 |        default: return "(unknown:"||image(i)||")"
41 |    }
42 | end
43 | 
44 | procedure OpRStr(opr)
45 |    if type(Op)~=="Op__state" then Op()
46 |    case opr of {
47 |      Op.R_NONE: return "NONE"
48 |      Op.R_ABS:  return "ABS"
49 |      Op.R_IMM:  return "IMM"
50 |      Op.R_STACK: return "STACK"
51 |      Op.R_HEAP: return "HEAP"
52 |    }
53 | end
54 | 


--------------------------------------------------------------------------------
/ch11/Op.java:
--------------------------------------------------------------------------------
1 | public class Op {
2 |   public final static short HALT=1, NOOP=2, ADD=3, SUB=4,
3 |     MUL=5, DIV=6, MOD=7, NEG=8, PUSH=9, POP=10, CALL=11,
4 |     RETURN=12, GOTO=13, BIF=14, LT=15, LE=16, GT=17, GE=18,
5 |     EQ=19, NEQ=20, LOCAL=21, LOAD=22, STORE=23;
6 |   public final static short R_NONE=0, R_ABS=1, R_IMM=2,
7 |     R_STACK=3, R_HEAP=4;
8 | }
9 | 


--------------------------------------------------------------------------------
/ch11/hello.j0:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/PacktPublishing/Build-Your-Own-Programming-Language/714a2367238d52144843a871b68f908fdee5f5b2/ch11/hello.j0


--------------------------------------------------------------------------------
/ch11/hello.java:
--------------------------------------------------------------------------------
 1 | public class hello {
 2 |    public static void main(String argv[]) {
 3 |       int x = argv.length;
 4 |       x = x + 2;
 5 |       if (x > 3) {
 6 |          System.out.println("hello, jzero!");
 7 |       }
 8 |    }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch11/j0machine.icn:
--------------------------------------------------------------------------------
  1 | link signed
  2 | class j0machine(code, ip, stack, data, finstr, sp, bp, hp, op, opr, opnd)
  3 |   # loadbytecode at present returns everything after the first two-words of header
  4 |   method loadbytecode(filename)
  5 |     sz := stat(filename).size
  6 |     f := open(filename) | stop("cannot open ", filename)
  7 |     s := reads(f, sz) | stop("cannot read from ", filename)
  8 |     close(f)
  9 |     s ? {
 10 |       if tab(find("Jzero!!\0001.0\0\0\0\0\0")) then {
 11 |         return tab(0)
 12 |         }
 13 |       else stop("file ", filename, " is not a Jzero file")
 14 |       }
 15 |   end
 16 |   method init(filename)
 17 |     ip := 0
 18 |     code := loadbytecode(filename) |
 19 |       stop("cannot open program.j0")
 20 |     Op()
 21 |     ip := 16
 22 |     ip := finstr := 8*getOpnd()
 23 |     data := Data(code[25:ip+1])
 24 |     stack := list()
 25 |     bp := sp := 1
 26 |   end
 27 |   method fetch()
 28 |     op := ord(code[1+ip])
 29 |     opr := ord(code[2+ip])
 30 |     if opr ~= 0 then { opnd := getOpnd() }
 31 |     ip +:= 8
 32 |   end
 33 |   method getOpnd()
 34 |     return signed(reverse(code[ip+3+:6]))
 35 |   end
 36 |   method word(s)
 37 |    local i := 0, j
 38 |      every j := 8 to 1 by -1 do {
 39 |        b := ord(s[j])
 40 |        i := ishift(i, 8) + ord(b)
 41 |      }
 42 |    return i
 43 |   end
 44 |   method interp()
 45 |     repeat {
 46 |       fetch()
 47 |       case (op) of {
 48 |          Op.HALT: { stop("Execution completed.") }
 49 |          Op.NOOP: {   }
 50 |          Op.ADD: {
 51 |            val1 := pop(stack); val2 := pop(stack)
 52 |            push(stack, val1 + val2)
 53 |            }
 54 |          Op.PUSH: {
 55 |            (val := deref(opr, opnd)) | stop("deref failed")
 56 |            push(stack, val)
 57 |            }
 58 |          Op.POP: {
 59 |            val := pop(stack)
 60 |            assign(opnd, val)
 61 |            }
 62 |          Op.GOTO: {
 63 |            ip := opnd
 64 |            }
 65 |          Op.BIF: {
 66 |            if pop(stack)~=0 then
 67 |              ip := opnd
 68 |            }
 69 |          Op.CALL: {
 70 |            f := stack[1+opnd]
 71 |            if f >= 0 then {
 72 |              push( stack, ip) # save old ip
 73 |              push( stack, bp) # save old ip
 74 |              bp := *stack     # set new bp
 75 |              ip := f          # set new ip
 76 |              }
 77 |            else if f = -1 then do_println()
 78 |            else stop("no CALL defined for ", image(f))
 79 |            }
 80 |          Op.RETURN: {
 81 |            while *stack > bp do pop(stack)
 82 |            bp := pop(stack)
 83 |            ip := pop( stack )
 84 |            }
 85 | 
 86 |          Op.LT: {  }
 87 |          Op.LE: {  }
 88 |          default: { stop("Illegal opcode ", op) }
 89 |          }
 90 |       }
 91 |   end
 92 |   method do_println()
 93 |     x := stack[1]
 94 |     y := c_string(code[1+x:0])
 95 |     write(y)
 96 |   end
 97 |   method c_string(s)
 98 |     if i := find("\0", s) then return s[1:i]
 99 |     else stop("no C string in ", image(s))
100 |   end
101 |   method deref(reg, od)
102 |     case reg of {
103 |       Op.R_ABS: {
104 |         if od < finstr then return data.word(od)
105 |         else return code[od]
106 |         }
107 |       Op.R_IMM: { return od }
108 |       Op.R_STACK: { return stack[bp+od] }
109 |       default: { stop("deref region ", reg) }
110 |     }
111 |   end
112 | 
113 | end
114 | class Data(d)
115 |   method word(o)
116 |     return d[1+o +: 8]
117 |   end
118 | end
119 | 


--------------------------------------------------------------------------------
/ch11/j0machine.java:
--------------------------------------------------------------------------------
  1 | import java.io.IOException;
  2 | import java.nio.file.Files;
  3 | import java.nio.file.Paths;
  4 | import java.nio.charset.StandardCharsets;
  5 | import java.nio.ByteBuffer;
  6 | public class j0machine {
  7 |   public static byte[] code, stack;
  8 |   public static ByteBuffer codebuf, stackbuf;
  9 |   public static int ip, sp, bp, hp, op, opr, finstr;
 10 |   public static long opnd;
 11 | 
 12 |   public static boolean loadbytecode(String filename)
 13 |     throws IOException {
 14 |       code = Files.readAllBytes(Paths.get(filename));
 15 |       byte[] magstr = "Jzero!!\0".getBytes(
 16 |                           StandardCharsets.US_ASCII);
 17 |       int i = find(magstr, code);
 18 |       if (i>=0) {
 19 |         // need to check version, allow for self-execution script header
 20 |         codebuf = ByteBuffer.wrap(code);
 21 |         return true;
 22 |       }
 23 |       else return false;
 24 |   }
 25 | 
 26 |   public static int find(byte[]needle, byte[]haystack) {
 27 |     int i=0;
 28 |     for( ; i < haystack.length - needle.length+1; ++i) {
 29 |         boolean found = true;
 30 |         for(int j = 0; j < needle.length; ++j) {
 31 |            if (haystack[i+j] != needle[j]) {
 32 |                found = false;
 33 |                break;
 34 |            }
 35 |         }
 36 |         if (found) return i;
 37 |     }
 38 |     return -1;
 39 |   }
 40 |   public static void init(String filename)
 41 |     throws IOException {
 42 |       ip = sp = 0;
 43 |       if (! loadbytecode(filename)) {
 44 |          System.err.println("cannot open program.j0");
 45 |          System.exit(1);
 46 |          }
 47 |       ip = 16;
 48 |       ip = finstr = (int) (8*getOpnd());
 49 |       stack = new byte[800000];
 50 |       stackbuf = ByteBuffer.wrap(stack);
 51 |     }
 52 |   public static void fetch() {
 53 |       op = code[ip];
 54 |       opr = code[ip+1];
 55 |       if (opr != 0) { opnd = getOpnd(); }
 56 |       ip += 8;
 57 |   }
 58 |   public static long getOpnd() {
 59 |    long i=0;
 60 |    if (codebuf.get(ip+7) < 0) i = -1;
 61 |    for(int j=7;j>1;j--) i = (i<<8) | codebuf.get(ip+j);
 62 |    return i;
 63 |   }
 64 |   public static void stop(String s) {
 65 |     System.err.println(s);
 66 |     System.exit(1);
 67 |     }
 68 |   public static void interp() {
 69 |     for(;;) {
 70 |       fetch();
 71 |       switch (op) {
 72 |         case Op.HALT: { stop("Execution complete."); break; }
 73 |         case Op.NOOP: { break; }
 74 |         case Op.ADD: {
 75 |           long val1 = stackbuf.getLong(sp--);
 76 |           long val2 = stackbuf.getLong(sp--);
 77 | 	  stackbuf.putLong(sp++, val1 + val2);
 78 |           break;
 79 |           }
 80 |       case Op.PUSH: {
 81 | 	  long val = deref(opr, opnd);
 82 | 	  push(val);
 83 | 	  break;
 84 |       }
 85 |       case Op.POP: {
 86 | 	  long val = pop();
 87 | 	  assign(opnd, val);
 88 | 	  break;
 89 |       }
 90 |       case Op.GOTO: {
 91 | 	  ip = (int)opnd;
 92 | 	  break;
 93 |       }
 94 |       case Op.BIF: {
 95 | 	  if (pop() != 0)
 96 | 	      ip = (int)opnd;
 97 | 	  break;
 98 |       }
 99 | 
100 |       case Op.CALL: {
101 | 	  long f;
102 | 	  f = stackbuf.getLong(sp-8-(int)(8*opnd));
103 | 	  if (f >= 0) {
104 | 	      push( ip);
105 | 	      push( bp);
106 | 	      bp = sp;
107 | 	      ip = (int)f;
108 |              }
109 | 	  else if (f == -1) do_println();
110 | 	  else { stop("no CALL defined for " + f); }
111 | 	  break;
112 |            }
113 |       case Op.RETURN: {
114 |            sp = bp;
115 |            bp = (int)pop();
116 |            ip = (int)pop();
117 | 	   break;
118 |            }
119 | 
120 |       case Op.LT: { stop("LT not implemented yet."); break; }
121 |       case Op.LE: { stop("LE not implemented yet."); break; }
122 |       default: { stop("Illegal opcode " + op); }
123 |       }
124 |     }
125 |   }
126 | 
127 |     public static void do_println() {
128 | 	// execute a system.out.println on an argument on the stack
129 | 	long addr = stackbuf.getLong(sp-8);
130 | 	byte b = codebuf.get((int)addr++);
131 | 	while (b != 0) {
132 | 	   System.out.print((char)b);
133 |            b = codebuf.get((int)addr++);
134 |         }
135 | 	System.out.println();
136 |     }
137 | 
138 |     public static long deref(int reg, long od) {
139 | 	switch(reg) {
140 | 	case Op.R_ABS: { return codebuf.getLong((int)od); }
141 | 	case Op.R_IMM: { return od; }
142 | 	case Op.R_STACK: { return stackbuf.getLong(bp+(int)od); }
143 |         default: { stop("deref region " + reg); }
144 | 	}
145 | 	return 0;
146 |     }
147 | 
148 |     public static void assign(long ad, long val) {
149 | 	switch(opr) {
150 | 	case Op.R_ABS: {  }
151 | 	case Op.R_IMM: {  }
152 | 	case Op.R_STACK: {  }
153 |         default: { stop("assign region " + opr); }
154 | 	}
155 |     }
156 | 
157 |     public static void push(long val) {
158 |       stackbuf.putLong(val);
159 |       sp += 8;
160 |     }
161 | 
162 |     public static long pop() {
163 |       sp -= 8;
164 |       long rv = stackbuf.getLong(sp);
165 |       return rv;
166 |     }
167 | }
168 | 


--------------------------------------------------------------------------------
/ch11/j0x.icn:
--------------------------------------------------------------------------------
1 | procedure main(argv)
2 |   if not (filename := argv[1]) then
3 |     stop("usage: j0x file[.j0]")
4 |   if not (filename[-3:0] == ".j0") then argv[1] ||:= ".j0"
5 |   j0machine := j0machine()
6 |   j0machine.init(filename)
7 |   j0machine.interp()
8 | end
9 | 


--------------------------------------------------------------------------------
/ch11/j0x.java:
--------------------------------------------------------------------------------
 1 | public class j0x {
 2 |   public static void main(String[] argv) {
 3 |     if (argv.length < 1) {
 4 |       System.err.println("usage: j0x file[.j0]" + argv.length);
 5 |       System.exit(1);
 6 |       }
 7 |     String filename = argv[0];
 8 |     if (! filename.endsWith(".j0"))
 9 |       filename = filename + ".j0";
10 |     try {
11 |       j0machine.init(filename);
12 |     } catch(Exception ex) {
13 | 	System.err.println("Can't initialize. Exiting.");
14 | 	System.exit(1);
15 |     }
16 |     j0machine.interp();
17 |   }
18 | }
19 | 


--------------------------------------------------------------------------------
/ch11/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | U=j0x.u j0machine.u op.u
 5 | unicon:j0x
 6 | %.u : %.icn
 7 | 	unicon -c 
lt;
 8 | 
 9 | j0x: $(U)
10 | 	unicon $(U)
11 | 
12 | JSRC=j0x.java j0machine.java Op.java
13 | java: j0x.class
14 | 
15 | j0x.class: $(JSRC)
16 | 	javac $(JSRC)
17 | 


--------------------------------------------------------------------------------
/ch11/writehello.icn:
--------------------------------------------------------------------------------
 1 | procedure main()
 2 |     f := open("hello.j0","w") | stop("can't open hello.j0")
 3 |     writes(f, "Jzero!!\0")		# word 0, magic word
 4 |     writes(f, "1.0\0\0\0\0\0")          # word 1, version #
 5 |     writes(f, "\0\0\4\0\0\0\0\0")       # word 2, first instruction at word 4
 6 |     writes(f, "hello\0\0\0")            # word 3, static data
 7 |     writes(f, "\11\2\70\0\0\0\0\0")     # word 4, PUSH IMM 56, func entry pt 56
 8 |     writes(f, "\13\2\0\0\0\0\0\0")      # word 5, call 0
 9 |     writes(f, "\1\0\0\0\0\0\0\0")       # word 6, halt
10 |     writes(f, "\11\2\377\377\377\377\377\377") # word 7, push IMM -1
11 |     writes(f, "\11\2\30\0\0\0\0\0")     # word 8, push IMM 24 "hello"
12 |     writes(f, "\13\2\1\0\0\0\0\0")      # word 9, call IMM 1
13 |     writes(f, "\14\2\0\0\0\0\0\0")      # word 10, ret IMM 0
14 |     close(f)
15 | end
16 | 


--------------------------------------------------------------------------------
/ch12/Op.icn:
--------------------------------------------------------------------------------
 1 | class Op(HALT, NOOP, ADD, SUB, MUL, DIV, MOD, NEG, PUSH, POP, CALL, RETURN,
 2 | 	 GOTO, BIF, LT, LE, GT, GE, EQ, NEQ, LOCAL, LOAD, STORE,
 3 | 	 LABEL, STRING, CODE, PROC, GLOBAL, END,
 4 | 	 R_NONE, R_ABS, R_IMM, R_STACK, R_HEAP)
 5 | initially
 6 |   HALT := 1;  NOOP := 2; ADD := 3; SUB := 4; MUL := 5
 7 |   DIV := 6; MOD := 7; NEG := 8; PUSH := 9; POP := 10
 8 |   CALL := 11; RETURN := 12; GOTO := 13; BIF := 14; LT := 15
 9 |   LE := 16; GT := 17; GE := 18; EQ := 19; NEQ := 20;
10 |   LOCAL := 21; LOAD := 22; STORE := 23;
11 |   LABEL := 101; STRING:=102; CODE:=103; PROC:=104; GLOBAL := 105; END := 106
12 |   R_NONE := 0; R_ABS := 1; R_IMM := 2
13 |   R_STACK := 3; R_HEAP := 4
14 |   Op := self
15 | end
16 | 
17 | procedure OpStr(i)
18 |    if type(Op)~=="Op__state" then Op()
19 |    case i of {
20 |        Op.HALT: return "HALT"
21 |        Op.NOOP: return "NOOP"
22 |        Op.ADD:  return "ADD"
23 |        Op.SUB:  return "SUB"
24 |        Op.MUL:  return "MUL"
25 |        Op.DIV:  return "DIV"
26 |        Op.MOD:  return "MOD"
27 |        Op.NEG:  return "NEG"
28 |        Op.PUSH: return "PUSH"
29 |        Op.POP:  return "POP"
30 |        Op.CALL: return "CALL"
31 |        Op.RETURN: return "RETURN"
32 |        Op.GOTO: return "GOTO"
33 |        Op.BIF: return "BIF"
34 |        Op.LT: return "LT"
35 |        Op.LE: return "LE"
36 |        Op.GT: return "GT"
37 |        Op.GE: return "GE"
38 |        Op.EQ: return "EQ"
39 |        Op.NEQ: return "NEQ"
40 |        Op.LOCAL: return "LOCAL"
41 |        Op.LOAD: return "LOAD"
42 |        Op.STORE: return "STORE"
43 |        default: return "(unknown:"||image(i)||")"
44 |    }
45 | end
46 | 
47 | procedure OpRStr(opr)
48 |    if type(Op)~=="Op__state" then Op()
49 |    case opr of {
50 |      Op.R_NONE: return "NONE"
51 |      Op.R_ABS:  return "ABS"
52 |      Op.R_IMM:  return "IMM"
53 |      Op.R_STACK: return "STACK"
54 |      Op.R_HEAP: return "HEAP"
55 |    }
56 | end
57 | 


--------------------------------------------------------------------------------
/ch12/Op.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class Op {
 3 |   public final static short HALT=1, NOOP=2, ADD=3, SUB=4,
 4 |     MUL=5, DIV=6, MOD=7, NEG=8, PUSH=9, POP=10, CALL=11,
 5 |     RETURN=12, GOTO=13, BIF=14, LT=15, LE=16, GT=17, GE=18,
 6 |     EQ=19, NEQ=20, LOCAL=21, LOAD=22, STORE=23;
 7 |     public final static short LABEL=101, STRING=102,
 8 | 	CODE=103, PROC=104, GLOBAL=105, END=106;
 9 |   public final static short R_NONE=0, R_ABS=1, R_IMM=2, R_STACK=3, R_HEAP=4;
10 | }
11 | 


--------------------------------------------------------------------------------
/ch12/address.icn:
--------------------------------------------------------------------------------
 1 | class address(region, offset)
 2 | method regaddr()
 3 |   return if region == "method" then "loc" else region
 4 | end
 5 | method str()
 6 |   if region=="lab" then return "L"||offset
 7 |   return regaddr() || ":" || offset
 8 | end
 9 | method print()
10 |   writes(str())
11 | end
12 | #initially
13 | #   if /region then {
14 | #write("when is it ever OK to make an address with no region?")
15 | #runerr(103, region)
16 | #	}
17 | end
18 | 


--------------------------------------------------------------------------------
/ch12/address.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class address {
 3 |     public String region;
 4 |     public int offset;
 5 |     public String regaddr() { return region.equals("method")?"loc":region; }
 6 |     public String str() {
 7 |         if (region.equals("lab")) return "L"+offset;
 8 | 	return regaddr() + ":" + offset; }
 9 |     public void print() { System.out.print(str()); }
10 |     address(String s, int o) { region = s; offset = o; }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch12/arraytype.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class arraytype extends typeinfo {
 3 |    typeinfo element_type;
 4 |     public String str() {
 5 | 	return "array of " + (element_type!=null?element_type.str():"undef");
 6 |     }
 7 |    public arraytype(typeinfo t) {
 8 |       basetype = "array"; element_type = t; }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch12/byc.icn:
--------------------------------------------------------------------------------
 1 | link printf
 2 | class byc(op, opreg, opnd)
 3 |   method print(f:&output)
 4 |     write(f, "\t", nameof(), " ", addrof()) |
 5 |       write(&errout, "can't print ", image(self), " op ", image(op))
 6 |   end
 7 |   method nameof()
 8 |    static opnames
 9 |    initial opnames := table(Op.HALT, "halt", Op.NOOP, "noop",
10 |       Op.ADD, "add", Op.SUB, "sub", Op.MUL, "mul",
11 |       Op.DIV, "div", Op.MOD, "mod", Op.NEG, "neg",
12 |       Op.PUSH, "push", Op.POP, "pop", Op.CALL, "call",
13 |       Op.RETURN, "return", Op.GOTO, "goto", Op.BIF, "bif",
14 |       Op.LT, "lt", Op.LE, "le", Op.GT, "gt", Op.GE, "ge",
15 |       Op.EQ, "eq", Op.NEQ, "neq", Op.LOCAL, "local",
16 |       Op.LOAD, "load", Op.STORE, "store", Op.LABEL, "LABEL",
17 |       Op.STRING, "STRING", Op.CODE, "CODE", Op.PROC, "PROC",
18 |       Op.GLOBAL, "GLOBAL", Op.END, "END")
19 |    return opnames[op]
20 |   end
21 | method addrof()
22 |    case opreg of {
23 |       Op.R_NONE | &null: return ""
24 |       Op.R_ABS: return "@" || sprintf("%x",opnd)
25 |       Op.R_IMM: return string(opnd)
26 |       Op.R_STACK: return "stack:" || opnd
27 |       Op.R_HEAP: return "heap:" || opnd
28 |       default: {
29 |         return string(opreg) || ":" || opnd
30 |         }
31 |       }
32 | end
33 | 
34 |   method printb(f:&output)
35 |    writes(f, char(op), char(\opreg|0))
36 |    x := (\opnd | 0)
37 |    every !6 do {
38 |      writes(f, char(iand(x, 255)))
39 |      x := ishift(x, -8)
40 |      }
41 |   end
42 |   method addr(a)
43 |    if /a then opreg := Op.R_NONE
44 |    else if type(a) == "integer" then {
45 |      opreg := Op.R_IMM; opnd := a
46 |    }
47 |    else if type(a) == "string" then {
48 |      if not (sa := stringtab.lookup(a)) then write("don't know ", image(a))
49 |        # string region addresses are just pointers offset 24 from start
50 |        opreg := Op.R_IMM; opnd := sa.addr.offset + 24
51 |    }
52 |    else case a.region of {
53 |    "method": { opreg := Op.R_STACK; opnd := a.offset }
54 |    "global": { opreg := Op.R_ABS; opnd := a.offset + stringtab.count }
55 |    "const": { opreg := Op.R_ABS; opnd := a.offset }
56 |    "lab": { opreg := Op.R_ABS; opnd := a.offset }
57 |    "obj": { opreg := Op.R_HEAP; opnd := a.offset }
58 |    "imm": { opreg := Op.R_IMM; opnd := a.offset }
59 |    "strings": { opreg := Op.R_IMM; opnd := a.offset + 24 }
60 |    default: {
61 |       write("system error. region ", image(a.region),
62 |                          " offset ", image(a.offset))
63 |       runerr(103, a.region)
64 |       }
65 |    }
66 |   end
67 | initially(o, a)
68 |   op := o; addr(a);
69 |   if type(nameof()) ~== "string" then {
70 |      write(&errout, "bad op ", image(op))
71 |      runerr(103, op)
72 |   }
73 | end
74 | 


--------------------------------------------------------------------------------
/ch12/byc.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | import java.util.HashMap;
 3 | import java.io.PrintStream;
 4 | public class byc {
 5 |    int op, opreg;
 6 |    long opnd;
 7 |    public byc(int o, address a) {
 8 |       op=o; addr(a);
 9 |    }
10 |    public void print(PrintStream f) {
11 |       f.println("\t" + nameof() + " " + addrof());
12 |    }
13 |    public void print() {
14 |       print(System.out);
15 |    }
16 |   static HashMap<Short,String> ops;
17 |   static { ops = new HashMap<>();
18 |     ops.put(Op.HALT,"halt"); ops.put(Op.NOOP,"noop");
19 |     ops.put(Op.ADD,"add"); ops.put(Op.SUB,"sub");
20 |     ops.put(Op.MUL,"mul"); ops.put(Op.DIV, "div");
21 |     ops.put(Op.MOD,"mod"); ops.put(Op.NEG, "neg");
22 |     ops.put(Op.PUSH,"push"); ops.put(Op.POP, "pop");
23 |     ops.put(Op.CALL, "call"); ops.put(Op.RETURN, "return");
24 |     ops.put(Op.GOTO, "goto"); ops.put(Op.BIF, "bif");
25 |     ops.put(Op.LT, "lt"); ops.put(Op.LE, "le");
26 |     ops.put(Op.GT, "gt"); ops.put(Op.GE, "ge");
27 |     ops.put(Op.EQ, "eq"); ops.put(Op.NEQ, "neq");
28 |     ops.put(Op.LOCAL, "local"); ops.put(Op.LOAD, "load");
29 |     ops.put(Op.STORE, "store"); ops.put(Op.LABEL, "LABEL");
30 |     ops.put(Op.STRING, "STRING"); ops.put(Op.CODE, "CODE");
31 |     ops.put(Op.PROC, "PROC"); ops.put(Op.GLOBAL, "GLOBAL");
32 |     ops.put(Op.END, "END");
33 |   }
34 |   public String nameof() {
35 |     return ops.get(op);
36 |   }
37 | 
38 |   public String addrof() {
39 |    switch (opreg) {
40 |    case Op.R_NONE: return "";
41 |    case Op.R_ABS: return "@"+ java.lang.Long.toHexString(opnd);
42 |    case Op.R_IMM: return String.valueOf(opnd);
43 |    case Op.R_STACK: return "stack:" + String.valueOf(opnd);
44 |    case Op.R_HEAP: return "heap:" + String.valueOf(opnd);
45 |    }
46 |   return String.valueOf(opreg)+":"+String.valueOf(opnd);
47 |   }
48 | 
49 |    public void printb(PrintStream f) {
50 |    long x = opnd;
51 |    f.print((char)op);
52 |    f.print((char)opreg);
53 |    for(int i = 0; i < 6; i++) {
54 |       f.print((char)(x & 0xff));
55 |       x = x>>8;
56 |       }
57 |    }
58 |     public void printb() { printb(System.out); }
59 | 
60 |    public void addr(address a) {
61 |    if (a == null) opreg = Op.R_NONE;
62 |    else switch (a.region) {
63 |      case "method": opreg = Op.R_STACK; opnd = a.offset; break;
64 |      case "global": opreg = Op.R_ABS; opnd = a.offset; break;
65 |      case "const": opreg = Op.R_ABS; opnd = a.offset; break;
66 |      case "lab": opreg = Op.R_ABS; opnd = a.offset; break;
67 |      case "obj": opreg = Op.R_HEAP; opnd = a.offset; break;
68 |      case "imm": opreg = Op.R_IMM; opnd = a.offset; break;
69 |      case "strings": opreg = Op.R_IMM; opnd = a.offset + 24; break;
70 |      }
71 |    }
72 | }
73 | 


--------------------------------------------------------------------------------
/ch12/classtype.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class classtype extends typeinfo {
 3 |    String name;
 4 |    symtab st;
 5 |    parameter [] methods;
 6 |    parameter [] fields;
 7 |    typeinfo [] constrs;
 8 |     public String str() {
 9 | 	return name;
10 |     }
11 |     public classtype(String s) { name = s; basetype="class";}
12 |     public classtype(String s, symtab stab) { name = s; st = stab; basetype="class";}
13 |    public classtype(String s, symtab stab,
14 | 		    parameter []ms, parameter[]fs, typeinfo[]cs) {
15 |        name = s; st = stab; methods=ms; fields=fs; constrs=cs; basetype="class";}
16 | }
17 | 


--------------------------------------------------------------------------------
/ch12/hello.icn:
--------------------------------------------------------------------------------
1 | link printf
2 | procedure main()
3 |    s := sprintf("0x%x", 5252)
4 |    write("s is ", s)
5 | end
6 | 


--------------------------------------------------------------------------------
/ch12/hello.j0:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/PacktPublishing/Build-Your-Own-Programming-Language/714a2367238d52144843a871b68f908fdee5f5b2/ch12/hello.j0


--------------------------------------------------------------------------------
/ch12/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |          System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch12/j0.icn:
--------------------------------------------------------------------------------
  1 | link bincvt
  2 | global yyfilename, yylineno, yycolno, yylval, parser, global_st, stringtab
  3 | global labeltable, methodAddrPushed
  4 | procedure main(argv)
  5 |    j0 := j0()
  6 |    serial := serial()
  7 |    parser := Parser()
  8 |    yyfilename := argv[1] | stop("usage: j0 filename")
  9 |    if not (map(yyfilename[-5:0])==".java") then yyfilename ||:= ".java"
 10 |    yyin := open(yyfilename) | stop("usage: j0 filename")
 11 |    write("Compiling ", yyfilename, " to .j0 format")
 12 |    yylineno := yycolno := 1
 13 |    if yyparse() = 0 then
 14 |       write("no errors")
 15 | end
 16 | class j0()
 17 |    method lexErr(s)
 18 |       stop(s, ": ", yytext) 
 19 |    end
 20 |    method scan(cat)
 21 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
 22 |       yycolno +:= *yytext
 23 |       return cat
 24 |    end
 25 |    method whitespace()
 26 |       yycolno +:= *yytext
 27 |    end
 28 |    method newline()
 29 |       yylineno +:= 1; yycolno := 1
 30 |    end
 31 |    method comment()
 32 |       yytext ? {
 33 |          while tab(find("\n")+1) do newline()
 34 |          yycolno +:= *tab(0)
 35 |       }
 36 |    end
 37 |    method ord(s)
 38 |       return proc("ord",0)(s[1])
 39 |    end
 40 |    method print(root)
 41 |       root.print()
 42 |    end
 43 |    method node(s,r,p[])
 44 |       rv := tree ! ([s,r] ||| p)
 45 |       return rv
 46 |    end
 47 |    method semantic(root)
 48 |    local out_st, System_st
 49 |      global_st := symtab("global")
 50 |      stringtab := symtab("strings")
 51 |      System_st := symtab("class")
 52 |      out_st := symtab("class")
 53 |      out_st.insert("println", false, ,
 54 |         methodtype([classtype("String")], typeinfo("void")))
 55 |      System_st.insert("out", false, out_st, classtype("PrintStream",out_st))
 56 |      global_st.insert("System", false, System_st, classtype("System",System_st))
 57 |      if \verbose then write("making symbol tables")
 58 |      root.mkSymTables(global_st)
 59 |      root.populateSymTables()
 60 |      if \verbose then write("checking symbol tables")
 61 |      root.checkSymTables()
 62 |      root.mkcls()
 63 |      root.checktype()
 64 |    end
 65 |    method semErr(s)
 66 |      stop("semantic error: ", s)
 67 |    end
 68 |    method calctype(t)
 69 |      t.kids[1].calctype()
 70 |      t.kids[2].assigntype(t.kids[1].typ)
 71 |    end
 72 |    method gencode(root)
 73 |       root.genfirst()
 74 |       root.genfollow()
 75 |       root.gentargets()
 76 |       root.gencode()
 77 | 
 78 |       labeltable := table()
 79 |       bcode := bytecode(root.icode)
 80 |       genbytecode(bcode)
 81 |    end
 82 | 
 83 |   method bgen(o, a)
 84 |     return [byc(o, a)]
 85 |   end
 86 | 
 87 |   method bytecode(icode)
 88 |     if type(Op)=="procedure" then Op()
 89 |     bcode := []
 90 |     every i := 1 to *\icode do {
 91 |       instr := icode[i]
 92 |       case instr.op of {
 93 |       "ADD": {
 94 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
 95 |         j0.bgen(Op.PUSH, instr.op3) ||| j0.bgen(Op.ADD) |||
 96 |         j0.bgen(Op.POP, instr.op1)
 97 |       }
 98 |       "SUB": { }
 99 |       "NEG": {
100 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
101 |           j0.bgen(Op.NEG) ||| j0.bgen(Op.POP, instr.op1)
102 |       }
103 |       "ASN": {
104 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
105 |                     j0.bgen(Op.POP, instr.op1)
106 |       }
107 |       "ADDR": {
108 |         bcode |||:= j0.bgen(Op.LOAD, instr.op1)
109 |       }
110 |       "LCON": {
111 |         bcode |||:= j0.bgen(Op.LOAD, instr.op2) |||
112 |                     j0.bgen(Op.POP, instr.op1)
113 |       }
114 |       "SCON": {
115 |         bcode |||:= j0.bgen(Op.STORE, instr.op2) |||
116 |                     j0.bgen(Op.POP, instr.op1)
117 |       }
118 |       "GOTO": {
119 |         bcode |||:= j0.bgen(Op.GOTO, instr.op1)
120 |       }
121 |       "BLT": {
122 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
123 |           j0.bgen(Op.PUSH, instr.op3) |||
124 |           j0.bgen(Op.LT) |||
125 |           j0.bgen(Op.BIF, instr.op1)
126 |       }
127 |       "PARM": {
128 |         if /methodAddrPushed then {
129 |           every j := i+1 to *icode do
130 |             if icode[j].op == "CALL" then {
131 |               if icode[j].op1 === "PrintStream__println" then {
132 |                 bcode |||:= j0.bgen(Op.PUSH, address("imm", -1))
133 |               } else {
134 |                 bcode |||:= j0.bgen(Op.PUSH, icode[j].op1)
135 |               }
136 |               break
137 |             }
138 |             methodAddrPushed := 1
139 |         }
140 | 
141 |         bcode |||:= j0.bgen(Op.PUSH, instr.op1)
142 |       }
143 |       "CALL": {
144 |         bcode |||:= j0.bgen(Op.CALL, instr.op2)
145 |         methodAddrPushed := &null
146 |       }
147 | 
148 |       "RETURN": {
149 |         bcode |||:= j0.bgen(Op.RETURN, instr.op1)
150 |       }
151 |       "RET": {
152 |          bcode |||:= j0.bgen(Op.RETURN, instr.op1)
153 | 	 }
154 | 
155 |       "proc": {
156 |          # record address
157 |          labeltable[instr.op1.region] := *bcode * 8
158 |         }
159 |       "end": { }
160 |       ".code": { }
161 |       ".global": { }
162 |       ".string": { }
163 |       "LAB": {
164 |          # record address
165 |          labeltable[instr.op1.offset] := *bcode * 8
166 | 	 }
167 |       "string": {
168 |          # strings are written out separately
169 | 	 }
170 |       "global": {
171 |          # globals are written out separately
172 | 	 }
173 |       "FIELD": {
174 |          # compute a result in op1 that is obtained by computing on op2 and op3
175 |          # dummy placeholder for future object-orientation
176 |          bcode |||:= j0.bgen(Op.PUSH, instr.op2) ||| j0.bgen(Op.POP, instr.op1)
177 | 	 }
178 | 
179 |       default: {
180 |          stop("What is ", image(instr.op))
181 |          }
182 |          }
183 |       }
184 |      return bcode
185 |   end
186 | 
187 |   # calculate the first instruction offset.  Count how many words of string
188 |   # constants there are
189 |   method calculate_fio()
190 |      return 3 + (stringtab.count / 8) + (global_st.count / 8)
191 |   end
192 | 
193 |   # The string region always starts at offset 24 after the three-word header.
194 |   method write_stringarea(bc, fout)
195 |   local s
196 |     every s := !(stringtab.L) do {
197 |       # should fully-binarize (de-escape) string here
198 |       # for now, just strip double quotes, replace with NULs
199 |       s := s[2:-1] || "\0\0"
200 | 
201 |       len := *s
202 |       while len > 0 do {
203 |          if len < 9 then {
204 |             writes(fout, s)
205 |             if len < 8 then writes(fout, repl("\0", 8-len))
206 |             }
207 |          else { writes(fout, s[1:9]); s := s[9:0] }
208 |          len -:= 8
209 |          }
210 |      }
211 |   end
212 | 
213 |   method write_globalarea(bc, fout)
214 |     writes(fout, repl("\0", global_st.count))
215 |   end
216 | 
217 |   method write_instructions(bc, fout)
218 |   local i #, offset := where(fout)-1
219 |      every i := 1 to *bc do {
220 |        case bc[i].op of {
221 |        Op.CODE: { }
222 |        Op.GLOBAL: { }
223 |        Op.LABEL: { }
224 |        Op.PROC: {  }
225 |        Op.STRING: {  }
226 |        Op.END: { }
227 |        default: {
228 |          bc[i].printb(fout)
229 |          }
230 |        }
231 | #    offset := where(fout)-1
232 |     }
233 |   end
234 | 
235 |   method genbytecode(bc)
236 |     outfilename := yyfilename[1:find(".java", yyfilename)] || ".j0"
237 |     if fout := open(outfilename, "w") then {
238 |       writes(fout, "Jzero!!\0")		# word 0, magic word
239 |       writes(fout, "1.0\0\0\0\0\0")          # word 1, version #
240 |       # write the first instruction offset. convert Unicon binary to bcode binary
241 |       fio := calculate_fio(bc)
242 |       writes(fout, "\0\0", reverse(rawstring(fio, 6)))
243 |       write_stringarea(bc, fout)
244 |       write_globalarea(bc, fout)
245 | 
246 |       #bootstrap instructions: push addr of main, push dummy self, call 0, and halt
247 |       codept := entrypt := fio*8+32
248 |       if not member(labeltable, "main") then stop("main() not found")
249 |       entrypt +:= labeltable["main"]
250 |       writes(fout, "\11\2",reverse(rawstring(entrypt, 6))) # PUSH IMM (func entry pt) fio*8+24
251 |       writes(fout, "\11\2\0\0\0\0\0\0")           # PUSH 0 (null self)
252 |       writes(fout, "\13\2\0\0\0\0\0\0")           # call 0
253 |       writes(fout, "\1\0\0\0\0\0\0\0")            # halt
254 | 
255 |       write_instructions(bc, fout)
256 |       close(fout)
257 |     } else stop("couldn't open output file ",image(outfilename)," for writing")
258 |   end
259 | 
260 | end
261 | 


--------------------------------------------------------------------------------
/ch12/j0.java:
--------------------------------------------------------------------------------
  1 | package ch12;
  2 | import java.io.FileReader;
  3 | import java.io.PrintStream;
  4 | import java.util.ArrayList;
  5 | import java.util.HashMap;
  6 | public class j0 {
  7 |    public static Yylex yylexer;
  8 |    public static ch12.parser par;
  9 |    public static ch12.symtab global_st, stringtab;
 10 |    public static HashMap<String,Integer> labeltable;
 11 |    public static boolean methodAddrPushed;
 12 |    public static void main(String argv[]) throws Exception {
 13 |       init(argv[0]);
 14 |       par = new parser();
 15 |       //                  par.yydebug=true;
 16 |       yylineno = yycolno = 1;
 17 |       //      System.out.println("Compiling "+ yyfilename + " to .j0 format");
 18 |       int i = par.yyparse();
 19 |       if (i == 0)
 20 |          System.out.println("no errors");
 21 |    }
 22 |     public static int yylineno, yycolno;
 23 |    public static String yyfilename;
 24 |     //   public static parserVal yylval;
 25 |    public static void init(String s) throws Exception {
 26 |       yyfilename = s;
 27 |       if (! yyfilename.endsWith(".java"))
 28 | 	  yyfilename = yyfilename + ".java";
 29 |       yylexer = new Yylex(new FileReader(yyfilename));
 30 |    }
 31 |    public static int YYEOF() { return Yylex.YYEOF; }
 32 |    public static int yylex() {
 33 |       int rv = 0;
 34 |       try {
 35 |         rv = yylexer.yylex();
 36 |       } catch(java.io.IOException ioException) {
 37 |         rv = -1;
 38 |       }
 39 |       return rv;
 40 |    }
 41 |    public static String yytext() {
 42 |       return yylexer.yytext();
 43 |    }
 44 |    public static void lexErr(String s) {
 45 |        stop(s);
 46 |    }
 47 |    public static int scan(int cat) {
 48 |        ch12.j0.par.yylval =
 49 | 	   new parserVal(new tree("token",cat,
 50 | 		new token(cat, yytext(), yylineno)));
 51 |       return cat;
 52 |    }
 53 |    public static void newline() {
 54 |       yylineno++;
 55 |    }
 56 |    public static void whitespace() {
 57 |    }
 58 |    public static void comment() {
 59 |    }
 60 |    public static short ord(String s) { return (short)(s.charAt(0)); }
 61 |    public static void print(parserVal root) {
 62 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
 63 |    }
 64 |   public static tree unwrap(Object obj) {
 65 |     if (obj instanceof token)
 66 |       return new tree("token",0,(token)obj);
 67 |     else return (tree)obj;
 68 |   }
 69 |   public static parserVal node(String s,int r,parserVal...p) {
 70 |      tree[] t = new tree[p.length];
 71 |      for(int i = 0; i < t.length; i++)
 72 | 	 t[i] = (tree)(p[i].obj);
 73 |      return new parserVal((Object)new tree(s,r,t));
 74 |   }
 75 |   public static void semantic(parserVal r) {
 76 |     tree root = (tree)(r.obj);
 77 |     ch12.symtab out_st, System_st;
 78 |     global_st = new ch12.symtab("global");
 79 |     stringtab = new ch12.symtab("strings");
 80 |     System_st = new ch12.symtab("class");
 81 |     out_st = new ch12.symtab("class");
 82 |     out_st.insert("println", false, null,
 83 | 		  new methodtype(new typeinfo[]{new classtype("String")},
 84 | 				 new typeinfo("void")));
 85 |     System_st.insert("out", false, out_st,
 86 |        new classtype("PrintStream",out_st));
 87 |     global_st.insert("System", false, System_st,
 88 |        new classtype("System",System_st));
 89 |    root.mkSymTables(global_st);
 90 |    root.populateSymTables();
 91 |    root.checkSymTables();
 92 |    root.mkcls();
 93 |    //   global_st.print();
 94 |    root.checktype(false);
 95 |   }
 96 |   public static void semErr(String s) {
 97 |    stop("semantic error: " + s);
 98 |   }
 99 |   public static void calctype(parserVal pv){
100 |     tree t = (tree)pv.obj;
101 |     t.kids[0].calctype();
102 |     t.kids[1].assigntype(t.kids[0].typ);
103 |   }
104 |   public static void gencode(parserVal r) {
105 |     tree root = (tree)(r.obj);
106 |     root.genfirst();
107 |     root.genfollow();
108 |     root.gentargets();
109 |     root.gencode();
110 |     labeltable = new HashMap<>();
111 |     methodAddrPushed = false;
112 |     ArrayList<byc> bcode = bytecode(root.icode);
113 |     genbytecode(bcode);
114 |   }
115 | 
116 | public static ArrayList<byc> bgen(int o, address a) {
117 |     ArrayList<byc> L = new ArrayList<byc>();
118 |    byc b = new byc(o, a);
119 |    L.add(b);
120 |    return L;
121 | }
122 | 
123 |   public static ArrayList<byc> bytecode(ArrayList<tac> icode) {
124 |     ArrayList<byc> rv = new ArrayList<byc>();
125 |     for(int i=0; i<icode.size(); i++) {
126 |       tac instr = icode.get(i);
127 |       switch(instr.op) {
128 |       case "ADD": {
129 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
130 |         rv.addAll(j0.bgen(Op.PUSH, instr.op3));
131 |         rv.addAll(j0.bgen(Op.ADD, null));
132 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
133 |         break;
134 |       }
135 |       case "SUB": {  }
136 |       case "NEG": {
137 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
138 |         rv.addAll(j0.bgen(Op.NEG, null));
139 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
140 |         break;
141 |       }
142 |       case "ASN": {
143 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
144 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
145 |         break;
146 |       }
147 |       case "ADDR": {
148 |         rv.addAll(j0.bgen(Op.LOAD, instr.op1));
149 |         break;
150 |       }
151 |       case "LCON": {
152 |         rv.addAll(j0.bgen(Op.LOAD, instr.op2));
153 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
154 |         break;
155 |       }
156 |       case "SCON": {
157 |         rv.addAll(j0.bgen(Op.STORE, instr.op2));
158 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
159 |         break;
160 |       }
161 |       case "GOTO": {
162 |         rv.addAll(j0.bgen(Op.GOTO, instr.op1));
163 |         break;
164 |       }
165 |       case "BLT": {
166 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
167 |         rv.addAll(j0.bgen(Op.PUSH, instr.op3));
168 |         rv.addAll(j0.bgen(Op.LT, null));
169 | 	rv.addAll(j0.bgen(Op.BIF, instr.op1));
170 | 	break;
171 |       }
172 |       case "PARM": {
173 |         if (methodAddrPushed == false) {
174 | 	    for(int j = i+1; j < icode.size(); j++) {
175 |             tac callinstr = icode.get(j);
176 | 	    if (callinstr.op.equals("CALL")) {
177 | 		if (callinstr.op1.str().equals("PrintStream__println:0")) {
178 |                   rv.addAll(j0.bgen(Op.PUSH, new address("imm", -1)));
179 |                } else {
180 |                   rv.addAll(j0.bgen(Op.PUSH, callinstr.op1));
181 | 	       }
182 |                break;
183 | 	    }
184 | 	    methodAddrPushed = true;
185 |           }
186 |         }
187 |         rv.addAll(j0.bgen(Op.PUSH, instr.op1));
188 |         break;
189 |       }
190 |       case "CALL": {
191 |          rv.addAll(j0.bgen(Op.CALL, instr.op2));
192 | 	 methodAddrPushed = false;
193 |          break;
194 |       }
195 |       case "RET": case "RETURN": {
196 |         rv.addAll(j0.bgen(Op.RETURN, instr.op1));
197 |         break;
198 |       }
199 |       case "proc": {
200 | 	// record address
201 | 	  labeltable.put(instr.op1.region, rv.size() * 8);
202 | 	break;
203 |         }
204 |       case "end": { break; }
205 |       case ".code": { break; }
206 |       case ".global": { break; }
207 |       case ".string": {break; }
208 |       case "LAB": {
209 | 	  labeltable.put("L"+String.valueOf(instr.op1.offset), rv.size() * 8);
210 |          break;
211 |       }
212 |       case "string": {break; }
213 |       case "global": { break; }
214 |       case "FIELD": {
215 | 	  rv.addAll(j0.bgen(Op.PUSH, instr.op2));
216 | 	  rv.addAll(j0.bgen(Op.POP, instr.op1));
217 | 	  break;
218 | 	 }
219 | 
220 |       default: { stop("What is " + instr.op); }
221 |       }
222 |     }
223 |     return rv;
224 |   }
225 | 
226 |     public static int calculate_fio() {
227 | 	return 3+ stringtab.count/8 + global_st.count/8;
228 |     }
229 | 
230 |     public static void write_stringarea(PrintStream fout) {
231 | 	String s;
232 | 	for(int i=0; i<stringtab.L.size(); i++) {
233 | 	    s = stringtab.L.get(i);
234 | 	    // should fully-binarize (de-escape) string here
235 | 	    // for now, just strip double quotes, replace with NULs
236 | 	    s = s.substring(1,s.length()-1) + "\0\0" ;
237 | 
238 | 	    int len = s.length();
239 | 	    while (len > 0) {
240 | 		if (len < 9) {
241 | 		   fout.print(s);
242 | 		   if (len < 8) {
243 | 		       for(int j = 0; j<8-len; j++)
244 | 			   fout.print( "\0");
245 | 		   }
246 | 		}
247 | 		else { fout.print(s.substring(0,8)); s = s.substring(8); }
248 | 		len -= 8;
249 |          }
250 |      }
251 |     }
252 | 
253 |     public static void write_globalarea(PrintStream fout){
254 | 	for(int i=0; i<global_st.count; i++)
255 | 	    fout.print("\0");
256 |     }
257 | 
258 |     public static void write_instructions(ArrayList<byc> bc,
259 | 					  PrintStream fout) {
260 | 	for(int i=0; i<bc.size(); i++) {
261 | 	    byc b = bc.get(i);
262 | 	    switch( b.op ) {
263 | 	    case Op.CODE: { }
264 | 	    case Op.GLOBAL: { }
265 | 	    case Op.LABEL: { }
266 | 	    case Op.PROC: {  }
267 | 	    case Op.STRING: {  }
268 | 	    case Op.END: {break; }
269 | 	    default: {
270 | 		bc.get(i).printb(fout);
271 | 	    }
272 | 	    }
273 | 	}
274 |     }
275 | 
276 |     public static void stop(String s) {
277 | 	System.err.println(s);
278 | 	System.exit(1);
279 |     }
280 | 
281 |     public static String rawstring(int i, int len) {
282 | 	String s = "";
283 | 	for(int j=0; j<len; j++) {
284 | 	    s = Character.toString((char)(i & 0xFF)) + s;
285 | 	    i = i >> 8;
286 | 	}
287 | 	return s;
288 |     }
289 |     public static String reverse(String s) {
290 | 	return (new StringBuffer(s)).reverse().toString();
291 |     }
292 |     public static int where;
293 |     public static PrintStream open(String s){
294 | 	PrintStream p = null;
295 | 	where = 0;
296 | 	try {
297 |           p = new PrintStream(s);
298 | 	} catch (java.io.FileNotFoundException e) {
299 |           stop("couldn't open output file "+ s + " for writing");
300 | 	}
301 | 	return p;
302 |     }
303 | 
304 |   public static int find(byte[] needle, byte[]haystack) {
305 |     int i=0;
306 |     for( ; i < haystack.length - needle.length+1; ++i) {
307 |         boolean found = true;
308 |         for(int j = 0; j < needle.length; ++j) {
309 |            if (haystack[i+j] != needle[j]) {
310 |                found = false;
311 |                break;
312 |            }
313 |         }
314 |         if (found) return i;
315 |     }
316 |     return -1;
317 |   }
318 |   public static int find(String needle, String haystack) {
319 |       return find(needle.getBytes(), haystack.getBytes());
320 |   }
321 | 
322 |     public static void genbytecode(ArrayList<byc> bc) {
323 |     int i = find(".java", yyfilename), fio;
324 |     int entrypt;
325 |     String outfilename = yyfilename.substring(0,i) + ".j0";
326 |     PrintStream fout;
327 |     fout = open(outfilename);
328 |       fout.print("Jzero!!\0");               // word 0, magic word
329 |       fout.print("1.0\0\0\0\0\0");           // word 1, version #
330 |       // write first instruction offset. convert Java binary to bcode binary
331 |       fio = calculate_fio();
332 |       fout.print("\0\0" + reverse(rawstring(fio, 6)));
333 |       write_stringarea(fout);
334 |       write_globalarea(fout);
335 | 
336 |       // bootstrap instructions: push addr of main, push dummy self, call 0, and halt
337 |       entrypt = fio*8+32;
338 |       if (! labeltable.containsKey("main")) stop("main() not found");
339 |       entrypt += labeltable.get("main");
340 |       fout.print("\11\2"+reverse(rawstring(entrypt, 6))); // PUSH IMM (func entry pt) fio*8+24
341 |       fout.print("\11\2\0\0\0\0\0\0");            // PUSH 0 (null self)
342 |       fout.print("\13\2\0\0\0\0\0\0");            // call 0
343 |       fout.print("\1\0\0\0\0\0\0\0");             // halt
344 | 
345 |       write_instructions(bc, fout);
346 |       fout.close();
347 |   }
348 | }
349 | 


--------------------------------------------------------------------------------
/ch12/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC NEW
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |   j0.gencode($);
 12 |  } ;
 13 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 14 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 15 | ClassBodyDecls: ClassBodyDecl
 16 | | ClassBodyDecls ClassBodyDecl {
 17 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 18 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 19 | FieldDecl: Type VarDecls ';' {
 20 |   $=j0.node("FieldDecl",1030,$1,$2);
 21 |   j0.calctype($);
 22 |   };
 23 | Type: INT | DOUBLE | BOOLEAN | STRING | Name ;
 24 | 
 25 | Name: IDENTIFIER | QualifiedName ;
 26 | QualifiedName: Name '.' IDENTIFIER {
 27 |   $=j0.node("QualifiedName",1040,$1,$3);};
 28 | 
 29 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 30 |   $=j0.node("VarDecls",1050,$1,$3); };
 31 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 32 |   $=j0.node("VarDeclarator",1060,$1); };
 33 | 
 34 | MethodReturnVal : Type | VOID ;
 35 | MethodDecl: MethodHeader Block {
 36 |   $=j0.node("MethodDecl",1380,$1,$2);
 37 |  };
 38 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 39 |   $=j0.node("MethodHeader",1070,$3,$4);
 40 |   j0.calctype($);
 41 |   };
 42 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 43 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 44 | 
 45 | FormalParmListOpt: FormalParmList | ;
 46 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 47 |   $=j0.node("FormalParmList",1090,$1,$3); };
 48 | FormalParm: Type VarDeclarator {
 49 |   $=j0.node("FormalParm",1100,$1,$2);
 50 |   j0.calctype($);
 51 |  };
 52 | 
 53 | ConstructorDecl: MethodDeclarator Block {
 54 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 55 | 
 56 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 57 | BlockStmtsOpt: BlockStmts | ;
 58 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 59 |   $=j0.node("BlockStmts",1130,$1,$2); };
 60 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 61 | 
 62 | LocalVarDeclStmt: LocalVarDecl ';' ;
 63 | LocalVarDecl: Type VarDecls {
 64 |   $=j0.node("LocalVarDecl",1140,$1,$2);
 65 |   j0.calctype($);
 66 |   };
 67 | 
 68 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 69 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 70 |       | WhileStmt | ForStmt ;
 71 | 
 72 | ExprStmt: StmtExpr ';' ;
 73 | 
 74 | StmtExpr: Assignment | MethodCall ;
 75 | 
 76 | IfThenStmt: IF '(' Expr ')' Block {
 77 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 78 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 79 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 80 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 81 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 82 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 83 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 84 | 
 85 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 86 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 87 | ElseIfStmt: ELSE IfThenStmt {
 88 |   $=j0.node("ElseIfStmt",1190,$2); };
 89 | WhileStmt: WHILE '(' Expr ')' Stmt {
 90 |   $=j0.node("WhileStmt",1210,$3,$5); };
 91 | 
 92 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 93 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 94 | ForInit: StmtExprList | LocalVarDecl | ;
 95 | ExprOpt: Expr |  ;
 96 | ForUpdate: StmtExprList | ;
 97 | 
 98 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 99 |   $=j0.node("StmtExprList",1230,$1,$3); };
100 | 
101 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
102 |   $=j0.node("BreakStmt",1240,$2); };
103 | ReturnStmt: RETURN ExprOpt ';' {
104 |   $=j0.node("ReturnStmt",1250,$2); };
105 | 
106 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
107 | Primary:  Literal | FieldAccess | MethodCall | ArrayAccess |
108 |          '(' Expr ')' { $=$2;} | ArrayCreation | InstanceCreation;
109 | InstanceCreation: NEW Name '(' ArgListOpt ')' {
110 |   $=j0.node("InstanceCreation", 1261, $2, $4); };
111 | ArrayCreation: NEW Type '[' Expr ']' {
112 |   $=j0.node("ArrayCreation", 1260, $2, $4); };
113 | 
114 | ArgList: Expr | ArgList ',' Expr {
115 |   $=j0.node("ArgList",1270,$1,$3); };
116 | FieldAccess: Primary '.' IDENTIFIER {
117 |   $=j0.node("FieldAccess",1280,$1,$3); };
118 | 
119 | ArgListOpt:  ArgList | ;
120 | MethodCall: Name '(' ArgListOpt ')' {
121 |   $=j0.node("MethodCall",1290,$1,$3); }
122 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
123 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
124 | 	;
125 | 
126 | PostFixExpr: Primary | Name ;
127 | UnaryExpr:  '-' UnaryExpr {
128 |   $=j0.node("UnaryExpr",1300,$1,$2); }
129 |     | '!' UnaryExpr {
130 |   $=j0.node("UnaryExpr",1301,$1,$2); }
131 |     | PostFixExpr ;
132 | MulExpr: UnaryExpr
133 |     | MulExpr '*' UnaryExpr {
134 |       $=j0.node("MulExpr",1310,$1,$3); }
135 |     | MulExpr '/' UnaryExpr {
136 |       $=j0.node("MulExpr",1311,$1,$3); }
137 |     | MulExpr '%' UnaryExpr {
138 |       $=j0.node("MulExpr",1312,$1,$3); };
139 | AddExpr: MulExpr
140 |     | AddExpr '+' MulExpr {
141 |       $=j0.node("AddExpr",1320,$1,$3); }
142 |     | AddExpr '-' MulExpr {
143 |       $=j0.node("AddExpr",1321,$1,$3); };
144 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
145 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
146 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
147 | 
148 | EqExpr: RelExpr
149 |     | EqExpr ISEQUALTO RelExpr {
150 |   $=j0.node("EqExpr",1340,$1,$3); }
151 | | EqExpr NOTEQUALTO RelExpr {
152 |   $=j0.node("EqExpr",1341,$1,$3); };
153 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
154 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
155 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
156 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
157 | 
158 | ArrayAccess: Name '[' Expr ']' { $=j0.node("ArrayAccess",1390,$1,$3); };
159 | 
160 | Expr: CondOrExpr | Assignment ;
161 | Assignment: LeftHandSide AssignOp Expr {
162 |   $=j0.node("Assignment",1370, $1, $2, $3); };
163 | LeftHandSide: Name | FieldAccess | ArrayAccess ;
164 | AssignOp: '=' | INCREMENT | DECREMENT ;
165 | 


--------------------------------------------------------------------------------
/ch12/j0machine.icn:
--------------------------------------------------------------------------------
  1 | link signed
  2 | class j0machine(code, ip, stack, data, finstr, sp, bp, hp, op, opr, opnd)
  3 |   # loadbytecode at present returns everything after the first two-words of header
  4 |   method loadbytecode(filename)
  5 |     sz := stat(filename).size
  6 |     f := open(filename) | stop("cannot open ", filename)
  7 |     s := reads(f, sz) | stop("cannot read from ", filename)
  8 |     close(f)
  9 |     s ? {
 10 |       if tab(find("Jzero!!\0001.0\0\0\0\0\0")) then {
 11 |         return tab(0)
 12 |         }
 13 |       else stop("file ", filename, " is not a Jzero file")
 14 |       }
 15 |   end
 16 |   method init(filename)
 17 |     ip := 0
 18 |     code := loadbytecode(filename) |
 19 |       stop("cannot open program.j0")
 20 |     Op()
 21 |     ip := 16
 22 |     ip := finstr := 8*getOpnd()
 23 |     data := Data(code[25:ip+1])
 24 |     stack := list()
 25 |     bp := sp := 1
 26 |   end
 27 |   method fetch()
 28 |     op := ord(code[1+ip]) | stop("can't get op at ", ip)
 29 |     opr := ord(code[2+ip])
 30 |     if opr ~= 0 then { opnd := getOpnd() }
 31 |     ip +:= 8
 32 |   end
 33 |   method getOpnd()
 34 |     return signed(reverse(code[ip+3+:6])) | stop("getOpnd failed")
 35 |   end
 36 |   method word(s)
 37 |    local i := 0, j
 38 |      every j := 8 to 1 by -1 do {
 39 |        b := ord(s[j])
 40 |        i := ishift(i, 8) + ord(b)
 41 |      }
 42 |    return i
 43 |   end
 44 |   method interp()
 45 |     repeat {
 46 |       fetch()
 47 |       case (op) of {
 48 |          Op.HALT: { stop("Execution completed.") }
 49 |          Op.NOOP: {   }
 50 |          Op.ADD: {
 51 |            val1 := pop(stack); val2 := pop(stack)
 52 |            push(stack, val1 + val2)
 53 |            }
 54 |          Op.PUSH: {
 55 |            (val := deref(opr, opnd)) | stop("deref failed")
 56 |            push(stack, val)
 57 |            }
 58 |          Op.POP: {
 59 |            val := pop(stack)
 60 |            assign(opnd, val)
 61 |            }
 62 |          Op.GOTO: {
 63 |            ip := opnd
 64 |            }
 65 |          Op.BIF: {
 66 |            if pop(stack)~=0 then
 67 |              ip := opnd
 68 |            }
 69 |          Op.CALL: {
 70 |            f := stack[2+opnd]
 71 |            if f >= 0 then {
 72 |              push( stack, ip) # save old ip
 73 |              push( stack, bp) # save old ip
 74 |              bp := *stack     # set new bp
 75 |              ip := f          # set new ip
 76 |              }
 77 |            else if f = -1 then do_println()
 78 |            else stop("no CALL defined for ", image(f))
 79 |            }
 80 |          Op.RETURN: {
 81 |            while *stack > bp do pop(stack)
 82 |            bp := pop(stack)
 83 |            ip := pop( stack )
 84 |            }
 85 | 
 86 |          Op.LT: {  }
 87 |          Op.LE: {  }
 88 |          default: { stop("Illegal opcode ", op) }
 89 |          }
 90 |       }
 91 |   end
 92 |   method do_println()
 93 |     # stack[1] is self. first arg is stack[2]
 94 |     x := stack[2]
 95 |     y := c_string(code[1+x:0])
 96 |     write(y)
 97 |   end
 98 |   method c_string(s)
 99 |     if i := find("\0", s) then return s[1:i]
100 |     else stop("no C string in ", image(s))
101 |   end
102 |   method assign(x, y)
103 |     # implement assign
104 |   end
105 | 
106 |   method deref(reg, opd)
107 |     case reg of {
108 |       Op.R_ABS: {
109 |         if opd < finstr then return data.word(opd) | stop("datafail")
110 |         else return code[opd] | stop("codefail")
111 |         }
112 |       Op.R_IMM: { return opd }
113 |       Op.R_STACK: {
114 |          return stack[bp+opd/8] | stop("stackfail bp ", bp, " opd ", opd) }
115 |       default: { write("deref region ", reg); runerr(101, reg) }
116 |     }
117 |   end
118 | 
119 | end
120 | class Data(d)
121 |   method word(o)
122 |     return d[1+o +: 8]
123 |   end
124 | end
125 | 


--------------------------------------------------------------------------------
/ch12/j0machine.java:
--------------------------------------------------------------------------------
  1 | package ch12;
  2 | import java.io.IOException;
  3 | import java.nio.file.Files;
  4 | import java.nio.file.Paths;
  5 | import java.nio.charset.StandardCharsets;
  6 | import java.nio.ByteBuffer;
  7 | public class j0machine {
  8 |   public static byte[] code, stack;
  9 |   public static ByteBuffer codebuf, stackbuf;
 10 |   public static int ip, sp, bp, hp, op, opr, finstr;
 11 |   public static long opnd;
 12 | 
 13 |   public static boolean loadbytecode(String filename)
 14 |     throws IOException {
 15 |       code = Files.readAllBytes(Paths.get(filename));
 16 |       byte[] magstr = "Jzero!!\0".getBytes(
 17 |                           StandardCharsets.US_ASCII);
 18 |       int i = find(magstr, code);
 19 |       if (i>=0) {
 20 |         // need to check version, allow for self-execution script header
 21 |         codebuf = ByteBuffer.wrap(code);
 22 |         return true;
 23 |       }
 24 |       else return false;
 25 |   }
 26 | 
 27 |   public static int find(byte[]needle, byte[]haystack) {
 28 |     int i=0;
 29 |     for( ; i < haystack.length - needle.length+1; ++i) {
 30 |         boolean found = true;
 31 |         for(int j = 0; j < needle.length; ++j) {
 32 |            if (haystack[i+j] != needle[j]) {
 33 |                found = false;
 34 |                break;
 35 |            }
 36 |         }
 37 |         if (found) return i;
 38 |     }
 39 |     return -1;
 40 |   }
 41 |   public static void init(String filename)
 42 |     throws IOException {
 43 |       ip = sp = 0;
 44 |       if (! loadbytecode(filename)) {
 45 |          System.err.println("cannot open program.j0");
 46 |          System.exit(1);
 47 |          }
 48 |       ip = 16;
 49 |       ip = finstr = (int) (8*getOpnd());
 50 |       stack = new byte[800000];
 51 |       stackbuf = ByteBuffer.wrap(stack);
 52 |     }
 53 |   public static void fetch() {
 54 |       op = code[ip];
 55 |       opr = code[ip+1];
 56 |       if (opr != 0) { opnd = getOpnd(); }
 57 |       ip += 8;
 58 |   }
 59 |   public static long getOpnd() {
 60 |    long i=0;
 61 |    if (codebuf.get(ip+7) < 0) i = -1;
 62 |    for(int j=7;j>1;j--) i = (i<<8) | codebuf.get(ip+j);
 63 |    return i;
 64 |   }
 65 |   public static void stop(String s) {
 66 |     System.err.println(s);
 67 |     System.exit(1);
 68 |     }
 69 |   public static void interp() {
 70 |     for(;;) {
 71 |       fetch();
 72 |       switch (op) {
 73 |         case Op.HALT: { stop("Execution complete."); break; }
 74 |         case Op.NOOP: { break; }
 75 |         case Op.ADD: {
 76 |           long val1 = stackbuf.getLong(sp--);
 77 |           long val2 = stackbuf.getLong(sp--);
 78 | 	  stackbuf.putLong(sp++, val1 + val2);
 79 |           break;
 80 |           }
 81 |       case Op.PUSH: {
 82 | 	  long val = deref(opr, opnd);
 83 | 	  push(val);
 84 | 	  break;
 85 |       }
 86 |       case Op.POP: {
 87 | 	  long val = pop();
 88 | 	  assign(opnd, val);
 89 | 	  break;
 90 |       }
 91 |       case Op.GOTO: {
 92 | 	  ip = (int)opnd;
 93 | 	  break;
 94 |       }
 95 |       case Op.BIF: {
 96 | 	  if (pop() != 0)
 97 | 	      ip = (int)opnd;
 98 | 	  break;
 99 |       }
100 | 
101 |       case Op.CALL: {
102 | 	  long f;
103 | 	  f = stackbuf.getLong(sp-16-(int)(8*opnd));
104 | 	  if (f >= 0) {
105 | 	      push( ip);
106 | 	      push( bp);
107 | 	      bp = sp;
108 | 	      ip = (int)f;
109 |              }
110 | 	  else if (f == -1) do_println();
111 | 	  else { stop("no CALL defined for " + f); }
112 | 	  break;
113 |            }
114 |       case Op.RETURN: {
115 |            sp = bp;
116 |            bp = (int)pop();
117 |            ip = (int)pop();
118 | 	   break;
119 |            }
120 | 
121 |       case Op.LT: { stop("LT not implemented yet."); break; }
122 |       case Op.LE: { stop("LE not implemented yet."); break; }
123 |       default: { stop("Illegal opcode " + op); }
124 |       }
125 |     }
126 |   }
127 | 
128 |     public static void do_println() {
129 | 	// execute a system.out.println on an argument on the stack
130 | 	long addr = stackbuf.getLong(sp-16);
131 | 	byte b = codebuf.get((int)addr++);
132 | 	while (b != 0) {
133 | 	   System.out.print((char)b);
134 |            b = codebuf.get((int)addr++);
135 |         }
136 | 	System.out.println();
137 |     }
138 | 
139 |     public static long deref(int reg, long od) {
140 | 	switch(reg) {
141 | 	case Op.R_ABS: { return codebuf.getLong((int)od); }
142 | 	case Op.R_IMM: { return od; }
143 | 	case Op.R_STACK: { return stackbuf.getLong(bp+(int)od); }
144 |         default: { stop("deref region " + reg); }
145 | 	}
146 | 	return 0;
147 |     }
148 | 
149 |     public static void assign(long ad, long val) {
150 | 	switch(opr) {
151 | 	case Op.R_ABS: {  }
152 | 	case Op.R_IMM: {  }
153 | 	case Op.R_STACK: {  }
154 |         default: {  } // stop("assign region " + opr); }
155 | 	}
156 |     }
157 | 
158 |     public static void push(long val) {
159 |       stackbuf.putLong(val);
160 |       sp += 8;
161 |     }
162 | 
163 |     public static long pop() {
164 |       sp -= 8;
165 |       long rv = stackbuf.getLong(sp);
166 |       return rv;
167 |     }
168 | }
169 | 


--------------------------------------------------------------------------------
/ch12/j0x.icn:
--------------------------------------------------------------------------------
1 | procedure main(argv)
2 |   if not (filename := argv[1]) then
3 |     stop("usage: j0x file[.j0]")
4 |   if not (filename[-3:0] == ".j0") then filename ||:= ".j0"
5 |   j0machine := j0machine()
6 |   j0machine.init(filename)
7 |   j0machine.interp()
8 | end
9 | 


--------------------------------------------------------------------------------
/ch12/j0x.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class j0x {
 3 |   public static void main(String[] argv) {
 4 |     if (argv.length < 1) {
 5 |       System.err.println("usage: j0x file[.j0]" + argv.length);
 6 |       System.exit(1);
 7 |       }
 8 |     String filename = argv[0];
 9 |     if (! filename.endsWith(".j0"))
10 |       filename = filename + ".j0";
11 |     try {
12 |       j0machine.init(filename);
13 |     } catch(Exception ex) {
14 | 	System.err.println("Can't initialize. Exiting.");
15 | 	System.exit(1);
16 |     }
17 |     j0machine.interp();
18 |   }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch12/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "new"                  { return j0.scan(parser.NEW); }
18 | "null"                 { return j0.scan(parser.NULLVAL); }
19 | "public"               { return j0.scan(parser.PUBLIC); }
20 | "return"               { return j0.scan(parser.RETURN); }
21 | "static"               { return j0.scan(parser.STATIC); }
22 | "string"               { return j0.scan(parser.STRING); }
23 | "true"                 { return j0.scan(parser.BOOLLIT); }
24 | "boolean"              { return j0.scan(parser.BOOLEAN); }
25 | "void"                 { return j0.scan(parser.VOID); }
26 | "while"                { return j0.scan(parser.WHILE); }
27 | "class"                { return j0.scan(parser.CLASS); }
28 | "("                    { return j0.scan(j0.ord("("));}
29 | ")"                    { return j0.scan(j0.ord(")"));}
30 | "["                    { return j0.scan(j0.ord("["));}
31 | "]"                    { return j0.scan(j0.ord("]"));}
32 | "{"                    { return j0.scan(j0.ord("{"));}
33 | "}"                    { return j0.scan(j0.ord("}"));}
34 | ";"                    { return j0.scan(j0.ord(";"));}
35 | ":"                    { return j0.scan(j0.ord(":"));}
36 | "!"                    { return j0.scan(j0.ord("!"));}
37 | "*"                    { return j0.scan(j0.ord("*"));}
38 | "/"                    { return j0.scan(j0.ord("/"));}
39 | "%"                    { return j0.scan(j0.ord("%"));}
40 | "+"                    { return j0.scan(j0.ord("+"));}
41 | "-"                    { return j0.scan(j0.ord("-"));}
42 | "<"                    { return j0.scan(j0.ord("<"));}
43 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
44 | ">"                    { return j0.scan(j0.ord(">"));}
45 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
46 | "=="                   { return j0.scan(parser.ISEQUALTO);}
47 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
48 | "&&"                   { return j0.scan(parser.LOGICALAND);}
49 | "||"                   { return j0.scan(parser.LOGICALOR);}
50 | "="                    { return j0.scan(j0.ord("=")); }
51 | "+="                   { return j0.scan(parser.INCREMENT); }
52 | "-="                   { return j0.scan(parser.DECREMENT); }
53 | ","                    { return j0.scan(j0.ord(",")); }
54 | "."                    { return j0.scan(j0.ord(".")); }
55 | {id}                   { return j0.scan(parser.IDENTIFIER); }
56 | [0-9]+                 { return j0.scan(parser.INTLIT); }
57 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
58 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
59 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
60 | .                      { j0.lexErr("unrecognized character"); }
61 | 


--------------------------------------------------------------------------------
/ch12/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u typeinfo.u
 6 | CGU=tac.u address.u byc.u op.u
 7 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU) $(CGU)
 8 | UX=j0x.u j0machine.u op.u
 9 | 
10 | unicon: j0 j0x
11 | %.u : %.icn
12 | 	unicon -c 
lt;
13 | j0: $(U)
14 | 	unicon $(U)
15 | javalex.icn: javalex.l
16 | 	uflex javalex.l
17 | j0gram.icn j0gram_tab.icn: j0gram.y
18 | 	iyacc -dd j0gram.y
19 | j0x: $(UX)
20 | 	unicon $(UX)
21 | 
22 | 
23 | # A typical run might use
24 | # set CLASSPATH=".;c:\users\username\byopl"
25 | # in order to run from c:\users\username\byopl\ch12
26 | LYSRC=Yylex.java parser.java parserVal.java
27 | TPJ=typeinfo.java arraytype.java classtype.java methodtype.java parameter.java
28 | STJ=symtab.java symtab_entry.java $(TPJ)
29 | CGJ=tac.java address.java byc.java op.java
30 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ) $(CGJ)
31 | JXSRC= Op.java j0x.java j0machine.java
32 | BYJOPTS= -Jclass=parser -Jpackage=ch12
33 | BYJIMPS= -Jyylex=ch12.j0.yylex -Jyyerror=ch12.yyerror.yyerror
34 | java: j0.class j0x.class
35 | 
36 | j: java
37 | 	java ch12.j0 hello.java
38 | 	dot -Tpng hello.java.dot >hello.png
39 | 
40 | j0.class: $(JSRC)
41 | 	javac $(JSRC)
42 | parser.java parserVal.java: j0gram.y
43 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
44 | Yylex.java: javalex.l
45 | 	jflex javalex.l
46 | 
47 | j0x.class: $(JXSRC)
48 | 	javac $(JXSRC)
49 | 


--------------------------------------------------------------------------------
/ch12/methodtype.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class methodtype extends typeinfo {
 3 |    typeinfo [] parameters;
 4 |    typeinfo return_type;
 5 |     public String str() {
 6 | 	String s;
 7 | 	s = "method " + ((return_type!=null)?return_type.str():"undef") + "(";
 8 | 	for(typeinfo p : parameters)
 9 | 	    s = s + p.str() + ",";
10 | 	s = s.substring(0,s.length()-2) + ")";
11 | 	return s;
12 |     }
13 |    methodtype(typeinfo [] p, typeinfo rt){
14 |        parameters = p;
15 |        if (rt !=null) return_type = rt;
16 |        else return_type = new typeinfo("void");
17 |        basetype="method";
18 |    }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch12/parameter.java:
--------------------------------------------------------------------------------
1 | package ch12;
2 | public class parameter {
3 |    String name;
4 |    typeinfo param_type;
5 |    parameter(String s, typeinfo t) { name=s; param_type=t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch12/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch12/serial.java:
--------------------------------------------------------------------------------
1 | package ch12;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch12/symtab.icn:
--------------------------------------------------------------------------------
 1 | # t is the actual hash table, L holds keys in the order inserted
 2 | class symtab(scope, parent, t, L, count)
 3 |   method lookup(s)
 4 |     return if rv := \ (t[s]) then {
 5 |               rv }
 6 |            else {
 7 |              (\parent).lookup(s)
 8 |              }
 9 |   end
10 |   method insert(s, isConst, sub, typ)
11 |     if \ (t[s]) then {
12 |       if scope == "strings" then {
13 | #         write("eureka, a duplicate string constant")
14 |          }
15 |       else
16 |          j0.semErr("redeclaration of " || s)
17 |       }
18 |     else {
19 |       (\sub).parent := self
20 |       t[s] := symtab_entry(s, self, sub, isConst, typ,
21 |                            address(scope,count))
22 |       put(L, s)
23 |       len := *s
24 |       while len > 0 do {
25 |          count +:= 8
26 | 	 len -:= 8
27 | 	 }
28 |       }
29 |   end
30 |   method genlocal()
31 |   local s := "__local
quot; || count
32 |     insert(s, false, , typeinfo("int"))
33 |     return t[s].addr
34 |   end
35 |   method print(level:0)
36 |     writes(repl(" ",level))
37 |     write(scope, " - ", *t, " symbols")
38 |     every (!t).print(level+1);
39 |   end
40 | 
41 | initially
42 |   t := table()
43 |   L := [ ]
44 |   count := 0
45 | end
46 | 


--------------------------------------------------------------------------------
/ch12/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | import java.util.HashMap;
 3 | import java.util.ArrayList;
 4 | public class symtab {
 5 |    String scope;
 6 |    symtab parent;
 7 |    HashMap<String,symtab_entry> t;
 8 |    ArrayList<String> L;
 9 |    int count;
10 |    symtab(String sc) {
11 |       scope = sc;
12 |       t = new HashMap<String,symtab_entry>();
13 |       L = new ArrayList<String>();
14 |   }
15 |     symtab(String sc, symtab p) {
16 |       scope = sc; parent = p;
17 |       t = new HashMap<String,symtab_entry>();
18 |       L = new ArrayList<String>();
19 |    }
20 |    symtab_entry lookup(String s) {
21 |        symtab_entry rv;
22 |        rv = t.get(s);
23 |        if (rv != null) {
24 | 	   return rv;
25 |        }
26 |       if (parent != null) return parent.lookup(s);
27 |       return null;
28 |    }
29 |    void insert(String s, Boolean iC, symtab sub, typeinfo typ) {
30 |       if (t.containsKey(s)) {
31 |          j0.semErr("redeclaration of " + s);
32 |       } else {
33 |          if (sub != null)
34 |             sub.parent = this;
35 |          t.put(s, new symtab_entry(s, this, iC, sub, typ,
36 | 				   new address(scope,count)));
37 | 	 L.add(s);
38 | 	 int len = s.length();
39 | 	 while(len > 0) {
40 | 	     count += 8;
41 | 	     len -= 8;
42 | 	 }
43 |       }
44 |    }
45 |    address genlocal() {
46 |       String s = "__local
quot; + count;
47 |       insert(s, false, null, new typeinfo("int"));
48 |       return t.get(s).addr;
49 |    }
50 |    void insert(String s, Boolean iC) {
51 |       if (t.containsKey(s)) {
52 |          j0.semErr("redeclaration of " + s);
53 |       } else {
54 |          t.put(s, new symtab_entry(s, this, iC));
55 |       }
56 |    }
57 |    void print() { print(0); }
58 |    void print(int level) {
59 |       for(int i=0; i<level; i++)
60 |         System.out.print(" ");
61 |       System.out.println(scope + " - " + t.size() + " symbols");
62 |       for(symtab_entry se : t.values()) se.print(level+1);
63 |    }
64 | }
65 | 


--------------------------------------------------------------------------------
/ch12/symtab_entry.icn:
--------------------------------------------------------------------------------
 1 | class symtab_entry(sym,parent_st,st,isConst,typ,addr)
 2 |   method print(level:0)
 3 |     writes(repl(" ",level), sym)
 4 |     if \isconst then writes(" (const)")
 5 |     if \typ then writes(" ", typ.str())
 6 |     write()
 7 |     (\st).print(level+1);
 8 |   end
 9 | end
10 | 


--------------------------------------------------------------------------------
/ch12/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    typeinfo typ;
 7 |    address addr;
 8 |    void print(int level) {
 9 |       for(int i=0; i<level; i++) System.out.print(" ");
10 |       System.out.print(sym);
11 |       if (isConst) System.out.print(" (const)");
12 |       System.out.println("");
13 |       if (st != null) st.print(level+1);
14 |    }
15 |    symtab_entry(String s, symtab p, boolean iC) {
16 |        sym = s; parent_st = p; isConst = iC; }
17 |    symtab_entry(String s, symtab p, boolean iC,
18 | 		symtab t, typeinfo ti, address a) {
19 |       sym = s; parent_st = p; isConst = iC;
20 |       st = t; typ = ti; addr = a;
21 |  }
22 | }
23 | 


--------------------------------------------------------------------------------
/ch12/tac.icn:
--------------------------------------------------------------------------------
 1 | class tac(op, op1, op2, op3)
 2 |    method print()
 3 |       case op of {
 4 |       "proc": write(op || "\t" || op1.region || ",0,0")
 5 | 			     # || op2.str() || "," || op3.str());
 6 |       "end": write(op)
 7 |       ".code": write(op)
 8 |       ".global": write(op)
 9 |       ".string": write(op)
10 |       "LAB": writes("L",op1.offset,":")
11 |       "string": {
12 | 	  write("\t", op, "\t", op1)
13 | 	 }
14 |       default: {
15 | 	  writes("\t" || op)
16 | 	  if \op1 then {
17 |              writes("\t")
18 |              if string(op1) then {
19 |                 if ste := stringtab.lookup(op1) then writes("str:", ste.addr.offset)
20 |                 else writes(op1)
21 |                 }
22 |              else {
23 | 	        writes(op1.str())
24 | 		}
25 | 	     if \op2 then
26 | 	        writes("," || (string(op2)|op2.str()))
27 | 	     if \op3 then
28 | 	        writes("," || op3.str())
29 | 	     }
30 | 	  write()
31 | 	  }
32 |       }
33 |    end
34 | end
35 | 


--------------------------------------------------------------------------------
/ch12/tac.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class tac {
 3 |    String op;
 4 |    address op1, op2, op3;
 5 |    public void print() {
 6 |       switch (op) {
 7 |       case "proc":
 8 | 	  System.out.println(op + "\t" + op1.region + ",0,0");
 9 | 			     // + op2.str() + "," + op3.str());
10 | 	  break;
11 |       case "end":
12 | 	  System.out.println(op);
13 | 	  break;
14 |       default:
15 | 	  System.out.print("\t" + op + "\t");
16 | 	  if (op1 != null)
17 | 	     System.out.print(op1.str());
18 | 	  if (op2 != null)
19 | 	      System.out.print("," + op2.str());
20 | 	  if (op3 != null)
21 | 	      System.out.print("," + op3.str());
22 | 	  System.out.println("");
23 |       }
24 |    }
25 |    tac(String s) { op = s; }
26 |    tac(String s, address o) { op = s; op1 = o; }
27 |    tac(String s, address o1, address o2) {
28 |       op = s; op1 = o1; op2 = o2; }
29 |    tac(String s, address o1, address o2, address o3) {
30 |       op = s; op1 = o1; op2 = o2; op3 = o3; }
31 | }
32 | 


--------------------------------------------------------------------------------
/ch12/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval, typ, isPublic, isStatic)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | method type(stab)
21 |   if \typ then return typ
22 |   if cat === parser.IDENTIFIER then
23 |     if rv := stab.lookup(text) then return typ := rv.typ
24 |     else stop("line ", lineno ,": cannot check type of undeclared ", image(text))
25 | end
26 | initially
27 |    case cat of {
28 |      parser.INT:     typ := typeinfo("int")
29 |      parser.DOUBLE:  typ := typeinfo("double")
30 |      parser.BOOLEAN: typ := typeinfo("boolean")
31 |      parser.VOID:    typ := typeinfo("void")
32 |      parser.INTLIT: { ival := integer(text); typ:=typeinfo("int") }
33 |      parser.DOUBLELIT: { dval := real(text); typ:=typeinfo("double") }
34 |      parser.STRINGLIT: { sval := deEscape(text); typ:=classtype("String") }
35 |      parser.BOOLLIT: { typ := typeinfo("boolean") }
36 |      parser.NULLVAL: { typ := typeinfo("null") }
37 |      ord("="|"+"|"-"): { typ := typeinfo("n/a") }
38 |    }
39 | end
40 | 


--------------------------------------------------------------------------------
/ch12/token.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class token {
 3 |   public int id;
 4 |   public int cat;
 5 |   public String text;
 6 |   public int lineno;
 7 |   public typeinfo typ;
 8 |   public token(int c, String s, int l) {
 9 |     cat = c; text = s; lineno = l;
10 |     id = serial.getid();
11 |     switch (cat) {
12 |     case parser.INT: typ = new typeinfo("int"); break;
13 |     case parser.DOUBLE: typ = new typeinfo("double"); break;
14 |     case parser.BOOLEAN: typ = new typeinfo("boolean"); break;
15 |     case parser.VOID: typ = new typeinfo("void"); break;
16 |     case parser.INTLIT: typ = new typeinfo("int"); break;
17 |     case parser.DOUBLELIT: typ = new typeinfo("double"); break;
18 |     case parser.STRINGLIT: typ = new typeinfo("String"); break;
19 |     case parser.BOOLLIT: typ = new typeinfo("boolean"); break;
20 |     case parser.NULLVAL: typ = new typeinfo("null"); break;
21 |     case '=': case '+': case '-': typ = new typeinfo("n/a"); break;
22 |     }
23 |    }
24 | public typeinfo type(symtab stab) {
25 |   symtab_entry rv;
26 |   if (typ != null) return typ;
27 |   if (cat == parser.IDENTIFIER)
28 |       if ((rv = stab.lookup(text)) != null) return typ=rv.typ;
29 |   j0.semErr("cannot check the type of " + text);
30 |   return null;
31 | }
32 | }
33 | 


--------------------------------------------------------------------------------
/ch12/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab,
  2 | 	    typ,icode,addr,first,follow,onTrue,onFalse)
  3 |   method print(level:0)
  4 |     writes(repl(" ",level))
  5 |     if \tok then {
  6 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  7 |       }
  8 |     else {
  9 |        write(id, "   ", sym, " (", rule, "): ", nkids)
 10 |        every (!kids).print(level+1)
 11 |        }
 12 |   end
 13 |   method print_graph(fw)
 14 |     if type(filename) == "string" then {
 15 |       fw := open(filename,  "w") |
 16 |         stop("can't open ", image(filename), " for writing")
 17 |       write(fw, "digraph {")
 18 |       print_graph(fw)
 19 |       write(fw, "}")
 20 |       close(fw)
 21 |     }
 22 |     else if \tok then print_leaf(fw)
 23 |     else { 
 24 |       print_branch(fw)
 25 |       every i := 1 to nkids do
 26 |         if \kids[i] then {
 27 |           write(fw, "N",id," -> N",kids[i].id,";")
 28 |           kids[i].print_graph(fw)
 29 |         } else {
 30 |           write(fw, "N",id," -> N",id,"_",j,";")
 31 |           write(fw, "N", id, "_", j,
 32 |                     " [label=\"Empty rule\"];")
 33 |           j +:= 1
 34 |         }
 35 |     }
 36 |   end
 37 |   method print_leaf(pw)
 38 |     local s := parser.yyname[tok.cat]
 39 |     print_branch(pw)
 40 |     write(pw,"N",id,
 41 |           " [shape=box style=dotted label=\" ",s," \\n ")
 42 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 43 |              tok.lineno," \\l\"];\n")
 44 |   end
 45 |   method print_branch(pw)
 46 |     write(pw, "N",id," [shape=box label=\"",
 47 |           pretty_print_name(),"\"];\n");
 48 |   end
 49 |   method escape(s)
 50 |     if s[1] == "\"" then
 51 |       return "\\" || s[1:-1] || "\\\""
 52 |     else return s
 53 |   end
 54 |   method pretty_print_name()
 55 |     if /tok then return sym || "#" || (rule%10)
 56 |     else return escape(tok.text) || ":" || tok.cat
 57 |   end
 58 |   method mkSymTables(curr)
 59 |     stab := curr
 60 |     case sym of {
 61 |       "ClassDecl": { curr := symtab("class",curr) }
 62 |       "MethodDecl": { curr := symtab("method",curr) }
 63 |     }
 64 |     every (!\kids).mkSymTables(curr)
 65 |   end
 66 |   method populateSymTables()
 67 |   case sym of {
 68 |     "ClassDecl": {
 69 |        stab.insert(kids[1].tok.text, , kids[1].stab) # new classtype() ?
 70 |        }
 71 |     "FieldDecl" | "LocalVarDecl" : {
 72 |        k := kids[2]
 73 |        while \k & k.sym=="VarDecls" do {
 74 |          insert_vardeclarator(k.kids[2])
 75 |          k := k.kids[1]
 76 |          }
 77 |        insert_vardeclarator(k); return
 78 |        }
 79 |     "MethodDecl": {
 80 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab,
 81 | 	          kids[1].kids[2].typ)
 82 |       kids[1].stab.insert("return", , , kids[1].kids[1].typ)
 83 |       }
 84 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 85 |     }
 86 |     every (!\kids).populateSymTables()
 87 |   end
 88 |   method insert_vardeclarator(vd)
 89 |     if \vd.tok then stab.insert(vd.tok.text,&null,&null,vd.typ)
 90 |     else insert_vardeclarator(vd.kids[1])
 91 |   end
 92 |   method calc_isConst()
 93 |    every (!\kids).calc_isConst()
 94 |    case sym of {
 95 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 96 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 97 |       "UnaryExpr": isConst := \kid[2].isConst
 98 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 99 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
100 |       "MULEXPR"|
101 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
102 |       default: isConst := &null
103 |    }
104 |   end
105 |   # after symbol table population, we have enough information to fill in
106 |   # correct class type information.
107 |   method mkcls()
108 |     if sym == "ClassDecl" then {
109 |         rv := stab.lookup(kids[1].tok.text)
110 |         flds := []; methds := []; constrs := []
111 |         every k := key(rv.st.t) do
112 |            if match("method ", rv.st.t[k].typ.str()) then
113 |              put(methds, parameter(k, rv.st.t[k].typ))
114 |            else
115 |              put(flds, parameter(k, rv.st.t[k].typ))
116 |         (/(rv.typ) := classtype(kids[1].tok.text, rv.st, flds, methds, constrs))
117 |     }
118 |     else every k := !kids do
119 |       if k.nkids>0 then k.mkcls()
120 |   end
121 |   method checkSymTables()
122 |     check_codeblocks()
123 |   end
124 |   # this looks for undeclareds
125 |   method check_codeblocks()
126 |    if sym == "MethodDecl" then { kids[2].check_block() }
127 |    else every k := !kids do
128 |          if k.nkids>0 then k.check_codeblocks()
129 |   end
130 |   method check_block()
131 |    case sym of {
132 |    "IDENTIFIER": {
133 |      if not (stab.lookup(tok.text)) then
134 |         j0.semErr("undeclared variable "||tok.text)
135 |      }
136 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
137 |    "MethodCall": {
138 |       kids[1].check_block()
139 |       if rule = 1290 then
140 |          kids[2].check_block()
141 |       else kids[3].check_block()
142 |      }
143 |    "LocalVarDecl": { } # skip
144 |    default:  {
145 |       every k := !\kids do {
146 |             k.check_block()
147 |          }
148 |       }
149 |    }
150 |   end
151 |   # calctype - synthesize the type of a variable declaration
152 |   method calctype()
153 |     every (!\kids).calctype()
154 |     case sym of {
155 |       "FieldDecl": typ := kids[1].typ
156 |       "token": {
157 |          if typ := \ (tok.typ) then return
158 |          case tok.cat of {
159 |          parser.IDENTIFIER:{
160 |            if \ (rv := (\stab).lookup(tok.text)) then {
161 |               if typ := \ (rv.typ) then
162 |                  return typ
163 |               }
164 |            return typ := classtype(tok.text)
165 |            }
166 |          default:
167 |            j0.semErr("can't grok the type of " || image(tok.text) ||
168 | 		     " cat " || tok.cat)
169 |          }
170 |       }
171 |     default:
172 |        j0.semErr("don't know how to calctype " || image(sym))
173 |     }
174 |   end
175 | 
176 |    # check a call against a signature
177 |    method cksig(sig)
178 |    local i:=*sig.parameters, nactual := 1, t := kids[2]
179 |      if /t then {
180 |        if i ~= 0 then stop("0 parameters, expected ", i)
181 |        }
182 |      else {
183 |        while t.sym == "ArgList" do { nactual +:= 1; t:=t.kids[1] }
184 |        if nactual ~= i then
185 |          stop(nactual, " parameters, expected ", i)
186 |        t := kids[2]
187 |        while t.sym == "ArgList" do {
188 |          check_types(t.kids[-1].typ, sig.parameters[i])
189 |          t := t.kids[1]; i-:=1
190 |          }
191 |        check_types(t.typ, sig.parameters[1])
192 |      }
193 |      typ := sig.return_type
194 |    end
195 | 
196 |   # return a list of types corresponding to a syntax subtree parameter list
197 |   method mksig()
198 |      case sym of {
199 |         "FormalParm": return [kids[1].typ]
200 |         "FormalParmList": return kids[1].mksig() ||| kids[2].mksig()
201 |         }
202 |   end
203 | 
204 |   # assigntype - inherit a type, typically into a variable declaration list
205 |   method assigntype(t)
206 |   local parmList
207 |     typ := t
208 |     case sym of {
209 |     "VarDeclarator": { # we have an ARRAY of whatever type t was
210 |       kids[1].assigntype(arraytype(t))
211 |       return
212 |     }
213 |     "MethodDeclarator": { # pass a return type into a method
214 |        parmList := (\ (kids[2]).mksig()) | []
215 |        kids[1].typ := typ := methodtype(parmList , t)
216 |        return
217 |     }
218 |     "token": {
219 |       case tok.cat of {
220 |          parser.IDENTIFIER: return
221 |          default: stop("eh? ", image(tok.cat))
222 |       }
223 |     }
224 |     default:
225 |        stop("don't know how to assign the type of ", image(sym))
226 |     }
227 |     every (!\kids).assigntype(t)
228 |   end
229 | 
230 | method checkkids(in_codeblock)
231 |     case sym of {
232 |        # turn on in executable StmtBlock
233 |        "MethodDecl": { kids[2].checktype(1); return }
234 |        # turn off in LocalVarDecl list...(back on in initializers, if any)
235 |        "LocalVarDecl": { kids[2].checktype(); return }
236 |        "FieldAccess": { kids[1].checktype(in_codeblock);
237 |           return }
238 |        "QualifiedName": { # has to be a type you can . on
239 |            kids[1].checktype(in_codeblock);
240 |        }
241 |        "RelExpr": {
242 |            kids[1].checktype(in_codeblock);
243 |            kids[3].checktype(in_codeblock);
244 |        }
245 |        default: { every (!\kids).checktype(in_codeblock) }
246 |        }
247 | end
248 | 
249 |   # given a qualifiedname, return its type
250 |   method dequalify()
251 |   local rv, ste
252 |     if kids[1].sym == "QualifiedName" then
253 |       rv := kids[1].dequalify()
254 |     else if kids[1].sym=="token" &
255 |             kids[1].tok.cat=parser.IDENTIFIER then {
256 |       if not \ (rv := stab.lookup(kids[1].tok.text)) then
257 |          j0.semErr("unknown symbol " || kids[1].tok.text)
258 |       rv := rv.typ
259 |     }
260 |     else j0.semErr("can't dequalify " || sym)
261 |     if rv.basetype ~== "class" then
262 |       j0.semErr("can't dequalify " || rv.basetype)
263 |     if \ (ste := rv.st.lookup(kids[2].tok.text)) then
264 |       return ste.typ
265 |     else j0.semErr("couldn't lookup " || kids[2].tok.text ||
266 | 		   " in " || rv.str())
267 | end
268 | 
269 |   # checktype - check, and determine, the type of each expression
270 |   method checktype(in_codeblock)
271 |     if checkkids(in_codeblock) then return
272 |     if /in_codeblock then return
273 |     case sym of {
274 |     "Assignment": typ := check_types(kids[1].typ, kids[3].typ)
275 |     "AddExpr": typ := check_types(kids[1].typ, kids[2].typ)
276 |     "RelExpr": typ := check_types(kids[1].typ, kids[3].typ)
277 |     "ArgList"|"Block" | "BlockStmts": { typ := &null }
278 |     "MethodCall": {
279 |       if rule = 1290 then {
280 |         if kids[1].sym == "QualifiedName" then {
281 |           rv := kids[1].dequalify()
282 |           cksig(rv)
283 |           }
284 |         else {
285 |            if kids[1].sym ~== "token" then
286 |               stop("can't check type of Name ", kids[1].sym)
287 |            if (\ (kids[1].tok)).cat == parser.IDENTIFIER then {
288 |               write("checking the type of a call to ", kids[1].tok.text)
289 |               if ( \ (rv := stab.lookup(kids[1].tok.text))) then {
290 |                  rv := rv.typ
291 | #make sure it is actually a method
292 |                  if not match("method ", rv.str()) then
293 |                    stop("method expected, got ", rv.str())
294 |                  cksig(rv)
295 | 		}
296 |               }
297 |            else stop("can't check the type of token ", kids[1].tok.cat)
298 | }
299 |            }
300 |         else stop("Jzero does not handle complex calls")
301 |     }
302 |     "QualifiedName": {
303 |        # get my type by look up kid #2 within kid #1
304 |        if type(kids[1].typ) == "classtype__state" then {
305 |          typ := (kids[1].typ.st.lookup(kids[2].tok.text)).typ
306 |        } else if type(kids[1].typ) == "arraytype__state" &
307 |                  kids[2].tok.text=="length" then {
308 |          typ := typeinfo("int")
309 |        } else stop("illegal . operator on ",kids[1].typ.str())
310 |       }
311 |     "InstanceCreation": {
312 |       if not (rv := stab.lookup(kids[1].tok.text)) then
313 |         stop("unknown type ",kids[1].tok.text)
314 |       if not (typ := \ (rv.typ)) then
315 |         stop(kids[1].tok.text, " has unknown type")
316 |     }
317 |     "ArrayCreation": typ := arraytype(kids[1].typ)
318 |     "ArrayAccess": {
319 |        if match("array ", kids[1].typ.str()) then {
320 |           if kids[2].typ.str()=="int" then
321 |              typ := kids[1].typ.element_type
322 |           else stop("subscripting array with ",kids[2].typ.str())
323 |           }
324 |        else stop("illegal subscript on type ", kids[1].typ.str())
325 |        }
326 |     "ReturnStmt": {
327 |       # check the return type against the current function
328 |       if not (rt := ( \ (stab.lookup("return")).typ)) then
329 |          stop("stab did not find a returntype")
330 |       if \ (kids[1].typ) then
331 |           typ := check_types(rt, kids[1].typ)
332 |        else { # return; check that return type is void
333 |           if rt.str() ~== "void" then
334 |              stop("void return from non-void method")
335 |           typ := rt
336 |        }
337 |     }
338 |     "token": typ := tok.type(stab)
339 |     "IfThenStmt"|"WhileStmt": { # no checks for j0 statements
340 |     }
341 |     default: { stop("cannot check the type of: ", image(sym)) }
342 |     }
343 |   end
344 |    method get_op()
345 |       return case sym of {
346 |           "ReturnStmt" : "return"
347 |           "MethodCall" : "param"
348 |           "Assignment" : "="
349 |           "AddExpr": if rule=1320 then "+" else "-"
350 |           "RelExpr": {
351 |             if kids[2].sym === "token" then return kids[2].tok.text
352 |             }
353 |           default: fail
354 |       }
355 |    end
356 | 
357 |    method check_types(op1, op2)
358 |       operator := get_op()
359 |       tok := findatoken()
360 |       case operator of {
361 |          "param"|"return"|"="|"+"|"-" : {
362 |             if op1.str() === op2.str() ===
363 |                    ("int"|"double"|"String") then {
364 |                # write("typecheck ",operator," on a ", op1.str(),
365 |                #      " and a ", op2.str(), " -> OK")
366 |                return op1
367 |                }
368 |             else if (op1.basetype===op2.basetype==="array") & operator==="=" &
369 |                     check_types(op1.element_type,op2.element_type) then {
370 |                return op1
371 |                }
372 |             else if (op1.str() == op2.str()) & operator ==="=" then {
373 |                return op1
374 |                }
375 |             else {
376 |                writes(&errout, "line ", (\tok).tok.lineno, ": ")
377 |                j0.semErr("typecheck "||operator||" on a "||
378 | 		      op1.str()|| " and a "|| op2.str()|| " -> FAIL")
379 |               }
380 |             }
381 |          "<"|">": {
382 |             if op1.str() === op2.str() === ("int"|"double") then {
383 |                # write("typecheck ",operator," on a ", op1.str(),
384 |                #      " and a ", op2.str(), " -> OK")
385 |                return typeinfo("bool")
386 |                }
387 |             }
388 |          default: {
389 |             writes(&errout, "line ", (\tok).tok.lineno, ": ")
390 |             j0.semErr("don't know how to check " || image(operator))
391 |             }
392 |         }
393 |    end
394 |   method findatoken()
395 |     if sym==="token" then return self
396 |     return (!kids).findatoken()
397 |   end
398 | method genlabel()
399 |    return address("lab", serial.getid())
400 | end
401 | method genlocal()
402 |    return stab.genlocal()
403 | end
404 | method genfirst()
405 |   every (!\kids).genfirst()
406 |   case sym of {
407 |   "UnaryExpr": first := \kids[2].first | genlabel()
408 |   "AddExpr"|"MulExpr"|"RelExpr": {
409 |      first := (\ (kids[1|2].first)) | genlabel()
410 |      }
411 |   "Block"|"WhileStmt": {
412 |     first := \ (kids[1].first) | genlabel()
413 |   }
414 |   "BlockStmts": {
415 |     / (kids[2].first) := genlabel()
416 |     first := \ (kids[1|2].first) | genlabel()
417 |   }
418 |   # ...
419 |   default: first := (!\kids).first
420 |   }
421 | end
422 | method genfollow()
423 |    case sym of {
424 |    "MethodDecl": {
425 |      kids[2].follow := follow := genlabel()
426 |      }
427 |    "BlockStmts": {
428 |       kids[1].follow := kids[2].first
429 |       kids[2].follow := follow
430 |       }
431 |    "Block": {
432 |       kids[1].follow := follow
433 |       }
434 |    # ...
435 |    }
436 |    every (!\kids).genfollow()
437 | end
438 | 
439 | method gencode()
440 |   every (!\kids).gencode()
441 |   case sym of {
442 |     "ClassDecl": { genClassDecl() }
443 |     "AddExpr": { genAddExpr() }
444 |     "MulExpr": { genMulExpr() }
445 |     "RelExpr": { genRelExpr() }
446 |     "WhileStmt": { genWhileStmt() }
447 |     "IfThenStmt": { genIfThenStmt() }
448 |     "Assignment": { genAssignment() }
449 |     "MethodCall": { genMethodCall() }
450 |     "MethodDecl": { genMethodDecl() }
451 |     "QualifiedName": { genQualifiedName() }
452 |     # ...
453 |     "token":   { gentoken() }
454 |     default: {
455 |        icode := []
456 |        every icode |||:= (!\kids).icode
457 |        }
458 |    }
459 | end
460 | 
461 | method genClassDecl()
462 |   icode := []
463 |   # emit string constants
464 |   if *(stringtab.t)>0 then {
465 |     icode |||:= gen(".string")
466 |     every k := key(stringtab.t) do {
467 |       x := stringtab.lookup(k)
468 | if / (x.addr) then stop("null label in stringtab")
469 |       icode |||:= gen("LAB", x.addr)
470 |       icode |||:= gen("string", k)  # should k be addr(k) ?
471 |       }
472 |     }
473 | 
474 |     # emit the globals 
475 |     every k := key(global_st.t) do {
476 |       x := global_st.lookup(k)
477 | # if type is not a proc...or class or something
478 |       if /first_global then { icode |||:= gen(".global"); first_global := 1 }
479 |       icode |||:= gen("global", x.addr, k)
480 | #      icode |||:= gen("string", image(k))
481 |       }
482 |   icode |||:= gen(".code")
483 |   every icode |||:= (!kids).icode
484 | end
485 | 
486 | method genAssignment()
487 |   addr := kids[1].addr
488 |   icode := [ ]
489 |   every icode |||:= kids[1|3].icode
490 |   icode |||:= gen("ASN", addr, kids[3].addr)
491 | end
492 | 
493 | method genAddExpr()
494 |       addr := genlocal()
495 |       icode := kids[1].icode ||| kids[2].icode |||
496 |               gen(if rule=1320 then "ADD" else "SUB",
497 |                   addr, kids[1].addr, kids[2].addr)
498 | end
499 | 
500 | method genMulExpr()
501 |   addr := genlocal()
502 |   icode := [ ]
503 |   every icode |||:= (!kids).icode
504 |   if rule=1310 then
505 |     icode |||:= gen("MUL", addr, kids[1].addr, kids[2].addr)
506 |   else if rule=1311 then
507 |     icode |||:= gen("DIV", addr, kids[1].addr, kids[2].addr)
508 |   else
509 |     icode |||:= gen("MOD", addr, kids[1].addr, kids[2].addr)
510 | end
511 | 
512 | method genMethodDecl()
513 |    icode := [ ]
514 | 
515 |    icode |||:= gen("proc", address(kids[1].kids[2].kids[1].tok.text, 0))
516 |    every icode |||:= (!kids).icode
517 | if /follow then stop("null lab in genMethodDecl")
518 |    icode |||:= gen("LAB", follow)
519 |    icode |||:= gen("RET")
520 |    icode |||:= gen("end")
521 | end
522 | 
523 | method gentoken()
524 |   icode := []
525 |   case tok.cat of {
526 |     parser.IDENTIFIER: {
527 |        addr := stab.lookup(tok.text).addr }
528 |     parser.INTLIT: { addr := address("imm", tok.ival) }
529 |     parser.STRINGLIT: {
530 |       stringtab.insert(tok.text, 1, &null, typeinfo("string"))
531 |       addr := stringtab.lookup(tok.text).addr
532 |       }
533 |     # ...
534 |     }
535 | end
536 | 
537 | method gentargets()
538 |    case sym of {
539 |    "IfThenStmt"|"WhileStmt": {
540 |       kids[1].onTrue := kids[2].first
541 |       kids[1].onFalse := follow
542 |       }
543 |    "CondAndExpr": {
544 |       kids[1].onTrue := kids[2].first
545 |       kids[1].onFalse := onFalse
546 |       kids[2].onTrue := onTrue
547 |       kids[2].onFalse := onFalse
548 |       }    
549 |    # ...
550 |    }
551 |    every (!\kids).gentargets()
552 | end
553 | 
554 | method genRelExpr()
555 |   op :=  case kids[2].tok.cat of {
556 |     ord("<"): "BLT"; ord(">"): "BGT";
557 |     parser.LESSTHANOREQUAL: "BLE"
558 |     parser.GREATERTHANOREQUAL: "BGT" }
559 |   icode := kids[1].icode ||| kids[3].icode |||
560 |             gen(op, onTrue, kids[1].addr, kids[3].addr) |||
561 |             gen("GOTO", onFalse)
562 | end
563 | 
564 | method genIfThenStmt()
565 | if / (kids[1].first) then stop("null first lab in ifthen")
566 | if / (kids[1].onTrue) then stop("null onTrue lab in ifthen")
567 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
568 |            gen("LAB", kids[1].onTrue) |||
569 |            kids[2].icode
570 | end
571 | 
572 | method genWhileStmt()
573 | if / (kids[1].first) then stop("null first lab in while")
574 | if / (kids[1].onTrue) then stop("null onTrue lab in while")
575 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
576 |            gen("LAB", kids[1].onTrue) |||
577 |            kids[2].icode ||| gen("GOTO", kids[1].first)
578 | end
579 | 
580 | #  class.member
581 | method genQualifiedName()
582 |    icode := [ ]
583 |    icode |||:= kids[1].icode
584 |    if match("method ",((\ typ).str())) then { # no icode, compile-time method resolution
585 |       addr := kids[1].typ.str() || "__" || kids[2].tok.text
586 |       }
587 |    else {
588 |       addr := genlocal()
589 |       if match("array ", (\ (kids[1].typ)).str()) then { # array.length
590 |          icode |||:= gen("ASIZE", addr, kids[1].addr)
591 |          }
592 |       else if \ (ste := (\ (kids[1].typ)).st.lookup(kids[2].tok.text)) then {
593 |          # lookup address within class
594 |          /(kids[2].addr) := ste.addr
595 |          icode |||:= gen("FIELD", addr, kids[1].addr, kids[2].addr)
596 |       }
597 |    }
598 | end
599 | 
600 | method genMethodCall()
601 |   local nparms := 0
602 |   if k := \ kids[2] then {
603 |     icode := k.icode
604 |     while k.sym === "ArgList" do {
605 |        icode |||:= gen("PARM", k.kids[2].addr)
606 |        k := k.kids[1]; nparms +:= 1
607 |        }
608 |     icode |||:= gen("PARM", k.addr); nparms +:= 1
609 |     }
610 |   else icode := [ ]
611 | 
612 |   # after all parameters, extra parameter for the object.
613 | 
614 |   if kids[1].sym === "QualifiedName" then {
615 |     # icode for a qualifiedname will be non-empty
616 |     icode |||:= kids[1].icode
617 |     # addr for a qualified name will be new temp var
618 |     icode |||:= gen("PARM", kids[1].kids[1].addr)
619 |     }
620 |   else {
621 |     icode |||:= gen("PARM", "self")
622 |     }
623 |   icode |||:= gen("CALL", kids[1].addr, nparms)
624 | end
625 | 
626 | 
627 | method gen(o, o1, o2, o3)
628 |    return [ tac(o, o1, o2, o3) ]
629 | end
630 | 
631 | initially (s,r,x[])
632 |    id := serial.getid(); sym := s; rule := r
633 |    if type(x[1]) == "token__state" then {
634 |       nkids := 0; tok := x[1]
635 |       typ := (\tok).typ
636 |    } else {
637 |       nkids := *x;
638 |       kids := x
639 |    }
640 | end
641 | 


--------------------------------------------------------------------------------
/ch12/tree.java:
--------------------------------------------------------------------------------
  1 | package ch12;
  2 | import java.util.ArrayList;
  3 | import java.io.PrintWriter;
  4 | import java.io.BufferedWriter;
  5 | import java.io.FileWriter;
  6 | class tree {
  7 |   int id, rule, nkids;
  8 |   String sym;
  9 |   token tok;
 10 |   tree kids[];
 11 |   Boolean isConst;
 12 |   symtab stab;
 13 |   typeinfo typ;
 14 |   ArrayList<tac> icode;
 15 |   address addr, first, follow, onTrue, onFalse;
 16 | 
 17 |   public String escape(String s) {
 18 |       if (s.charAt(0) == '\"')
 19 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 20 |       else return s;
 21 |   }
 22 | 
 23 |   public String pretty_print_name() {
 24 |     if (tok == null) return sym +"#"+(rule%10);
 25 |     else {
 26 | 	return escape(tok.text)+":"+tok.cat;
 27 | 	}
 28 |     }
 29 | 
 30 |   void print_graph(String filename){
 31 |     try {
 32 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 33 |       pw.printf("digraph {\n");
 34 |       j = 0;
 35 |       print_graph(pw);
 36 |       pw.printf("}\n");
 37 |       pw.close();
 38 |       }
 39 |     catch (java.io.IOException ioException) {
 40 |       System.err.println("printgraph exception");
 41 |       System.exit(1);
 42 |       }
 43 |     }
 44 | 
 45 |   int j;
 46 |   void print_graph(PrintWriter pw) {
 47 |   int i;
 48 |     if (tok != null) {
 49 | 	print_leaf(pw);
 50 |         return;
 51 |     }
 52 |     // from here on out, we know we are not a leaf
 53 |     print_branch(pw);
 54 |     
 55 |     for(i=0; i<nkids; i++) {
 56 |         if (kids[i] != null) {
 57 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 58 | 	    kids[i].print_graph(pw);
 59 |         } else {
 60 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 61 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 62 | 	    j++;
 63 |         }
 64 |     }
 65 |   }
 66 | 
 67 |   void print_leaf(PrintWriter pw) {
 68 |     String s = parser.yyname[tok.cat];
 69 |     print_branch(pw);
 70 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 71 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 72 | 	      escape(tok.text), tok.lineno);
 73 |   }
 74 | 
 75 |   void print_branch(PrintWriter pw) {
 76 |     pw.printf("N%d ",id);
 77 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 78 |     if (tok != null)
 79 | 	pw.printf("struct token* leaf %d", tok.id);
 80 |     pw.printf("\"];\n");
 81 |   }
 82 | 
 83 |   public void print(int level) {
 84 |     int i;
 85 |     for(i=0;i<level;i++) System.out.print(" ");
 86 |     if (tok != null) {
 87 |       System.out.println(id + "   " + tok.text +
 88 |                          " (" + tok.cat + "): "+tok.lineno);
 89 |     }
 90 |     else {
 91 |       System.out.println(id + "   " + sym +
 92 | 			 " (" + rule + "): "+nkids);
 93 |     }
 94 |     for(i=0; i<nkids; i++)
 95 |       kids[i].print(level+1);
 96 |   }
 97 |   public void print() {
 98 |     print(0);
 99 |   }
100 | 
101 |   void mkSymTables(symtab curr) {
102 |    stab = curr;
103 |    switch (sym) {
104 |    case "ClassDecl": curr = new symtab("class", curr); break;
105 |    case "MethodDecl": curr = new symtab("method", curr); break;
106 |    }
107 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
108 |   }
109 | 
110 |   void populateSymTables() {
111 |     switch(sym) {
112 |     case "ClassDecl":
113 | 	stab.insert(kids[0].tok.text, false, kids[0].stab, null);
114 | 	//		    new classtype(kids[0].tok.text, kids[0].stab));
115 |        break;
116 |     case "FieldDecl": case "LocalVarDecl":
117 |        tree k = kids[1];
118 |        while ((k != null) && k.sym.equals("VarDecls")) {
119 |          insert_vardeclarator(k.kids[1]);
120 |          k = k.kids[0];
121 |          }
122 |        insert_vardeclarator(k); return;
123 |     case "MethodDecl":
124 | 	String s = kids[0].kids[1].kids[0].tok.text;
125 | 	stab.insert(s, false, kids[0].stab, kids[0].kids[1].typ);
126 | 	kids[0].stab.insert("return", false, null, kids[0].kids[0].typ);
127 | 	break;
128 |     case "FormalParm":
129 |       insert_vardeclarator(kids[1]); return;
130 |     }
131 |     if (kids!=null)
132 | 	for(tree k : kids)
133 | 	   if (k!=null)
134 | 	      k.populateSymTables();
135 |   }
136 | 
137 |   void insert_vardeclarator(tree vd) {
138 |     if (vd.tok != null) {
139 |       stab.insert(vd.tok.text, false, null, vd.typ);
140 |       }
141 |     else insert_vardeclarator(vd.kids[0]);
142 |   }
143 | 
144 |   void calc_isConst() {
145 |    for(int i=0; i <nkids; i++)
146 |       kids[i].calc_isConst();
147 |    switch(sym) {
148 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
149 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
150 |    case "UnaryExpr": isConst = kids[1].isConst; break;
151 |    case "RelExpr":
152 |       isConst = kids[0].isConst && kids[2].isConst; break;
153 |    case "CondOrExpr": case "CondAndExpr":
154 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
155 |       isConst = kids[0].isConst && kids[1].isConst; break;
156 |    default: isConst = false;
157 |    }
158 |   }
159 | 
160 |   void mkcls() {
161 |     symtab_entry rv;
162 |     if (sym.equals("ClassDecl")) {
163 |       int ms=0, fs=0;
164 |       rv = stab.lookup(kids[0].tok.text);
165 |       for(String k : rv.st.t.keySet()) {
166 | 	  symtab_entry ste = rv.st.t.get(k);
167 | 	  if ((ste.typ.str()).startsWith("method ")) ms++;
168 | 	  else fs++;
169 |       }
170 |       parameter flds[] = new parameter[fs];
171 |       parameter methds[] = new parameter[ms];
172 |       fs=0; ms=0;
173 |       for(String k : rv.st.t.keySet()) {
174 | 	  symtab_entry ste = rv.st.t.get(k);
175 | 	  if ((ste.typ.str()).startsWith("method "))
176 | 	      methds[ms++] = new parameter(k, ste.typ);
177 | 	  else flds[fs++] = new parameter(k, ste.typ);
178 |       }
179 |       rv.typ = new classtype(kids[0].tok.text, rv.st,
180 | 			       flds, methds, new typeinfo[0]);
181 |     }
182 |     else for(int i = 0; i<nkids; i++)
183 |       if (kids[i].nkids>0) kids[i].mkcls();
184 |   }
185 | 
186 |   void checkSymTables() { check_codeblocks(); }
187 |   void check_codeblocks() {
188 |   tree k;
189 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
190 |    else {
191 |       for(int i = 0; i<nkids; i++){
192 |          k = kids[i];
193 |          if (k.nkids>0) k.check_codeblocks();
194 |       }
195 |    }
196 |   }
197 | void check_block() {
198 |    switch (sym) {
199 |    case "IDENTIFIER":
200 |      if (stab.lookup(tok.text) == null)
201 |         j0.semErr("undeclared variable " + tok.text);
202 |      break;
203 |    case "FieldAccess": case "QualifiedName":
204 |      kids[0].check_block();
205 |      break;
206 |   case "MethodCall":
207 |       kids[0].check_block();
208 |       if (rule == 1290)
209 |          kids[1].check_block();
210 |       else kids[2].check_block();
211 |       break;
212 |    case "LocalVarDecl": break;
213 |    default:
214 |       for(int i=0;i<nkids;i++)
215 |          kids[i].check_block();
216 |    }
217 |   }
218 | 
219 |   void calctype() {
220 |     for(int i=0; i<nkids; i++) kids[i].calctype();
221 |     switch (sym) {
222 |     case "FieldDecl": typ = kids[0].typ; return;
223 |     case "token":
224 | 	if ((typ = tok.typ) != null) return;
225 | 	switch (tok.cat) {
226 | 	case parser.IDENTIFIER:
227 | 	    if (stab != null) {
228 | 		symtab_entry rv = stab.lookup(tok.text);
229 | 		if (rv != null)
230 | 		    if ((typ = rv.typ) != null) return;
231 | 	    }
232 | 	    typ = new classtype(tok.text);
233 | 	    return;
234 | 	default:
235 | 	  j0.semErr("can't grok the type of " + tok.text + " cat " + tok.cat);
236 | 	}
237 | 	break;
238 |     default: j0.semErr("don't know how to calctype " + sym);
239 |     }
240 |   }
241 | 
242 |   void cksig(methodtype sig) {
243 |     int i = sig.parameters.length, nactual = 1;
244 |     tree t = kids[1];
245 |       if (t == null) {
246 |         if (i != 0) j0.semErr("0 params, expected " + i);
247 |       }
248 |       else {
249 |         while (t.sym.equals("ArgList")) { nactual++; t=t.kids[0]; }
250 | 	if (nactual != i)
251 | 	    j0.semErr(nactual + " parameters, expected "+ i);
252 | 	t = kids[1];
253 | 	i--;
254 | 	while (t.sym.equals("ArgList")) {
255 | 	    check_types(t.kids[1].typ, sig.parameters[i]);
256 | 	    t = t.kids[0];
257 | 	    i--;
258 | 	}
259 | 	check_types(t.typ, sig.parameters[0]);
260 |       }
261 |       typ = sig.return_type;
262 |     }
263 | 
264 |   typeinfo [] mksig() {
265 |   switch (sym) {
266 |     case "FormalParm": return new typeinfo[]{kids[0].typ};
267 |     case "FormalParmList":
268 |       typeinfo ta1[] = kids[0].mksig();
269 |       typeinfo ta2[] = kids[1].mksig();
270 |       typeinfo ta[] = new typeinfo[ta1.length + ta2.length];
271 |       for(int i=0; i<ta1.length; i++) ta[i]=ta1[i];
272 |       for(int j=0; j<ta2.length; j++)
273 | 	ta[ta1.length+j]=ta1[j];
274 |       return ta;
275 |       }
276 |     return null;
277 |   }
278 | 
279 |   void assigntype(typeinfo t) {
280 |     typ = t;
281 |     switch (sym) {
282 |     case "VarDeclarator":
283 |       kids[0].assigntype(new arraytype(t));
284 |       return;
285 |     case "MethodDeclarator": // pass a return type into a method
286 | 	typeinfo parmList[];
287 | 	if (kids[1] != null) parmList = kids[1].mksig();
288 | 	else parmList = new typeinfo [0];
289 | 	kids[0].typ = typ = new methodtype(parmList , t);
290 | 	return;
291 |     case "token":
292 |       switch (tok.cat) {
293 |         case parser.IDENTIFIER: return;
294 |         default: j0.semErr("eh? " + tok.cat);
295 |       }
296 |       break;
297 |       default: j0.semErr("don't know how to assigntype " + sym);
298 |     }
299 |     if(kids!=null) for(tree k : kids) k.assigntype(t);
300 |   }
301 | 
302 |   public boolean checkkids(boolean in_codeblock) {
303 |     switch (sym) {
304 |     case "MethodDecl": { kids[1].checktype(true); return true; }
305 |     case "LocalVarDecl": { kids[1].checktype(false); return true; }
306 |     case "FieldAccess": { kids[0].checktype(in_codeblock);
307 |                           return true; }
308 |     case "QualifiedName":
309 |        kids[0].checktype(in_codeblock); break;
310 |     default: if (kids != null) for (tree k : kids)
311 | 	       k.checktype(in_codeblock);
312 |     }
313 |     return false;
314 |   }
315 |     
316 |   public typeinfo dequalify() {
317 |       typeinfo rv = null;
318 |       symtab_entry ste;
319 |       if (kids[0].sym.equals("QualifiedName"))
320 | 	  rv = kids[0].dequalify();
321 |       else if (kids[0].sym.equals("token") &
322 | 	       (kids[0].tok.cat==parser.IDENTIFIER)) {
323 | 	  if ((ste = stab.lookup(kids[0].tok.text)) == null)
324 | 	      j0.semErr("unknown symbol " + kids[0].tok.text);
325 | 	  rv = ste.typ;
326 |       }
327 |       else j0.semErr("can't dequalify " + sym);
328 |       if (!rv.basetype.equals("class"))
329 | 	  j0.semErr("can't dequalify " + rv.basetype);
330 |       ste = ((classtype)rv).st.lookup(kids[1].tok.text);
331 |       if (ste != null) return ste.typ;
332 |       j0.semErr("couldn't lookup " + kids[1].tok.text +
333 | 		  " in " + rv.str());
334 |       return null;
335 |   }
336 | 
337 |   void checktype(boolean in_codeblock) {
338 |     if (checkkids(in_codeblock)) return;
339 |     if (! in_codeblock) return;
340 |     switch (sym) {
341 |     case "Assignment": typ = check_types(kids[0].typ, kids[2].typ); break;
342 |     case "AddExpr": typ = check_types(kids[0].typ, kids[1].typ); break;
343 |     case "RelExpr": typ = check_types(kids[0].typ, kids[2].typ); break;
344 |     case "ArgList": case "Block": case "BlockStmts": typ = null; break;
345 |     case "MethodCall":
346 |       if (rule == 1290) {
347 |         symtab_entry rve;
348 |         methodtype rv;
349 |         if (kids[0].sym.equals("QualifiedName")) {
350 |           rv = (methodtype)(kids[0].dequalify());
351 |           cksig(rv);
352 |           }
353 |         else {
354 |           if (!kids[0].sym.equals("token"))
355 |             j0.semErr("can't check type of " + kids[0].sym);
356 |           if (kids[0].tok.cat == parser.IDENTIFIER) {
357 | 	      // System.out.println("checking the type of a call to " +
358 | 	      //                    kids[0].tok.text);
359 |             if ((rve = stab.lookup(kids[0].tok.text)) != null) {
360 |   	    if (! (rve.typ instanceof methodtype))
361 |               j0.semErr("method expected, got " + rve.typ.str());
362 | 	    rv = (methodtype)rve.typ;
363 |             cksig(rv);
364 |             }
365 |           }
366 |           else j0.semErr("can't typecheck token " + kids[0].tok.cat);
367 |           }
368 |         }
369 |       else j0.semErr("Jzero does not handle complex calls");
370 |       break;
371 |     case "QualifiedName":
372 | 	if (kids[0].typ instanceof classtype) {
373 | 	  classtype ct = (classtype)(kids[0].typ);
374 |           typ = (ct.st.lookup(kids[1].tok.text)).typ;
375 | 	  }
376 |         else if (kids[0].typ instanceof arraytype) {
377 |           typ = new typeinfo("int");
378 |           }
379 |         else j0.semErr("illegal . on  " + kids[0].typ.str());
380 | 	break;
381 |     case "InstanceCreation": {
382 |       symtab_entry rv;
383 |       if ((rv = stab.lookup(kids[0].tok.text))==null)
384 |         j0.semErr("unknown type " + kids[0].tok.text);
385 |       if ((typ = rv.typ) == null)
386 |         j0.semErr(kids[0].tok.text + " has unknown type");
387 |       break;
388 |     }
389 |     case "ArrayCreation":
390 | 	typ = new arraytype(kids[0].typ); break;
391 |     case "ArrayAccess":
392 | 	if (kids[0].typ.str().startsWith("array ")) {
393 | 	    if (kids[1].typ.str().equals("int"))
394 | 		typ = ((arraytype)(kids[0].typ)).element_type;
395 | 	    else j0.semErr("subscripting array with "+kids[1].typ.str());
396 |           }
397 | 	else j0.semErr("illegal subscript on type "+ kids[0].typ.str());
398 | 	break;
399 |     case "ReturnStmt":
400 |       symtab_entry ste;
401 |       if ((ste=stab.lookup("return")) == null)
402 |          j0.semErr("stab did not find a returntype");
403 |       typeinfo rt = ste.typ;
404 |       if (kids[0].typ != null)
405 |           typ = check_types(rt, kids[0].typ);
406 |       else { // return; check that return type is void
407 |           if (!rt.str().equals("void"))
408 | 	      j0.semErr("void return from non-void method");
409 | 	  typ = rt;		    
410 |           }
411 |       break;
412 |     case "token": typ = tok.type(stab); break;
413 |     case "IfThenStmt": case "WhileStmt": { // no checks for j0 statements
414 |     }
415 |     default: j0.semErr("cannot check type of " + sym);
416 |     }
417 |   }
418 | 
419 |    public String get_op() {
420 |      switch (sym) {
421 |      case "ReturnStmt" : return "return";
422 |      case "MethodCall" : return "param";
423 |      case "Assignment" : return "=";
424 |      case "AddExpr": if (rule==1320) return "+"; else return "-";
425 |      case "RelExpr": {
426 |         if (kids[1].sym.equals("token")) return kids[1].tok.text;
427 |         }
428 |      default: return null;
429 |      }
430 |    }
431 | 
432 |    public typeinfo check_types(typeinfo op1, typeinfo op2) {
433 |      String operator = get_op();
434 |      switch (operator) {
435 |      case "param": case "return": case "=": case "+": case"-": {
436 |        tree tk;
437 |        //       if ((tk = findatoken())!=null)
438 |        //         System.out.print("line " + tk.tok.lineno + ": ");
439 |        if (op1.str().equals(op2.str()) &&
440 | 	   (op1.str().equals("int") ||
441 | 	    op1.str().equals("double") ||
442 | 	    op1.str().equals("String"))) {
443 | 	   //  System.out.println("typecheck "+operator+" on a "+ op1.str()+
444 | 	   //		    " and a "+ op2.str()+ " -> OK");
445 | 	 return op1;
446 | 	 }
447 |        else if (op1.basetype.equals("array") &&
448 |                 op2.basetype.equals("array") &&
449 |                 operator.equals("=") &&
450 |                 (check_types(((arraytype)op1).element_type,
451 | 			     ((arraytype)op2).element_type) != null)) {
452 |                 return op1;
453 |                }
454 |        else if (op1.str().equals(op2.str()) & operator.equals("=")) {
455 | 	  return op1;
456 |                }
457 |        else j0.semErr("typecheck "+operator+" on a "+ op2.str()+
458 | 			" and a "+ op1.str()+ " -> FAIL");
459 |        break;
460 |        }
461 |        case "<": case ">": {
462 | 	   if (op1.str().equals(op2.str()) &&
463 | 	       (op1.str().equals("int") ||
464 | 		op1.str().equals("double"))) {
465 | 		    // write("typecheck ",operator," on a ", op1.str(),
466 | 		    //     " and a ", op2.str(), " -> OK")
467 | 		    return new typeinfo("bool");
468 |                }
469 |         }
470 |      default: j0.semErr("don't know how to check " + operator);
471 |      }
472 |    return null;
473 |    }
474 |    public tree findatoken() {
475 |      tree rv;
476 |      if (sym=="token") return this;
477 |      if (kids != null)
478 |      for (tree t : kids) if ((rv=t.findatoken()) != null) return rv;
479 |      return null;
480 |    }
481 |   address genlabel() {
482 |     return new address("lab", serial.getid());
483 |   }
484 |   address genlocal() {
485 | 	return stab.genlocal();
486 |   }
487 | void genfirst() {
488 |   if (kids != null) for(tree k : kids) k.genfirst();
489 |   switch (sym) {
490 |   case "UnaryExpr": {
491 |       if (kids[1].first != null) first = kids[1].first;
492 |       else first = genlabel();
493 |       break;
494 |   }
495 |   case "AddExpr": case "MulExpr": case "RelExpr": {
496 |       if (kids[0].first != null) first = kids[0].first;
497 |       else if (kids[1].first != null) first = kids[1].first;
498 |       else first = genlabel();
499 |       break;
500 |       }
501 |   case "Block": case "WhileStmt": {
502 |       if (kids[0].first != null) first = kids[0].first;
503 |       else first = genlabel();
504 |       break;
505 |       }
506 |   case "BlockStmts": {
507 |     if (kids[1].first == null) kids[1].first = genlabel();
508 |     if (kids[0].first != null) first = kids[0].first;
509 |     else first = kids[1].first;
510 |     break;
511 |   }
512 |     // ...
513 |   default: {
514 |       if (kids != null)
515 | 	  for(tree k : kids)
516 | 	      if (k.first != null) { first = k.first; break; }
517 |       }
518 |    }
519 | }
520 | 
521 | void genfollow() {
522 |   switch (sym) {
523 |    case "MethodDecl": {
524 |      kids[1].follow = follow = genlabel();
525 |      break;
526 |      }
527 |    case "BlockStmts": {
528 |       kids[0].follow = kids[1].first;
529 |       kids[1].follow = follow;
530 |       break;
531 |       }
532 |    case "Block": {
533 |       kids[0].follow = follow;
534 |       break;
535 |       }
536 |    // ...
537 |    }
538 |   if (kids != null) for(tree k : kids) k.genfollow();
539 | }
540 | 
541 | void gencode() {
542 |   if (kids != null) for(tree k : kids) k.gencode();
543 |   switch (sym) {
544 |   case "ClassDecl": { genClassDecl(); break; }
545 |   case "AddExpr": { genAddExpr(); break; }
546 |   case "MulExpr": { genMulExpr(); break; }
547 |   case "RelExpr": { genRelExpr(); break; }
548 |   case "WhileStmt": { genWhileStmt(); break; }
549 |   case "IfThenStmt": { genIfThenStmt(); break; }
550 |   case "Assignment": { genAssignment(); break; }
551 |   case "MethodCall": { genMethodCall(); break; }
552 |   case "MethodDecl": { genMethodDecl(); break; }
553 |   case "QualifiedName": { genQualifiedName(); break; }
554 |   // ...
555 |   case "token": { gentoken(); break; }
556 |   default: {
557 |     icode = new ArrayList<tac>();
558 |     if (kids != null) for(tree k : kids) icode.addAll(k.icode);
559 |     }
560 |   }
561 | }
562 | 
563 | void genClassDecl() {
564 |   int first_global;
565 |   first_global = 0;
566 |   icode = new ArrayList<tac>();
567 |   // emit string constants
568 |   if (j0.stringtab.t.size()>0) {
569 |      icode.addAll( gen(".string") );
570 |      for(String k : j0.stringtab.t.keySet()) {
571 | 	 symtab_entry ste = j0.stringtab.t.get(k);
572 | 	 if (ste.addr == null) {
573 | 	     System.err.println("null label in stringtab");
574 | 	     System.exit(1);
575 | 	 }
576 |          icode.addAll( gen("LAB", ste.addr));
577 |          icode.addAll( gen("string", new address(k, 0)) );
578 |         }
579 |       }
580 | 
581 |   // emit the globals 
582 |   for(String k : j0.global_st.t.keySet()) {
583 |       symtab_entry ste = j0.global_st.t.get(k);
584 |       // if type is not a proc...or class or something
585 |       if (first_global == 0) {
586 | 	  icode.addAll( gen(".global") ); first_global = 1; }
587 |           icode.addAll( gen("global", ste.addr, new address(k,0)) );
588 |         }
589 |   icode.addAll( gen(".code") );
590 |   if (kids != null) for(tree k: kids) icode.addAll(k.icode);
591 | }
592 | 
593 | void genAssignment() {
594 |   addr = kids[0].addr;
595 |   icode = new ArrayList<tac>();
596 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
597 |   icode.addAll(gen("ASN", addr, kids[2].addr));
598 | }
599 | 
600 | void genAddExpr() {
601 |   addr = genlocal();
602 |   icode = new ArrayList<tac>();
603 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
604 |   icode.addAll(gen(((rule==1320)?"ADD":"SUB"), addr,
605 |                    kids[0].addr, kids[1].addr));
606 | }
607 | 
608 | void genMulExpr() {
609 |   addr = genlocal();
610 |   icode = new ArrayList<tac>();
611 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
612 |   if (rule==1310)
613 |     icode.addAll(gen("MUL", addr, kids[0].addr, kids[1].addr));
614 |   else if (rule==1311)
615 |     icode.addAll(gen("DIV", addr, kids[0].addr, kids[1].addr));
616 |   else
617 |     icode.addAll(gen("MOD", addr, kids[0].addr, kids[1].addr));
618 | }
619 | 
620 | void genMethodDecl() {
621 |     icode = new ArrayList<tac>();
622 |     icode.addAll(gen("proc", new address(kids[0].kids[1].kids[0].tok.text, 0)));
623 |     for(tree k : kids) icode.addAll(k.icode);
624 |     icode.addAll(gen("LAB", follow));
625 |     icode.addAll(gen("RET"));
626 |     icode.addAll(gen("end"));
627 | }
628 | 
629 | void gentoken() {
630 |   icode = new ArrayList<tac>();
631 |   switch (tok.cat) {
632 |     case parser.IDENTIFIER: {
633 |       symtab_entry ste;
634 |       ste = stab.lookup(tok.text);
635 |       if (ste == null) {
636 |       }
637 |       else {
638 | 	  addr = ste.addr;
639 |       }
640 |       break;
641 |       }
642 |     case parser.INTLIT: {
643 |       addr = new address("imm", Integer.parseInt(tok.text)); break;
644 |     }
645 |     case parser.STRINGLIT: {
646 |       j0.stringtab.insert(tok.text, true, null, new typeinfo("string"));
647 |       addr = j0.stringtab.lookup(tok.text).addr;
648 |       break;
649 |     }
650 |     // ...
651 |     }
652 | }
653 | 
654 | void gentargets() {
655 |    switch (sym) {
656 |    case "IfThenStmt": {
657 |       kids[0].onTrue = kids[1].first;
658 |       kids[0].onFalse = follow;
659 |       }
660 |    case "CondAndExpr": {
661 |       kids[0].onTrue = kids[1].first;
662 |       kids[0].onFalse = onFalse;
663 |       kids[1].onTrue = onTrue;
664 |       kids[1].onFalse = onFalse;
665 |       }    
666 |    // ...
667 |    }
668 |    if (kids!=null) for (tree k:kids) k.gentargets();
669 | }
670 | 
671 | void genRelExpr() {
672 |   String op = "ERROR";
673 |   switch (kids[1].tok.cat) {
674 |     case '<': op="BLT"; break; case ';': op="BGT"; break;
675 |     case parser.LESSTHANOREQUAL: op="BLE"; break;
676 |     case parser.GREATERTHANOREQUAL: op="BGT";
677 |     }
678 |   icode = new ArrayList<tac>();
679 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
680 |   icode.addAll(gen(op, onTrue, kids[0].addr, kids[2].addr));
681 |   icode.addAll(gen("GOTO", onFalse));
682 | }
683 | 
684 | void genIfThenStmt() {
685 |   icode = new ArrayList<tac>();
686 |   icode.addAll(kids[0].icode);
687 |   icode.addAll(gen("LAB", kids[0].onTrue));
688 |   icode.addAll(kids[1].icode);
689 | }
690 | 
691 | void genWhileStmt() {
692 |   icode = new ArrayList<tac>();
693 |   icode.addAll(gen("LAB", kids[0].first));
694 |   icode.addAll(kids[0].icode);
695 |   icode.addAll(gen("LAB", kids[0].onTrue));
696 |   icode.addAll(kids[1].icode);
697 |   icode.addAll(gen("GOTO", kids[0].first));
698 | }
699 | 
700 | void genQualifiedName() {
701 |   symtab_entry ste;
702 |   classtype ct;
703 | 
704 |   icode = new ArrayList<tac>();
705 |   icode.addAll( kids[0].icode );
706 |   if (typ != null && typ instanceof methodtype) {// no icode, compile-time method resolution
707 |       addr = new address(kids[0].typ.str() + "__" + kids[1].tok.text, 0);
708 |       }
709 |    else {
710 |       addr = genlocal();
711 |       if (kids[0].typ instanceof arraytype) { // array.length
712 | 	  icode.addAll( gen("ASIZE", addr, kids[0].addr) );
713 |       }
714 |       else if ((kids[0].typ != null) && (kids[0].typ instanceof classtype) &&
715 | 	       ((ct = (classtype)(kids[0].typ)) != null) &&
716 | 	       ((ste=ct.st.lookup(kids[1].tok.text)) != null)) {
717 | 	  // lookup address within class
718 | 	  if (kids[1].addr == null) kids[1].addr = ste.addr;
719 | 	  icode.addAll( gen("FIELD", addr, kids[0].addr, kids[1].addr));
720 |       }
721 |    }
722 | }
723 | 
724 | void genMethodCall() {
725 |   int nparms = 0;
726 |   if (kids[1] != null) {
727 |     tree k = kids[1];
728 |     icode = k.icode;
729 |     while (k.sym.equals("ArgList")) {
730 |       icode.addAll(gen("PARM", k.kids[1].addr));
731 |       k = k.kids[0]; nparms++;
732 |       }
733 |     icode.addAll(gen("PARM", k.addr)); nparms++;
734 |     }
735 |   else
736 |     icode = new ArrayList<tac>();
737 |   if (kids[0].sym.equals("QualifiedName")) {
738 |     icode.addAll(kids[0].icode);
739 |     icode.addAll(gen("PARM", kids[0].kids[0].addr));
740 |   }
741 |   else icode.addAll(gen("PARM", new address("self",0)));
742 |   icode.addAll(gen("CALL", kids[0].addr, new address("imm",nparms)));
743 | }
744 | 
745 | 
746 | ArrayList<tac> gen(String o, address ... a) {
747 |   ArrayList<tac> L = new ArrayList<tac>();
748 |   tac t = null;
749 |   switch(a.length) {
750 |     case 3: t = new tac(o, a[0], a[1], a[2]); break;
751 |     case 2: t = new tac(o, a[0], a[1]); break;
752 |     case 1: t = new tac(o, a[0]); break;
753 |     case 0: t = new tac(o); break;
754 |     default: j0.semErr("gen(): wrong # of arguments");
755 |   }
756 |   L.add(t);
757 |   return L;
758 | }
759 | 
760 |    public tree(String s, int r, token t) {
761 | 	id = serial.getid();
762 |         sym = s; rule = r; tok = t; if (tok!=null) typ = tok.typ; }
763 | 
764 |     public tree(String s, int r, tree[] t) {
765 | 	id = serial.getid();
766 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
767 | 	sym = s; rule = r; nkids = t.length;
768 | 	kids = t;
769 |     }
770 | }
771 | 


--------------------------------------------------------------------------------
/ch12/typeinfo.icn:
--------------------------------------------------------------------------------
 1 | class typeinfo(basetype)
 2 |    method str()
 3 |       return string(basetype)|"unknown"
 4 |    end
 5 | end
 6 | class arraytype : typeinfo(element_type)
 7 |    method str()
 8 |       return "array of " || (\element_type).str()
 9 |    end
10 | initially
11 |    basetype := "array"
12 | end
13 | class methodtype : typeinfo(parameters,return_type)
14 |    method str()
15 |       s := "method " || ((\return_type).str()|"undef") || "("
16 |       every s ||:= (!parameters).str() do s ||:= ","
17 |       s[-1] := ")"
18 |       return s
19 |    end
20 | initially
21 |    basetype := "method"
22 |    /parameters := []
23 |    /return_type := typeinfo("void")
24 | end
25 | class classtype : typeinfo(name, st, fields, methods, constrs)
26 |    method str()
27 |       return name
28 |    end
29 | initially
30 |    basetype := "class"
31 |    /st := symtab("class",global_st)
32 |    /fields := []
33 |    /methods := []
34 |    /constrs := []
35 | end
36 | class parameter(name, element_type)
37 | end
38 | 


--------------------------------------------------------------------------------
/ch12/typeinfo.java:
--------------------------------------------------------------------------------
1 | package ch12;
2 | public class typeinfo {
3 |    String basetype;
4 |    public typeinfo() { basetype = "unknown"; }
5 |    public typeinfo(String s) { basetype = s; }
6 |    public String str() { return basetype; }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch12/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     writes(&errout, yylineno, ": ", image(yytext),": ")
3 |     stop(s)
4 | end
5 | 


--------------------------------------------------------------------------------
/ch12/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch12;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch13/Op.icn:
--------------------------------------------------------------------------------
 1 | class Op(HALT, NOOP, ADD, SUB, MUL, DIV, MOD, NEG, PUSH, POP, CALL, RETURN,
 2 | 	 GOTO, BIF, LT, LE, GT, GE, EQ, NEQ, LOCAL, LOAD, STORE,
 3 | 	 LABEL, STRING, CODE, PROC, GLOBAL, END,
 4 | 	 R_NONE, R_ABS, R_IMM, R_STACK, R_HEAP)
 5 | initially
 6 |   HALT := 1;  NOOP := 2; ADD := 3; SUB := 4; MUL := 5
 7 |   DIV := 6; MOD := 7; NEG := 8; PUSH := 9; POP := 10
 8 |   CALL := 11; RETURN := 12; GOTO := 13; BIF := 14; LT := 15
 9 |   LE := 16; GT := 17; GE := 18; EQ := 19; NEQ := 20;
10 |   LOCAL := 21; LOAD := 22; STORE := 23;
11 |   LABEL := 101; STRING:=102; CODE:=103; PROC:=104; GLOBAL := 105; END := 106
12 |   R_NONE := 0; R_ABS := 1; R_IMM := 2
13 |   R_STACK := 3; R_HEAP := 4
14 |   Op := self
15 | end
16 | 
17 | procedure OpStr(i)
18 |    if type(Op)~=="Op__state" then Op()
19 |    case i of {
20 |        Op.HALT: return "HALT"
21 |        Op.NOOP: return "NOOP"
22 |        Op.ADD:  return "ADD"
23 |        Op.SUB:  return "SUB"
24 |        Op.MUL:  return "MUL"
25 |        Op.DIV:  return "DIV"
26 |        Op.MOD:  return "MOD"
27 |        Op.NEG:  return "NEG"
28 |        Op.PUSH: return "PUSH"
29 |        Op.POP:  return "POP"
30 |        Op.CALL: return "CALL"
31 |        Op.RETURN: return "RETURN"
32 |        Op.GOTO: return "GOTO"
33 |        Op.BIF: return "BIF"
34 |        Op.LT: return "LT"
35 |        Op.LE: return "LE"
36 |        Op.GT: return "GT"
37 |        Op.GE: return "GE"
38 |        Op.EQ: return "EQ"
39 |        Op.NEQ: return "NEQ"
40 |        Op.LOCAL: return "LOCAL"
41 |        Op.LOAD: return "LOAD"
42 |        Op.STORE: return "STORE"
43 |        default: return "(unknown:"||image(i)||")"
44 |    }
45 | end
46 | 
47 | procedure OpRStr(opr)
48 |    if type(Op)~=="Op__state" then Op()
49 |    case opr of {
50 |      Op.R_NONE: return "NONE"
51 |      Op.R_ABS:  return "ABS"
52 |      Op.R_IMM:  return "IMM"
53 |      Op.R_STACK: return "STACK"
54 |      Op.R_HEAP: return "HEAP"
55 |    }
56 | end
57 | 


--------------------------------------------------------------------------------
/ch13/Op.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class Op {
 3 |   public final static short HALT=1, NOOP=2, ADD=3, SUB=4,
 4 |     MUL=5, DIV=6, MOD=7, NEG=8, PUSH=9, POP=10, CALL=11,
 5 |     RETURN=12, GOTO=13, BIF=14, LT=15, LE=16, GT=17, GE=18,
 6 |     EQ=19, NEQ=20, LOCAL=21, LOAD=22, STORE=23;
 7 |     public final static short LABEL=101, STRING=102,
 8 | 	CODE=103, PROC=104, GLOBAL=105, END=106;
 9 |   public final static short R_NONE=0, R_ABS=1, R_IMM=2, R_STACK=3, R_HEAP=4;
10 | }
11 | 


--------------------------------------------------------------------------------
/ch13/RegUse.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | import java.util.ArrayList;
 3 | public class RegUse {
 4 |    public String reg;
 5 |    int offset;
 6 |    public boolean loaded, dirty;
 7 |     public RegUse(String s, int i) { reg = s; offset=i; loaded=dirty=false; }
 8 |    public ArrayList<x64> load() {
 9 |       if (loaded) return null;
10 |       loaded = true;
11 |       return j0.xgen("movq", offset+"(%rbp)", reg);
12 |    }
13 |    public ArrayList<x64> save() {
14 |       if (!dirty) return null;
15 |       dirty = false;
16 |       return j0.xgen("movq", reg, offset+"(%rbp)");
17 |    }
18 | }
19 | 


--------------------------------------------------------------------------------
/ch13/address.icn:
--------------------------------------------------------------------------------
 1 | class address(region, offset)
 2 | method regaddr()
 3 |   return if region == "method" then "loc" else region
 4 | end
 5 | method str()
 6 |   if region=="lab" then return "L"||offset
 7 |   return regaddr() || ":" || offset
 8 | end
 9 | method intgr()
10 |   if region=="imm" then return integer(offset)
11 | end
12 | method print()
13 |   writes(str())
14 | end
15 | end
16 | 


--------------------------------------------------------------------------------
/ch13/address.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class address {
 3 |     public String region;
 4 |     public int offset;
 5 |     public String regaddr() { return region.equals("method")?"loc":region; }
 6 |     public String str() {
 7 |         if (region.equals("lab")) return "L"+offset;
 8 | 	return regaddr() + ":" + offset; }
 9 |     public int intgr() {
10 | 	if (region.equals("imm")) return offset;
11 | 	System.err.println("intgr() on region " + region);
12 | 	return 0;
13 |     }
14 |     public void print() { System.out.print(str()); }
15 |     address(String s, int o) { region = s; offset = o; }
16 | }
17 | 


--------------------------------------------------------------------------------
/ch13/arraytype.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class arraytype extends typeinfo {
 3 |    typeinfo element_type;
 4 |     public String str() {
 5 | 	return "array of " + (element_type!=null?element_type.str():"undef");
 6 |     }
 7 |    public arraytype(typeinfo t) {
 8 |       basetype = "array"; element_type = t; }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch13/byc.icn:
--------------------------------------------------------------------------------
 1 | link printf
 2 | class byc(op, opreg, opnd)
 3 |   method print(f:&output)
 4 |     write(f, "\t", nameof(), " ", addrof()) |
 5 |       write(&errout, "can't print ", image(self), " op ", image(op))
 6 |   end
 7 |   method nameof()
 8 |    static opnames
 9 |    initial opnames := table(Op.HALT, "halt", Op.NOOP, "noop",
10 |       Op.ADD, "add", Op.SUB, "sub", Op.MUL, "mul",
11 |       Op.DIV, "div", Op.MOD, "mod", Op.NEG, "neg",
12 |       Op.PUSH, "push", Op.POP, "pop", Op.CALL, "call",
13 |       Op.RETURN, "return", Op.GOTO, "goto", Op.BIF, "bif",
14 |       Op.LT, "lt", Op.LE, "le", Op.GT, "gt", Op.GE, "ge",
15 |       Op.EQ, "eq", Op.NEQ, "neq", Op.LOCAL, "local",
16 |       Op.LOAD, "load", Op.STORE, "store", Op.LABEL, "LABEL",
17 |       Op.STRING, "STRING", Op.CODE, "CODE", Op.PROC, "PROC",
18 |       Op.GLOBAL, "GLOBAL", Op.END, "END")
19 |    return opnames[op]
20 |   end
21 |   method addrof()
22 |    case opreg of {
23 |       Op.R_NONE | &null: return ""
24 |       Op.R_ABS: return "@" || sprintf("%x",opnd)
25 |       Op.R_IMM: return string(opnd)
26 |       Op.R_STACK: return "stack:" || opnd
27 |       Op.R_HEAP: return "heap:" || opnd
28 |       default: {
29 |         return string(opreg) || ":" || opnd
30 |         }
31 |       }
32 |   end
33 | 
34 |   method printb(f:&output)
35 |    writes(f, char(op), char(\opreg|0))
36 |    x := (\opnd | 0)
37 |    every !6 do {
38 |      writes(f, char(iand(x, 255)))
39 |      x := ishift(x, -8)
40 |      }
41 |   end
42 |   method addr(a)
43 |    if /a then opreg := Op.R_NONE
44 |    else if type(a) == "integer" then {
45 |      opreg := Op.R_IMM; opnd := a
46 |    }
47 |    else if type(a) == "string" then {
48 |      if not (sa := stringtab.lookup(a)) then write("don't know ", image(a))
49 |        # string region addresses are just pointers offset 24 from start
50 |        opreg := Op.R_IMM; opnd := sa.addr.offset + 24
51 |    }
52 |    else case a.region of {
53 |    "method": { opreg := Op.R_STACK; opnd := a.offset }
54 |    "global": { opreg := Op.R_ABS; opnd := a.offset + stringtab.count }
55 |    "const": { opreg := Op.R_ABS; opnd := a.offset }
56 |    "lab": { opreg := Op.R_ABS; opnd := a.offset }
57 |    "obj": { opreg := Op.R_HEAP; opnd := a.offset }
58 |    "imm": { opreg := Op.R_IMM; opnd := a.offset }
59 |    "strings": { opreg := Op.R_IMM; opnd := a.offset + 24 }
60 |    default: {
61 |       write("system error. region ", image(a.region),
62 |                          " offset ", image(a.offset))
63 |       runerr(103, a.region)
64 |       }
65 |    }
66 |   end
67 | initially(o, a)
68 |   op := o; addr(a);  # addr(\a);?
69 |   if type(nameof()) ~== "string" then {
70 |      write(&errout, "bad op ", image(op))
71 |      runerr(103, op)
72 |   }
73 | end
74 | 


--------------------------------------------------------------------------------
/ch13/byc.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | import java.util.HashMap;
 3 | import java.io.PrintStream;
 4 | public class byc {
 5 |    int op, opreg;
 6 |    long opnd;
 7 |    public byc(int o, address a) {
 8 |       op=o; addr(a);
 9 |    }
10 |    public void print(PrintStream f) {
11 |       f.println("\t" + nameof() + " " + addrof());
12 |    }
13 |    public void print() {
14 |       print(System.out);
15 |    }
16 |   static HashMap<Short,String> ops;
17 |   static { ops = new HashMap<>();
18 |     ops.put(Op.HALT,"halt"); ops.put(Op.NOOP,"noop");
19 |     ops.put(Op.ADD,"add"); ops.put(Op.SUB,"sub");
20 |     ops.put(Op.MUL,"mul"); ops.put(Op.DIV, "div");
21 |     ops.put(Op.MOD,"mod"); ops.put(Op.NEG, "neg");
22 |     ops.put(Op.PUSH,"push"); ops.put(Op.POP, "pop");
23 |     ops.put(Op.CALL, "call"); ops.put(Op.RETURN, "return");
24 |     ops.put(Op.GOTO, "goto"); ops.put(Op.BIF, "bif");
25 |     ops.put(Op.LT, "lt"); ops.put(Op.LE, "le");
26 |     ops.put(Op.GT, "gt"); ops.put(Op.GE, "ge");
27 |     ops.put(Op.EQ, "eq"); ops.put(Op.NEQ, "neq");
28 |     ops.put(Op.LOCAL, "local"); ops.put(Op.LOAD, "load");
29 |     ops.put(Op.STORE, "store"); ops.put(Op.LABEL, "LABEL");
30 |     ops.put(Op.STRING, "STRING"); ops.put(Op.CODE, "CODE");
31 |     ops.put(Op.PROC, "PROC"); ops.put(Op.GLOBAL, "GLOBAL");
32 |     ops.put(Op.END, "END");
33 |   }
34 |   public String nameof() {
35 |     return ops.get(op);
36 |   }
37 | 
38 |   public String addrof() {
39 |    switch (opreg) {
40 |    case Op.R_NONE: return "";
41 |    case Op.R_ABS: return "@"+ java.lang.Long.toHexString(opnd);
42 |    case Op.R_IMM: return String.valueOf(opnd);
43 |    case Op.R_STACK: return "stack:" + String.valueOf(opnd);
44 |    case Op.R_HEAP: return "heap:" + String.valueOf(opnd);
45 |    }
46 |   return String.valueOf(opreg)+":"+String.valueOf(opnd);
47 |   }
48 | 
49 |    public void printb(PrintStream f) {
50 |    long x = opnd;
51 |    f.print((char)op);
52 |    f.print((char)opreg);
53 |    for(int i = 0; i < 6; i++) {
54 |       f.print((char)(x & 0xff));
55 |       x = x>>8;
56 |       }
57 |    }
58 |     public void printb() { printb(System.out); }
59 | 
60 |    public void addr(address a) {
61 |    if (a == null) opreg = Op.R_NONE;
62 |    else switch (a.region) {
63 |      case "method": opreg = Op.R_STACK; opnd = a.offset; break;
64 |      case "global": opreg = Op.R_ABS; opnd = a.offset; break;
65 |      case "const": opreg = Op.R_ABS; opnd = a.offset; break;
66 |      case "lab": opreg = Op.R_ABS; opnd = a.offset; break;
67 |      case "obj": opreg = Op.R_HEAP; opnd = a.offset; break;
68 |      case "imm": opreg = Op.R_IMM; opnd = a.offset; break;
69 |      case "strings": opreg = Op.R_IMM; opnd = a.offset + 24; break;
70 |      }
71 |    }
72 | }
73 | 


--------------------------------------------------------------------------------
/ch13/classtype.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class classtype extends typeinfo {
 3 |    String name;
 4 |    symtab st;
 5 |    parameter [] methods;
 6 |    parameter [] fields;
 7 |    typeinfo [] constrs;
 8 |     public String str() {
 9 | 	return name;
10 |     }
11 |     public classtype(String s) { name = s; basetype="class";}
12 |     public classtype(String s, symtab stab) { name = s; st = stab; basetype="class";}
13 |    public classtype(String s, symtab stab,
14 | 		    parameter []ms, parameter[]fs, typeinfo[]cs) {
15 |        name = s; st = stab; methods=ms; fields=fs; constrs=cs; basetype="class";}
16 | }
17 | 


--------------------------------------------------------------------------------
/ch13/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |          System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch13/j0.icn:
--------------------------------------------------------------------------------
  1 | link bincvt
  2 | global yyfilename, yylineno, yycolno, yylval, parser, global_st, stringtab
  3 | global labeltable, methodAddrPushed, regs, isNative, xcode
  4 | procedure main(argv)
  5 |    local off
  6 |    j0 := j0()
  7 |    serial := serial()
  8 |    parser := Parser()
  9 |    j0init(argv)
 10 |    yylineno := yycolno := 1
 11 |    off := 0
 12 |    regs := [: RegUse("%rdi"|"%rsi"|"%rdx"|"%rcx"|"%r8"|
 13 |             "%r9"|"%r10"|"%r11"|"%r12"|"%r13"|"%r14", off-:=8) :]
 14 | 
 15 |    if yyparse() = 0 then
 16 |       write("no errors")
 17 | end
 18 | procedure j0init(argv)
 19 |    local fnam_idx := 1
 20 |    if argv[1] == "-x64" then {
 21 |       isNative := 1; fnam_idx +:= 1
 22 |       write("Compiling ", argv[2], " to x64 .s format")
 23 |    }
 24 |    else write("Compiling ", argv[1], " to .j0 format")
 25 | 
 26 |    if fnam_idx > *argv then stop("usage: j0 filename")
 27 |    yyfilename := argv[fnam_idx]
 28 |    if not (map(yyfilename[-5:0])==".java") then yyfilename ||:= ".java"
 29 |    yyin := open(yyfilename) | stop("usage: j0 filename")
 30 | end
 31 | class j0()
 32 |    method lexErr(s)
 33 |       stop(s, ": ", yytext) 
 34 |    end
 35 |    method scan(cat)
 36 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
 37 |       yycolno +:= *yytext
 38 |       return cat
 39 |    end
 40 |    method whitespace()
 41 |       yycolno +:= *yytext
 42 |    end
 43 |    method newline()
 44 |       yylineno +:= 1; yycolno := 1
 45 |    end
 46 |    method comment()
 47 |       yytext ? {
 48 |          while tab(find("\n")+1) do newline()
 49 |          yycolno +:= *tab(0)
 50 |       }
 51 |    end
 52 |    method ord(s)
 53 |       return proc("ord",0)(s[1])
 54 |    end
 55 |    method print(root)
 56 |       root.print()
 57 |    end
 58 |    method node(s,r,p[])
 59 |       rv := tree ! ([s,r] ||| p)
 60 |       return rv
 61 |    end
 62 |    method semantic(root)
 63 |    local out_st, System_st
 64 |      global_st := symtab("global")
 65 |      stringtab := symtab("strings")
 66 |      System_st := symtab("class")
 67 |      out_st := symtab("class")
 68 |      out_st.insert("println", false, ,
 69 |         methodtype([classtype("String")], typeinfo("void")))
 70 |      System_st.insert("out", false, out_st, classtype("PrintStream",out_st))
 71 |      global_st.insert("System", false, System_st, classtype("System",System_st))
 72 |      if \verbose then write("making symbol tables")
 73 |      root.mkSymTables(global_st)
 74 |      root.populateSymTables()
 75 |      if \verbose then write("checking symbol tables")
 76 |      root.checkSymTables()
 77 |      root.mkcls()
 78 | #     global_st.print()
 79 |      root.checktype()
 80 |    end
 81 |    method semErr(s)
 82 |      stop("semantic error: ", s)
 83 |    end
 84 |    method calctype(t)
 85 |      t.kids[1].calctype()
 86 |      t.kids[2].assigntype(t.kids[1].typ)
 87 |    end
 88 |    method gencode(root)
 89 |       root.genfirst()
 90 |       root.genfollow()
 91 |       root.gentargets()
 92 |       root.gencode()
 93 | 
 94 |       labeltable := table()
 95 |       methodAddrPushed := &null
 96 |        if \isNative then {
 97 |          xcode := x64code(root.icode)
 98 |          genx64code(xcode)
 99 |          }
100 |       else {
101 |          bcode := bytecode(root.icode)
102 |          genbytecode(bcode)
103 |          }
104 |    end
105 | 
106 |   method xgen(o, src, dst)
107 |     return [x64(o, (loc(src)|&null), (loc(dst)|&null))]
108 |   end
109 | 
110 | method x64code(icode)
111 |     xcode := [ ]
112 |     every i := 1 to *\icode do {
113 |        instr := icode[i]
114 |        case instr.op of {
115 |           "ADD": {
116 |             xcode |||:= xgen("movq", instr.op2, "%rax") |||
117 |                         xgen("addq", instr.op3, "%rax") |||
118 |                         xgen("movq", "%rax", instr.op1)
119 |            }
120 |           "SUB": { } # append translation of SUB to return val
121 |           "NEG": {
122 |              xcode |||:= xgen("movq", instr.op2, "%rax") |||
123 |                          xgen("negq", "%rax") |||
124 |                          xgen("movq", "%rax", instr.op1)
125 |              }
126 |           "ASN": {
127 |              xcode |||:= xgen("movq", instr.op2, "%rax") |||
128 |                          xgen("movq", "%rax", instr.op1)
129 |              }
130 |           "ADDR": {
131 |              xcode |||:= xgen("leaq", instr.op2, "%rax")
132 |              xcode |||:= xgen("%rax", instr.op1)
133 |              }
134 |           "LCON": {
135 |              xcode |||:= xgen("movq", instr.op2, "%rax") |||
136 |                          xgen("movq", "(%rax)", "%rax") |||
137 |                          xgen("movq", "%rax", instr.op1)
138 |              }
139 |           "SCON": {
140 |              xcode |||:= xgen("movq", instr.op2, "%rbx") |||
141 |                          xgen("movq", instr.op1, "%rax")
142 |                          xgen("movq", "%rbx", "(%rax)")
143 |              }
144 |           "GOTO": {
145 |              xcode |||:= xgen("goto", instr.op1)
146 |              }
147 |           "BLT": {
148 |              xcode |||:= xgen("movq", instr.op2, "%rax") |||
149 |                          xgen("cmpq", instr.op3, "%rax") |||
150 |                          xgen("jle", instr.op1)
151 |              }
152 |           "PARM": {
153 |              if /parmCount then {
154 |                 parmCount := 1
155 |                 every j := i+1 to *icode do
156 |                    if icode[j].op == "CALL" then break
157 |                 parmCount +:= 1
158 |                 }
159 |              else parmCount -:= 1
160 |              genParm(parmCount, instr.op1)
161 |             }
162 |           "CALL": {
163 |              xcode |||:= xgen("call", instr.op1)
164 |              if \(instr.op3) then
165 |                 xcode |||:= xgen("movq", "%rax", instr.op2)
166 |              methodAddrPushed := &null
167 |              }
168 |           "RETURN"|"RET": {
169 |              if /(instr.op1) then
170 |                xcode |||:= xgen("movq", "$0", "%rax")
171 |              else
172 |                xcode |||:= xgen("movq", instr.op1, "%rax")
173 |              xcode |||:= xgen("leave")
174 |              xcode |||:= xgen("ret", instr.op1)
175 |              }
176 |           "proc": {
177 |              n := ((\(instr.op2)).intgr() + (\(instr.op3)).intgr()) * 8
178 |              xcode |||:= xgen(".text") | stop("something fails")
179 |              xcode |||:= xgen(".globl", instr.op1.region) | stop("something fails2")
180 |              xcode |||:= xgen(".def\t" || instr.op1.region ||
181 | 			      ";\t.scl\t2;\t.type\t32;\t.endef") | stop("something fails3")
182 |              xcode |||:= xgen(".seh_proc\t"||instr.op1.region)
183 |              xcode |||:= xgen("lab", instr.op1.region)
184 | # Linux?
185 | #             xcode |||:= xgen(".type", instr.op1, "@function") | stop("something fails3")
186 |              xcode |||:= xgen("pushq", "%rbp") | stop("something fails5")
187 |              xcode |||:= xgen(".seh_pushreg\t%rbp")
188 |              xcode |||:= xgen("movq", "%rsp", "%rbp") | stop("something fails6")
189 |              xcode |||:= xgen(".seh_setframe\t%rbp, 0")
190 |              xcode |||:= xgen("subq", "
quot;||\n, "%rsp") | stop("something fails7")
191 |              xcode |||:= xgen(".seh_stackalloc\t"||n)
192 |              xcode |||:= xgen(".seh_endprologue")
193 |              if instr.op1.region === "main" then
194 |                 xcode |||:= xgen("call","__main")
195 |              every i := !((\(instr.op2)).intgr()) do
196 |                regs[i].loaded := regs[i].dirty := "true"
197 |              /i := 0
198 |              every j := i+1 to 11 do
199 |                regs[i].loaded := regs[i].dirty := "false"
200 |              }
201 |           "end": {
202 |              if xcode[-1].op ~== "ret" then
203 |                 xcode |||:= xgen("leave") ||| xgen("ret")
204 |              xcode |||:= xgen(".seh_endproc")
205 |              }
206 |       ".code": {
207 | #	 xcode |||:= xgen(".text")
208 | 	 }
209 |       ".global": {
210 | #         xcode |||:= xgen(".global")
211 |           }
212 |       ".string": {
213 | #           xcode |||:= xgen(".section\t.rdata,\"dr\"")
214 |           }
215 |       "LAB": {
216 |              every (!regs).save() # saveregs()?
217 |           if not match("strings:",instr.op1.str()) then {
218 |              xcode |||:= xgen("lab", instr.op1)
219 |              }
220 |              }
221 |       "string": {
222 |          # strings are written out separately
223 | 	 }
224 |       "global": {
225 |          # globals are written out separately
226 | 	 }
227 |       "FIELD": {
228 |          # compute a result in op1 that is obtained by computing on op2 and op3
229 |          # dummy placeholder for future object-orientation
230 | #         xcode |||:= xgen("push", instr.op2) |||
231 | #                     xgen("pop", instr.op1)
232 | 	 }
233 |           default: { stop("don't handle op ", image(instr.op)) }
234 |          }
235 |       }
236 |    return xcode
237 |   end
238 | 
239 |   method genParm(n, addr)
240 |    every xcode |||:= (!regs).save()
241 | 
242 |    if n > 6 then xcode |||:= xgen("pushq", addr) # dubious
243 |    else {
244 |       if type(addr) == "address__state" & addr.region=="strings" then
245 |          popcode := "leaq"
246 |       else popcode := "movq"
247 |       xcode |||:= xgen(popcode, addr,
248 |          case n of {
249 |          1: "%rdi"; 2: "%rsi"; 3: "%rdx";
250 |          4: "%rcx"; 5: "%r8";   6: "%r9"
251 |          })
252 |       }
253 |   end
254 | 
255 |   method bgen(o, a)
256 |     return [byc(o, a)]
257 |   end
258 | 
259 |   method bytecode(icode)
260 |     if type(Op)=="procedure" then Op()
261 |     bcode := []
262 |     every i := 1 to *\icode do {
263 |       instr := icode[i]
264 |       case instr.op of {
265 |       "ADD": {
266 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
267 |         j0.bgen(Op.PUSH, instr.op3) ||| j0.bgen(Op.ADD) |||
268 |         j0.bgen(Op.POP, instr.op1)
269 |       }
270 |       "SUB": { }
271 |       "NEG": {
272 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
273 |           j0.bgen(Op.NEG) ||| j0.bgen(Op.POP, instr.op1)
274 |       }
275 |       "ASN": {
276 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
277 |                     j0.bgen(Op.POP, instr.op1)
278 |       }
279 |       "ADDR": {
280 |         bcode |||:= j0.bgen(Op.LOAD, instr.op1)
281 |       }
282 |       "LCON": {
283 |         bcode |||:= j0.bgen(Op.LOAD, instr.op2) |||
284 |                     j0.bgen(Op.POP, instr.op1)
285 |       }
286 |       "SCON": {
287 |         bcode |||:= j0.bgen(Op.STORE, instr.op2) |||
288 |                     j0.bgen(Op.POP, instr.op1)
289 |       }
290 |       "GOTO": {
291 |         bcode |||:= j0.bgen(Op.GOTO, instr.op1)
292 |       }
293 |       "BLT": {
294 |         bcode |||:= j0.bgen(Op.PUSH, instr.op2) |||
295 |           j0.bgen(Op.PUSH, instr.op3) |||
296 |           j0.bgen(Op.LT) |||
297 |           j0.bgen(Op.BIF, instr.op1)
298 |       }
299 |       "PARM": {
300 |         if /methodAddrPushed then {
301 |           every j := i+1 to *icode do
302 |             if icode[j].op == "CALL" then {
303 |               if icode[j].op1 === "PrintStream__println" then {
304 |                 bcode |||:= j0.bgen(Op.PUSH, address("imm", -1))
305 |               } else {
306 |                 bcode |||:= j0.bgen(Op.PUSH, icode[j].op1)
307 |               }
308 |               break
309 |             }
310 |             methodAddrPushed := 1
311 |         }
312 | 
313 |         bcode |||:= j0.bgen(Op.PUSH, instr.op1)
314 |       }
315 |       "CALL": {
316 |         bcode |||:= j0.bgen(Op.CALL, instr.op2)
317 |         methodAddrPushed := &null
318 |       }
319 | 
320 |       "RETURN"|"RET": {
321 |          bcode |||:= j0.bgen(Op.RETURN, instr.op1)
322 | 	 }
323 | 
324 |       "proc": {
325 |          # record address
326 |          labeltable[instr.op1.region] := *bcode * 8
327 |         }
328 |       "end": { }
329 |       ".code": { }
330 |       ".global": { }
331 |       ".string": { }
332 |       "LAB": {
333 |          # record address
334 |          labeltable[instr.op1.offset] := *bcode * 8
335 | 	 }
336 |       "string": {
337 |          # strings are written out separately
338 | 	 }
339 |       "global": {
340 |          # globals are written out separately
341 | 	 }
342 |       "FIELD": {
343 |          # compute a result in op1 that is obtained by computing on op2 and op3
344 |          # dummy placeholder for future object-orientation
345 |          bcode |||:= j0.bgen(Op.PUSH, instr.op2) ||| j0.bgen(Op.POP, instr.op1)
346 | 	 }
347 | 
348 |       default: {
349 |          stop("What is ", image(instr.op))
350 |          }
351 |        }
352 |      }
353 |      return bcode
354 |   end
355 | 
356 |   # calculate the first instruction offset.  Count how many words of string
357 |   # constants there are
358 |   method calculate_fio()
359 |      return 3 + (stringtab.count / 8) + (global_st.count / 8)
360 |   end
361 | 
362 |   # The string region always starts at offset 24 after the three-word header.
363 |   method write_stringarea(bc, fout)
364 |   local s
365 |     every s := !(stringtab.L) do {
366 |       # should fully-binarize (de-escape) string here
367 |       # for now, just strip double quotes, replace with NULs
368 |       s := s[2:-1] || "\0\0"
369 | 
370 |       len := *s
371 |       while len > 0 do {
372 |          if len < 9 then {
373 |             writes(fout, s)
374 |             if len < 8 then writes(fout, repl("\0", 8-len))
375 |             }
376 |          else { writes(fout, s[1:9]); s := s[9:0] }
377 |          len -:= 8
378 |          }
379 |      }
380 |   end
381 | 
382 |   method write_globalarea(bc, fout)
383 |     writes(fout, repl("\0", global_st.count))
384 |   end
385 | 
386 |   method write_instructions(bc, fout)
387 |   local i #, offset := where(fout)-1
388 |      every i := 1 to *bc do {
389 |        case bc[i].op of {
390 |        Op.CODE: { }
391 |        Op.GLOBAL: { }
392 |        Op.LABEL: { }
393 |        Op.PROC: {  }
394 |        Op.STRING: {  }
395 |        Op.END: { }
396 |        default: {
397 |          bc[i].printb(fout)
398 |          }
399 |        }
400 | #    offset := where(fout)-1
401 |     }
402 |   end
403 | 
404 |   method genbytecode(bc)
405 |     outfilename := yyfilename[1:find(".java", yyfilename)] || ".j0"
406 |     if fout := open(outfilename, "w") then {
407 |       writes(fout, "Jzero!!\0")		# word 0, magic word
408 |       writes(fout, "1.0\0\0\0\0\0")          # word 1, version #
409 |       # write the first instruction offset. convert Unicon binary to bcode binary
410 |       fio := calculate_fio(bc)
411 |       writes(fout, "\0\0", reverse(rawstring(fio, 6)))
412 |       write_stringarea(bc, fout)
413 |       write_globalarea(bc, fout)
414 | 
415 |       #bootstrap instructions: push addr of main, push dummy self, call 0, and halt
416 |       codept := entrypt := fio*8+32
417 |       if not member(labeltable, "main") then stop("main() not found")
418 |       entrypt +:= labeltable["main"]
419 |       writes(fout, "\11\2",reverse(rawstring(entrypt, 6))) # PUSH IMM (func entry pt) fio*8+24
420 |       writes(fout, "\11\2\0\0\0\0\0\0")           # PUSH 0 (null self)
421 |       writes(fout, "\13\2\0\0\0\0\0\0")           # call 0
422 |       writes(fout, "\1\0\0\0\0\0\0\0")            # halt
423 | 
424 |       write_instructions(bc, fout)
425 |       close(fout)
426 |     } else stop("couldn't open output file ",image(outfilename)," for writing")
427 |   end
428 | 
429 |   method genx64code(xc)
430 |     outfilename := yyfilename[1:find(".java", yyfilename)] || ".s"
431 |     if fout := open(outfilename, "w") then {
432 |       write(fout, "\t.file\t\"", yyfilename, "\"")
433 |       # for now, write out our "runtime system" with every generated code
434 |       write(fout, "\t.text")
435 |       write(fout, "\t.globl\tPrintStream__println")
436 |       write(fout, "\t.def\tPrintStream__println;\t.scl\t2;\t.type\t32;\t.endef")
437 |       write(fout, "\t.seh_proc\tPrintStream__println")
438 |       write(fout, "PrintStream__println:")
439 |       write(fout, "\tpushq\t%rbp")
440 |       write(fout, "\t.seh_pushreg\t%rbp")
441 |       write(fout, "\tmovq\t%rsp, %rbp")
442 |       write(fout, "\t.seh_setframe\t%rbp, 0")
443 |       write(fout, "\tsubq\t$32, %rsp\n",
444 | 	    "\t.seh_stackalloc\t32\n",
445 | 	    "\t.seh_endprologue\n",
446 | 	    "\tmovq\t%rsi, %rcx\n", # Windows conventions!
447 | 	    "\tcall\tputs\n",
448 | 	    "\tnop\n",
449 | 	    "\taddq\t$32, %rsp\n",
450 | 	    "\tpopq\t%rbp\n",
451 | 	    "\tret\n",
452 | 	    "\t.seh_endproc")
453 |       write(fout, "\t.text")
454 |       write(fout, "\t.def\t__main;\t.scl\t2;\t.type\t32;\t.endef")
455 |       write_x64strings(fout)
456 |       x64print(fout)
457 |       write(fout, "\t.ident\t\"j0: (Unicon) 0.1.0\"")
458 |       write(fout, "\t.def\tputs;\t.scl\t2;\t.type\t32;\t.endef")
459 |       close(fout)
460 |     } else stop("couldn't open output file ",image(outfilename)," for writing")
461 |   end
462 | 
463 |   method write_x64strings(fout)
464 |   local s
465 |     write(fout, "\t.section\t.rdata,\"dr\"")
466 |     every i := !*(stringtab.L) do {
467 |       s := stringtab.L[i]
468 |       write(fout, ".Lstr", i-1, ":")
469 |       s[-1] := "\\0\""
470 |       write(fout, "\t.ascii ",s)
471 |      }
472 |   end
473 | 
474 |   method x64print(f:&output)
475 |     every (!xcode).print(f)
476 |   end
477 | 
478 |    method loc(a)
479 |      if /a then return
480 |      if string(a) then return x64loc(a)
481 |      else case a.region of {
482 |      "method"|
483 |      "loc": { if a.offset <= 88 then return loadreg(a)
484 |               else return x64loc("rbp", -a.offset) }
485 |      "glob": { return x64loc("rip", a.offset) }
486 |      "const": { return x64loc("imm", a.offset) }
487 |      "lab": { return x64loc("lab", a.offset) }
488 |      "obj": { return x64loc("r15", a.offset) }
489 |      "imm": { return x64loc("imm", a.offset) }
490 |      "strings": { return x64loc("%rip", ".Lstr"||a.offset) }
491 |      default: {
492 | #write("no loc for ", image(a.region), " offset ", image(a.offset))
493 |         return x64loc("lab", a.region)
494 |         }
495 |      }
496 |    end
497 |   method loadreg(a)
498 |     r := a.offset/8 + 1
499 |     if / (regs[r].loaded) then {
500 |       every put(xcode,
501 |                !xgen("movq",(-a.offset)||"(%rbp)",regs[r].reg))
502 |       regs[r].loaded := "true"
503 |       }
504 |     return x64loc(regs[a.offset/8+1].reg)
505 |   end
506 | 
507 | end
508 | 


--------------------------------------------------------------------------------
/ch13/j0.java:
--------------------------------------------------------------------------------
  1 | package ch13;
  2 | import java.io.FileReader;
  3 | import java.io.PrintStream;
  4 | import java.util.ArrayList;
  5 | import java.util.Arrays;
  6 | import java.util.HashMap;
  7 | public class j0 {
  8 |    public static Yylex yylexer;
  9 |    public static ch13.parser par;
 10 |    public static ch13.symtab global_st, stringtab;
 11 |    public static HashMap<String,Integer> labeltable;
 12 |    public static boolean methodAddrPushed;
 13 |    public static RegUse [] regs;
 14 |    public static void main(String argv[]) throws Exception {
 15 |       j0init(argv);
 16 |       regs = new RegUse[]{new RegUse("%rdi", -8),
 17 |              new RegUse("%rsi", -16), new RegUse("%rdx", -24),
 18 |              new RegUse("%rcx", -32), new RegUse("%r8", -40),
 19 |              new RegUse("%r9",-48), new RegUse("%r10", -56),
 20 |              new RegUse("%r11", -64), new RegUse("%r12", -72),
 21 |              new RegUse("%r13", -80), new RegUse("%r14", -88) };
 22 | 
 23 |       par = new parser();
 24 |       //                  par.yydebug=true;
 25 |       yylineno = yycolno = 1;
 26 |       int i = par.yyparse();
 27 |       if (i == 0)
 28 |          System.out.println("no errors");
 29 |    }
 30 |    public static int yylineno, yycolno;
 31 |    public static String yyfilename;
 32 |     //   public static parserVal yylval;
 33 |    public static void j0init(String argv[]) throws Exception {
 34 |       int fnam_idx = 0;
 35 |       if (argv.length == 0) stop("usage: j0 [-x64] filename");
 36 |       if (argv[0].equals("-x64")) {
 37 |          isNative = true; fnam_idx++;
 38 | 	 System.out.println("Compiling " + argv[1] + " to x64 .s format");
 39 |          }
 40 |       else {
 41 |         isNative = false;
 42 | 	System.out.println("Compiling " + argv[0] + " to .j0 format");
 43 |       }
 44 |       if (fnam_idx >= argv.length) stop("usage: j0 [-x64] filename");
 45 |       yyfilename = argv[fnam_idx];
 46 |       if (! yyfilename.endsWith(".java"))
 47 | 	  yyfilename = yyfilename + ".java";
 48 |       yylexer = new Yylex(new FileReader(yyfilename));
 49 |    }
 50 |    public static int YYEOF() { return Yylex.YYEOF; }
 51 |    public static int yylex() {
 52 |       int rv = 0;
 53 |       try {
 54 |         rv = yylexer.yylex();
 55 |       } catch(java.io.IOException ioException) {
 56 |         rv = -1;
 57 |       }
 58 |       return rv;
 59 |    }
 60 |    public static String yytext() {
 61 |       return yylexer.yytext();
 62 |    }
 63 |    public static void lexErr(String s) {
 64 |        stop(s);
 65 |    }
 66 |    public static int scan(int cat) {
 67 |        ch13.j0.par.yylval =
 68 | 	   new parserVal(new tree("token",cat,
 69 | 		new token(cat, yytext(), yylineno)));
 70 |       return cat;
 71 |    }
 72 |    public static void newline() {
 73 |       yylineno++;
 74 |    }
 75 |    public static void whitespace() {
 76 |    }
 77 |    public static void comment() {
 78 |    }
 79 |    public static short ord(String s) { return (short)(s.charAt(0)); }
 80 |    public static void print(parserVal root) {
 81 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
 82 |    }
 83 |   public static tree unwrap(Object obj) {
 84 |     if (obj instanceof token)
 85 |       return new tree("token",0,(token)obj);
 86 |     else return (tree)obj;
 87 |   }
 88 |   public static parserVal node(String s,int r,parserVal...p) {
 89 |      tree[] t = new tree[p.length];
 90 |      for(int i = 0; i < t.length; i++)
 91 | 	 t[i] = (tree)(p[i].obj);
 92 |      return new parserVal((Object)new tree(s,r,t));
 93 |   }
 94 |   public static void semantic(parserVal r) {
 95 |     tree root = (tree)(r.obj);
 96 |     ch13.symtab out_st, System_st;
 97 |     global_st = new ch13.symtab("global");
 98 |     stringtab = new ch13.symtab("strings");
 99 |     System_st = new ch13.symtab("class");
100 |     out_st = new ch13.symtab("class");
101 |     out_st.insert("println", false, null,
102 | 		  new methodtype(new typeinfo[]{new classtype("String")},
103 | 				 new typeinfo("void")));
104 |     System_st.insert("out", false, out_st,
105 |        new classtype("PrintStream",out_st));
106 |     global_st.insert("System", false, System_st,
107 |        new classtype("System",System_st));
108 |    root.mkSymTables(global_st);
109 |    root.populateSymTables();
110 |    root.checkSymTables();
111 |    root.mkcls();
112 |    //   global_st.print();
113 |    root.checktype(false);
114 |   }
115 |   public static void semErr(String s) {
116 |    stop("semantic error: " + s);
117 |   }
118 |   public static void calctype(parserVal pv){
119 |     tree t = (tree)pv.obj;
120 |     t.kids[0].calctype();
121 |     t.kids[1].assigntype(t.kids[0].typ);
122 |   }
123 |   public static boolean isNative;
124 |   public static ArrayList<x64> xcode;
125 |   public static void gencode(parserVal r) {
126 |     tree root = (tree)(r.obj);
127 |     root.genfirst();
128 |     root.genfollow();
129 |     root.gentargets();
130 |     root.gencode();
131 |     labeltable = new HashMap<>();
132 |     methodAddrPushed = false;
133 |     if (isNative) {
134 |       xcode = x64code(root.icode);
135 |       genx64code();
136 |       }
137 |     else {
138 |       ArrayList<byc> bcode = bytecode(root.icode);
139 |       if (bcode != null) {
140 |         genbytecode(bcode);
141 |         }
142 |       }
143 |   }
144 | 
145 | public static ArrayList<x64> l64(x64 x) {
146 |    return new ArrayList<x64>(Arrays.asList(x)); }
147 | public static ArrayList<x64> xgen(String o){
148 |     return l64(new x64(o)); }
149 | public static ArrayList<x64> xgen(String o,
150 |                             address src, address dst) {
151 |     return l64(new x64(o, loc(src), loc(dst))); }
152 | public static ArrayList<x64> xgen(String o, address opnd) {
153 |     return l64(new x64(o, loc(opnd))); }
154 | public static ArrayList<x64> xgen(String o, address src, String dst) {
155 |     return l64(new x64(o, loc(src), loc(dst))); }
156 | public static ArrayList<x64> xgen(String o, String src, address dst) {
157 |     return l64(new x64(o,loc(src),loc(dst))); }
158 | public static ArrayList<x64> xgen(String o, String src, String dst) {
159 |     return l64(new x64(o,loc(src),loc(dst))); }
160 | public static ArrayList<x64> xgen(String o, String opnd) {
161 |     return l64(new x64(o, loc(opnd))); }
162 | 
163 | public static ArrayList<x64> x64code(ArrayList<tac> icode)
164 | {
165 |     int parmCount = -1;
166 |     xcode = new ArrayList<x64>();
167 |     for(int i=0; i<icode.size(); i++) {
168 |       tac instr = icode.get(i);
169 |       switch(instr.op) {
170 |       case "ADD": {
171 |          xcode.addAll(xgen("movq", instr.op2, "%rax"));
172 |          xcode.addAll(xgen("addq", instr.op3, "%rax"));
173 |          xcode.addAll(xgen("movq", "%rax", instr.op1));
174 |          break;
175 |          }
176 |       case "SUB": { } // append translation of SUB to rv
177 |       case "NEG": {
178 |          xcode.addAll(xgen("movq", instr.op2, "%rax"));
179 |          xcode.addAll(xgen("negq", "%rax"));
180 |          xcode.addAll(xgen("movq", "%rax", instr.op1));
181 |          break;
182 |          }
183 |       case "ASN": {
184 |          xcode.addAll(xgen("movq", instr.op2, "%rax"));
185 |          xcode.addAll(xgen("movq", "%rax", instr.op1));
186 |          break;
187 |          }
188 |       case "ADDR": {
189 |          xcode.addAll(xgen("leaq", instr.op2, "%rax"));
190 |          xcode.addAll(xgen("%rax", instr.op1));
191 |          break;
192 |          }
193 |       case "LCON": {
194 |          xcode.addAll(xgen("movq", instr.op2, "%rax"));
195 |          xcode.addAll(xgen("movq", "(%rax)", "%rax"));
196 |          xcode.addAll(xgen("movq", "%rax", instr.op1));
197 |          break;
198 |          }
199 |       case "SCON": {
200 |          xcode.addAll(xgen("movq", instr.op2, "%rbx"));
201 |          xcode.addAll(xgen("movq", instr.op1, "%rax"));
202 |          xcode.addAll(xgen("movq", "%rbx", "(%rax)"));
203 |          break;
204 |          }
205 |       case "GOTO": {
206 |          xcode.addAll(xgen("goto", instr.op1));
207 |          break;
208 |          }
209 |       case "BLT": {
210 |          xcode.addAll(xgen("movq", instr.op2, "%rax"));
211 |          xcode.addAll(xgen("cmpq", instr.op3, "%rax"));
212 |          xcode.addAll(xgen("jle", instr.op1));
213 |          break;
214 |          }
215 |       case "PARM": {
216 |          if (parmCount == -1) {
217 |             parmCount = 0;
218 |             for(int j = i+1; j<icode.size(); j++) {
219 | 	       tac callinstr = icode.get(j);
220 |                if (callinstr.op.equals("CALL")) break;
221 |                parmCount++;
222 |                }
223 |             }
224 |          else parmCount--;
225 |          genParm(parmCount, instr.op1);
226 |          break;
227 |          }
228 |       case "CALL": {
229 |          xcode.addAll(xgen("call", instr.op1));
230 |          if (instr.op3 != null)
231 |             xcode.addAll(xgen("movq", "%rax", instr.op2));
232 |          methodAddrPushed = false;
233 | 	 parmCount = -1;
234 |          break;
235 |          }
236 |       case "RET":
237 |       case "RETURN": {
238 | 	  if (instr.op1 == null)
239 |          xcode.addAll(xgen("movq", "$0", "%rax"));
240 | 	  else
241 |          xcode.addAll(xgen("movq", instr.op1, "%rax"));
242 |          xcode.addAll(xgen("leave"));
243 |          xcode.addAll(xgen("ret", instr.op1));
244 |          break;
245 |          }
246 |       case "proc": {
247 |          int n = 0;
248 | 	 if (instr.op2 == null)
249 | 	     System.err.println("instr.op2 is null");
250 | 	 if (instr.op3 == null)
251 | 	     System.err.println("instr.op3 is null");
252 | 	 if (instr.op2 != null) n += instr.op2.intgr();
253 | 	 if (instr.op3 != null) n += instr.op3.intgr();
254 | 	 n *= 8;
255 | 	 //         int n = (instr.op1.offset + instr.op2.offset) * 8;
256 |          xcode.addAll(xgen(".text"));
257 |          xcode.addAll(xgen(".globl", instr.op1.region));
258 |          xcode.addAll(xgen(".def\t" + instr.op1.region +
259 | 			   ";\t.scl\t2;\t.type\t32;\t.endef"));
260 | 	 xcode.addAll(xgen(".seh_proc\t"+instr.op1.region));
261 | 	 xcode.addAll(xgen("lab", instr.op1.region));
262 | 	 // Linux?
263 | 	 // xcode.addAll(xgen(".type", instr.op1, "@function"));
264 | 	 xcode.addAll(xgen("pushq", "%rbp"));
265 | 	 xcode.addAll(xgen(".seh_pushreg\t%rbp"));
266 | 	 xcode.addAll(xgen("movq", "%rsp", "%rbp"));
267 | 	 xcode.addAll(xgen(".seh_setframe\t%rbp, 0"));
268 | 	 xcode.addAll(xgen("subq", "
quot;+n, "%rsp"));
269 | 	 xcode.addAll(xgen(".seh_stackalloc\t"+n));
270 | 	 xcode.addAll(xgen(".seh_endprologue"));
271 | 	 if (instr.op1.region.equals("main"))
272 | 	     xcode.addAll(xgen("call","__main"));
273 | 	 int j = 0;
274 |          if (instr.op2 != null)
275 | 	     for( ; j < instr.op2.offset; j++)
276 | 		 regs[j].loaded = regs[j].dirty = true;
277 | 	 for( ; j < 11; j++)
278 | 	     regs[j].loaded = regs[j].dirty = false;
279 | 	 break;
280 |       }
281 |       case "end": {
282 | 	  if (! xcode.get(xcode.size()-1).op.equals("ret")) {
283 | 	     xcode.addAll(xgen("leave"));
284 | 	     xcode.addAll(xgen("ret"));
285 |              }
286 | 	  xcode.addAll(xgen(".seh_endproc"));
287 | 	 break;
288 |              }
289 |       case ".code": {
290 | 	  //	 xcode |||:= xgen(".text")
291 | 	 break;
292 | 	 }
293 |       case ".global": {
294 | 	  //         xcode |||:= xgen(".global")
295 | 	 break;
296 |           }
297 |       case ".string": {
298 | 	  //           xcode |||:= xgen(".section\t.rdata,\"dr\"")
299 | 	 break;
300 |           }
301 |       case "LAB": {
302 |          for(RegUse ru : regs) if (ru.dirty) ru.save();
303 | 	 if (! instr.op1.str().startsWith("strings:"))
304 | 	     xcode.addAll(xgen("lab", instr.op1));
305 |          break;
306 |          }
307 | 
308 |       }
309 |    }
310 |     return xcode;
311 | }
312 | 
313 | public static void genParm(int n, address addr) {
314 |    for (RegUse x : regs) x.save();
315 |    if (n > 6) xcode.addAll(xgen("pushq", addr));
316 |    else {
317 |       String s = "error:" + String.valueOf(n);
318 |       switch (n) {
319 |       case 1: s = "%rdi"; break; case 2: s = "%rsi"; break;
320 |       case 3: s ="%rdx"; break; case 4: s = "%rcx"; break;
321 |       case 5: s = "%r8"; break; case 6: s = "%r9"; break;
322 |       }
323 |       String popcode;
324 |       if ((addr instanceof address) && addr.region.equals("strings"))
325 | 	  popcode = "leaq"; else popcode = "movq";
326 |       xcode.addAll(xgen(popcode, addr, s));
327 |    }
328 | }
329 | 
330 | public static ArrayList<byc> bgen(int o, address a) {
331 |     ArrayList<byc> L = new ArrayList<byc>();
332 |    byc b = new byc(o, a);
333 |    L.add(b);
334 |    return L;
335 | }
336 | 
337 |   public static ArrayList<byc> bytecode(ArrayList<tac> icode) {
338 |     ArrayList<byc> rv = new ArrayList<byc>();
339 |     for(int i=0; i<icode.size(); i++) {
340 |       tac instr = icode.get(i);
341 |       switch(instr.op) {
342 |       case "ADD": {
343 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
344 |         rv.addAll(j0.bgen(Op.PUSH, instr.op3));
345 |         rv.addAll(j0.bgen(Op.ADD, null));
346 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
347 |         break;
348 |       }
349 |       case "SUB": {  }
350 |       case "NEG": {
351 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
352 |         rv.addAll(j0.bgen(Op.NEG, null));
353 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
354 |         break;
355 |       }
356 |       case "ASN": {
357 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
358 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
359 |         break;
360 |       }
361 |       case "ADDR": {
362 |         rv.addAll(j0.bgen(Op.LOAD, instr.op1));
363 |         break;
364 |       }
365 |       case "LCON": {
366 |         rv.addAll(j0.bgen(Op.LOAD, instr.op2));
367 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
368 |         break;
369 |       }
370 |       case "SCON": {
371 |         rv.addAll(j0.bgen(Op.STORE, instr.op2));
372 |         rv.addAll(j0.bgen(Op.POP, instr.op1));
373 |         break;
374 |       }
375 |       case "GOTO": {
376 |         rv.addAll(j0.bgen(Op.GOTO, instr.op1));
377 |         break;
378 |       }
379 |       case "BLT": {
380 |         rv.addAll(j0.bgen(Op.PUSH, instr.op2));
381 |         rv.addAll(j0.bgen(Op.PUSH, instr.op3));
382 |         rv.addAll(j0.bgen(Op.LT, null));
383 | 	rv.addAll(j0.bgen(Op.BIF, instr.op1));
384 | 	break;
385 |       }
386 |       case "PARM": {
387 |         if (methodAddrPushed == false) {
388 | 	    for(int j = i+1; j < icode.size(); j++) {
389 |             tac callinstr = icode.get(j);
390 | 	    if (callinstr.op.equals("CALL")) {
391 | 		if (callinstr.op1.str().equals("PrintStream__println:0")) {
392 |                   rv.addAll(j0.bgen(Op.PUSH, new address("imm", -1)));
393 |                } else {
394 |                   rv.addAll(j0.bgen(Op.PUSH, callinstr.op1));
395 | 	       }
396 |                break;
397 | 	    }
398 | 	    methodAddrPushed = true;
399 |           }
400 |         }
401 |         rv.addAll(j0.bgen(Op.PUSH, instr.op1));
402 |         break;
403 |       }
404 |       case "CALL": {
405 |          rv.addAll(j0.bgen(Op.CALL, instr.op2));
406 | 	 methodAddrPushed = false;
407 |          break;
408 |       }
409 |       case "RET": case "RETURN": {
410 |         rv.addAll(j0.bgen(Op.RETURN, instr.op1));
411 |         break;
412 |       }
413 |       case "proc": {
414 | 	// record address
415 | 	  labeltable.put(instr.op1.region, rv.size() * 8);
416 | 	break;
417 |         }
418 |       case "end": { break; }
419 |       case ".code": { break; }
420 |       case ".global": { break; }
421 |       case ".string": {break; }
422 |       case "LAB": {
423 | 	  labeltable.put("L"+String.valueOf(instr.op1.offset), rv.size() * 8);
424 |          break;
425 |       }
426 |       case "string": {break; }
427 |       case "global": { break; }
428 |       case "FIELD": {
429 | 	  rv.addAll(j0.bgen(Op.PUSH, instr.op2));
430 | 	  rv.addAll(j0.bgen(Op.POP, instr.op1));
431 | 	  break;
432 | 	 }
433 | 
434 |       default: { stop("What is " + instr.op); }
435 |       }
436 |     }
437 |     return rv;
438 |   }
439 | 
440 |     public static int calculate_fio() {
441 | 	return 3+ stringtab.count/8 + global_st.count/8;
442 |     }
443 | 
444 |     public static void write_stringarea(PrintStream fout) {
445 | 	String s;
446 | 	for(int i=0; i<stringtab.L.size(); i++) {
447 | 	    s = stringtab.L.get(i);
448 | 	    // should fully-binarize (de-escape) string here
449 | 	    // for now, just strip double quotes, replace with NULs
450 | 	    s = s.substring(1,s.length()-1) + "\0\0" ;
451 | 
452 | 	    int len = s.length();
453 | 	    while (len > 0) {
454 | 		if (len < 9) {
455 | 		   fout.print(s);
456 | 		   if (len < 8) {
457 | 		       for(int j = 0; j<8-len; j++)
458 | 			   fout.print( "\0");
459 | 		   }
460 | 		}
461 | 		else { fout.print(s.substring(0,8)); s = s.substring(8); }
462 | 		len -= 8;
463 |          }
464 |      }
465 |     }
466 | 
467 |     public static void write_globalarea(PrintStream fout){
468 | 	for(int i=0; i<global_st.count; i++)
469 | 	    fout.print("\0");
470 |     }
471 | 
472 |     public static void write_instructions(ArrayList<byc> bc,
473 | 					  PrintStream fout) {
474 | 	for(int i=0; i<bc.size(); i++) {
475 | 	    byc b = bc.get(i);
476 | 	    switch( b.op ) {
477 | 	    case Op.CODE: { }
478 | 	    case Op.GLOBAL: { }
479 | 	    case Op.LABEL: { }
480 | 	    case Op.PROC: {  }
481 | 	    case Op.STRING: {  }
482 | 	    case Op.END: {break; }
483 | 	    default: {
484 | 		bc.get(i).printb(fout);
485 | 	    }
486 | 	    }
487 | 	}
488 |     }
489 | 
490 |     public static void stop(String s) {
491 | 	System.err.println(s);
492 | 	System.exit(1);
493 |     }
494 | 
495 |     public static String rawstring(int i, int len) {
496 | 	String s = "";
497 | 	for(int j=0; j<len; j++) {
498 | 	    s = Character.toString((char)(i & 0xFF)) + s;
499 | 	    i = i >> 8;
500 | 	}
501 | 	return s;
502 |     }
503 |     public static String reverse(String s) {
504 | 	return (new StringBuffer(s)).reverse().toString();
505 |     }
506 |     public static int where;
507 |     public static PrintStream open(String s){
508 | 	PrintStream p = null;
509 | 	where = 0;
510 | 	try {
511 |           p = new PrintStream(s);
512 | 	} catch (java.io.FileNotFoundException e) {
513 |           stop("couldn't open output file "+ s + " for writing");
514 | 	}
515 | 	return p;
516 |     }
517 | 
518 |   public static int find(byte[] needle, byte[]haystack) {
519 |     int i=0;
520 |     for( ; i < haystack.length - needle.length+1; ++i) {
521 |         boolean found = true;
522 |         for(int j = 0; j < needle.length; ++j) {
523 |            if (haystack[i+j] != needle[j]) {
524 |                found = false;
525 |                break;
526 |            }
527 |         }
528 |         if (found) return i;
529 |     }
530 |     return -1;
531 |   }
532 |   public static int find(String needle, String haystack) {
533 |       return find(needle.getBytes(), haystack.getBytes());
534 |   }
535 | 
536 |     public static void genbytecode(ArrayList<byc> bc) {
537 |     int i = find(".java", yyfilename), fio;
538 |     int entrypt;
539 |     String outfilename = yyfilename.substring(0,i) + ".j0";
540 |     PrintStream fout;
541 |     fout = open(outfilename);
542 |       fout.print("Jzero!!\0");               // word 0, magic word
543 |       fout.print("1.0\0\0\0\0\0");           // word 1, version #
544 |       // write first instruction offset. convert Java binary to bcode binary
545 |       fio = calculate_fio();
546 |       fout.print("\0\0" + reverse(rawstring(fio, 6)));
547 |       write_stringarea(fout);
548 |       write_globalarea(fout);
549 | 
550 |       // bootstrap instructions: push addr of main, push dummy self, call 0, and halt
551 |       entrypt = fio*8+32;
552 |       if (! labeltable.containsKey("main")) stop("main() not found");
553 |       entrypt += labeltable.get("main");
554 |       fout.print("\11\2"+reverse(rawstring(entrypt, 6))); // PUSH IMM (func entry pt) fio*8+24
555 |       fout.print("\11\2\0\0\0\0\0\0");            // PUSH 0 (null self)
556 |       fout.print("\13\2\0\0\0\0\0\0");            // call 0
557 |       fout.print("\1\0\0\0\0\0\0\0");             // halt
558 | 
559 |       write_instructions(bc, fout);
560 |       fout.close();
561 |   }
562 | 
563 |     public static void genx64code() {
564 | 	int i = find(".java", yyfilename);
565 | 	String outfilename = yyfilename.substring(0,i) + ".s";
566 | 	PrintStream fout;
567 |         fout = open(outfilename);
568 | 	fout.println("\t.file\t\"" + yyfilename + "\"");
569 | 	// write out our "runtime system" with every generated code
570 | 	fout.println("\t.text");
571 | 	fout.println("\t.globl\tPrintStream__println");
572 | 	fout.println("\t.def\tPrintStream__println;\t.scl\t2;\t.type\t32;\t.endef");
573 | 	fout.println("\t.seh_proc\tPrintStream__println");
574 | 	fout.println("PrintStream__println:");
575 | 	fout.println("\tpushq\t%rbp");
576 | 	fout.println("\t.seh_pushreg\t%rbp");
577 |         fout.println("\tmovq\t%rsp, %rbp");
578 | 	fout.println("\t.seh_setframe\t%rbp, 0");
579 | 	fout.println("\tsubq\t$32, %rsp\n"+
580 | 		     "\t.seh_stackalloc\t32\n" +
581 | 		     "\t.seh_endprologue\n"+
582 | 		     "\tmovq\t%rsi, %rcx\n"+ // Windows conventions!
583 | 		     "\tcall\tputs\n"+
584 | 		     "\tnop\n"+
585 | 		     "\taddq\t$32, %rsp\n"+
586 | 		     "\tpopq\t%rbp\n"+
587 | 		     "\tret\n"+
588 | 		     "\t.seh_endproc\n"+
589 | 		     "\t.text\n"+
590 | 		     "\t.def\t__main;\t.scl\t2;\t.type\t32;\t.endef");
591 | 	write_x64strings(fout);
592 | 	x64print(fout);
593 | 	fout.println("\t.ident\t\"j0: (Unicon) 0.1.0\"");
594 | 	fout.println("\t.def\tputs;\t.scl\t2;\t.type\t32;\t.endef");
595 | 	fout.close();
596 |     }
597 | 
598 |   public static void write_x64strings(PrintStream fout) {
599 |     String s;
600 |     fout.println("\t.section\t.rdata,\"dr\"");
601 |     for(int i=0; i < stringtab.L.size(); i++) {
602 | 	s = stringtab.L.get(i);
603 | 	fout.println(".Lstr" + i + ":");
604 | 	s = s.substring(0, s.length()-1) + "\\0\"";
605 | 	fout.println("\t.ascii " + s);
606 |      }
607 |   }
608 | 
609 |   public static void x64print(PrintStream f) {
610 |     for(x64 x : xcode) x.print(f);
611 |   }
612 |   public static void x64print() {
613 |     for(x64 x : xcode) x.print(System.out);
614 |   }
615 | 
616 |    public static x64loc loc(String s) { return new x64loc(s); }
617 |    public static x64loc loc(Object o) {
618 |       if (o instanceof String) return loc((String)o);
619 |       if (o instanceof address) return loc((address)o);
620 |       return null;
621 |    }
622 |    public static x64loc loc(address a) {
623 |      if (a == null) return null;
624 |      switch (a.region) {
625 |      case "method":
626 |      case "loc": { if (a.offset <= 88) return loadreg(a);
627 |                    else return new x64loc("rbp", -a.offset); }
628 |      case "glob": { return new x64loc("rip", a.offset); }
629 |      case "const": { return new x64loc("imm", a.offset); }
630 |      case "lab": { return new x64loc("lab", a.offset); }
631 |      case "obj": { return new x64loc("r15", a.offset); }
632 |      case "imm": { return new x64loc("imm", a.offset); }
633 |      case "strings": { return new x64loc("%rip", ".Lstr"+a.offset); }
634 |      default: {
635 | 	 // semErr("x64loc unknown region" + a.region);
636 | 	 return new x64loc("lab", a.region);
637 |      }
638 |      }
639 |   }
640 |   public static x64loc loadreg(address a) {
641 |     int r = a.offset/8;
642 |     if (!(regs[r].loaded)) {
643 |       xcode.addAll(xgen("movq",
644 | 			String.valueOf(-a.offset)+"(%rbp)", regs[r].reg));
645 |       regs[r].loaded = true;
646 |       }
647 |     return new x64loc(regs[a.offset/8+1].reg);
648 |   }
649 | }
650 | 


--------------------------------------------------------------------------------
/ch13/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC NEW BOOLEAN
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |   j0.gencode($);
 12 |  } ;
 13 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 14 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 15 | ClassBodyDecls: ClassBodyDecl
 16 | | ClassBodyDecls ClassBodyDecl {
 17 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 18 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 19 | FieldDecl: Type VarDecls ';' {
 20 |   $=j0.node("FieldDecl",1030,$1,$2);
 21 |   j0.calctype($);
 22 |   };
 23 | Type: INT | DOUBLE | BOOLEAN | STRING | Name ;
 24 | 
 25 | Name: IDENTIFIER | QualifiedName ;
 26 | QualifiedName: Name '.' IDENTIFIER {
 27 |   $=j0.node("QualifiedName",1040,$1,$3);};
 28 | 
 29 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 30 |   $=j0.node("VarDecls",1050,$1,$3); };
 31 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 32 |   $=j0.node("VarDeclarator",1060,$1); };
 33 | 
 34 | MethodReturnVal : Type | VOID ;
 35 | MethodDecl: MethodHeader Block {
 36 |   $=j0.node("MethodDecl",1380,$1,$2);
 37 |  };
 38 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 39 |   $=j0.node("MethodHeader",1070,$3,$4);
 40 |   j0.calctype($);
 41 |   };
 42 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 43 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 44 | 
 45 | FormalParmListOpt: FormalParmList | ;
 46 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 47 |   $=j0.node("FormalParmList",1090,$1,$3); };
 48 | FormalParm: Type VarDeclarator {
 49 |   $=j0.node("FormalParm",1100,$1,$2);
 50 |   j0.calctype($);
 51 |  };
 52 | 
 53 | ConstructorDecl: MethodDeclarator Block {
 54 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 55 | 
 56 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 57 | BlockStmtsOpt: BlockStmts | ;
 58 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 59 |   $=j0.node("BlockStmts",1130,$1,$2); };
 60 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 61 | 
 62 | LocalVarDeclStmt: LocalVarDecl ';' ;
 63 | LocalVarDecl: Type VarDecls {
 64 |   $=j0.node("LocalVarDecl",1140,$1,$2);
 65 |   j0.calctype($);
 66 |   };
 67 | 
 68 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 69 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 70 |       | WhileStmt | ForStmt ;
 71 | 
 72 | ExprStmt: StmtExpr ';' ;
 73 | 
 74 | StmtExpr: Assignment | MethodCall ;
 75 | 
 76 | IfThenStmt: IF '(' Expr ')' Block {
 77 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 78 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 79 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 80 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 81 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 82 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 83 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 84 | 
 85 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 86 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 87 | ElseIfStmt: ELSE IfThenStmt {
 88 |   $=j0.node("ElseIfStmt",1190,$2); };
 89 | WhileStmt: WHILE '(' Expr ')' Stmt {
 90 |   $=j0.node("WhileStmt",1210,$3,$5); };
 91 | 
 92 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 93 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 94 | ForInit: StmtExprList | LocalVarDecl | ;
 95 | ExprOpt: Expr |  ;
 96 | ForUpdate: StmtExprList | ;
 97 | 
 98 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 99 |   $=j0.node("StmtExprList",1230,$1,$3); };
100 | 
101 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
102 |   $=j0.node("BreakStmt",1240,$2); };
103 | ReturnStmt: RETURN ExprOpt ';' {
104 |   $=j0.node("ReturnStmt",1250,$2); };
105 | 
106 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
107 | Primary:  Literal | FieldAccess | MethodCall | ArrayAccess |
108 |          '(' Expr ')' { $=$2;} | ArrayCreation | InstanceCreation;
109 | InstanceCreation: NEW Name '(' ArgListOpt ')' {
110 |   $=j0.node("InstanceCreation", 1261, $2, $4); };
111 | ArrayCreation: NEW Type '[' Expr ']' {
112 |   $=j0.node("ArrayCreation", 1260, $2, $4); };
113 | 
114 | ArgList: Expr | ArgList ',' Expr {
115 |   $=j0.node("ArgList",1270,$1,$3); };
116 | FieldAccess: Primary '.' IDENTIFIER {
117 |   $=j0.node("FieldAccess",1280,$1,$3); };
118 | 
119 | ArgListOpt:  ArgList | ;
120 | MethodCall: Name '(' ArgListOpt ')' {
121 |   $=j0.node("MethodCall",1290,$1,$3); }
122 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
123 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
124 | 	;
125 | 
126 | PostFixExpr: Primary | Name ;
127 | UnaryExpr:  '-' UnaryExpr {
128 |   $=j0.node("UnaryExpr",1300,$1,$2); }
129 |     | '!' UnaryExpr {
130 |   $=j0.node("UnaryExpr",1301,$1,$2); }
131 |     | PostFixExpr ;
132 | MulExpr: UnaryExpr
133 |     | MulExpr '*' UnaryExpr {
134 |       $=j0.node("MulExpr",1310,$1,$3); }
135 |     | MulExpr '/' UnaryExpr {
136 |       $=j0.node("MulExpr",1311,$1,$3); }
137 |     | MulExpr '%' UnaryExpr {
138 |       $=j0.node("MulExpr",1312,$1,$3); };
139 | AddExpr: MulExpr
140 |     | AddExpr '+' MulExpr {
141 |       $=j0.node("AddExpr",1320,$1,$3); }
142 |     | AddExpr '-' MulExpr {
143 |       $=j0.node("AddExpr",1321,$1,$3); };
144 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
145 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
146 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
147 | 
148 | EqExpr: RelExpr
149 |     | EqExpr ISEQUALTO RelExpr {
150 |   $=j0.node("EqExpr",1340,$1,$3); }
151 | | EqExpr NOTEQUALTO RelExpr {
152 |   $=j0.node("EqExpr",1341,$1,$3); };
153 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
154 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
155 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
156 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
157 | 
158 | ArrayAccess: Name '[' Expr ']' { $=j0.node("ArrayAccess",1390,$1,$3); };
159 | 
160 | Expr: CondOrExpr | Assignment ;
161 | Assignment: LeftHandSide AssignOp Expr {
162 |   $=j0.node("Assignment",1370, $1, $2, $3); };
163 | LeftHandSide: Name | FieldAccess | ArrayAccess ;
164 | AssignOp: '=' | INCREMENT | DECREMENT ;
165 | 


--------------------------------------------------------------------------------
/ch13/j0machine.icn:
--------------------------------------------------------------------------------
  1 | link signed
  2 | class j0machine(code, ip, stack, data, finstr, sp, bp, hp, op, opr, opnd)
  3 |   # loadbytecode at present returns everything after the first two-words of header
  4 |   method loadbytecode(filename)
  5 |     sz := stat(filename).size
  6 |     f := open(filename) | stop("cannot open ", filename)
  7 |     s := reads(f, sz) | stop("cannot read from ", filename)
  8 |     close(f)
  9 |     s ? {
 10 |       if tab(find("Jzero!!\0001.0\0\0\0\0\0")) then {
 11 |         return tab(0)
 12 |         }
 13 |       else stop("file ", filename, " is not a Jzero file")
 14 |       }
 15 |   end
 16 |   method init(filename)
 17 |     ip := 0
 18 |     code := loadbytecode(filename) |
 19 |       stop("cannot open program.j0")
 20 |     Op()
 21 |     ip := 16
 22 |     ip := finstr := 8*getOpnd()
 23 |     data := Data(code[25:ip+1])
 24 |     stack := list()
 25 |     bp := sp := 1
 26 |   end
 27 |   method fetch()
 28 |     op := ord(code[1+ip]) | stop("can't get op at ", ip)
 29 |     opr := ord(code[2+ip])
 30 |     if opr ~= 0 then { opnd := getOpnd() }
 31 |     ip +:= 8
 32 |   end
 33 |   method getOpnd()
 34 |     return signed(reverse(code[ip+3+:6])) | stop("getOpnd failed")
 35 |   end
 36 |   method word(s)
 37 |    local i := 0, j
 38 |      every j := 8 to 1 by -1 do {
 39 |        b := ord(s[j])
 40 |        i := ishift(i, 8) + ord(b)
 41 |      }
 42 |    return i
 43 |   end
 44 |   method interp()
 45 |     repeat {
 46 |       fetch()
 47 |       case (op) of {
 48 |          Op.HALT: { stop("Execution completed.") }
 49 |          Op.NOOP: {   }
 50 |          Op.ADD: {
 51 |            val1 := pop(stack); val2 := pop(stack)
 52 |            push(stack, val1 + val2)
 53 |            }
 54 |          Op.PUSH: {
 55 |            (val := deref(opr, opnd)) | stop("deref failed")
 56 |            push(stack, val)
 57 |            }
 58 |          Op.POP: {
 59 |            val := pop(stack)
 60 |            assign(opnd, val)
 61 |            }
 62 |          Op.GOTO: {
 63 |            ip := opnd
 64 |            }
 65 |          Op.BIF: {
 66 |            if pop(stack)~=0 then
 67 |              ip := opnd
 68 |            }
 69 |          Op.CALL: {
 70 |            f := stack[2+opnd]
 71 |            if f >= 0 then {
 72 |              push( stack, ip) # save old ip
 73 |              push( stack, bp) # save old ip
 74 |              bp := *stack     # set new bp
 75 |              ip := f          # set new ip
 76 |              }
 77 |            else if f = -1 then do_println()
 78 |            else stop("no CALL defined for ", image(f))
 79 |            }
 80 |          Op.RETURN: {
 81 |            while *stack > bp do pop(stack)
 82 |            bp := pop(stack)
 83 |            ip := pop( stack )
 84 |            }
 85 | 
 86 |          Op.LT: {  }
 87 |          Op.LE: {  }
 88 |          default: { stop("Illegal opcode ", op) }
 89 |          }
 90 |       }
 91 |   end
 92 |   method do_println()
 93 |     # stack[1] is self. first arg is stack[2]
 94 |     x := stack[2]
 95 |     y := c_string(code[1+x:0])
 96 |     write(y)
 97 |   end
 98 |   method c_string(s)
 99 |     if i := find("\0", s) then return s[1:i]
100 |     else stop("no C string in ", image(s))
101 |   end
102 |   method assign(x, y)
103 |     # implement assign
104 |   end
105 | 
106 |   method deref(reg, opd)
107 |     case reg of {
108 |       Op.R_ABS: {
109 |         if opd < finstr then return data.word(opd) | stop("datafail")
110 |         else return code[opd] | stop("codefail")
111 |         }
112 |       Op.R_IMM: { return opd }
113 |       Op.R_STACK: {
114 |          return stack[bp+opd/8] | stop("stackfail bp ", bp, " opd ", opd) }
115 |       default: { write("deref region ", reg); runerr(101, reg) }
116 |     }
117 |   end
118 | 
119 | end
120 | class Data(d)
121 |   method word(o)
122 |     return d[1+o +: 8]
123 |   end
124 | end
125 | 


--------------------------------------------------------------------------------
/ch13/j0machine.java:
--------------------------------------------------------------------------------
  1 | package ch13;
  2 | import java.io.IOException;
  3 | import java.nio.file.Files;
  4 | import java.nio.file.Paths;
  5 | import java.nio.charset.StandardCharsets;
  6 | import java.nio.ByteBuffer;
  7 | public class j0machine {
  8 |   public static byte[] code, stack;
  9 |   public static ByteBuffer codebuf, stackbuf;
 10 |   public static int ip, sp, bp, hp, op, opr, finstr;
 11 |   public static long opnd;
 12 | 
 13 |   public static boolean loadbytecode(String filename)
 14 |     throws IOException {
 15 |       code = Files.readAllBytes(Paths.get(filename));
 16 |       byte[] magstr = "Jzero!!\0".getBytes(
 17 |                           StandardCharsets.US_ASCII);
 18 |       int i = find(magstr, code);
 19 |       if (i>=0) {
 20 |         // need to check version, allow for self-execution script header
 21 |         codebuf = ByteBuffer.wrap(code);
 22 |         return true;
 23 |       }
 24 |       else return false;
 25 |   }
 26 | 
 27 |   public static int find(byte[]needle, byte[]haystack) {
 28 |     int i=0;
 29 |     for( ; i < haystack.length - needle.length+1; ++i) {
 30 |         boolean found = true;
 31 |         for(int j = 0; j < needle.length; ++j) {
 32 |            if (haystack[i+j] != needle[j]) {
 33 |                found = false;
 34 |                break;
 35 |            }
 36 |         }
 37 |         if (found) return i;
 38 |     }
 39 |     return -1;
 40 |   }
 41 |   public static void init(String filename)
 42 |     throws IOException {
 43 |       ip = sp = 0;
 44 |       if (! loadbytecode(filename)) {
 45 |          System.err.println("cannot open program.j0");
 46 |          System.exit(1);
 47 |          }
 48 |       ip = 16;
 49 |       ip = finstr = (int) (8*getOpnd());
 50 |       stack = new byte[800000];
 51 |       stackbuf = ByteBuffer.wrap(stack);
 52 |     }
 53 |   public static void fetch() {
 54 |       op = code[ip];
 55 |       opr = code[ip+1];
 56 |       if (opr != 0) { opnd = getOpnd(); }
 57 |       ip += 8;
 58 |   }
 59 |   public static long getOpnd() {
 60 |    long i=0;
 61 |    if (codebuf.get(ip+7) < 0) i = -1;
 62 |    for(int j=7;j>1;j--) i = (i<<8) | codebuf.get(ip+j);
 63 |    return i;
 64 |   }
 65 |   public static void stop(String s) {
 66 |     System.err.println(s);
 67 |     System.exit(1);
 68 |     }
 69 |   public static void interp() {
 70 |     for(;;) {
 71 |       fetch();
 72 |       switch (op) {
 73 |         case Op.HALT: { stop("Execution complete."); break; }
 74 |         case Op.NOOP: { break; }
 75 |         case Op.ADD: {
 76 |           long val1 = stackbuf.getLong(sp--);
 77 |           long val2 = stackbuf.getLong(sp--);
 78 | 	  stackbuf.putLong(sp++, val1 + val2);
 79 |           break;
 80 |           }
 81 |       case Op.PUSH: {
 82 | 	  long val = deref(opr, opnd);
 83 | 	  push(val);
 84 | 	  break;
 85 |       }
 86 |       case Op.POP: {
 87 | 	  long val = pop();
 88 | 	  assign(opnd, val);
 89 | 	  break;
 90 |       }
 91 |       case Op.GOTO: {
 92 | 	  ip = (int)opnd;
 93 | 	  break;
 94 |       }
 95 |       case Op.BIF: {
 96 | 	  if (pop() != 0)
 97 | 	      ip = (int)opnd;
 98 | 	  break;
 99 |       }
100 | 
101 |       case Op.CALL: {
102 | 	  long f;
103 | 	  f = stackbuf.getLong(sp-16-(int)(8*opnd));
104 | 	  if (f >= 0) {
105 | 	      push( ip);
106 | 	      push( bp);
107 | 	      bp = sp;
108 | 	      ip = (int)f;
109 |              }
110 | 	  else if (f == -1) do_println();
111 | 	  else { stop("no CALL defined for " + f); }
112 | 	  break;
113 |            }
114 |       case Op.RETURN: {
115 |            sp = bp;
116 |            bp = (int)pop();
117 |            ip = (int)pop();
118 | 	   break;
119 |            }
120 | 
121 |       case Op.LT: { stop("LT not implemented yet."); break; }
122 |       case Op.LE: { stop("LE not implemented yet."); break; }
123 |       default: { stop("Illegal opcode " + op); }
124 |       }
125 |     }
126 |   }
127 | 
128 |     public static void do_println() {
129 | 	// execute a system.out.println on an argument on the stack
130 | 	long addr = stackbuf.getLong(sp-16);
131 | 	byte b = codebuf.get((int)addr++);
132 | 	while (b != 0) {
133 | 	   System.out.print((char)b);
134 |            b = codebuf.get((int)addr++);
135 |         }
136 | 	System.out.println();
137 |     }
138 | 
139 |     public static long deref(int reg, long od) {
140 | 	switch(reg) {
141 | 	case Op.R_ABS: { return codebuf.getLong((int)od); }
142 | 	case Op.R_IMM: { return od; }
143 | 	case Op.R_STACK: { return stackbuf.getLong(bp+(int)od); }
144 |         default: { stop("deref region " + reg); }
145 | 	}
146 | 	return 0;
147 |     }
148 | 
149 |     public static void assign(long ad, long val) {
150 | 	switch(opr) {
151 | 	case Op.R_ABS: {  }
152 | 	case Op.R_IMM: {  }
153 | 	case Op.R_STACK: {  }
154 |         default: {  } // stop("assign region " + opr); }
155 | 	}
156 |     }
157 | 
158 |     public static void push(long val) {
159 |       stackbuf.putLong(val);
160 |       sp += 8;
161 |     }
162 | 
163 |     public static long pop() {
164 |       sp -= 8;
165 |       long rv = stackbuf.getLong(sp);
166 |       return rv;
167 |     }
168 | }
169 | 


--------------------------------------------------------------------------------
/ch13/j0x.icn:
--------------------------------------------------------------------------------
1 | procedure main(argv)
2 |   if not (filename := argv[1]) then
3 |     stop("usage: j0x file[.j0]")
4 |   if not (filename[-3:0] == ".j0") then filename ||:= ".j0"
5 |   j0machine := j0machine()
6 |   j0machine.init(filename)
7 |   j0machine.interp()
8 | end
9 | 


--------------------------------------------------------------------------------
/ch13/j0x.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class j0x {
 3 |   public static void main(String[] argv) {
 4 |     if (argv.length < 1) {
 5 |       System.err.println("usage: j0x file[.j0]" + argv.length);
 6 |       System.exit(1);
 7 |       }
 8 |     String filename = argv[0];
 9 |     if (! filename.endsWith(".j0"))
10 |       filename = filename + ".j0";
11 |     try {
12 |       j0machine.init(filename);
13 |     } catch(Exception ex) {
14 | 	System.err.println("Can't initialize. Exiting.");
15 | 	System.exit(1);
16 |     }
17 |     j0machine.interp();
18 |   }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch13/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "new"                  { return j0.scan(parser.NEW); }
18 | "null"                 { return j0.scan(parser.NULLVAL); }
19 | "public"               { return j0.scan(parser.PUBLIC); }
20 | "return"               { return j0.scan(parser.RETURN); }
21 | "static"               { return j0.scan(parser.STATIC); }
22 | "string"               { return j0.scan(parser.STRING); }
23 | "true"                 { return j0.scan(parser.BOOLLIT); }
24 | "boolean"              { return j0.scan(parser.BOOLEAN); }
25 | "void"                 { return j0.scan(parser.VOID); }
26 | "while"                { return j0.scan(parser.WHILE); }
27 | "class"                { return j0.scan(parser.CLASS); }
28 | "("                    { return j0.scan(j0.ord("("));}
29 | ")"                    { return j0.scan(j0.ord(")"));}
30 | "["                    { return j0.scan(j0.ord("["));}
31 | "]"                    { return j0.scan(j0.ord("]"));}
32 | "{"                    { return j0.scan(j0.ord("{"));}
33 | "}"                    { return j0.scan(j0.ord("}"));}
34 | ";"                    { return j0.scan(j0.ord(";"));}
35 | ":"                    { return j0.scan(j0.ord(":"));}
36 | "!"                    { return j0.scan(j0.ord("!"));}
37 | "*"                    { return j0.scan(j0.ord("*"));}
38 | "/"                    { return j0.scan(j0.ord("/"));}
39 | "%"                    { return j0.scan(j0.ord("%"));}
40 | "+"                    { return j0.scan(j0.ord("+"));}
41 | "-"                    { return j0.scan(j0.ord("-"));}
42 | "<"                    { return j0.scan(j0.ord("<"));}
43 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
44 | ">"                    { return j0.scan(j0.ord(">"));}
45 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
46 | "=="                   { return j0.scan(parser.ISEQUALTO);}
47 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
48 | "&&"                   { return j0.scan(parser.LOGICALAND);}
49 | "||"                   { return j0.scan(parser.LOGICALOR);}
50 | "="                    { return j0.scan(j0.ord("=")); }
51 | "+="                   { return j0.scan(parser.INCREMENT); }
52 | "-="                   { return j0.scan(parser.DECREMENT); }
53 | ","                    { return j0.scan(j0.ord(",")); }
54 | "."                    { return j0.scan(j0.ord(".")); }
55 | {id}                   { return j0.scan(parser.IDENTIFIER); }
56 | [0-9]+                 { return j0.scan(parser.INTLIT); }
57 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
58 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
59 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
60 | .                      { j0.lexErr("unrecognized character"); }
61 | 


--------------------------------------------------------------------------------
/ch13/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u typeinfo.u
 6 | CGU=tac.u address.u byc.u op.u reguse.u x64.u x64loc.u
 7 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU) $(CGU)
 8 | UX=j0x.u j0machine.u op.u
 9 | 
10 | unicon: j0 j0x
11 | %.u : %.icn
12 | 	unicon -c 
lt;
13 | j0: $(U)
14 | 	unicon $(U)
15 | javalex.icn: javalex.l
16 | 	uflex javalex.l
17 | j0gram.icn j0gram_tab.icn: j0gram.y
18 | 	iyacc -dd j0gram.y
19 | j0x: $(UX)
20 | 	unicon $(UX)
21 | 
22 | # A typical run might use
23 | # set CLASSPATH=".;c:\users\username\byopl"
24 | # in order to run from c:\users\username\byopl\ch13
25 | LYSRC=Yylex.java parser.java parserVal.java
26 | TPJ=typeinfo.java arraytype.java classtype.java methodtype.java parameter.java
27 | STJ=symtab.java symtab_entry.java $(TPJ)
28 | CGJ=tac.java address.java byc.java op.java RegUse.java x64.java x64loc.java
29 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ) $(CGJ)
30 | JXSRC= Op.java j0x.java j0machine.java
31 | BYJOPTS= -Jclass=parser -Jpackage=ch13
32 | BYJIMPS= -Jyylex=ch13.j0.yylex -Jyyerror=ch13.yyerror.yyerror
33 | java: j0.class j0x.class
34 | 
35 | j: java
36 | 	java ch13.j0 hello.java
37 | 	dot -Tpng hello.java.dot >hello.png
38 | 
39 | j0.class: $(JSRC)
40 | 	CLASSPATH=".;D:\Users\Clinton Jeffery\books\byopl" javac $(JSRC)
41 | parser.java parserVal.java: j0gram.y
42 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
43 | Yylex.java: javalex.l
44 | 	jflex javalex.l
45 | 
46 | j0x.class: $(JXSRC)
47 | 	javac $(JXSRC)
48 | 


--------------------------------------------------------------------------------
/ch13/methodtype.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class methodtype extends typeinfo {
 3 |    typeinfo [] parameters;
 4 |    typeinfo return_type;
 5 |     public String str() {
 6 | 	String s;
 7 | 	s = "method " + ((return_type!=null)?return_type.str():"undef") + "(";
 8 | 	for(typeinfo p : parameters)
 9 | 	    s = s + p.str() + ",";
10 | 	s = s.substring(0,s.length()-2) + ")";
11 | 	return s;
12 |     }
13 |    methodtype(typeinfo [] p, typeinfo rt){
14 |        parameters = p;
15 |        if (rt !=null) return_type = rt;
16 |        else return_type = new typeinfo("void");
17 |        basetype="method";
18 |    }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch13/parameter.java:
--------------------------------------------------------------------------------
1 | package ch13;
2 | public class parameter {
3 |    String name;
4 |    typeinfo param_type;
5 |    parameter(String s, typeinfo t) { name=s; param_type=t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch13/reguse.icn:
--------------------------------------------------------------------------------
 1 | class RegUse (reg, offset, loaded, dirty)
 2 |    method load()
 3 |       if \loaded then fail
 4 |       loaded := 1
 5 |       return j0.xgen("movq", offset||"(%rbp)", reg)
 6 |    end
 7 |    method save()
 8 |       if /dirty then fail
 9 |       dirty := &null
10 |       return j0.xgen("movq", reg, offset||"(%rbp)")
11 |    end
12 | end
13 | 


--------------------------------------------------------------------------------
/ch13/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch13/serial.java:
--------------------------------------------------------------------------------
1 | package ch13;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch13/symtab.icn:
--------------------------------------------------------------------------------
 1 | # t is the actual hash table, L holds keys in the order inserted
 2 | class symtab(scope, parent, t, L, count)
 3 |   method lookup(s)
 4 |     return if rv := \ (t[s]) then {
 5 |               rv }
 6 |            else {
 7 |              (\parent).lookup(s)
 8 |              }
 9 |   end
10 |   method insert(s, isConst, sub, typ)
11 |     if \ (t[s]) then {
12 |       if scope == "strings" then {
13 | #         write("eureka, a duplicate string constant")
14 |          }
15 |       else
16 |          j0.semErr("redeclaration of " || s)
17 |       }
18 |     else {
19 |       (\sub).parent := self
20 |       t[s] := symtab_entry(s, self, sub, isConst, typ,
21 |                            address(scope,count))
22 |       put(L, s)
23 |       len := *s
24 |       while len > 0 do {
25 |          count +:= 8
26 | 	 len -:= 8
27 | 	 }
28 |       }
29 |   end
30 |   method genlocal()
31 |   local s := "__local
quot; || count
32 |     insert(s, false, , typeinfo("int"))
33 |     return t[s].addr
34 |   end
35 |   method print(level:0)
36 |     writes(repl(" ",level))
37 |     write(scope, " - ", *t, " symbols")
38 |     every (!t).print(level+1);
39 |   end
40 | 
41 | initially
42 |   t := table()
43 |   L := [ ]
44 |   count := 0
45 | end
46 | 


--------------------------------------------------------------------------------
/ch13/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | import java.util.HashMap;
 3 | import java.util.ArrayList;
 4 | public class symtab {
 5 |    String scope;
 6 |    symtab parent;
 7 |    HashMap<String,symtab_entry> t;
 8 |    ArrayList<String> L;
 9 |    int count;
10 |    symtab(String sc) {
11 |       scope = sc;
12 |       t = new HashMap<String,symtab_entry>();
13 |       L = new ArrayList<String>();
14 |    }
15 |     symtab(String sc, symtab p) {
16 |       scope = sc; parent = p;
17 |       t = new HashMap<String,symtab_entry>();
18 |       L = new ArrayList<String>();
19 |    }
20 |    symtab_entry lookup(String s) {
21 |        symtab_entry rv;
22 |        rv = t.get(s);
23 |        if (rv != null) {
24 | 	   return rv;
25 |        }
26 |       if (parent != null) return parent.lookup(s);
27 |       return null;
28 |    }
29 |    void insert(String s, Boolean iC, symtab sub, typeinfo typ) {
30 |       if (t.containsKey(s)) {
31 |          j0.semErr("redeclaration of " + s);
32 |       } else {
33 |          if (sub != null)
34 |             sub.parent = this;
35 |          t.put(s, new symtab_entry(s, this, iC, sub, typ,
36 | 				   new address(scope,count)));
37 | 	 L.add(s);
38 | 	 int len = s.length();
39 | 	 while(len > 0) {
40 | 	     count += 8;
41 | 	     len -= 8;
42 | 	 }
43 |       }
44 |    }
45 |    address genlocal() {
46 |       String s = "__local
quot; + count;
47 |       insert(s, false, null, new typeinfo("int"));
48 |       return t.get(s).addr;
49 |    }
50 |    void insert(String s, Boolean iC) {
51 |       if (t.containsKey(s)) {
52 |          j0.semErr("redeclaration of " + s);
53 |       } else {
54 |          t.put(s, new symtab_entry(s, this, iC));
55 |       }
56 |    }
57 |    void print() { print(0); }
58 |    void print(int level) {
59 |       for(int i=0; i<level; i++)
60 |         System.out.print(" ");
61 |       System.out.println(scope + " - " + t.size() + " symbols");
62 |       for(symtab_entry se : t.values()) se.print(level+1);
63 |    }
64 | }
65 | 


--------------------------------------------------------------------------------
/ch13/symtab_entry.icn:
--------------------------------------------------------------------------------
 1 | class symtab_entry(sym,parent_st,st,isConst,typ,addr)
 2 |   method print(level:0)
 3 |     writes(repl(" ",level), sym)
 4 |     if \isconst then writes(" (const)")
 5 |     if \typ then writes(" ", typ.str())
 6 |     write()
 7 |     (\st).print(level+1);
 8 |   end
 9 | end
10 | 


--------------------------------------------------------------------------------
/ch13/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    typeinfo typ;
 7 |    address addr;
 8 |    void print(int level) {
 9 |       for(int i=0; i<level; i++) System.out.print(" ");
10 |       System.out.print(sym);
11 |       if (isConst) System.out.print(" (const)");
12 |       System.out.println("");
13 |       if (st != null) st.print(level+1);
14 |    }
15 |    symtab_entry(String s, symtab p, boolean iC) {
16 |        sym = s; parent_st = p; isConst = iC; }
17 |    symtab_entry(String s, symtab p, boolean iC,
18 | 		symtab t, typeinfo ti, address a) {
19 |       sym = s; parent_st = p; isConst = iC;
20 |       st = t; typ = ti; addr = a;
21 |  }
22 | }
23 | 


--------------------------------------------------------------------------------
/ch13/tac.icn:
--------------------------------------------------------------------------------
 1 | class tac(op, op1, op2, op3)
 2 |    method print()
 3 |       case op of {
 4 |       "proc": write(op || "\t" || op1.region || ",0,0")
 5 | 			     # || op2.str() || "," || op3.str());
 6 |       "end": write(op)
 7 |       ".code": write(op)
 8 |       ".global": write(op)
 9 |       ".string": write(op)
10 |       "LAB": writes("L",op1.offset,":")
11 |       "string": {
12 | 	  write("\t", op, "\t", op1)
13 | 	 }
14 |       default: {
15 | 	  writes("\t" || op)
16 | 	  if \op1 then {
17 |              writes("\t")
18 |              if string(op1) then {
19 |                 if ste := stringtab.lookup(op1) then writes("str:", ste.addr.offset)
20 |                 else writes(op1)
21 |                 }
22 |              else
23 | 	        writes(op1.str())
24 | 	     if \op2 then
25 | 	        writes("," || (string(op2)|op2.str()))
26 | 	     if \op3 then
27 | 	        writes("," || op3.str())
28 | 	     }
29 | 	  write()
30 | 	  }
31 |       }
32 |    end
33 | end
34 | 


--------------------------------------------------------------------------------
/ch13/tac.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class tac {
 3 |    String op;
 4 |    address op1, op2, op3;
 5 |    public void print() {
 6 |       switch (op) {
 7 |       case "proc":
 8 | 	  System.out.println(op + "\t" + op1.region + ",0,0");
 9 | 			     // + op2.str() + "," + op3.str());
10 | 	  break;
11 |       case "end":
12 | 	  System.out.println(op);
13 | 	  break;
14 |       default:
15 | 	  System.out.print("\t" + op + "\t");
16 | 	  if (op1 != null)
17 | 	     System.out.print(op1.str());
18 | 	  if (op2 != null)
19 | 	      System.out.print("," + op2.str());
20 | 	  if (op3 != null)
21 | 	      System.out.print("," + op3.str());
22 | 	  System.out.println("");
23 |       }
24 |    }
25 |    tac(String s) { op = s; }
26 |    tac(String s, address o) { op = s; op1 = o; }
27 |    tac(String s, address o1, address o2) {
28 |       op = s; op1 = o1; op2 = o2; }
29 |    tac(String s, address o1, address o2, address o3) {
30 |       op = s; op1 = o1; op2 = o2; op3 = o3; }
31 | }
32 | 


--------------------------------------------------------------------------------
/ch13/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval, typ, isPublic, isStatic)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | method type(stab)
21 |   if \typ then return typ
22 |   if cat === parser.IDENTIFIER then
23 |     if rv := stab.lookup(text) then return typ := rv.typ
24 |     else stop("line ", lineno ,": cannot check type of undeclared ", image(text))
25 | end
26 | initially
27 |    case cat of {
28 |      parser.INT:     typ := typeinfo("int")
29 |      parser.DOUBLE:  typ := typeinfo("double")
30 |      parser.BOOLEAN: typ := typeinfo("boolean")
31 |      parser.VOID:    typ := typeinfo("void")
32 |      parser.INTLIT: { ival := integer(text); typ:=typeinfo("int") }
33 |      parser.DOUBLELIT: { dval := real(text); typ:=typeinfo("double") }
34 |      parser.STRINGLIT: { sval := deEscape(text); typ:=classtype("String") }
35 |      parser.BOOLLIT: { typ := typeinfo("boolean") }
36 |      parser.NULLVAL: { typ := typeinfo("null") }
37 |      ord("="|"+"|"-"): { typ := typeinfo("n/a") }
38 |    }
39 | end
40 | 


--------------------------------------------------------------------------------
/ch13/token.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class token {
 3 |   public int id;
 4 |   public int cat;
 5 |   public String text;
 6 |   public int lineno;
 7 |   public typeinfo typ;
 8 |   public token(int c, String s, int l) {
 9 |     cat = c; text = s; lineno = l;
10 |     id = serial.getid();
11 |     switch (cat) {
12 |     case parser.INT: typ = new typeinfo("int"); break;
13 |     case parser.DOUBLE: typ = new typeinfo("double"); break;
14 |     case parser.BOOLEAN: typ = new typeinfo("boolean"); break;
15 |     case parser.VOID: typ = new typeinfo("void"); break;
16 |     case parser.INTLIT: typ = new typeinfo("int"); break;
17 |     case parser.DOUBLELIT: typ = new typeinfo("double"); break;
18 |     case parser.STRINGLIT: typ = new typeinfo("String"); break;
19 |     case parser.BOOLLIT: typ = new typeinfo("boolean"); break;
20 |     case parser.NULLVAL: typ = new typeinfo("null"); break;
21 |     case '=': case '+': case '-': typ = new typeinfo("n/a"); break;
22 |     }
23 |    }
24 | public typeinfo type(symtab stab) {
25 |   symtab_entry rv;
26 |   if (typ != null) return typ;
27 |   if (cat == parser.IDENTIFIER)
28 |       if ((rv = stab.lookup(text)) != null) return typ=rv.typ;
29 |   j0.semErr("cannot check the type of " + text);
30 |   return null;
31 | }
32 | }
33 | 


--------------------------------------------------------------------------------
/ch13/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab,
  2 | 	    typ,icode,addr,first,follow,onTrue,onFalse)
  3 |   method print(level:0)
  4 |     writes(repl(" ",level))
  5 |     if \tok then {
  6 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  7 |       }
  8 |     else {
  9 |        write(id, "   ", sym, " (", rule, "): ", nkids)
 10 |        every (!kids).print(level+1)
 11 |        }
 12 |   end
 13 |   method print_graph(fw)
 14 |     if type(filename) == "string" then {
 15 |       fw := open(filename,  "w") |
 16 |         stop("can't open ", image(filename), " for writing")
 17 |       write(fw, "digraph {")
 18 |       print_graph(fw)
 19 |       write(fw, "}")
 20 |       close(fw)
 21 |     }
 22 |     else if \tok then print_leaf(fw)
 23 |     else { 
 24 |       print_branch(fw)
 25 |       every i := 1 to nkids do
 26 |         if \kids[i] then {
 27 |           write(fw, "N",id," -> N",kids[i].id,";")
 28 |           kids[i].print_graph(fw)
 29 |         } else {
 30 |           write(fw, "N",id," -> N",id,"_",j,";")
 31 |           write(fw, "N", id, "_", j,
 32 |                     " [label=\"Empty rule\"];")
 33 |           j +:= 1
 34 |         }
 35 |     }
 36 |   end
 37 |   method print_leaf(pw)
 38 |     local s := parser.yyname[tok.cat]
 39 |     print_branch(pw)
 40 |     write(pw,"N",id,
 41 |           " [shape=box style=dotted label=\" ",s," \\n ")
 42 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 43 |              tok.lineno," \\l\"];\n")
 44 |   end
 45 |   method print_branch(pw)
 46 |     write(pw, "N",id," [shape=box label=\"",
 47 |           pretty_print_name(),"\"];\n");
 48 |   end
 49 |   method escape(s)
 50 |     if s[1] == "\"" then
 51 |       return "\\" || s[1:-1] || "\\\""
 52 |     else return s
 53 |   end
 54 |   method pretty_print_name()
 55 |     if /tok then return sym || "#" || (rule%10)
 56 |     else return escape(tok.text) || ":" || tok.cat
 57 |   end
 58 |   method mkSymTables(curr)
 59 |     stab := curr
 60 |     case sym of {
 61 |       "ClassDecl": { curr := symtab("class",curr) }
 62 |       "MethodDecl": { curr := symtab("method",curr) }
 63 |     }
 64 |     every (!\kids).mkSymTables(curr)
 65 |   end
 66 |   method populateSymTables()
 67 |   case sym of {
 68 |     "ClassDecl": {
 69 |        stab.insert(kids[1].tok.text, , kids[1].stab) # new classtype() ?
 70 |        }
 71 |     "FieldDecl" | "LocalVarDecl" : {
 72 |        k := kids[2]
 73 |        while \k & k.sym=="VarDecls" do {
 74 |          insert_vardeclarator(k.kids[2])
 75 |          k := k.kids[1]
 76 |          }
 77 |        insert_vardeclarator(k); return
 78 |        }
 79 |     "MethodDecl": {
 80 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab,
 81 | 	          kids[1].kids[2].typ)
 82 |       kids[1].stab.insert("return", , , kids[1].kids[1].typ)
 83 |       }
 84 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 85 |     }
 86 |     every (!\kids).populateSymTables()
 87 |   end
 88 |   method insert_vardeclarator(vd)
 89 |     if \vd.tok then stab.insert(vd.tok.text,&null,&null,vd.typ)
 90 |     else insert_vardeclarator(vd.kids[1])
 91 |   end
 92 |   method calc_isConst()
 93 |    every (!\kids).calc_isConst()
 94 |    case sym of {
 95 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 96 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 97 |       "UnaryExpr": isConst := \kid[2].isConst
 98 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 99 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
100 |       "MULEXPR"|
101 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
102 |       default: isConst := &null
103 |    }
104 |   end
105 |   # after symbol table population, we have enough information to fill in
106 |   # correct class type information.
107 |   method mkcls()
108 |     if sym == "ClassDecl" then {
109 |         rv := stab.lookup(kids[1].tok.text)
110 |         flds := []; methds := []; constrs := []
111 |         every k := key(rv.st.t) do
112 |            if match("method ", rv.st.t[k].typ.str()) then
113 |              put(methds, parameter(k, rv.st.t[k].typ))
114 |            else
115 |              put(flds, parameter(k, rv.st.t[k].typ))
116 |         (/(rv.typ) := classtype(kids[1].tok.text, rv.st, flds, methds, constrs))
117 |     }
118 |     else every k := !kids do
119 |       if k.nkids>0 then k.mkcls()
120 |   end
121 |   method checkSymTables()
122 |     check_codeblocks()
123 |   end
124 |   # this looks for undeclareds
125 |   method check_codeblocks()
126 |    if sym == "MethodDecl" then { kids[2].check_block() }
127 |    else every k := !kids do
128 |          if k.nkids>0 then k.check_codeblocks()
129 |   end
130 |   method check_block()
131 |    case sym of {
132 |    "IDENTIFIER": {
133 |      if not (stab.lookup(tok.text)) then
134 |         j0.semErr("undeclared variable "||tok.text)
135 |      }
136 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
137 |    "MethodCall": {
138 |       kids[1].check_block()
139 |       if rule = 1290 then
140 |          kids[2].check_block()
141 |       else kids[3].check_block()
142 |      }
143 |    "LocalVarDecl": { } # skip
144 |    default:  {
145 |       every k := !\kids do {
146 |             k.check_block()
147 |          }
148 |       }
149 |    }
150 |   end
151 |   # calctype - synthesize the type of a variable declaration
152 |   method calctype()
153 |     every (!\kids).calctype()
154 |     case sym of {
155 |       "FieldDecl": typ := kids[1].typ
156 |       "token": {
157 |          if typ := \ (tok.typ) then return
158 |          case tok.cat of {
159 |          parser.IDENTIFIER:{
160 |            if \ (rv := (\stab).lookup(tok.text)) then {
161 |               if typ := \ (rv.typ) then
162 |                  return typ
163 |               }
164 |            return typ := classtype(tok.text)
165 |            }
166 |          default:
167 |            j0.semErr("can't grok the type of " || image(tok.text) ||
168 | 		     " cat " || tok.cat)
169 |          }
170 |       }
171 |     default:
172 |        j0.semErr("don't know how to calctype " || image(sym))
173 |     }
174 |   end
175 | 
176 |    # check a call against a signature
177 |    method cksig(sig)
178 |    local i:=*sig.parameters, nactual := 1, t := kids[2]
179 |      if /t then {
180 |        if i ~= 0 then stop("0 parameters, expected ", i)
181 |        }
182 |      else {
183 |        while t.sym == "ArgList" do { nactual +:= 1; t:=t.kids[1] }
184 |        if nactual ~= i then
185 |          stop(nactual, " parameters, expected ", i)
186 |        t := kids[2]
187 |        while t.sym == "ArgList" do {
188 |          check_types(t.kids[-1].typ, sig.parameters[i])
189 |          t := t.kids[1]; i-:=1
190 |          }
191 |        check_types(t.typ, sig.parameters[1])
192 |      }
193 |      typ := sig.return_type
194 |    end
195 | 
196 |   # return a list of types corresponding to a syntax subtree parameter list
197 |   method mksig()
198 |      case sym of {
199 |         "FormalParm": return [kids[1].typ]
200 |         "FormalParmList": return kids[1].mksig() ||| kids[2].mksig()
201 |         }
202 |   end
203 | 
204 |   # assigntype - inherit a type, typically into a variable declaration list
205 |   method assigntype(t)
206 |   local parmList
207 |     typ := t
208 |     case sym of {
209 |     "VarDeclarator": { # we have an ARRAY of whatever type t was
210 |       kids[1].assigntype(arraytype(t))
211 |       return
212 |     }
213 |     "MethodDeclarator": { # pass a return type into a method
214 |        parmList := (\ (kids[2]).mksig()) | []
215 |        kids[1].typ := typ := methodtype(parmList , t)
216 |        return
217 |     }
218 |     "token": {
219 |       case tok.cat of {
220 |          parser.IDENTIFIER: return
221 |          default: stop("eh? ", image(tok.cat))
222 |       }
223 |     }
224 |     default:
225 |        stop("don't know how to assign the type of ", image(sym))
226 |     }
227 |     every (!\kids).assigntype(t)
228 |   end
229 | 
230 | method checkkids(in_codeblock)
231 |     case sym of {
232 |        # turn on in executable StmtBlock
233 |        "MethodDecl": { kids[2].checktype(1); return }
234 |        # turn off in LocalVarDecl list...(back on in initializers, if any)
235 |        "LocalVarDecl": { kids[2].checktype(); return }
236 |        "FieldAccess": { kids[1].checktype(in_codeblock);
237 |           return }
238 |        "QualifiedName": { # has to be a type you can . on
239 |            kids[1].checktype(in_codeblock);
240 |        }
241 |        "RelExpr": {
242 |            kids[1].checktype(in_codeblock);
243 |            kids[3].checktype(in_codeblock);
244 |        }
245 |        default: { every (!\kids).checktype(in_codeblock) }
246 |        }
247 | end
248 | 
249 |   # given a qualifiedname, return its type
250 |   method dequalify()
251 |   local rv, ste
252 |     if kids[1].sym == "QualifiedName" then
253 |       rv := kids[1].dequalify()
254 |     else if kids[1].sym=="token" &
255 |             kids[1].tok.cat=parser.IDENTIFIER then {
256 |       if not \ (rv := stab.lookup(kids[1].tok.text)) then
257 |          j0.semErr("unknown symbol " || kids[1].tok.text)
258 |       rv := rv.typ
259 |     }
260 |     else j0.semErr("can't dequalify " || sym)
261 |     if rv.basetype ~== "class" then
262 |       j0.semErr("can't dequalify " || rv.basetype)
263 |     if \ (ste := rv.st.lookup(kids[2].tok.text)) then
264 |       return ste.typ
265 |     else j0.semErr("couldn't lookup " || kids[2].tok.text ||
266 | 		   " in " || rv.str())
267 | end
268 | 
269 |   # checktype - check, and determine, the type of each expression
270 |   method checktype(in_codeblock)
271 |     if checkkids(in_codeblock) then return
272 |     if /in_codeblock then return
273 |     case sym of {
274 |     "Assignment": typ := check_types(kids[1].typ, kids[3].typ)
275 |     "AddExpr": typ := check_types(kids[1].typ, kids[2].typ)
276 |     "RelExpr": typ := check_types(kids[1].typ, kids[3].typ)
277 |     "ArgList"|"Block" | "BlockStmts": { typ := &null }
278 |     "MethodCall": {
279 |       if rule = 1290 then {
280 |         if kids[1].sym == "QualifiedName" then {
281 |           rv := kids[1].dequalify()
282 |           cksig(rv)
283 |           }
284 |         else {
285 |            if kids[1].sym ~== "token" then
286 |               stop("can't check type of Name ", kids[1].sym)
287 |            if (\ (kids[1].tok)).cat == parser.IDENTIFIER then {
288 |               write("checking the type of a call to ", kids[1].tok.text)
289 |               if ( \ (rv := stab.lookup(kids[1].tok.text))) then {
290 |                  rv := rv.typ
291 | #make sure it is actually a method
292 |                  if not match("method ", rv.str()) then
293 |                    stop("method expected, got ", rv.str())
294 |                  cksig(rv)
295 | 		}
296 |               }
297 |            else stop("can't check the type of token ", kids[1].tok.cat)
298 | }
299 |            }
300 |         else stop("Jzero does not handle complex calls")
301 |     }
302 |     "QualifiedName": {
303 |        # get my type by look up kid #2 within kid #1
304 |        if type(kids[1].typ) == "classtype__state" then {
305 |          typ := (kids[1].typ.st.lookup(kids[2].tok.text)).typ
306 |        } else if type(kids[1].typ) == "arraytype__state" &
307 |                  kids[2].tok.text=="length" then {
308 |          typ := typeinfo("int")
309 |        } else stop("illegal . operator on ",kids[1].typ.str())
310 |       }
311 |     "InstanceCreation": {
312 |       if not (rv := stab.lookup(kids[1].tok.text)) then
313 |         stop("unknown type ",kids[1].tok.text)
314 |       if not (typ := \ (rv.typ)) then
315 |         stop(kids[1].tok.text, " has unknown type")
316 |     }
317 |     "ArrayCreation": typ := arraytype(kids[1].typ)
318 |     "ArrayAccess": {
319 |        if match("array ", kids[1].typ.str()) then {
320 |           if kids[2].typ.str()=="int" then
321 |              typ := kids[1].typ.element_type
322 |           else stop("subscripting array with ",kids[2].typ.str())
323 |           }
324 |        else stop("illegal subscript on type ", kids[1].typ.str())
325 |        }
326 |     "ReturnStmt": {
327 |       # check the return type against the current function
328 |       if not (rt := ( \ (stab.lookup("return")).typ)) then
329 |          stop("stab did not find a returntype")
330 |       if \ (kids[1].typ) then
331 |           typ := check_types(rt, kids[1].typ)
332 |        else { # return; check that return type is void
333 |           if rt.str() ~== "void" then
334 |              stop("void return from non-void method")
335 |           typ := rt
336 |        }
337 |     }
338 |     "token": typ := tok.type(stab)
339 |     "IfThenStmt"|"WhileStmt": { # no checks for j0 statements
340 |     }
341 |     default: { stop("cannot check the type of: ", image(sym)) }
342 |     }
343 |   end
344 |    method get_op()
345 |       return case sym of {
346 |           "ReturnStmt" : "return"
347 |           "MethodCall" : "param"
348 |           "Assignment" : "="
349 |           "AddExpr": if rule=1320 then "+" else "-"
350 |           "RelExpr": {
351 |             if kids[2].sym === "token" then return kids[2].tok.text
352 |             }
353 |           default: fail
354 |       }
355 |    end
356 | 
357 |    method check_types(op1, op2)
358 |       operator := get_op()
359 |       tok := findatoken()
360 |       case operator of {
361 |          "param"|"return"|"="|"+"|"-" : {
362 |             if op1.str() === op2.str() ===
363 |                    ("int"|"double"|"String") then {
364 |                # write("typecheck ",operator," on a ", op1.str(),
365 |                #      " and a ", op2.str(), " -> OK")
366 |                return op1
367 |                }
368 |             else if (op1.basetype===op2.basetype==="array") & operator==="=" &
369 |                     check_types(op1.element_type,op2.element_type) then {
370 |                return op1
371 |                }
372 |             else if (op1.str() == op2.str()) & operator ==="=" then {
373 |                return op1
374 |                }
375 |             else {
376 |                writes(&errout, "line ", (\tok).tok.lineno, ": ")
377 |                j0.semErr("typecheck "||operator||" on a "||
378 | 		      op1.str()|| " and a "|| op2.str()|| " -> FAIL")
379 |               }
380 |             }
381 |          "<"|">": {
382 |             if op1.str() === op2.str() === ("int"|"double") then {
383 |                # write("typecheck ",operator," on a ", op1.str(),
384 |                #      " and a ", op2.str(), " -> OK")
385 |                return typeinfo("bool")
386 |                }
387 |             }
388 |          default: {
389 |             writes(&errout, "line ", (\tok).tok.lineno, ": ")
390 |             j0.semErr("don't know how to check " || image(operator))
391 |             }
392 |         }
393 |    end
394 |   method findatoken()
395 |     if sym==="token" then return self
396 |     return (!kids).findatoken()
397 |   end
398 | method genlabel()
399 |    return address("lab", serial.getid())
400 | end
401 | method genlocal()
402 |    return stab.genlocal()
403 | end
404 | method genfirst()
405 |   every (!\kids).genfirst()
406 |   case sym of {
407 |   "UnaryExpr": first := \kids[2].first | genlabel()
408 |   "AddExpr"|"MulExpr"|"RelExpr": {
409 |      first := (\ (kids[1|2].first)) | genlabel()
410 |      }
411 |   "Block"|"WhileStmt": {
412 |     first := \ (kids[1].first) | genlabel()
413 |   }
414 |   "BlockStmts": {
415 |     / (kids[2].first) := genlabel()
416 |     first := \ (kids[1|2].first) | genlabel()
417 |   }
418 |   # ...
419 |   default: first := (!\kids).first
420 |   }
421 | end
422 | method genfollow()
423 |    case sym of {
424 |    "MethodDecl": {
425 |      kids[2].follow := follow := genlabel()
426 |      }
427 |    "BlockStmts": {
428 |       kids[1].follow := kids[2].first
429 |       kids[2].follow := follow
430 |       }
431 |    "Block": {
432 |       kids[1].follow := follow
433 |       }
434 |    # ...
435 |    }
436 |    every (!\kids).genfollow()
437 | end
438 | 
439 | method gencode()
440 |   every (!\kids).gencode()
441 |   case sym of {
442 |     "ClassDecl": { genClassDecl() }
443 |     "AddExpr": { genAddExpr() }
444 |     "MulExpr": { genMulExpr() }
445 |     "RelExpr": { genRelExpr() }
446 |     "WhileStmt": { genWhileStmt() }
447 |     "IfThenStmt": { genIfThenStmt() }
448 |     "Assignment": { genAssignment() }
449 |     "MethodCall": { genMethodCall() }
450 |     "MethodDecl": { genMethodDecl() }
451 |     "QualifiedName": { genQualifiedName() }
452 |     # ...
453 |     "token":   { gentoken() }
454 |     default: {
455 |        icode := []
456 |        every icode |||:= (!\kids).icode
457 |        }
458 |    }
459 | end
460 | 
461 | method genClassDecl()
462 |   icode := []
463 |   # emit string constants
464 |   if *(stringtab.t)>0 then {
465 |     icode |||:= gen(".string")
466 |     every k := key(stringtab.t) do {
467 |       x := stringtab.lookup(k)
468 | if / (x.addr) then stop("null label in stringtab")
469 |       icode |||:= gen("LAB", x.addr)
470 |       icode |||:= gen("string", k)  # should k be addr(k) ?
471 |       }
472 |     }
473 | 
474 |     # emit the globals 
475 |     every k := key(global_st.t) do {
476 |       x := global_st.lookup(k)
477 | # if type is not a proc...or class or something
478 |       if /first_global then { icode |||:= gen(".global"); first_global := 1 }
479 |       icode |||:= gen("global", x.addr, k)
480 | #      icode |||:= gen("string", image(k))
481 |       }
482 |   icode |||:= gen(".code")
483 |   every icode |||:= (!kids).icode
484 | end
485 | 
486 | method genAssignment()
487 |   addr := kids[1].addr
488 |   icode := [ ]
489 |   every icode |||:= kids[1|3].icode
490 |   icode |||:= gen("ASN", addr, kids[3].addr)
491 | end
492 | 
493 | method genAddExpr()
494 |       addr := genlocal()
495 |       icode := kids[1].icode ||| kids[2].icode |||
496 |               gen(if rule=1320 then "ADD" else "SUB",
497 |                   addr, kids[1].addr, kids[2].addr)
498 | end
499 | 
500 | method genMulExpr()
501 |   addr := genlocal()
502 |   icode := [ ]
503 |   every icode |||:= (!kids).icode
504 |   if rule=1310 then
505 |     icode |||:= gen("MUL", addr, kids[1].addr, kids[2].addr)
506 |   else if rule=1311 then
507 |     icode |||:= gen("DIV", addr, kids[1].addr, kids[2].addr)
508 |   else
509 |     icode |||:= gen("MOD", addr, kids[1].addr, kids[2].addr)
510 | end
511 | 
512 | method genMethodDecl()
513 |    icode := [ ]
514 | 
515 |    methodname := kids[1].kids[2].kids[1].tok.text
516 |    # in TAC, units are words
517 |    nparams := 0
518 |    nlocals := 0
519 |    every k := key(global_st.t) do {
520 |       if k ~== "System" then {
521 |          e := global_st.t[k]
522 |          if \(m := e.st.t[methodname]) then {
523 |             nparams := *(m.typ.parameters)
524 |             nlocals := m.st.count/8
525 |             break
526 |          }
527 |       }
528 |    }
529 |    icode |||:= gen("proc", address(methodname, 0),
530 |                    address("imm",nparams), address("imm",nlocals))
531 |    every icode |||:= (!kids).icode
532 |    if /follow then stop("null lab in genMethodDecl")
533 |    icode |||:= gen("LAB", follow)
534 |    icode |||:= gen("RET")
535 |    icode |||:= gen("end")
536 | end
537 | 
538 | method gentoken()
539 |   icode := []
540 |   case tok.cat of {
541 |     parser.IDENTIFIER: {
542 |        addr := stab.lookup(tok.text).addr }
543 |     parser.INTLIT: { addr := address("imm", tok.ival) }
544 |     parser.STRINGLIT: {
545 |       stringtab.insert(tok.text, 1, &null, typeinfo("string"))
546 |       addr := stringtab.lookup(tok.text).addr
547 |       }
548 |     # ...
549 |     }
550 | end
551 | 
552 | method gentargets()
553 |    case sym of {
554 |    "IfThenStmt"|"WhileStmt": {
555 |       kids[1].onTrue := kids[2].first
556 |       kids[1].onFalse := follow
557 |       }
558 |    "CondAndExpr": {
559 |       kids[1].onTrue := kids[2].first
560 |       kids[1].onFalse := onFalse
561 |       kids[2].onTrue := onTrue
562 |       kids[2].onFalse := onFalse
563 |       }    
564 |    # ...
565 |    }
566 |    every (!\kids).gentargets()
567 | end
568 | 
569 | method genRelExpr()
570 |   op :=  case kids[2].tok.cat of {
571 |     ord("<"): "BLT"; ord(">"): "BGT";
572 |     parser.LESSTHANOREQUAL: "BLE"
573 |     parser.GREATERTHANOREQUAL: "BGT" }
574 |   icode := kids[1].icode ||| kids[3].icode |||
575 |             gen(op, onTrue, kids[1].addr, kids[3].addr) |||
576 |             gen("GOTO", onFalse)
577 | end
578 | 
579 | method genIfThenStmt()
580 | if / (kids[1].first) then stop("null first lab in ifthen")
581 | if / (kids[1].onTrue) then stop("null onTrue lab in ifthen")
582 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
583 |            gen("LAB", kids[1].onTrue) |||
584 |            kids[2].icode
585 | end
586 | 
587 | method genWhileStmt()
588 | if / (kids[1].first) then stop("null first lab in while")
589 | if / (kids[1].onTrue) then stop("null onTrue lab in while")
590 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
591 |            gen("LAB", kids[1].onTrue) |||
592 |            kids[2].icode ||| gen("GOTO", kids[1].first)
593 | end
594 | 
595 | #  class.member
596 | method genQualifiedName()
597 |    icode := [ ]
598 |    icode |||:= kids[1].icode
599 |    if match("method ",((\ typ).str())) then { # no icode, compile-time method resolution
600 |       addr := kids[1].typ.str() || "__" || kids[2].tok.text
601 |       }
602 |    else {
603 |       addr := genlocal()
604 |       if match("array ", (\ (kids[1].typ)).str()) then { # array.length
605 |          icode |||:= gen("ASIZE", addr, kids[1].addr)
606 |          }
607 |       else if \ (ste := (\ (kids[1].typ)).st.lookup(kids[2].tok.text)) then {
608 |          # lookup address within class
609 |          /(kids[2].addr) := ste.addr
610 |          icode |||:= gen("FIELD", addr, kids[1].addr, kids[2].addr)
611 |       }
612 |    }
613 | end
614 | 
615 | method genMethodCall()
616 |   local nparms := 0
617 |   if k := \ kids[2] then {
618 |     icode := k.icode
619 |     while k.sym === "ArgList" do {
620 |        icode |||:= gen("PARM", k.kids[2].addr)
621 |        k := k.kids[1]; nparms +:= 1
622 |        }
623 |     icode |||:= gen("PARM", k.addr); nparms +:= 1
624 |     }
625 |   else icode := [ ]
626 | 
627 |   # after all parameters, extra parameter for the object.
628 | 
629 |   if kids[1].sym === "QualifiedName" then {
630 |     # icode for a qualifiedname will be non-empty
631 |     icode |||:= kids[1].icode
632 |     # addr for a qualified name will be new temp var
633 |     icode |||:= gen("PARM", kids[1].kids[1].addr)
634 |     }
635 |   else {
636 |     icode |||:= gen("PARM", "self")
637 |     }
638 |   icode |||:= gen("CALL", kids[1].addr, nparms)
639 | end
640 | 
641 | 
642 | method gen(o, o1, o2, o3)
643 |    return [ tac(o, o1, o2, o3) ]
644 | end
645 | 
646 | initially (s,r,x[])
647 |    id := serial.getid(); sym := s; rule := r
648 |    if type(x[1]) == "token__state" then {
649 |       nkids := 0; tok := x[1]
650 |       typ := (\tok).typ
651 |    } else {
652 |       nkids := *x;
653 |       kids := x
654 |    }
655 | end
656 | 


--------------------------------------------------------------------------------
/ch13/tree.java:
--------------------------------------------------------------------------------
  1 | package ch13;
  2 | import java.util.ArrayList;
  3 | import java.io.PrintWriter;
  4 | import java.io.BufferedWriter;
  5 | import java.io.FileWriter;
  6 | class tree {
  7 |   int id, rule, nkids;
  8 |   String sym;
  9 |   token tok;
 10 |   tree kids[];
 11 |   Boolean isConst;
 12 |   symtab stab;
 13 |   typeinfo typ;
 14 |   ArrayList<tac> icode;
 15 |   address addr, first, follow, onTrue, onFalse;
 16 | 
 17 |   public String escape(String s) {
 18 |       if (s.charAt(0) == '\"')
 19 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 20 |       else return s;
 21 |   }
 22 | 
 23 |   public String pretty_print_name() {
 24 |     if (tok == null) return sym +"#"+(rule%10);
 25 |     else {
 26 | 	return escape(tok.text)+":"+tok.cat;
 27 | 	}
 28 |     }
 29 | 
 30 |   void print_graph(String filename){
 31 |     try {
 32 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 33 |       pw.printf("digraph {\n");
 34 |       j = 0;
 35 |       print_graph(pw);
 36 |       pw.printf("}\n");
 37 |       pw.close();
 38 |       }
 39 |     catch (java.io.IOException ioException) {
 40 |       System.err.println("printgraph exception");
 41 |       System.exit(1);
 42 |       }
 43 |     }
 44 | 
 45 |   int j;
 46 |   void print_graph(PrintWriter pw) {
 47 |   int i;
 48 |     if (tok != null) {
 49 | 	print_leaf(pw);
 50 |         return;
 51 |     }
 52 |     // from here on out, we know we are not a leaf
 53 |     print_branch(pw);
 54 |     
 55 |     for(i=0; i<nkids; i++) {
 56 |         if (kids[i] != null) {
 57 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 58 | 	    kids[i].print_graph(pw);
 59 |         } else {
 60 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 61 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 62 | 	    j++;
 63 |         }
 64 |     }
 65 |   }
 66 | 
 67 |   void print_leaf(PrintWriter pw) {
 68 |     String s = parser.yyname[tok.cat];
 69 |     print_branch(pw);
 70 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 71 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 72 | 	      escape(tok.text), tok.lineno);
 73 |   }
 74 | 
 75 |   void print_branch(PrintWriter pw) {
 76 |     pw.printf("N%d ",id);
 77 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 78 |     if (tok != null)
 79 | 	pw.printf("struct token* leaf %d", tok.id);
 80 |     pw.printf("\"];\n");
 81 |   }
 82 | 
 83 |   public void print(int level) {
 84 |     int i;
 85 |     for(i=0;i<level;i++) System.out.print(" ");
 86 |     if (tok != null) {
 87 |       System.out.println(id + "   " + tok.text +
 88 |                          " (" + tok.cat + "): "+tok.lineno);
 89 |     }
 90 |     else {
 91 |       System.out.println(id + "   " + sym +
 92 | 			 " (" + rule + "): "+nkids);
 93 |     }
 94 |     for(i=0; i<nkids; i++)
 95 |       kids[i].print(level+1);
 96 |   }
 97 |   public void print() {
 98 |     print(0);
 99 |   }
100 | 
101 |   void mkSymTables(symtab curr) {
102 |    stab = curr;
103 |    switch (sym) {
104 |    case "ClassDecl": curr = new symtab("class", curr); break;
105 |    case "MethodDecl": curr = new symtab("method", curr); break;
106 |    }
107 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
108 |   }
109 | 
110 |   void populateSymTables() {
111 |     switch(sym) {
112 |     case "ClassDecl":
113 | 	stab.insert(kids[0].tok.text, false, kids[0].stab, null);
114 | 	//		    new classtype(kids[0].tok.text, kids[0].stab));
115 |        break;
116 |     case "FieldDecl": case "LocalVarDecl":
117 |        tree k = kids[1];
118 |        while ((k != null) && k.sym.equals("VarDecls")) {
119 |          insert_vardeclarator(k.kids[1]);
120 |          k = k.kids[0];
121 |          }
122 |        insert_vardeclarator(k); return;
123 |     case "MethodDecl":
124 | 	String s = kids[0].kids[1].kids[0].tok.text;
125 | 	stab.insert(s, false, kids[0].stab, kids[0].kids[1].typ);
126 | 	kids[0].stab.insert("return", false, null, kids[0].kids[0].typ);
127 | 	break;
128 |     case "FormalParm":
129 |       insert_vardeclarator(kids[1]); return;
130 |     }
131 |     if (kids!=null)
132 | 	for(tree k : kids)
133 | 	   if (k!=null)
134 | 	      k.populateSymTables();
135 |   }
136 | 
137 |   void insert_vardeclarator(tree vd) {
138 |     if (vd.tok != null) {
139 |       stab.insert(vd.tok.text, false, null, vd.typ);
140 |       }
141 |     else insert_vardeclarator(vd.kids[0]);
142 |   }
143 | 
144 |   void calc_isConst() {
145 |    for(int i=0; i <nkids; i++)
146 |       kids[i].calc_isConst();
147 |    switch(sym) {
148 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
149 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
150 |    case "UnaryExpr": isConst = kids[1].isConst; break;
151 |    case "RelExpr":
152 |       isConst = kids[0].isConst && kids[2].isConst; break;
153 |    case "CondOrExpr": case "CondAndExpr":
154 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
155 |       isConst = kids[0].isConst && kids[1].isConst; break;
156 |    default: isConst = false;
157 |    }
158 |   }
159 | 
160 |   void mkcls() {
161 |     symtab_entry rv;
162 |     if (sym.equals("ClassDecl")) {
163 |       int ms=0, fs=0;
164 |       rv = stab.lookup(kids[0].tok.text);
165 |       for(String k : rv.st.t.keySet()) {
166 | 	  symtab_entry ste = rv.st.t.get(k);
167 | 	  if ((ste.typ.str()).startsWith("method ")) ms++;
168 | 	  else fs++;
169 |       }
170 |       parameter flds[] = new parameter[fs];
171 |       parameter methds[] = new parameter[ms];
172 |       fs=0; ms=0;
173 |       for(String k : rv.st.t.keySet()) {
174 | 	  symtab_entry ste = rv.st.t.get(k);
175 | 	  if ((ste.typ.str()).startsWith("method "))
176 | 	      methds[ms++] = new parameter(k, ste.typ);
177 | 	  else flds[fs++] = new parameter(k, ste.typ);
178 |       }
179 |       rv.typ = new classtype(kids[0].tok.text, rv.st,
180 | 			       flds, methds, new typeinfo[0]);
181 |     }
182 |     else for(int i = 0; i<nkids; i++)
183 |       if (kids[i].nkids>0) kids[i].mkcls();
184 |   }
185 | 
186 |   void checkSymTables() { check_codeblocks(); }
187 |   void check_codeblocks() {
188 |   tree k;
189 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
190 |    else {
191 |       for(int i = 0; i<nkids; i++){
192 |          k = kids[i];
193 |          if (k.nkids>0) k.check_codeblocks();
194 |       }
195 |    }
196 |   }
197 | void check_block() {
198 |    switch (sym) {
199 |    case "IDENTIFIER":
200 |      if (stab.lookup(tok.text) == null)
201 |         j0.semErr("undeclared variable " + tok.text);
202 |      break;
203 |    case "FieldAccess": case "QualifiedName":
204 |      kids[0].check_block();
205 |      break;
206 |   case "MethodCall":
207 |       kids[0].check_block();
208 |       if (rule == 1290)
209 |          kids[1].check_block();
210 |       else kids[2].check_block();
211 |       break;
212 |    case "LocalVarDecl": break;
213 |    default:
214 |       for(int i=0;i<nkids;i++)
215 |          kids[i].check_block();
216 |    }
217 |   }
218 | 
219 |   void calctype() {
220 |     for(int i=0; i<nkids; i++) kids[i].calctype();
221 |     switch (sym) {
222 |     case "FieldDecl": typ = kids[0].typ; return;
223 |     case "token":
224 | 	if ((typ = tok.typ) != null) return;
225 | 	switch (tok.cat) {
226 | 	case parser.IDENTIFIER:
227 | 	    if (stab != null) {
228 | 		symtab_entry rv = stab.lookup(tok.text);
229 | 		if (rv != null)
230 | 		    if ((typ = rv.typ) != null) return;
231 | 	    }
232 | 	    typ = new classtype(tok.text);
233 | 	    return;
234 | 	default:
235 | 	  j0.semErr("can't grok the type of " + tok.text + " cat " + tok.cat);
236 | 	}
237 | 	break;
238 |     default: j0.semErr("don't know how to calctype " + sym);
239 |     }
240 |   }
241 | 
242 |   void cksig(methodtype sig) {
243 |     int i = sig.parameters.length, nactual = 1;
244 |     tree t = kids[1];
245 |       if (t == null) {
246 |         if (i != 0) j0.semErr("0 params, expected " + i);
247 |       }
248 |       else {
249 |         while (t.sym.equals("ArgList")) { nactual++; t=t.kids[0]; }
250 | 	if (nactual != i)
251 | 	    j0.semErr(nactual + " parameters, expected "+ i);
252 | 	t = kids[1];
253 | 	i--;
254 | 	while (t.sym.equals("ArgList")) {
255 | 	    check_types(t.kids[1].typ, sig.parameters[i]);
256 | 	    t = t.kids[0];
257 | 	    i--;
258 | 	}
259 | 	check_types(t.typ, sig.parameters[0]);
260 |       }
261 |       typ = sig.return_type;
262 |     }
263 | 
264 |   typeinfo [] mksig() {
265 |   switch (sym) {
266 |     case "FormalParm": return new typeinfo[]{kids[0].typ};
267 |     case "FormalParmList":
268 |       typeinfo ta1[] = kids[0].mksig();
269 |       typeinfo ta2[] = kids[1].mksig();
270 |       typeinfo ta[] = new typeinfo[ta1.length + ta2.length];
271 |       for(int i=0; i<ta1.length; i++) ta[i]=ta1[i];
272 |       for(int j=0; j<ta2.length; j++)
273 | 	ta[ta1.length+j]=ta1[j];
274 |       return ta;
275 |       }
276 |     return null;
277 |   }
278 | 
279 |   void assigntype(typeinfo t) {
280 |     typ = t;
281 |     switch (sym) {
282 |     case "VarDeclarator":
283 |       kids[0].assigntype(new arraytype(t));
284 |       return;
285 |     case "MethodDeclarator": // pass a return type into a method
286 | 	typeinfo parmList[];
287 | 	if (kids[1] != null) parmList = kids[1].mksig();
288 | 	else parmList = new typeinfo [0];
289 | 	kids[0].typ = typ = new methodtype(parmList , t);
290 | 	return;
291 |     case "token":
292 |       switch (tok.cat) {
293 |         case parser.IDENTIFIER: return;
294 |         default: j0.semErr("eh? " + tok.cat);
295 |       }
296 |       break;
297 |       default: j0.semErr("don't know how to assigntype " + sym);
298 |     }
299 |     if(kids!=null) for(tree k : kids) k.assigntype(t);
300 |   }
301 | 
302 |   public boolean checkkids(boolean in_codeblock) {
303 |     switch (sym) {
304 |     case "MethodDecl": { kids[1].checktype(true); return true; }
305 |     case "LocalVarDecl": { kids[1].checktype(false); return true; }
306 |     case "FieldAccess": { kids[0].checktype(in_codeblock);
307 |                           return true; }
308 |     case "QualifiedName":
309 |        kids[0].checktype(in_codeblock); break;
310 |     default: if (kids != null) for (tree k : kids)
311 | 	       k.checktype(in_codeblock);
312 |     }
313 |     return false;
314 |   }
315 |     
316 |   public typeinfo dequalify() {
317 |       typeinfo rv = null;
318 |       symtab_entry ste;
319 |       if (kids[0].sym.equals("QualifiedName"))
320 | 	  rv = kids[0].dequalify();
321 |       else if (kids[0].sym.equals("token") &
322 | 	       (kids[0].tok.cat==parser.IDENTIFIER)) {
323 | 	  if ((ste = stab.lookup(kids[0].tok.text)) == null)
324 | 	      j0.semErr("unknown symbol " + kids[0].tok.text);
325 | 	  rv = ste.typ;
326 |       }
327 |       else j0.semErr("can't dequalify " + sym);
328 |       if (!rv.basetype.equals("class"))
329 | 	  j0.semErr("can't dequalify " + rv.basetype);
330 |       ste = ((classtype)rv).st.lookup(kids[1].tok.text);
331 |       if (ste != null) return ste.typ;
332 |       j0.semErr("couldn't lookup " + kids[1].tok.text +
333 | 		  " in " + rv.str());
334 |       return null;
335 |   }
336 | 
337 |   void checktype(boolean in_codeblock) {
338 |     if (checkkids(in_codeblock)) return;
339 |     if (! in_codeblock) return;
340 |     switch (sym) {
341 |     case "Assignment": typ = check_types(kids[0].typ, kids[2].typ); break;
342 |     case "AddExpr": typ = check_types(kids[0].typ, kids[1].typ); break;
343 |     case "RelExpr": typ = check_types(kids[0].typ, kids[2].typ); break;
344 |     case "ArgList": case "Block": case "BlockStmts": typ = null; break;
345 |     case "MethodCall":
346 |       if (rule == 1290) {
347 |         symtab_entry rve;
348 |         methodtype rv;
349 |         if (kids[0].sym.equals("QualifiedName")) {
350 |           rv = (methodtype)(kids[0].dequalify());
351 |           cksig(rv);
352 |           }
353 |         else {
354 |           if (!kids[0].sym.equals("token"))
355 |             j0.semErr("can't check type of " + kids[0].sym);
356 |           if (kids[0].tok.cat == parser.IDENTIFIER) {
357 | 	      // System.out.println("checking the type of a call to " +
358 | 	      //                    kids[0].tok.text);
359 |             if ((rve = stab.lookup(kids[0].tok.text)) != null) {
360 |   	    if (! (rve.typ instanceof methodtype))
361 |               j0.semErr("method expected, got " + rve.typ.str());
362 | 	    rv = (methodtype)rve.typ;
363 |             cksig(rv);
364 |             }
365 |           }
366 |           else j0.semErr("can't typecheck token " + kids[0].tok.cat);
367 |           }
368 |         }
369 |       else j0.semErr("Jzero does not handle complex calls");
370 |       break;
371 |     case "QualifiedName":
372 | 	if (kids[0].typ instanceof classtype) {
373 | 	  classtype ct = (classtype)(kids[0].typ);
374 |           typ = (ct.st.lookup(kids[1].tok.text)).typ;
375 | 	  }
376 |         else if (kids[0].typ instanceof arraytype) {
377 |           typ = new typeinfo("int");
378 |           }
379 |         else j0.semErr("illegal . on  " + kids[0].typ.str());
380 | 	break;
381 |     case "InstanceCreation": {
382 |       symtab_entry rv;
383 |       if ((rv = stab.lookup(kids[0].tok.text))==null)
384 |         j0.semErr("unknown type " + kids[0].tok.text);
385 |       if ((typ = rv.typ) == null)
386 |         j0.semErr(kids[0].tok.text + " has unknown type");
387 |       break;
388 |     }
389 |     case "ArrayCreation":
390 | 	typ = new arraytype(kids[0].typ); break;
391 |     case "ArrayAccess":
392 | 	if (kids[0].typ.str().startsWith("array ")) {
393 | 	    if (kids[1].typ.str().equals("int"))
394 | 		typ = ((arraytype)(kids[0].typ)).element_type;
395 | 	    else j0.semErr("subscripting array with "+kids[1].typ.str());
396 |           }
397 | 	else j0.semErr("illegal subscript on type "+ kids[0].typ.str());
398 | 	break;
399 |     case "ReturnStmt":
400 |       symtab_entry ste;
401 |       if ((ste=stab.lookup("return")) == null)
402 |          j0.semErr("stab did not find a returntype");
403 |       typeinfo rt = ste.typ;
404 |       if (kids[0].typ != null)
405 |           typ = check_types(rt, kids[0].typ);
406 |       else { // return; check that return type is void
407 |           if (!rt.str().equals("void"))
408 | 	      j0.semErr("void return from non-void method");
409 | 	  typ = rt;		    
410 |           }
411 |       break;
412 |     case "token": typ = tok.type(stab); break;
413 |     case "IfThenStmt": case "WhileStmt": { // no checks for j0 statements
414 |     }
415 |     default: j0.semErr("cannot check type of " + sym);
416 |     }
417 |   }
418 | 
419 |    public String get_op() {
420 |      switch (sym) {
421 |      case "ReturnStmt" : return "return";
422 |      case "MethodCall" : return "param";
423 |      case "Assignment" : return "=";
424 |      case "AddExpr": if (rule==1320) return "+"; else return "-";
425 |      case "RelExpr": {
426 |         if (kids[1].sym.equals("token")) return kids[1].tok.text;
427 |         }
428 |      default: return null;
429 |      }
430 |    }
431 | 
432 |    public typeinfo check_types(typeinfo op1, typeinfo op2) {
433 |      String operator = get_op();
434 |      switch (operator) {
435 |      case "param": case "return": case "=": case "+": case"-": {
436 |        tree tk;
437 |        //       if ((tk = findatoken())!=null)
438 |        //         System.out.print("line " + tk.tok.lineno + ": ");
439 |        if (op1.str().equals(op2.str()) &&
440 | 	   (op1.str().equals("int") ||
441 | 	    op1.str().equals("double") ||
442 | 	    op1.str().equals("String"))) {
443 | 	   //  System.out.println("typecheck "+operator+" on a "+ op1.str()+
444 | 	   //		    " and a "+ op2.str()+ " -> OK");
445 | 	 return op1;
446 | 	 }
447 |        else if (op1.basetype.equals("array") &&
448 |                 op2.basetype.equals("array") &&
449 |                 operator.equals("=") &&
450 |                 (check_types(((arraytype)op1).element_type,
451 | 			     ((arraytype)op2).element_type) != null)) {
452 |                 return op1;
453 |                }
454 |        else if (op1.str().equals(op2.str()) & operator.equals("=")) {
455 | 	  return op1;
456 |                }
457 |        else j0.semErr("typecheck "+operator+" on a "+ op2.str()+
458 | 			" and a "+ op1.str()+ " -> FAIL");
459 |        break;
460 |        }
461 |        case "<": case ">": {
462 | 	   if (op1.str().equals(op2.str()) &&
463 | 	       (op1.str().equals("int") ||
464 | 		op1.str().equals("double"))) {
465 | 		    // write("typecheck ",operator," on a ", op1.str(),
466 | 		    //     " and a ", op2.str(), " -> OK")
467 | 		    return new typeinfo("bool");
468 |                }
469 |         }
470 |      default: j0.semErr("don't know how to check " + operator);
471 |      }
472 |    return null;
473 |    }
474 |    public tree findatoken() {
475 |      tree rv;
476 |      if (sym=="token") return this;
477 |      if (kids != null)
478 |      for (tree t : kids) if ((rv=t.findatoken()) != null) return rv;
479 |      return null;
480 |    }
481 |   address genlabel() {
482 |     return new address("lab", serial.getid());
483 |   }
484 |   address genlocal() {
485 | 	return stab.genlocal();
486 |   }
487 | void genfirst() {
488 |   if (kids != null) for(tree k : kids) k.genfirst();
489 |   switch (sym) {
490 |   case "UnaryExpr": {
491 |       if (kids[1].first != null) first = kids[1].first;
492 |       else first = genlabel();
493 |       break;
494 |   }
495 |   case "AddExpr": case "MulExpr": case "RelExpr": {
496 |       if (kids[0].first != null) first = kids[0].first;
497 |       else if (kids[1].first != null) first = kids[1].first;
498 |       else first = genlabel();
499 |       break;
500 |       }
501 |   case "Block": case "WhileStmt": {
502 |       if (kids[0].first != null) first = kids[0].first;
503 |       else first = genlabel();
504 |       break;
505 |       }
506 |   case "BlockStmts": {
507 |     if (kids[1].first == null) kids[1].first = genlabel();
508 |     if (kids[0].first != null) first = kids[0].first;
509 |     else first = kids[1].first;
510 |     break;
511 |   }
512 |     // ...
513 |   default: {
514 |       if (kids != null)
515 | 	  for(tree k : kids)
516 | 	      if (k.first != null) { first = k.first; break; }
517 |       }
518 |    }
519 | }
520 | 
521 | void genfollow() {
522 |   switch (sym) {
523 |    case "MethodDecl": {
524 |      kids[1].follow = follow = genlabel();
525 |      break;
526 |      }
527 |    case "BlockStmts": {
528 |       kids[0].follow = kids[1].first;
529 |       kids[1].follow = follow;
530 |       break;
531 |       }
532 |    case "Block": {
533 |       kids[0].follow = follow;
534 |       break;
535 |       }
536 |    // ...
537 |    }
538 |   if (kids != null) for(tree k : kids) k.genfollow();
539 | }
540 | 
541 | void gencode() {
542 |   if (kids != null) for(tree k : kids) k.gencode();
543 |   switch (sym) {
544 |   case "ClassDecl": { genClassDecl(); break; }
545 |   case "AddExpr": { genAddExpr(); break; }
546 |   case "MulExpr": { genMulExpr(); break; }
547 |   case "RelExpr": { genRelExpr(); break; }
548 |   case "WhileStmt": { genWhileStmt(); break; }
549 |   case "IfThenStmt": { genIfThenStmt(); break; }
550 |   case "Assignment": { genAssignment(); break; }
551 |   case "MethodCall": { genMethodCall(); break; }
552 |   case "MethodDecl": { genMethodDecl(); break; }
553 |   case "QualifiedName": { genQualifiedName(); break; }
554 |   // ...
555 |   case "token": { gentoken(); break; }
556 |   default: {
557 |     icode = new ArrayList<tac>();
558 |     if (kids != null) for(tree k : kids) icode.addAll(k.icode);
559 |     }
560 |   }
561 | }
562 | 
563 | void genClassDecl() {
564 |   int first_global;
565 |   first_global = 0;
566 |   icode = new ArrayList<tac>();
567 |   // emit string constants
568 |   if (j0.stringtab.t.size()>0) {
569 |      icode.addAll( gen(".string") );
570 |      for(String k : j0.stringtab.t.keySet()) {
571 | 	 symtab_entry ste = j0.stringtab.t.get(k);
572 | 	 if (ste.addr == null) {
573 | 	     System.err.println("null label in stringtab");
574 | 	     System.exit(1);
575 | 	 }
576 |          icode.addAll( gen("LAB", ste.addr));
577 |          icode.addAll( gen("string", new address(k, 0)) );
578 |         }
579 |       }
580 | 
581 |   // emit the globals 
582 |   for(String k : j0.global_st.t.keySet()) {
583 |       symtab_entry ste = j0.global_st.t.get(k);
584 |       // if type is not a proc...or class or something
585 |       if (first_global == 0) {
586 | 	  icode.addAll( gen(".global") ); first_global = 1; }
587 |           icode.addAll( gen("global", ste.addr, new address(k,0)) );
588 |         }
589 |   icode.addAll( gen(".code") );
590 |   if (kids != null) for(tree k: kids) icode.addAll(k.icode);
591 | }
592 | 
593 | void genAssignment() {
594 |   addr = kids[0].addr;
595 |   icode = new ArrayList<tac>();
596 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
597 |   icode.addAll(gen("ASN", addr, kids[2].addr));
598 | }
599 | 
600 | void genAddExpr() {
601 |   addr = genlocal();
602 |   icode = new ArrayList<tac>();
603 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
604 |   icode.addAll(gen(((rule==1320)?"ADD":"SUB"), addr,
605 |                    kids[0].addr, kids[1].addr));
606 | }
607 | 
608 | void genMulExpr() {
609 |   addr = genlocal();
610 |   icode = new ArrayList<tac>();
611 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
612 |   if (rule==1310)
613 |     icode.addAll(gen("MUL", addr, kids[0].addr, kids[1].addr));
614 |   else if (rule==1311)
615 |     icode.addAll(gen("DIV", addr, kids[0].addr, kids[1].addr));
616 |   else
617 |     icode.addAll(gen("MOD", addr, kids[0].addr, kids[1].addr));
618 | }
619 | 
620 | void genMethodDecl() {
621 |     icode = new ArrayList<tac>();
622 |     String methodname = kids[0].kids[1].kids[0].tok.text;
623 |     int nparams = 0;
624 |     int nlocals = 0;
625 |     symtab_entry m = j0.global_st.lookup("hello").st.t.get(methodname);
626 |     if (m == null) System.err.println("null m");
627 |     nparams = ((methodtype)(m.typ)).parameters.length;
628 |     nlocals = m.st.count/8;
629 |     icode.addAll(gen("proc", new address(methodname, 0), new address("imm", nparams), new address("imm", nlocals)));
630 |     for(tree k : kids) icode.addAll(k.icode);
631 |     icode.addAll(gen("LAB", follow));
632 |     icode.addAll(gen("RET"));
633 |     icode.addAll(gen("end"));
634 | }
635 | 
636 | void gentoken() {
637 |   icode = new ArrayList<tac>();
638 |   switch (tok.cat) {
639 |     case parser.IDENTIFIER: {
640 |       symtab_entry ste;
641 |       ste = stab.lookup(tok.text);
642 |       if (ste == null) {
643 |       }
644 |       else {
645 | 	  addr = ste.addr;
646 |       }
647 |       break;
648 |       }
649 |     case parser.INTLIT: {
650 |       addr = new address("imm", Integer.parseInt(tok.text)); break;
651 |     }
652 |     case parser.STRINGLIT: {
653 |       j0.stringtab.insert(tok.text, true, null, new typeinfo("string"));
654 |       addr = j0.stringtab.lookup(tok.text).addr;
655 |       break;
656 |     }
657 |     // ...
658 |     }
659 | }
660 | 
661 | void gentargets() {
662 |    switch (sym) {
663 |    case "IfThenStmt": {
664 |       kids[0].onTrue = kids[1].first;
665 |       kids[0].onFalse = follow;
666 |       }
667 |    case "CondAndExpr": {
668 |       kids[0].onTrue = kids[1].first;
669 |       kids[0].onFalse = onFalse;
670 |       kids[1].onTrue = onTrue;
671 |       kids[1].onFalse = onFalse;
672 |       }    
673 |    // ...
674 |    }
675 |    if (kids!=null) for (tree k:kids) k.gentargets();
676 | }
677 | 
678 | void genRelExpr() {
679 |   String op = "ERROR";
680 |   switch (kids[1].tok.cat) {
681 |     case '<': op="BLT"; break; case ';': op="BGT"; break;
682 |     case parser.LESSTHANOREQUAL: op="BLE"; break;
683 |     case parser.GREATERTHANOREQUAL: op="BGT";
684 |     }
685 |   icode = new ArrayList<tac>();
686 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
687 |   icode.addAll(gen(op, onTrue, kids[0].addr, kids[2].addr));
688 |   icode.addAll(gen("GOTO", onFalse));
689 | }
690 | 
691 | void genIfThenStmt() {
692 |   icode = new ArrayList<tac>();
693 |   icode.addAll(kids[0].icode);
694 |   icode.addAll(gen("LAB", kids[0].onTrue));
695 |   icode.addAll(kids[1].icode);
696 | }
697 | 
698 | void genWhileStmt() {
699 |   icode = new ArrayList<tac>();
700 |   icode.addAll(gen("LAB", kids[0].first));
701 |   icode.addAll(kids[0].icode);
702 |   icode.addAll(gen("LAB", kids[0].onTrue));
703 |   icode.addAll(kids[1].icode);
704 |   icode.addAll(gen("GOTO", kids[0].first));
705 | }
706 | 
707 | void genQualifiedName() {
708 |   symtab_entry ste;
709 |   classtype ct;
710 | 
711 |   icode = new ArrayList<tac>();
712 |   icode.addAll( kids[0].icode );
713 |   if (typ != null && typ instanceof methodtype) {// no icode, compile-time method resolution
714 |       addr = new address(kids[0].typ.str() + "__" + kids[1].tok.text, 0);
715 |       }
716 |    else {
717 |       addr = genlocal();
718 |       if (kids[0].typ instanceof arraytype) { // array.length
719 | 	  icode.addAll( gen("ASIZE", addr, kids[0].addr) );
720 |       }
721 |       else if ((kids[0].typ != null) && (kids[0].typ instanceof classtype) &&
722 | 	       ((ct = (classtype)(kids[0].typ)) != null) &&
723 | 	       ((ste=ct.st.lookup(kids[1].tok.text)) != null)) {
724 | 	  // lookup address within class
725 | 	  if (kids[1].addr == null) kids[1].addr = ste.addr;
726 | 	  icode.addAll( gen("FIELD", addr, kids[0].addr, kids[1].addr));
727 |       }
728 |    }
729 | }
730 | 
731 | void genMethodCall() {
732 |   int nparms = 0;
733 |   if (kids[1] != null) {
734 |     tree k = kids[1];
735 |     icode = k.icode;
736 |     while (k.sym.equals("ArgList")) {
737 |       icode.addAll(gen("PARM", k.kids[1].addr));
738 |       k = k.kids[0]; nparms++;
739 |       }
740 |     icode.addAll(gen("PARM", k.addr)); nparms++;
741 |     }
742 |   else
743 |     icode = new ArrayList<tac>();
744 |   if (kids[0].sym.equals("QualifiedName")) {
745 |     icode.addAll(kids[0].icode);
746 |     icode.addAll(gen("PARM", kids[0].kids[0].addr));
747 |   }
748 |   else icode.addAll(gen("PARM", new address("self",0)));
749 |   icode.addAll(gen("CALL", kids[0].addr, new address("imm",nparms)));
750 | }
751 | 
752 | 
753 | ArrayList<tac> gen(String o, address ... a) {
754 |   ArrayList<tac> L = new ArrayList<tac>();
755 |   tac t = null;
756 |   switch(a.length) {
757 |     case 3: t = new tac(o, a[0], a[1], a[2]); break;
758 |     case 2: t = new tac(o, a[0], a[1]); break;
759 |     case 1: t = new tac(o, a[0]); break;
760 |     case 0: t = new tac(o); break;
761 |     default: j0.semErr("gen(): wrong # of arguments");
762 |   }
763 |   L.add(t);
764 |   return L;
765 | }
766 | 
767 |    public tree(String s, int r, token t) {
768 | 	id = serial.getid();
769 |         sym = s; rule = r; tok = t; if (tok!=null) typ = tok.typ; }
770 | 
771 |     public tree(String s, int r, tree[] t) {
772 | 	id = serial.getid();
773 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
774 | 	sym = s; rule = r; nkids = t.length;
775 | 	kids = t;
776 |     }
777 | }
778 | 


--------------------------------------------------------------------------------
/ch13/typeinfo.icn:
--------------------------------------------------------------------------------
 1 | class typeinfo(basetype)
 2 |    method str()
 3 |       return string(basetype)|"unknown"
 4 |    end
 5 | end
 6 | class arraytype : typeinfo(element_type)
 7 |    method str()
 8 |       return "array of " || (\element_type).str()
 9 |    end
10 | initially
11 |    basetype := "array"
12 | end
13 | class methodtype : typeinfo(parameters,return_type)
14 |    method str()
15 |       s := "method " || ((\return_type).str()|"undef") || "("
16 |       every s ||:= (!parameters).str() do s ||:= ","
17 |       s[-1] := ")"
18 |       return s
19 |    end
20 | initially
21 |    basetype := "method"
22 |    /parameters := []
23 |    /return_type := typeinfo("void")
24 | end
25 | class classtype : typeinfo(name, st, fields, methods, constrs)
26 |    method str()
27 |       return name
28 |    end
29 | initially
30 |    basetype := "class"
31 |    /st := symtab("class",global_st)
32 |    /fields := []
33 |    /methods := []
34 |    /constrs := []
35 | end
36 | class parameter(name, element_type)
37 | end
38 | 


--------------------------------------------------------------------------------
/ch13/typeinfo.java:
--------------------------------------------------------------------------------
1 | package ch13;
2 | public class typeinfo {
3 |    String basetype;
4 |    public typeinfo() { basetype = "unknown"; }
5 |    public typeinfo(String s) { basetype = s; }
6 |    public String str() { return basetype; }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch13/x64.icn:
--------------------------------------------------------------------------------
 1 | class x64(op, opnd1, opnd2)
 2 |   method print(f:&output)
 3 |   if op === "lab" then {
 4 |     write(f,(\opnd1).str(), ":")
 5 |     }
 6 |   else {
 7 |     writes(f,"\t",op, " ")
 8 |     writes(f," ",(\opnd1).str())
 9 |     writes(f,",",(\opnd2).str())
10 |     write(f)
11 |   }
12 |   end
13 | initially(o, o1, o2)
14 |    op := o; opnd1 := o1; opnd2 := o2
15 | end
16 | 


--------------------------------------------------------------------------------
/ch13/x64.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | import java.io.PrintStream;
 3 | public class x64 {
 4 |    String op;
 5 |    x64loc opnd1, opnd2;
 6 |    public x64(String o, Object src, Object dst) {
 7 |       op=o;
 8 |       if (src instanceof x64loc) opnd1 = (x64loc)src;
 9 |       else opnd1 = j0.loc(src);
10 |       if (dst instanceof x64loc) opnd2 = (x64loc)dst;
11 |       else opnd2 = j0.loc(dst);
12 |    }
13 |    public x64(String o, Object opnd) {
14 |       op=o;
15 |       if (opnd instanceof x64loc) opnd1 = (x64loc)opnd;
16 |       else opnd1 = j0.loc(opnd);
17 |    }
18 |    public x64(String o) {
19 |        op=o;
20 |    }
21 |    public void print(PrintStream f) {
22 |        if (op.equals("lab")) {
23 | 	   if (opnd1 != null)
24 | 	       f.println(opnd1.str() + ":");
25 |        }
26 |        else {
27 | 	   f.print("\t" + op);
28 | 	   if (opnd1 != null)
29 | 	       f.print(" " +opnd1.str());
30 | 	   if (opnd2 != null)
31 | 	       f.print("," +opnd2.str());
32 | 	   f.println();
33 |        }
34 |    }
35 |     public void print() { print(System.out); }
36 | }
37 | 


--------------------------------------------------------------------------------
/ch13/x64loc.icn:
--------------------------------------------------------------------------------
 1 | # modes: 1=as-is, 2=int, 3=?, 4=?, 5=?, 6=label
 2 | class x64loc(reg, offset, mode)
 3 |    method str()
 4 |     rv := ""
 5 |     case mode of {
 6 |       1: return reg
 7 |       2: return string(offset)
 8 |     3|4: return offset||"("||reg||")"
 9 |       5: return "
quot; || string(offset)
10 |       6: return if integer(offset) then ".L"||offset else offset
11 |       default: runerr(101, mode)
12 |     }
13 |    end
14 | initially(x,y,z)
15 |    if \z then { reg := x; offset := y; mode := z }
16 |    else if \y then {
17 |       if x === "imm" then { offset := y; mode := 5 }
18 |       else if x === "lab" then { offset := y; mode := 6 }
19 |       else {
20 |          reg := x; offset := y
21 |          if integer(y) then mode := 3 else mode := 4
22 |          }
23 |       }
24 |    else {
25 |       if integer(x) then { offset := x; mode := 2 }
26 |       else if string(x) then { reg := x; mode := 1 }
27 |       else stop("bad x64loc ", image(x))
28 |    }
29 | end
30 | 


--------------------------------------------------------------------------------
/ch13/x64loc.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | import java.io.PrintStream;
 3 | public class x64loc {
 4 |   public String reg;
 5 |   Object offset;
 6 |   public int mode;
 7 |     public String str() {
 8 | 	String rv = "";
 9 | 	switch (mode) {
10 | 	case 1: return reg;
11 | 	case 2: return String.valueOf(offset);
12 | 	case 3: case 4: {
13 | 	    if (reg.equals("lab")) return (String)offset;
14 | 	    return offset + "(" + reg + ")";
15 | 	}
16 | 	case 5: return "
quot; + String.valueOf(offset);
17 | 	case 6: return (offset instanceof Integer)? (".L"+offset) : (String)offset;
18 | 	default: System.err.println("x64loc unknown mode " + mode);
19 |     }
20 | 	return "unknown";
21 |     }
22 | 
23 |   public x64loc(String r) { reg = r; mode = 1; }
24 |   public x64loc(int i) { offset=(Object)Integer.valueOf(i); mode=2; }
25 |   public x64loc(String r, int off) {
26 |     if (r.equals("imm")) {
27 |       offset=(Object)Integer.valueOf(off); mode = 5; }
28 |     else if (r.equals("lab")) {
29 |       offset=(Object)Integer.valueOf(off); mode = 6; }
30 |     else { reg = r; offset = (Object)Integer.valueOf(off); mode = 3; }
31 |   }
32 |   public x64loc(String r, String s) {
33 |     reg = r; offset = (Object)s; mode=4;
34 |   }
35 | }
36 | 


--------------------------------------------------------------------------------
/ch13/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     writes(&errout, yylineno, ": ", image(yytext),": ")
3 |     stop(s)
4 | end
5 | 


--------------------------------------------------------------------------------
/ch13/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch13;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch3/dorrie.in:
--------------------------------------------------------------------------------
1 | Dr J is 1 fine puppy


--------------------------------------------------------------------------------
/ch3/dorrie2.in:
--------------------------------------------------------------------------------
1 | Dorrie
2 | is 1
3 | fine puppy.
4 | 


--------------------------------------------------------------------------------
/ch3/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch3/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yylineno, yylval
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    parser := parser(257,258,259,260,261,262,263,264,265,266,
 5 |                     267,268,269,270,273,274,275,
 6 |                     276,277,278,280,
 7 |                     298,300,301,
 8 |                     302,303,304,306,
 9 |                     307,256)
10 |    yyin := open(argv[1]) | stop("usage: simple2 filename")
11 |    yylineno := 1
12 |    while i := yylex() do
13 |       write(yytext, ":",yylval.lineno, " ", i)
14 | end
15 | class j0()
16 |    method lexErr(s)
17 |       stop(s, ": ", yytext) 
18 |    end
19 |    method scan(cat)
20 |       yylval := token(cat, yytext, yylineno)
21 |       return cat
22 |    end
23 |    method whitespace()
24 |    end
25 |    method newline()
26 |       yylineno +:= 1
27 |    end
28 |    method comment()
29 |    end
30 |    method ord(s)
31 |       return proc("ord",0)(s[1])
32 |    end
33 | end
34 | record token(cat, text, lineno)
35 | record parser(BREAK,PUBLIC,DOUBLE,ELSE,FOR,IF,INT,RETURN,VOID,WHILE,
36 |               IDENTIFIER,CLASSNAME,CLASS,STATIC,STRING,BOOL,INTLIT,
37 |               DOUBLELIT,STRINGLIT,BOOLLIT,NULLVAL,
38 |               LESSTHANOREQUAL,GREATERTHANOREQUAL,ISEQUALTO,
39 |               NOTEQUALTO,LOGICALAND,LOGICALOR,INCREMENT,
40 |               DECREMENT,YYERRCODE)
41 | 


--------------------------------------------------------------------------------
/ch3/j0.java:
--------------------------------------------------------------------------------
 1 | import java.io.FileReader;
 2 | public class j0 {
 3 |    static Yylex lex;
 4 |    public static int yylineno;
 5 |    public static token yylval;
 6 |    public static void main(String argv[]) throws Exception {
 7 |       lex = new Yylex(new FileReader(argv[0]));
 8 |       yylineno = 1;
 9 |       int i;
10 |       while ((i=lex.yylex()) != Yylex.YYEOF) {
11 |          System.out.println("token " + i + ": " + yytext());
12 |       }
13 |    }
14 |    public static String yytext() {
15 |       return lex.yytext();
16 |    }
17 |    public static void lexErr(String s) {
18 |       System.err.println(s + ": line " + yylineno +
19 |                              ": " + yytext());
20 |       System.exit(1);
21 |    }
22 |    public static int scan(int cat) {
23 |       yylval = new token(cat, yytext(), yylineno);
24 |       return cat;
25 |    }
26 |    public static void newline() {
27 |       yylineno++;
28 |    }
29 |    public static void whitespace() {
30 |    }
31 |    public static void comment() {
32 |    }
33 |    public static short ord(String s) { return (short)(s.charAt(0)); }
34 | }
35 | 


--------------------------------------------------------------------------------
/ch3/j0go.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yylineno, last_token
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    parser := parser(257,259,260,261,262,263,264,265,266,267,
 5 |                     268,269,273,274,275,276,277,278,280,298,
 6 |                     300,301,302,303,304,306,307,256)
 7 |    yyin := open(argv[1]) | stop("usage: simple2 filename")
 8 |    yylineno := 1
 9 |    while i := yylex() do
10 |       write(yytext, ":",yylval.lineno, " ", i)
11 | end
12 | class j0()
13 |    method lexErr(s)
14 |       stop(s, ": ", yytext) 
15 |    end
16 |    method scan(cat)
17 |       last_token := yylval := token(cat, yytext, yylineno)
18 |       return cat
19 |    end
20 |    method newline()
21 |       yylineno +:= 1
22 |       if (\last_token).cat ===
23 |            ( parser.IDENTIFIER|parser.INTLIT|parser.DOUBLELIT|
24 |              parser.STRINGLIT|parser.BREAK|parser.RETURN|
25 |              parser.INCREMENT|parser.DECREMENT|
26 |              ord(!")]}") ) then return
27 |    end
28 |    method semicolon()
29 |       yytext := ";"
30 |       yylineno -:= 1
31 |       return scan(parser.SEMICOLON)
32 |    end
33 |    method ord(s)
34 |       return proc("ord",0)(s[1])
35 |    end
36 |    method whitespace()
37 |    end
38 |    method comment()
39 |    end
40 | end
41 | record token(cat, text, lineno)
42 | record parser(BREAK,DOUBLE,ELSE,FOR,IF,INT,RETURN,VOID,WHILE,
43 |               IDENTIFIER,CLASSNAME,CLASS,STRING,BOOL,INTLIT,
44 |               DOUBLELIT,STRINGLIT,BOOLLIT,NULLVAL,
45 |               LESSTHANOREQUAL,GREATERTHANOREQUAL,ISEQUALTO,
46 |               NOTEQUALTO,LOGICALAND,LOGICALOR,INCREMENT,
47 |               DECREMENT,YYERRCODE)
48 | 


--------------------------------------------------------------------------------
/ch3/j0go.java:
--------------------------------------------------------------------------------
 1 | import java.io.FileReader;
 2 | public class j0go {
 3 |    static Yylex lex;
 4 |    public static int yylineno, yycolno;
 5 |    public static token yylval;
 6 |    public static void main(String argv[]) throws Exception {
 7 |       lex = new Yylex(new FileReader(argv[0]));
 8 |       yylineno = yycolno = 1;
 9 |       int i;
10 |       while ((i=lex.yylex()) != Yylex.YYEOF) {
11 |          System.out.println("token " + i + ": " + yytext());
12 |       }
13 |    }
14 |    public static String yytext() {
15 |       return lex.yytext();
16 |    }
17 |    public static void lexErr(String s) {
18 |       System.err.println(s + ": line " + yylineno +
19 |                              ": " + yytext());
20 |       System.exit(1);
21 |    }
22 |    public static int scan(int cat) {
23 |       last_token = yylval =
24 | 	 new token(cat, yytext(), yylineno);
25 |       yycolno += yytext().length();
26 |       return cat;
27 |    }
28 |    public static void newline() {
29 |       yylineno++; yycolno = 1;
30 |       if (last_token != null)
31 |          switch(last_token.cat) {
32 |             case parser.IDENTIFIER: case parser.INTLIT:
33 |             case parser.DOUBLELIT: case parser.STRINGLIT:
34 |             case parser.BREAK: case parser.RETURN:
35 |             case parser.INCREMENT: case parser.DECREMENT:
36 |             case ')': case ']': case '}':
37 |                return true;
38 |          }
39 |       return false;
40 |    }
41 |    public static int semicolon() {
42 |        yytext = ";";
43 |        yylineno--;
44 |        return scan(parser.SEMICOLON);
45 |    }
46 |    public static void whitespace() {
47 |       yycolno += yytext().length();
48 |    }
49 |    public static void comment() {
50 |       int i, len;
51 |       String s = yytext();
52 |       len = s.length();
53 |       for(i=0; i<len; i++)
54 | 	 if (s.charAt(i)=='\n') { yylineno++; yycolno=1; }
55 |          else yycolno++;
56 |    }
57 |    public static short ord(String s) { return (short)(s.charAt(0)); }
58 | }
59 | 


--------------------------------------------------------------------------------
/ch3/javalex.l:
--------------------------------------------------------------------------------
 1 | %%
 2 | %int
 3 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 4 | %%
 5 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 6 | "//".*\r?\n                  { j0.comment(); }
 7 | [ \t\r\f]+                   { j0.whitespace(); }
 8 | \n             { j0.newline(); }
 9 | "break"                { return j0.scan(parser.BREAK); }
10 | "double"               { return j0.scan(parser.DOUBLE); } 
11 | "else"                 { return j0.scan(parser.ELSE); }
12 | "false"                { return j0.scan(parser.BOOLLIT); }
13 | "for"                  { return j0.scan(parser.FOR); }
14 | "if"                   { return j0.scan(parser.IF); }
15 | "int"                  { return j0.scan(parser.INT); }
16 | "null"                 { return j0.scan(parser.NULLVAL); }
17 | "public"               { return j0.scan(parser.PUBLIC); }
18 | "return"               { return j0.scan(parser.RETURN); }
19 | "static"               { return j0.scan(parser.STATIC); }
20 | "string"               { return j0.scan(parser.STRING); }
21 | "true"                 { return j0.scan(parser.BOOLLIT); }
22 | "bool"                 { return j0.scan(parser.BOOL); }
23 | "void"                 { return j0.scan(parser.VOID); }
24 | "while"                { return j0.scan(parser.WHILE); }
25 | "class"                { return j0.scan(parser.CLASS); }
26 | "("                    { return j0.scan(j0.ord("("));}
27 | ")"                    { return j0.scan(j0.ord(")"));}
28 | "["                    { return j0.scan(j0.ord("["));}
29 | "]"                    { return j0.scan(j0.ord("]"));}
30 | "{"                    { return j0.scan(j0.ord("{"));}
31 | "}"                    { return j0.scan(j0.ord("}"));}
32 | ";"                    { return j0.scan(j0.ord(";"));}
33 | ":"                    { return j0.scan(j0.ord(":"));}
34 | "!"                    { return j0.scan(j0.ord("!"));}
35 | "*"                    { return j0.scan(j0.ord("*"));}
36 | "/"                    { return j0.scan(j0.ord("/"));}
37 | "%"                    { return j0.scan(j0.ord("%"));}
38 | "+"                    { return j0.scan(j0.ord("+"));}
39 | "-"                    { return j0.scan(j0.ord("-"));}
40 | "<"                    { return j0.scan(j0.ord("<"));}
41 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
42 | ">"                    { return j0.scan(j0.ord(">"));}
43 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
44 | "=="                   { return j0.scan(parser.ISEQUALTO);}
45 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
46 | "&&"                   { return j0.scan(parser.LOGICALAND);}
47 | "||"                   { return j0.scan(parser.LOGICALOR);}
48 | "="                    { return j0.scan(j0.ord("=")); }
49 | "+="                   { return j0.scan(parser.INCREMENT); }
50 | "-="                   { return j0.scan(parser.DECREMENT); }
51 | ","                    { return j0.scan(j0.ord(",")); }
52 | "."                    { return j0.scan(j0.ord(".")); }
53 | {id}                   { return j0.scan(parser.IDENTIFIER); }
54 | [0-9]+                 { return j0.scan(parser.INTLIT); }
55 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
56 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
57 | \"[^\"]*\"     { return j0.scan(parser.STRINGLIT); }
58 | .              { j0.lexErr("unrecognized character"); }
59 | 


--------------------------------------------------------------------------------
/ch3/nnws-tok.l:
--------------------------------------------------------------------------------
1 | %%
2 | %int
3 | %%
4 | [a-zA-Z]+  { return simple2.scan(1); }
5 | [0-9]+     { return simple2.scan(2); }
6 | [ \t]+     { }
7 | \r?\n      { simple2.increment_lineno(); }
8 | .          { simple2.lexErr("unrecognized character"); }
9 | 


--------------------------------------------------------------------------------
/ch3/nnws.l:
--------------------------------------------------------------------------------
1 | %%
2 | %int
3 | %%
4 | [a-zA-Z]+   { return 1; }
5 | [0-9]+      { return 2; }
6 | [ \t]+      { }
7 | .	    { simple.lexErr("unrecognized character"); }
8 | 


--------------------------------------------------------------------------------
/ch3/parser.java:
--------------------------------------------------------------------------------
 1 | // stand-in for an iyacc parser object, gives terminal symbols
 2 | public class parser {
 3 | public final static short BREAK=257;
 4 | public final static short PUBLIC=258;
 5 | public final static short DOUBLE=259;
 6 | public final static short ELSE=260;
 7 | public final static short FOR=261;
 8 | public final static short IF=262;
 9 | public final static short INT=263;
10 | public final static short RETURN=264;
11 | public final static short VOID=265;
12 | public final static short WHILE=266;
13 | public final static short IDENTIFIER=267;
14 | public final static short CLASSNAME=268;
15 | public final static short CLASS=269;
16 | public final static short STATIC=270;
17 | public final static short STRING=273;
18 | public final static short BOOL=274;
19 | public final static short INTLIT=275;
20 | public final static short DOUBLELIT=276;
21 | public final static short STRINGLIT=277;
22 | public final static short BOOLLIT=278;
23 | public final static short NULLVAL=280;
24 | public final static short LESSTHANOREQUAL=298;
25 | public final static short GREATERTHANOREQUAL=300;
26 | public final static short ISEQUALTO=301;
27 | public final static short NOTEQUALTO=302;
28 | public final static short LOGICALAND=303;
29 | public final static short LOGICALOR=304;
30 | public final static short INCREMENT=306;
31 | public final static short DECREMENT=307;
32 | public final static short YYERRCODE=256;
33 | }
34 | 


--------------------------------------------------------------------------------
/ch3/simple.icn:
--------------------------------------------------------------------------------
 1 | procedure main(argv)
 2 |    simple := simple()
 3 |    yyin := open(argv[1])
 4 |    while i := yylex() do
 5 |       write(yytext, ": ", i)
 6 | end
 7 | class simple()
 8 |    method lexErr(s)
 9 |       stop(s, ": ", yytext)
10 |    end
11 | end
12 | 


--------------------------------------------------------------------------------
/ch3/simple.java:
--------------------------------------------------------------------------------
 1 | import java.io.FileReader;
 2 | public class simple {
 3 |    static Yylex yylexer;
 4 |    public static String yytext() {
 5 |       return yylexer.yytext();
 6 |    }
 7 |    public static void lexErr(String s) {
 8 |       System.err.println(s + ": " + yytext());
 9 |       System.exit(1);
10 |    }
11 |    public static void main(String argv[]) throws Exception {
12 |       if (argv.length == 0) {
13 |          System.out.println("usage: java simple [file]");
14 |       }
15 |       yylexer = new Yylex(new FileReader(argv[0]));
16 |       int i;
17 |       while ((i=yylexer.yylex()) != Yylex.YYEOF) {
18 |          System.out.println("token " + i + ": " + yytext());
19 |       }
20 |    }
21 | }
22 | 


--------------------------------------------------------------------------------
/ch3/simple2.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yylval
 2 | procedure main(argv)
 3 |    simple2 := simple2()
 4 |    yyin := open(argv[1]) | stop("usage: simple2 filename")
 5 |    yylineno := 1
 6 |    while i := yylex() do
 7 |       write("token ", i, " (line ", yylval.lineno, "): ", yytext)
 8 | end
 9 | class simple2()
10 |    method lexErr(s)
11 |       stop(s, ": line ", yylineno, ": ", yytext) 
12 |    end
13 |    method scan(cat)
14 |       yylval := token(cat, yytext, yylineno)
15 |       return cat
16 |    end
17 |    method increment_lineno()
18 |       yylineno +:= 1
19 |    end
20 | end
21 | record token(cat, text, lineno)
22 | 


--------------------------------------------------------------------------------
/ch3/simple2.java:
--------------------------------------------------------------------------------
 1 | import java.io.FileReader;
 2 | public class simple2 {
 3 |    static Yylex lex;
 4 |    public static int yylineno;
 5 |    public static token yylval;
 6 |    public static void main(String argv[]) throws Exception {
 7 |       lex = new Yylex(new FileReader(argv[0]));
 8 |       yylineno = 1;
 9 |       int i;
10 |       while ((i=lex.yylex()) != Yylex.YYEOF) {
11 | 	  System.out.println("token " + i +
12 |                    " (line " + yylval.lineno + "): " + yytext());
13 |       }
14 |    }
15 |    public static String yytext() {
16 |       return lex.yytext();
17 |    }
18 |    public static void lexErr(String s) {
19 |       System.err.println(s + ": line " + yylineno +
20 |                              ": " + yytext());
21 |       System.exit(1);
22 |    }
23 |    public static int scan(int cat) {
24 |       yylval = new token(cat, yytext(), yylineno);
25 |       return cat;
26 |    }
27 |    public static void increment_lineno() {
28 |       yylineno++;
29 |    }
30 | }
31 | 


--------------------------------------------------------------------------------
/ch3/token.java:
--------------------------------------------------------------------------------
1 | public class token {
2 |    public int cat;
3 |    public String text;
4 |    public int lineno;
5 |    public token(int c, String s, int l) {
6 |       cat = c; text = s; lineno = l;
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch4/Parser.java:
--------------------------------------------------------------------------------
  1 | //### This file created by BYACC 1.8(/Java extension  1.15)
  2 | //### Java capabilities added 7 Jan 97, Bob Jamison
  3 | //### Updated : 27 Nov 97  -- Bob Jamison, Joe Nieten
  4 | //###           01 Jan 98  -- Bob Jamison -- fixed generic semantic constructor
  5 | //###           01 Jun 99  -- Bob Jamison -- added Runnable support
  6 | //###           06 Aug 00  -- Bob Jamison -- made state variables class-global
  7 | //###           03 Jan 01  -- Bob Jamison -- improved flags, tracing
  8 | //###           16 May 01  -- Bob Jamison -- added custom stack sizing
  9 | //###           04 Mar 02  -- Yuval Oren  -- improved java performance, added options
 10 | //###           14 Mar 02  -- Tomas Hurka -- -d support, static initializer workaround
 11 | //### Please send bug reports to tom@hukatronic.cz
 12 | //### static char yysccsid[] = "@(#)yaccpar	1.8 (Berkeley) 01/20/90";
 13 | 
 14 | 
 15 | 
 16 | package ch4;
 17 | import static ch4.lexer.yylex;
 18 | import static ch4.yyerror.yyerror;
 19 | 
 20 | 
 21 | 
 22 | 
 23 | 
 24 | 
 25 | 
 26 | public class Parser
 27 | {
 28 | 
 29 | boolean yydebug;        //do I want debug output?
 30 | int yynerrs;            //number of errors so far
 31 | int yyerrflag;          //was there an error?
 32 | int yychar;             //the current working character
 33 | 
 34 | //########## MESSAGES ##########
 35 | //###############################################################
 36 | // method: debug
 37 | //###############################################################
 38 | void debug(String msg)
 39 | {
 40 |   if (yydebug)
 41 |     System.out.println(msg);
 42 | }
 43 | 
 44 | //########## STATE STACK ##########
 45 | final static int YYSTACKSIZE = 500;  //maximum stack size
 46 | int statestk[] = new int[YYSTACKSIZE]; //state stack
 47 | int stateptr;
 48 | int stateptrmax;                     //highest index of stackptr
 49 | int statemax;                        //state when highest index reached
 50 | //###############################################################
 51 | // methods: state stack push,pop,drop,peek
 52 | //###############################################################
 53 | final void state_push(int state)
 54 | {
 55 |   try {
 56 | 		stateptr++;
 57 | 		statestk[stateptr]=state;
 58 | 	 }
 59 | 	 catch (ArrayIndexOutOfBoundsException e) {
 60 |      int oldsize = statestk.length;
 61 |      int newsize = oldsize * 2;
 62 |      int[] newstack = new int[newsize];
 63 |      System.arraycopy(statestk,0,newstack,0,oldsize);
 64 |      statestk = newstack;
 65 |      statestk[stateptr]=state;
 66 |   }
 67 | }
 68 | final int state_pop()
 69 | {
 70 |   return statestk[stateptr--];
 71 | }
 72 | final void state_drop(int cnt)
 73 | {
 74 |   stateptr -= cnt; 
 75 | }
 76 | final int state_peek(int relative)
 77 | {
 78 |   return statestk[stateptr-relative];
 79 | }
 80 | //###############################################################
 81 | // method: init_stacks : allocate and prepare stacks
 82 | //###############################################################
 83 | final boolean init_stacks()
 84 | {
 85 |   stateptr = -1;
 86 |   val_init();
 87 |   return true;
 88 | }
 89 | //###############################################################
 90 | // method: dump_stacks : show n levels of the stacks
 91 | //###############################################################
 92 | void dump_stacks(int count)
 93 | {
 94 | int i;
 95 |   System.out.println("=index==state====value=     s:"+stateptr+"  v:"+valptr);
 96 |   for (i=0;i<count;i++)
 97 |     System.out.println(" "+i+"    "+statestk[i]+"      "+valstk[i]);
 98 |   System.out.println("======================");
 99 | }
100 | 
101 | 
102 | //########## SEMANTIC VALUES ##########
103 | //public class ParserVal is defined in ParserVal.java
104 | 
105 | 
106 | String   yytext;//user variable to return contextual strings
107 | ParserVal yyval; //used to return semantic vals from action routines
108 | ParserVal yylval;//the 'lval' (result) I got from yylex()
109 | ParserVal valstk[];
110 | int valptr;
111 | //###############################################################
112 | // methods: value stack push,pop,drop,peek.
113 | //###############################################################
114 | void val_init()
115 | {
116 |   valstk=new ParserVal[YYSTACKSIZE];
117 |   yyval=new ParserVal();
118 |   yylval=new ParserVal();
119 |   valptr=-1;
120 | }
121 | void val_push(ParserVal val)
122 | {
123 |   if (valptr>=YYSTACKSIZE)
124 |     return;
125 |   valstk[++valptr]=val;
126 | }
127 | ParserVal val_pop()
128 | {
129 |   if (valptr<0)
130 |     return new ParserVal();
131 |   return valstk[valptr--];
132 | }
133 | void val_drop(int cnt)
134 | {
135 | int ptr;
136 |   ptr=valptr-cnt;
137 |   if (ptr<0)
138 |     return;
139 |   valptr = ptr;
140 | }
141 | ParserVal val_peek(int relative)
142 | {
143 | int ptr;
144 |   ptr=valptr-relative;
145 |   if (ptr<0)
146 |     return new ParserVal();
147 |   return valstk[ptr];
148 | }
149 | final ParserVal dup_yyval(ParserVal val)
150 | {
151 |   ParserVal dup = new ParserVal();
152 |   dup.ival = val.ival;
153 |   dup.dval = val.dval;
154 |   dup.sval = val.sval;
155 |   dup.obj = val.obj;
156 |   return dup;
157 | }
158 | //#### end semantic value section ####
159 | public final static short NAME=257;
160 | public final static short NUMBER=258;
161 | public final static short YYERRCODE=256;
162 | final static short yylhs[] = {                           -1,
163 |     0,    0,    1,
164 | };
165 | final static short yylen[] = {                            2,
166 |     2,    0,    2,
167 | };
168 | final static short yydefred[] = {                         0,
169 |     0,    0,    0,    3,    1,
170 | };
171 | final static short yydgoto[] = {                          2,
172 |     3,
173 | };
174 | final static short yysindex[] = {                      -257,
175 |  -256,    0, -257,    0,    0,
176 | };
177 | final static short yyrindex[] = {                         1,
178 |     0,    0,    1,    0,    0,
179 | };
180 | final static short yygindex[] = {                         2,
181 |     0,
182 | };
183 | final static int YYTABLESIZE=5;
184 | static short yytable[];
185 | static { yytable();}
186 | static void yytable(){
187 | yytable = new short[]{                          1,
188 |     2,    4,    0,    0,    5,
189 | };
190 | }
191 | static short yycheck[];
192 | static { yycheck(); }
193 | static void yycheck() {
194 | yycheck = new short[] {                        257,
195 |     0,  258,   -1,   -1,    3,
196 | };
197 | }
198 | final static short YYFINAL=2;
199 | final static short YYMAXTOKEN=258;
200 | final static String yyname[] = {
201 | "end-of-file",null,null,null,null,null,null,null,null,null,null,null,null,null,
202 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
203 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
204 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
205 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
206 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
207 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
208 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
209 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
210 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
211 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
212 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
213 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
214 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
215 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
216 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
217 | null,null,null,"NAME","NUMBER",
218 | };
219 | final static String yyrule[] = {
220 | "$accept : sequence",
221 | "sequence : pair sequence",
222 | "sequence :",
223 | "pair : NAME NUMBER",
224 | };
225 | 
226 | //###############################################################
227 | // method: yylexdebug : check lexer state
228 | //###############################################################
229 | void yylexdebug(int state,int ch)
230 | {
231 | String s=null;
232 |   if (ch < 0) ch=0;
233 |   if (ch <= YYMAXTOKEN) //check index bounds
234 |      s = yyname[ch];    //now get it
235 |   if (s==null)
236 |     s = "illegal-symbol";
237 |   debug("state "+state+", reading "+ch+" ("+s+")");
238 | }
239 | 
240 | 
241 | 
242 | 
243 | 
244 | //The following are now global, to aid in error reporting
245 | int yyn;       //next next thing to do
246 | int yym;       //
247 | int yystate;   //current parsing state from state table
248 | String yys;    //current token string
249 | 
250 | 
251 | //###############################################################
252 | // method: yyparse : parse input and execute indicated items
253 | //###############################################################
254 | int yyparse()
255 | {
256 | boolean doaction;
257 |   init_stacks();
258 |   yynerrs = 0;
259 |   yyerrflag = 0;
260 |   yychar = -1;          //impossible char forces a read
261 |   yystate=0;            //initial state
262 |   state_push(yystate);  //save it
263 |   val_push(yylval);     //save empty value
264 |   while (true) //until parsing is done, either correctly, or w/error
265 |     {
266 |     doaction=true;
267 |     if (yydebug) debug("loop"); 
268 |     //#### NEXT ACTION (from reduction table)
269 |     for (yyn=yydefred[yystate];yyn==0;yyn=yydefred[yystate])
270 |       {
271 |       if (yydebug) debug("yyn:"+yyn+"  state:"+yystate+"  yychar:"+yychar);
272 |       if (yychar < 0)      //we want a char?
273 |         {
274 |         yychar = yylex();  //get next token
275 |         if (yydebug) debug(" next yychar:"+yychar);
276 |         //#### ERROR CHECK ####
277 |         if (yychar < 0)    //it it didn't work/error
278 |           {
279 |           yychar = 0;      //change it to default string (no -1!)
280 |           if (yydebug)
281 |             yylexdebug(yystate,yychar);
282 |           }
283 |         }//yychar<0
284 |       yyn = yysindex[yystate];  //get amount to shift by (shift index)
285 |       if ((yyn != 0) && (yyn += yychar) >= 0 &&
286 |           yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
287 |         {
288 |         if (yydebug)
289 |           debug("state "+yystate+", shifting to state "+yytable[yyn]);
290 |         //#### NEXT STATE ####
291 |         yystate = yytable[yyn];//we are in a new state
292 |         state_push(yystate);   //save it
293 |         val_push(yylval);      //push our lval as the input for next rule
294 |         yychar = -1;           //since we have 'eaten' a token, say we need another
295 |         if (yyerrflag > 0)     //have we recovered an error?
296 |            --yyerrflag;        //give ourselves credit
297 |         doaction=false;        //but don't process yet
298 |         break;   //quit the yyn=0 loop
299 |         }
300 | 
301 |     yyn = yyrindex[yystate];  //reduce
302 |     if ((yyn !=0 ) && (yyn += yychar) >= 0 &&
303 |             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
304 |       {   //we reduced!
305 |       if (yydebug) debug("reduce");
306 |       yyn = yytable[yyn];
307 |       doaction=true; //get ready to execute
308 |       break;         //drop down to actions
309 |       }
310 |     else //ERROR RECOVERY
311 |       {
312 |       if (yyerrflag==0)
313 |         {
314 |         yyerror("syntax error");
315 |         yynerrs++;
316 |         }
317 |       if (yyerrflag < 3) //low error count?
318 |         {
319 |         yyerrflag = 3;
320 |         while (true)   //do until break
321 |           {
322 |           if (stateptr<0)   //check for under & overflow here
323 |             {
324 |             yyerror("stack underflow. aborting...");  //note lower case 's'
325 |             return 1;
326 |             }
327 |           yyn = yysindex[state_peek(0)];
328 |           if ((yyn != 0) && (yyn += YYERRCODE) >= 0 &&
329 |                     yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
330 |             {
331 |             if (yydebug)
332 |               debug("state "+state_peek(0)+", error recovery shifting to state "+yytable[yyn]+" ");
333 |             yystate = yytable[yyn];
334 |             state_push(yystate);
335 |             val_push(yylval);
336 |             doaction=false;
337 |             break;
338 |             }
339 |           else
340 |             {
341 |             if (yydebug)
342 |               debug("error recovery discarding state "+state_peek(0)+" ");
343 |             if (stateptr<0)   //check for under & overflow here
344 |               {
345 |               yyerror("Stack underflow. aborting...");  //capital 'S'
346 |               return 1;
347 |               }
348 |             state_pop();
349 |             val_pop();
350 |             }
351 |           }
352 |         }
353 |       else            //discard this token
354 |         {
355 |         if (yychar == 0)
356 |           return 1; //yyabort
357 |         if (yydebug)
358 |           {
359 |           yys = null;
360 |           if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
361 |           if (yys == null) yys = "illegal-symbol";
362 |           debug("state "+yystate+", error recovery discards token "+yychar+" ("+yys+")");
363 |           }
364 |         yychar = -1;  //read another
365 |         }
366 |       }//end error recovery
367 |     }//yyn=0 loop
368 |     if (!doaction)   //any reason not to proceed?
369 |       continue;      //skip action
370 |     yym = yylen[yyn];          //get count of terminals on rhs
371 |     if (yydebug)
372 |       debug("state "+yystate+", reducing "+yym+" by rule "+yyn+" ("+yyrule[yyn]+")");
373 |     if (yym>0)                 //if count of rhs not 'nil'
374 |       yyval = val_peek(yym-1); //get current semantic value
375 |     yyval = dup_yyval(yyval); //duplicate yyval if ParserVal is used as semantic value
376 |     switch(yyn)
377 |       {
378 | //########## USER-SUPPLIED ACTIONS ##########
379 | //########## END OF USER-SUPPLIED ACTIONS ##########
380 |     }//switch
381 |     //#### Now let's reduce... ####
382 |     if (yydebug) debug("reduce");
383 |     state_drop(yym);             //we just reduced yylen states
384 |     yystate = state_peek(0);     //get new state
385 |     val_drop(yym);               //corresponding value drop
386 |     yym = yylhs[yyn];            //select next TERMINAL(on lhs)
387 |     if (yystate == 0 && yym == 0)//done? 'rest' state and at first TERMINAL
388 |       {
389 |       if (yydebug) debug("After reduction, shifting from state 0 to state "+YYFINAL+"");
390 |       yystate = YYFINAL;         //explicitly say we're done
391 |       state_push(YYFINAL);       //and save it
392 |       val_push(yyval);           //also save the semantic value of parsing
393 |       if (yychar < 0)            //we want another character?
394 |         {
395 |         yychar = yylex();        //get next character
396 |         if (yychar<0) yychar=0;  //clean, if necessary
397 |         if (yydebug)
398 |           yylexdebug(yystate,yychar);
399 |         }
400 |       if (yychar == 0)          //Good exit (if lex returns 0 ;-)
401 |          break;                 //quit the loop--all DONE
402 |       }//if yystate
403 |     else                        //else not done yet
404 |       {                         //get next state and push, for next yydefred[]
405 |       yyn = yygindex[yym];      //find out where to go
406 |       if ((yyn != 0) && (yyn += yystate) >= 0 &&
407 |             yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
408 |         yystate = yytable[yyn]; //get new state
409 |       else
410 |         yystate = yydgoto[yym]; //else go to new defred
411 |       if (yydebug) debug("after reduction, shifting from state "+state_peek(0)+" to state "+yystate+"");
412 |       state_push(yystate);     //going again, so push state & val...
413 |       val_push(yyval);         //for next action
414 |       }
415 |     }//main loop
416 |   return 0;//yyaccept!!
417 | }
418 | //## end of method parse() ######################################
419 | 
420 | 
421 | 
422 | //## run() --- for Thread #######################################
423 | /**
424 |  * A default run method, used for operating this parser
425 |  * object in the background.  It is intended for extending Thread
426 |  * or implementing Runnable.  Turn off with -Jnorun .
427 |  */
428 | public void run()
429 | {
430 |   yyparse();
431 | }
432 | //## end of method run() ########################################
433 | 
434 | 
435 | 
436 | //## Constructors ###############################################
437 | /**
438 |  * Default constructor.  Turn off with -Jnoconstruct .
439 | 
440 |  */
441 | public Parser()
442 | {
443 |   //nothing to do
444 | }
445 | 
446 | 
447 | /**
448 |  * Create a parser, setting the debug to true or false.
449 |  * @param debugMe true for debugging, false for no debug.
450 |  */
451 | public Parser(boolean debugMe)
452 | {
453 |   yydebug=debugMe;
454 | }
455 | //###############################################################
456 | 
457 | 
458 | 
459 | }
460 | //################### END OF CLASS ##############################
461 | 


--------------------------------------------------------------------------------
/ch4/Yylex.java:
--------------------------------------------------------------------------------
  1 | // DO NOT EDIT
  2 | // Generated by JFlex 1.8.2 http://jflex.de/
  3 | // source: nnws.l
  4 | 
  5 | package ch4;
  6 | 
  7 | // See https://github.com/jflex-de/jflex/issues/222
  8 | @SuppressWarnings("FallThrough")
  9 | class Yylex {
 10 | 
 11 |   /** This character denotes the end of file. */
 12 |   public static final int YYEOF = -1;
 13 | 
 14 |   /** Initial size of the lookahead buffer. */
 15 |   private static final int ZZ_BUFFERSIZE = 16384;
 16 | 
 17 |   // Lexical states.
 18 |   public static final int YYINITIAL = 0;
 19 | 
 20 |   /**
 21 |    * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
 22 |    * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
 23 |    *                  at the beginning of a line
 24 |    * l is of the form l = 2*k, k a non negative integer
 25 |    */
 26 |   private static final int ZZ_LEXSTATE[] = {
 27 |      0, 0
 28 |   };
 29 | 
 30 |   /**
 31 |    * Top-level table for translating characters to character classes
 32 |    */
 33 |   private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
 34 | 
 35 |   private static final String ZZ_CMAP_TOP_PACKED_0 =
 36 |     "\1\0\37\u0100\1\u0200\267\u0100\10\u0300\u1020\u0100";
 37 | 
 38 |   private static int [] zzUnpackcmap_top() {
 39 |     int [] result = new int[4352];
 40 |     int offset = 0;
 41 |     offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
 42 |     return result;
 43 |   }
 44 | 
 45 |   private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
 46 |     int i = 0;       /* index in packed string  */
 47 |     int j = offset;  /* index in unpacked array */
 48 |     int l = packed.length();
 49 |     while (i < l) {
 50 |       int count = packed.charAt(i++);
 51 |       int value = packed.charAt(i++);
 52 |       do result[j++] = value; while (--count > 0);
 53 |     }
 54 |     return j;
 55 |   }
 56 | 
 57 | 
 58 |   /**
 59 |    * Second-level tables for translating characters to character classes
 60 |    */
 61 |   private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
 62 | 
 63 |   private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
 64 |     "\11\0\1\1\4\2\22\0\1\1\17\0\12\3\7\0"+
 65 |     "\32\4\6\0\32\4\12\0\1\2\u01a2\0\2\2\326\0"+
 66 |     "\u0100\2";
 67 | 
 68 |   private static int [] zzUnpackcmap_blocks() {
 69 |     int [] result = new int[1024];
 70 |     int offset = 0;
 71 |     offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
 72 |     return result;
 73 |   }
 74 | 
 75 |   private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
 76 |     int i = 0;       /* index in packed string  */
 77 |     int j = offset;  /* index in unpacked array */
 78 |     int l = packed.length();
 79 |     while (i < l) {
 80 |       int count = packed.charAt(i++);
 81 |       int value = packed.charAt(i++);
 82 |       do result[j++] = value; while (--count > 0);
 83 |     }
 84 |     return j;
 85 |   }
 86 | 
 87 |   /**
 88 |    * Translates DFA states to action switch labels.
 89 |    */
 90 |   private static final int [] ZZ_ACTION = zzUnpackAction();
 91 | 
 92 |   private static final String ZZ_ACTION_PACKED_0 =
 93 |     "\1\0\1\1\1\2\1\3\1\4";
 94 | 
 95 |   private static int [] zzUnpackAction() {
 96 |     int [] result = new int[5];
 97 |     int offset = 0;
 98 |     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
 99 |     return result;
100 |   }
101 | 
102 |   private static int zzUnpackAction(String packed, int offset, int [] result) {
103 |     int i = 0;       /* index in packed string  */
104 |     int j = offset;  /* index in unpacked array */
105 |     int l = packed.length();
106 |     while (i < l) {
107 |       int count = packed.charAt(i++);
108 |       int value = packed.charAt(i++);
109 |       do result[j++] = value; while (--count > 0);
110 |     }
111 |     return j;
112 |   }
113 | 
114 | 
115 |   /**
116 |    * Translates a state to a row index in the transition table
117 |    */
118 |   private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
119 | 
120 |   private static final String ZZ_ROWMAP_PACKED_0 =
121 |     "\0\0\0\5\0\12\0\17\0\24";
122 | 
123 |   private static int [] zzUnpackRowMap() {
124 |     int [] result = new int[5];
125 |     int offset = 0;
126 |     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
127 |     return result;
128 |   }
129 | 
130 |   private static int zzUnpackRowMap(String packed, int offset, int [] result) {
131 |     int i = 0;  /* index in packed string  */
132 |     int j = offset;  /* index in unpacked array */
133 |     int l = packed.length();
134 |     while (i < l) {
135 |       int high = packed.charAt(i++) << 16;
136 |       result[j++] = high | packed.charAt(i++);
137 |     }
138 |     return j;
139 |   }
140 | 
141 |   /**
142 |    * The transition table of the DFA
143 |    */
144 |   private static final int [] ZZ_TRANS = zzUnpackTrans();
145 | 
146 |   private static final String ZZ_TRANS_PACKED_0 =
147 |     "\1\2\1\3\1\0\1\4\1\5\6\0\1\3\6\0"+
148 |     "\1\4\5\0\1\5";
149 | 
150 |   private static int [] zzUnpackTrans() {
151 |     int [] result = new int[25];
152 |     int offset = 0;
153 |     offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
154 |     return result;
155 |   }
156 | 
157 |   private static int zzUnpackTrans(String packed, int offset, int [] result) {
158 |     int i = 0;       /* index in packed string  */
159 |     int j = offset;  /* index in unpacked array */
160 |     int l = packed.length();
161 |     while (i < l) {
162 |       int count = packed.charAt(i++);
163 |       int value = packed.charAt(i++);
164 |       value--;
165 |       do result[j++] = value; while (--count > 0);
166 |     }
167 |     return j;
168 |   }
169 | 
170 | 
171 |   /** Error code for "Unknown internal scanner error". */
172 |   private static final int ZZ_UNKNOWN_ERROR = 0;
173 |   /** Error code for "could not match input". */
174 |   private static final int ZZ_NO_MATCH = 1;
175 |   /** Error code for "pushback value was too large". */
176 |   private static final int ZZ_PUSHBACK_2BIG = 2;
177 | 
178 |   /**
179 |    * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
180 |    * {@link #ZZ_PUSHBACK_2BIG} respectively.
181 |    */
182 |   private static final String ZZ_ERROR_MSG[] = {
183 |     "Unknown internal scanner error",
184 |     "Error: could not match input",
185 |     "Error: pushback value was too large"
186 |   };
187 | 
188 |   /**
189 |    * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
190 |    */
191 |   private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
192 | 
193 |   private static final String ZZ_ATTRIBUTE_PACKED_0 =
194 |     "\1\0\1\11\3\1";
195 | 
196 |   private static int [] zzUnpackAttribute() {
197 |     int [] result = new int[5];
198 |     int offset = 0;
199 |     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
200 |     return result;
201 |   }
202 | 
203 |   private static int zzUnpackAttribute(String packed, int offset, int [] result) {
204 |     int i = 0;       /* index in packed string  */
205 |     int j = offset;  /* index in unpacked array */
206 |     int l = packed.length();
207 |     while (i < l) {
208 |       int count = packed.charAt(i++);
209 |       int value = packed.charAt(i++);
210 |       do result[j++] = value; while (--count > 0);
211 |     }
212 |     return j;
213 |   }
214 | 
215 |   /** Input device. */
216 |   private java.io.Reader zzReader;
217 | 
218 |   /** Current state of the DFA. */
219 |   private int zzState;
220 | 
221 |   /** Current lexical state. */
222 |   private int zzLexicalState = YYINITIAL;
223 | 
224 |   /**
225 |    * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
226 |    * string.
227 |    */
228 |   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
229 | 
230 |   /** Text position at the last accepting state. */
231 |   private int zzMarkedPos;
232 | 
233 |   /** Current text position in the buffer. */
234 |   private int zzCurrentPos;
235 | 
236 |   /** Marks the beginning of the {@link #yytext()} string in the buffer. */
237 |   private int zzStartRead;
238 | 
239 |   /** Marks the last character in the buffer, that has been read from input. */
240 |   private int zzEndRead;
241 | 
242 |   /**
243 |    * Whether the scanner is at the end of file.
244 |    * @see #yyatEOF
245 |    */
246 |   private boolean zzAtEOF;
247 | 
248 |   /**
249 |    * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
250 |    *
251 |    * <p>When a lead/high surrogate has been read from the input stream into the final
252 |    * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
253 |    */
254 |   private int zzFinalHighSurrogate = 0;
255 | 
256 |   /** Number of newlines encountered up to the start of the matched text. */
257 |   @SuppressWarnings("unused")
258 |   private int yyline;
259 | 
260 |   /** Number of characters from the last newline up to the start of the matched text. */
261 |   @SuppressWarnings("unused")
262 |   private int yycolumn;
263 | 
264 |   /** Number of characters up to the start of the matched text. */
265 |   @SuppressWarnings("unused")
266 |   private long yychar;
267 | 
268 |   /** Whether the scanner is currently at the beginning of a line. */
269 |   @SuppressWarnings("unused")
270 |   private boolean zzAtBOL = true;
271 | 
272 |   /** Whether the user-EOF-code has already been executed. */
273 |   @SuppressWarnings("unused")
274 |   private boolean zzEOFDone;
275 | 
276 | 
277 |   /**
278 |    * Creates a new scanner
279 |    *
280 |    * @param   in  the java.io.Reader to read input from.
281 |    */
282 |   Yylex(java.io.Reader in) {
283 |     this.zzReader = in;
284 |   }
285 | 
286 |   /**
287 |    * Translates raw input code points to DFA table row
288 |    */
289 |   private static int zzCMap(int input) {
290 |     int offset = input & 255;
291 |     return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
292 |   }
293 | 
294 |   /**
295 |    * Refills the input buffer.
296 |    *
297 |    * @return {@code false} iff there was new input.
298 |    * @exception java.io.IOException  if any I/O-Error occurs
299 |    */
300 |   private boolean zzRefill() throws java.io.IOException {
301 | 
302 |     /* first: make room (if you can) */
303 |     if (zzStartRead > 0) {
304 |       zzEndRead += zzFinalHighSurrogate;
305 |       zzFinalHighSurrogate = 0;
306 |       System.arraycopy(zzBuffer, zzStartRead,
307 |                        zzBuffer, 0,
308 |                        zzEndRead - zzStartRead);
309 | 
310 |       /* translate stored positions */
311 |       zzEndRead -= zzStartRead;
312 |       zzCurrentPos -= zzStartRead;
313 |       zzMarkedPos -= zzStartRead;
314 |       zzStartRead = 0;
315 |     }
316 | 
317 |     /* is the buffer big enough? */
318 |     if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {
319 |       /* if not: blow it up */
320 |       char newBuffer[] = new char[zzBuffer.length * 2];
321 |       System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
322 |       zzBuffer = newBuffer;
323 |       zzEndRead += zzFinalHighSurrogate;
324 |       zzFinalHighSurrogate = 0;
325 |     }
326 | 
327 |     /* fill the buffer with new input */
328 |     int requested = zzBuffer.length - zzEndRead;
329 |     int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
330 | 
331 |     /* not supposed to occur according to specification of java.io.Reader */
332 |     if (numRead == 0) {
333 |       throw new java.io.IOException(
334 |           "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
335 |     }
336 |     if (numRead > 0) {
337 |       zzEndRead += numRead;
338 |       if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
339 |         if (numRead == requested) { // We requested too few chars to encode a full Unicode character
340 |           --zzEndRead;
341 |           zzFinalHighSurrogate = 1;
342 |         } else {                    // There is room in the buffer for at least one more char
343 |           int c = zzReader.read();  // Expecting to read a paired low surrogate char
344 |           if (c == -1) {
345 |             return true;
346 |           } else {
347 |             zzBuffer[zzEndRead++] = (char)c;
348 |           }
349 |         }
350 |       }
351 |       /* potentially more input available */
352 |       return false;
353 |     }
354 | 
355 |     /* numRead < 0 ==> end of stream */
356 |     return true;
357 |   }
358 | 
359 | 
360 |   /**
361 |    * Closes the input reader.
362 |    *
363 |    * @throws java.io.IOException if the reader could not be closed.
364 |    */
365 |   public final void yyclose() throws java.io.IOException {
366 |     zzAtEOF = true; // indicate end of file
367 |     zzEndRead = zzStartRead; // invalidate buffer
368 | 
369 |     if (zzReader != null) {
370 |       zzReader.close();
371 |     }
372 |   }
373 | 
374 | 
375 |   /**
376 |    * Resets the scanner to read from a new input stream.
377 |    *
378 |    * <p>Does not close the old reader.
379 |    *
380 |    * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
381 |    * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
382 |    *
383 |    * <p>Internal scan buffer is resized down to its initial length, if it has grown.
384 |    *
385 |    * @param reader The new input stream.
386 |    */
387 |   public final void yyreset(java.io.Reader reader) {
388 |     zzReader = reader;
389 |     zzEOFDone = false;
390 |     yyResetPosition();
391 |     zzLexicalState = YYINITIAL;
392 |     if (zzBuffer.length > ZZ_BUFFERSIZE) {
393 |       zzBuffer = new char[ZZ_BUFFERSIZE];
394 |     }
395 |   }
396 | 
397 |   /**
398 |    * Resets the input position.
399 |    */
400 |   private final void yyResetPosition() {
401 |       zzAtBOL  = true;
402 |       zzAtEOF  = false;
403 |       zzCurrentPos = 0;
404 |       zzMarkedPos = 0;
405 |       zzStartRead = 0;
406 |       zzEndRead = 0;
407 |       zzFinalHighSurrogate = 0;
408 |       yyline = 0;
409 |       yycolumn = 0;
410 |       yychar = 0L;
411 |   }
412 | 
413 | 
414 |   /**
415 |    * Returns whether the scanner has reached the end of the reader it reads from.
416 |    *
417 |    * @return whether the scanner has reached EOF.
418 |    */
419 |   public final boolean yyatEOF() {
420 |     return zzAtEOF;
421 |   }
422 | 
423 | 
424 |   /**
425 |    * Returns the current lexical state.
426 |    *
427 |    * @return the current lexical state.
428 |    */
429 |   public final int yystate() {
430 |     return zzLexicalState;
431 |   }
432 | 
433 | 
434 |   /**
435 |    * Enters a new lexical state.
436 |    *
437 |    * @param newState the new lexical state
438 |    */
439 |   public final void yybegin(int newState) {
440 |     zzLexicalState = newState;
441 |   }
442 | 
443 | 
444 |   /**
445 |    * Returns the text matched by the current regular expression.
446 |    *
447 |    * @return the matched text.
448 |    */
449 |   public final String yytext() {
450 |     return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
451 |   }
452 | 
453 | 
454 |   /**
455 |    * Returns the character at the given position from the matched text.
456 |    *
457 |    * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
458 |    *
459 |    * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
460 |    *
461 |    * @return the character at {@code position}.
462 |    */
463 |   public final char yycharat(int position) {
464 |     return zzBuffer[zzStartRead + position];
465 |   }
466 | 
467 | 
468 |   /**
469 |    * How many characters were matched.
470 |    *
471 |    * @return the length of the matched text region.
472 |    */
473 |   public final int yylength() {
474 |     return zzMarkedPos-zzStartRead;
475 |   }
476 | 
477 | 
478 |   /**
479 |    * Reports an error that occurred while scanning.
480 |    *
481 |    * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
482 |    * match-all fallback rule) this method will only be called with things that
483 |    * "Can't Possibly Happen".
484 |    *
485 |    * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
486 |    * scanner etc.).
487 |    *
488 |    * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
489 |    *
490 |    * @param errorCode the code of the error message to display.
491 |    */
492 |   private static void zzScanError(int errorCode) {
493 |     String message;
494 |     try {
495 |       message = ZZ_ERROR_MSG[errorCode];
496 |     } catch (ArrayIndexOutOfBoundsException e) {
497 |       message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
498 |     }
499 | 
500 |     throw new Error(message);
501 |   }
502 | 
503 | 
504 |   /**
505 |    * Pushes the specified amount of characters back into the input stream.
506 |    *
507 |    * <p>They will be read again by then next call of the scanning method.
508 |    *
509 |    * @param number the number of characters to be read again. This number must not be greater than
510 |    *     {@link #yylength()}.
511 |    */
512 |   public void yypushback(int number)  {
513 |     if ( number > yylength() )
514 |       zzScanError(ZZ_PUSHBACK_2BIG);
515 | 
516 |     zzMarkedPos -= number;
517 |   }
518 | 
519 | 
520 | 
521 | 
522 |   /**
523 |    * Resumes scanning until the next regular expression is matched, the end of input is encountered
524 |    * or an I/O-Error occurs.
525 |    *
526 |    * @return the next token.
527 |    * @exception java.io.IOException if any I/O-Error occurs.
528 |    */
529 |   public int yylex() throws java.io.IOException {
530 |     int zzInput;
531 |     int zzAction;
532 | 
533 |     // cached fields:
534 |     int zzCurrentPosL;
535 |     int zzMarkedPosL;
536 |     int zzEndReadL = zzEndRead;
537 |     char[] zzBufferL = zzBuffer;
538 | 
539 |     int [] zzTransL = ZZ_TRANS;
540 |     int [] zzRowMapL = ZZ_ROWMAP;
541 |     int [] zzAttrL = ZZ_ATTRIBUTE;
542 | 
543 |     while (true) {
544 |       zzMarkedPosL = zzMarkedPos;
545 | 
546 |       zzAction = -1;
547 | 
548 |       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
549 | 
550 |       zzState = ZZ_LEXSTATE[zzLexicalState];
551 | 
552 |       // set up zzAction for empty match case:
553 |       int zzAttributes = zzAttrL[zzState];
554 |       if ( (zzAttributes & 1) == 1 ) {
555 |         zzAction = zzState;
556 |       }
557 | 
558 | 
559 |       zzForAction: {
560 |         while (true) {
561 | 
562 |           if (zzCurrentPosL < zzEndReadL) {
563 |             zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
564 |             zzCurrentPosL += Character.charCount(zzInput);
565 |           }
566 |           else if (zzAtEOF) {
567 |             zzInput = YYEOF;
568 |             break zzForAction;
569 |           }
570 |           else {
571 |             // store back cached positions
572 |             zzCurrentPos  = zzCurrentPosL;
573 |             zzMarkedPos   = zzMarkedPosL;
574 |             boolean eof = zzRefill();
575 |             // get translated positions and possibly new buffer
576 |             zzCurrentPosL  = zzCurrentPos;
577 |             zzMarkedPosL   = zzMarkedPos;
578 |             zzBufferL      = zzBuffer;
579 |             zzEndReadL     = zzEndRead;
580 |             if (eof) {
581 |               zzInput = YYEOF;
582 |               break zzForAction;
583 |             }
584 |             else {
585 |               zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
586 |               zzCurrentPosL += Character.charCount(zzInput);
587 |             }
588 |           }
589 |           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
590 |           if (zzNext == -1) break zzForAction;
591 |           zzState = zzNext;
592 | 
593 |           zzAttributes = zzAttrL[zzState];
594 |           if ( (zzAttributes & 1) == 1 ) {
595 |             zzAction = zzState;
596 |             zzMarkedPosL = zzCurrentPosL;
597 |             if ( (zzAttributes & 8) == 8 ) break zzForAction;
598 |           }
599 | 
600 |         }
601 |       }
602 | 
603 |       // store back cached position
604 |       zzMarkedPos = zzMarkedPosL;
605 | 
606 |       if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
607 |         zzAtEOF = true;
608 |         return YYEOF;
609 |       }
610 |       else {
611 |         switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
612 |           case 1:
613 |             { lexer.lexErr("unrecognized character");
614 |             }
615 |             // fall through
616 |           case 5: break;
617 |           case 2:
618 |             { 
619 |             }
620 |             // fall through
621 |           case 6: break;
622 |           case 3:
623 |             { return Parser.NUMBER;
624 |             }
625 |             // fall through
626 |           case 7: break;
627 |           case 4:
628 |             { return Parser.NAME;
629 |             }
630 |             // fall through
631 |           case 8: break;
632 |           default:
633 |             zzScanError(ZZ_NO_MATCH);
634 |         }
635 |       }
636 |     }
637 |   }
638 | 
639 | 
640 | }
641 | 


--------------------------------------------------------------------------------
/ch4/dorrie3.in:
--------------------------------------------------------------------------------
1 | Dorrie 1 Clint 0


--------------------------------------------------------------------------------
/ch4/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch4/helloerror.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!")
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch4/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yycolno, yylval, parser
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    parser := Parser()
 5 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 6 |    yylineno := yycolno := 1
 7 |    if yyparse() = 0 then
 8 |       write("no errors, ", j0.count, " tokens parsed")
 9 | end
10 | class j0(count)
11 |    method lexErr(s)
12 |       stop(s, ": ", yytext) 
13 |    end
14 |    method scan(cat)
15 |       yylval := token(cat, yytext, yylineno, yycolno)
16 |       yycolno +:= *yytext
17 |       count +:= 1
18 |       return cat
19 |    end
20 |    method whitespace()
21 |       yycolno +:= *yytext
22 |    end
23 |    method newline()
24 |       yylineno +:= 1; yycolno := 1
25 |    end
26 |    method comment()
27 |       yytext ? {
28 |          while tab(find("\n")+1) do newline()
29 |          yycolno +:= *tab(0)
30 |       }
31 |    end
32 |    method ord(s)
33 |       return proc("ord",0)(s[1])
34 |    end
35 | initially
36 |    count := 0
37 | end
38 | class token(cat, text, lineno, colno, ival, dval, sval)
39 |    method deEscape(sin)
40 |       local sout := ""
41 |       sin := sin[2:-1]
42 |       sin ? {
43 |          while c := move(1) do {
44 |             if c == "\\" then {
45 |                if not (c := move(1)) then
46 |                   j0.lexErr("malformed string literal")
47 |                else case c of {
48 |                   "t":{ sout ||:= "\t" }
49 |                   "n":{ sout ||:= "\n" }
50 |                   }
51 |             }
52 |             else sout ||:= c
53 |          }
54 |       }
55 |       return sout
56 |    end
57 | initially
58 |    case cat of {
59 |      parser.INTLIT:    { ival := integer(text) }
60 |      parser.DOUBLELIT: { dval := real(text) }
61 |      parser.STRINGLIT: { sval := deEscape(text) }
62 |    }
63 | end
64 | 


--------------------------------------------------------------------------------
/ch4/j0.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | import java.io.FileReader;
 3 | public class j0 {
 4 |    public static Yylex yylexer;
 5 |    public static ch4.parser par;
 6 |     public static int yylineno, yycolno, count;
 7 |    public static void main(String argv[]) throws Exception {
 8 |       init(argv[0]);
 9 |       par = new ch4.parser();
10 |       //      par.yydebug=true;
11 |       yylineno = yycolno = 1;
12 |       count = 0;
13 |       int i = par.yyparse();
14 |       if (i == 0)
15 |          System.out.println("no errors, " + j0.count +
16 | 			    "tokens parsed");
17 |    }
18 |     //   public static parserVal yylval;
19 |    public static void init(String s) throws Exception {
20 |       yylexer = new Yylex(new FileReader(s));
21 |    }
22 |    public static int YYEOF() { return Yylex.YYEOF; }
23 |    public static int yylex() {
24 |       int rv = 0;
25 |       try {
26 |         rv = yylexer.yylex();
27 |       } catch(java.io.IOException ioException) {
28 |         rv = -1;
29 |       }
30 |       return rv;
31 |    }
32 |    public static String yytext() {
33 |       return yylexer.yytext();
34 |    }
35 |    public static void lexErr(String s) {
36 |       System.err.println(s);
37 |       System.exit(1);
38 |    }
39 |    public static int scan(int cat) {
40 |       ch4.j0.par.yylval = new parserVal(
41 | 				new token(cat, yytext(), yylineno, yycolno));
42 |       return cat;
43 |    }
44 |    public static void newline() {
45 |       yylineno++;
46 |    }
47 |    public static void whitespace() {
48 |    }
49 |    public static void comment() {
50 |    }
51 |    public static short ord(String s) { return (short)(s.charAt(0)); }
52 | }
53 | 


--------------------------------------------------------------------------------
/ch4/j0go.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yylineno, last_token
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    parser := parser(257,259,260,261,262,263,264,265,266,267,
 5 |                     268,269,273,274,275,276,277,278,280,298,
 6 |                     300,301,302,303,304,306,307,256)
 7 |    yyin := open(argv[1]) | stop("usage: simple2 filename")
 8 |    yylineno := 1
 9 |    while i := yylex() do
10 |       write(yytext, ":",yylval.lineno, " ", i)
11 | end
12 | class j0()
13 |    method lexErr(s)
14 |       stop(s, ": ", yytext) 
15 |    end
16 |    method scan(cat)
17 |       last_token := yylval := token(cat, yytext, yylineno)
18 |       return cat
19 |    end
20 |    method newline()
21 |       yylineno +:= 1
22 |       if (\last_token).cat ===
23 |            ( parser.IDENTIFIER|parser.INTLIT|parser.DOUBLELIT|
24 |              parser.STRINGLIT|parser.BREAK|parser.RETURN|
25 |              parser.INCREMENT|parser.DECREMENT|
26 |              ord(!")]}") ) then return
27 |    end
28 |    method semicolon()
29 |       yytext := ";"
30 |       yylineno -:= 1
31 |       return scan(parser.SEMICOLON)
32 |    end
33 |    method ord(s)
34 |       return proc("ord",0)(s[1])
35 |    end
36 |    method whitespace()
37 |    end
38 |    method comment()
39 |    end
40 | end
41 | record token(cat, text, lineno)
42 | record parser(BREAK,DOUBLE,ELSE,FOR,IF,INT,RETURN,VOID,WHILE,
43 |               IDENTIFIER,CLASSNAME,CLASS,STRING,BOOL,INTLIT,
44 |               DOUBLELIT,STRINGLIT,BOOLLIT,NULLVAL,
45 |               LESSTHANOREQUAL,GREATERTHANOREQUAL,ISEQUALTO,
46 |               NOTEQUALTO,LOGICALAND,LOGICALOR,INCREMENT,
47 |               DECREMENT,YYERRCODE)
48 | 


--------------------------------------------------------------------------------
/ch4/j0go.java:
--------------------------------------------------------------------------------
 1 | import java.io.FileReader;
 2 | public class j0go {
 3 |    static Yylex lex;
 4 |    public static int yylineno, yycolno;
 5 |    public static token yylval;
 6 |    public static void main(String argv[]) throws Exception {
 7 |       lex = new Yylex(new FileReader(argv[0]));
 8 |       yylineno = yycolno = 1;
 9 |       int i;
10 |       while ((i=lex.yylex()) != Yylex.YYEOF) {
11 |          System.out.println("token " + i + ": " + yytext());
12 |       }
13 |    }
14 |    public static String yytext() {
15 |       return lex.yytext();
16 |    }
17 |    public static void lexErr(String s) {
18 |       System.err.println(s + ": line " + yylineno +
19 |                              ": " + yytext());
20 |       System.exit(1);
21 |    }
22 |    public static int scan(int cat) {
23 |       last_token = yylval =
24 | 	 new token(cat, yytext(), yylineno);
25 |       yycolno += yytext().length();
26 |       return cat;
27 |    }
28 |    public static void newline() {
29 |       yylineno++; yycolno = 1;
30 |       if (last_token != null)
31 |          switch(last_token.cat) {
32 |             case parser.IDENTIFIER: case parser.INTLIT:
33 |             case parser.DOUBLELIT: case parser.STRINGLIT:
34 |             case parser.BREAK: case parser.RETURN:
35 |             case parser.INCREMENT: case parser.DECREMENT:
36 |             case ')': case ']': case '}':
37 |                return true;
38 |          }
39 |       return false;
40 |    }
41 |    public static int semicolon() {
42 |        yytext = ";";
43 |        yylineno--;
44 |        return scan(parser.SEMICOLON);
45 |    }
46 |    public static void whitespace() {
47 |       yycolno += yytext().length();
48 |    }
49 |    public static void comment() {
50 |       int i, len;
51 |       String s = yytext();
52 |       len = s.length();
53 |       for(i=0; i<len; i++)
54 | 	 if (s.charAt(i)=='\n') { yylineno++; yycolno=1; }
55 |          else yycolno++;
56 |    }
57 |    public static short ord(String s) { return (short)(s.charAt(0)); }
58 | }
59 | 


--------------------------------------------------------------------------------
/ch4/j0gram.icn:
--------------------------------------------------------------------------------
  1 | ### This file created by IYACC 1.1
  2 | ### Please send bug reports to jeffery@cs.nmt.edu
  3 | #define YYPREFIX "yy"
  4 | $define BREAK 257
  5 | $define DOUBLE 258
  6 | $define ELSE 259
  7 | $define FOR 260
  8 | $define IF 261
  9 | $define INT 262
 10 | $define RETURN 263
 11 | $define VOID 264
 12 | $define WHILE 265
 13 | $define IDENTIFIER 266
 14 | $define CLASSNAME 267
 15 | $define CLASS 268
 16 | $define STRING 269
 17 | $define BOOL 270
 18 | $define INTLIT 271
 19 | $define DOUBLELIT 272
 20 | $define STRINGLIT 273
 21 | $define BOOLLIT 274
 22 | $define NULLVAL 275
 23 | $define LESSTHANOREQUAL 276
 24 | $define GREATERTHANOREQUAL 277
 25 | $define ISEQUALTO 278
 26 | $define NOTEQUALTO 279
 27 | $define LOGICALAND 280
 28 | $define LOGICALOR 281
 29 | $define INCREMENT 282
 30 | $define DECREMENT 283
 31 | $define PUBLIC 284
 32 | $define STATIC 285
 33 | $define YYERRCODE 256
 34 | procedure init() 
 35 |   yylhs := [                                        -1,
 36 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 37 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 38 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 39 |    18,    6,   19,   20,   20,   14,   22,   22,   23,   23,
 40 |    24,   24,   25,   27,   26,   26,   26,   26,   26,   26,
 41 |    26,   26,   26,   26,   26,   36,   28,   37,   37,   37,
 42 |    31,   32,   33,   33,   42,   42,   43,   34,   35,   44,
 43 |    44,   44,   45,   45,   46,   46,   47,   47,   29,   29,
 44 |    30,   48,   48,   48,   48,   49,   49,   49,   49,   49,
 45 |    40,   21,   21,   50,   39,   39,   39,   39,   51,   51,
 46 |    52,   52,   52,   53,   53,   53,   53,   54,   54,   54,
 47 |    55,   55,   55,   55,   56,   56,   57,   57,   57,   58,
 48 |    58,   59,   59,   41,   41,   38,   60,   60,   61,   61,
 49 |    61,
 50 |   ]
 51 |   yylen := [                            2,
 52 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 53 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 54 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 55 |     2,    2,    4,    1,    0,    3,    1,    0,    1,    2,
 56 |     1,    1,    2,    2,    1,    1,    1,    1,    1,    0,
 57 |     1,    1,    1,    1,    1,    0,    2,    1,    1,    1,
 58 |     5,    7,    6,    8,    1,    2,    2,    5,    9,    1,
 59 |     1,    0,    1,    0,    1,    0,    1,    3,    2,    3,
 60 |     3,    1,    3,    1,    1,    1,    1,    1,    1,    1,
 61 |     4,    1,    3,    3,    4,    4,    6,    6,    1,    1,
 62 |     2,    2,    1,    1,    3,    3,    3,    1,    3,    3,
 63 |     1,    1,    1,    1,    1,    3,    1,    3,    3,    1,
 64 |     3,    1,    3,    1,    1,    3,    1,    1,    1,    1,
 65 |     1,
 66 |   ]
 67 |   yydefred := [                         0,
 68 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 69 |    12,    0,    3,    0,    4,    6,    7,    8,    0,    0,
 70 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 71 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 72 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 73 |     0,   86,   87,   89,   88,   90,   46,    0,    0,    0,
 74 |    45,    0,    0,   39,   41,   42,    0,   47,   48,   49,
 75 |    51,   52,   53,   54,   55,    0,   58,    0,   60,    0,
 76 |    82,    0,    0,    0,   33,    0,    0,   25,    0,   21,
 77 |     0,   79,    0,    0,    0,    0,    0,  125,   85,   73,
 78 |     0,    0,  103,  104,    0,    0,    0,    0,    0,    0,
 79 |     0,    0,    0,    0,    0,   36,   40,   43,   57,    0,
 80 |   130,  131,  129,    0,   30,    0,   80,   71,   77,    0,
 81 |     0,    0,    0,   84,  101,  102,    0,   81,    0,    0,
 82 |     0,    0,    0,  111,  112,  113,  114,    0,    0,    0,
 83 |     0,    0,    0,   83,    0,    0,   92,    0,    0,  126,
 84 |     0,    0,    0,    0,    0,  105,  106,  107,    0,    0,
 85 |     0,    0,    0,    0,    0,    0,   96,    0,    0,    0,
 86 |     0,   26,    0,    0,   78,    0,   95,   68,   93,    0,
 87 |     0,    0,    0,    0,   65,   98,   97,    0,    0,    0,
 88 |    62,   67,    0,   66,    0,    0,   64,   69,    0,    0,
 89 |    61,
 90 |   ]
 91 |   yydgoto := [                          2,
 92 |     6,   14,   15,   16,   17,   18,   36,   29,   97,   21,
 93 |    30,   42,   22,   61,   88,   37,   38,   39,   23,  155,
 94 |   156,   62,   63,   64,   65,   66,   67,   68,   69,   70,
 95 |    71,   72,   73,   74,   75,    0,   76,   98,   99,   79,
 96 |   157,  194,  195,  130,  101,  198,  131,  102,   81,   82,
 97 |   103,  104,  105,  106,  148,  107,  108,  109,  110,   83,
 98 |   124,
 99 |   ]
100 |   yysindex := [                      -272,
101 |  -229,    0, -216,  -57,  -95,    0,    0,    0,   28,    0,
102 |     0, -194,    0,  243,    0,    0,    0,    0, -155,   74,
103 |     0,   35,   35,  346,  193,    0,    0,    0,   14,   81,
104 |  -106,  207,    0,    0,    0, -155,  142,  147,    0,    0,
105 |     0,  -69,    0, -155,  107,    0,  -56,  172,  177,   50,
106 |   178,    0,    0,    0,    0,    0,    0,   50, -155,  -14,
107 |     0,   95,  207,    0,    0,    0,  166,    0,    0,    0,
108 |     0,    0,    0,    0,    0,  167,    0,    0,    0,  181,
109 |     0,    0,  -34,   81,    0,  346,  189,    0,   81,    0,
110 |   173,    0,  225,   50,   50,   50,  115,    0,    0,    0,
111 |   199,  181,    0,    0,  156,  170,   43, -145,  -49,  -44,
112 |    50,  195,  216,   50,   50,    0,    0,    0,    0,   -2,
113 |     0,    0,    0,   50,    0,  346,    0,    0,    0,  208,
114 |   229,  234,  115,    0,    0,    0,   50,    0,   50,   50,
115 |    50,   50,   50,    0,    0,    0,    0,   50,   50,   50,
116 |    50,   50,  235,    0,  149,  241,    0,  251,    9,    0,
117 |   259,   50,   -3,   35,  267,    0,    0,    0,  156,  156,
118 |   170,   43,   43, -145,  -49,  258,    0,   50,    0,   50,
119 |    50,    0,  250,  -14,    0,   59,    0,    0,    0,  201,
120 |   290,   -3, -109,   73,    0,    0,    0,  310,  229,  312,
121 |     0,    0, -109,    0,   35,   50,    0,    0,  324,   35,
122 |     0,
123 |   ]
124 |   yyrindex := [                         0,
125 |     0,    0,    0,    0,    0,    0,    0,    0,  -45,    0,
126 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  100,
127 |     0,    0,    0,  326,    0,    0,    0,    0,    0,   21,
128 |     0,  244,    0,    0,    0,    0,    0,  338,    0,    0,
129 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  323,
130 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -59,
131 |     0,    0,  262,    0,    0,    0,    0,    0,    0,    0,
132 |     0,    0,    0,    0,    0,    0,    0,  146,    0,    0,
133 |     0,  -37,    0,   45,    0,    0,    0,    0,   71,    0,
134 |     0,    0,  333,    0,    0,    0,    1,    0,    0,    0,
135 |     0,   10,    0,    0,   57,   77,   15,  103,  109,  137,
136 |     0,    0,  341,  264,  362,    0,    0,    0,    0,    0,
137 |     0,    0,    0,    0,    0,  326,    0,    0,    0,    0,
138 |   345,    0,   34,    0,    0,    0,  362,    0,    0,    0,
139 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
140 |     0,    0,    0,    0,    0,  -28,    0,    0,  -26,    0,
141 |     0,  323,    0,    0,    0,    0,    0,    0,   63,   69,
142 |    83,   23,   97,  105,  110,  -85,    0,    0,  160,  264,
143 |   362,    0,    0,   24,    0,  136,    0,    0,    0,    0,
144 |     0,  371,    0,  174,    0,    0,    0,    0,  372,    0,
145 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
146 |     0,
147 |   ]
148 |   yygindex := [                         0,
149 |     0,    0,  400,    0,    0,    0,  520,  356,  479,    0,
150 |    48,    0,    0,    6,    0,  291,    0,  332,    0,  190,
151 |     0,    0,    0,  353,    0,  245,  327,    0,    0,    0,
152 |  -162,    0,    0,    0,    0,    0,   -6,  363,  395,    0,
153 |   330,    0,  228,    0,  257,    0,  231,  397,    0,  451,
154 |     0,  233,   37,  277,    0,   16,  279,  276,    0,    0,
155 |     0,
156 |   ]
157 | $define YYTABLESIZE 671
158 |   yytable := [                         84,
159 |    15,  127,   92,   84,   84,   84,   84,   84,   84,   84,
160 |    94,    1,   34,   32,   94,   94,   94,   94,   94,   94,
161 |    94,   84,   84,  128,   84,  115,  123,   33,   34,   13,
162 |   202,   31,   94,   94,   94,   94,   58,  100,    3,   50,
163 |   202,  100,  100,  100,  100,  100,   99,  100,  181,    4,
164 |    99,   99,   99,   99,   99,  117,   99,   44,  117,  100,
165 |   100,  127,  100,  118,   18,    5,  118,   24,   99,   99,
166 |   100,   99,   43,  117,  100,  100,  100,  100,  100,   18,
167 |   100,  118,   96,   84,  127,   31,  129,   84,   31,   58,
168 |    25,   89,  100,  100,   95,  100,   34,  108,   94,  108,
169 |   108,  108,  146,  110,  147,  110,  110,  110,  114,  109,
170 |    28,  109,  109,  109,   19,  108,  108,  115,  108,   31,
171 |   115,  110,  110,  116,  110,  100,  116,  109,  109,   19,
172 |   109,  180,  149,  150,   99,  115,  115,  119,  115,  117,
173 |   119,  116,  116,  120,  116,  121,  120,  118,  121,  122,
174 |   123,  200,  122,  123,  137,  119,  185,   32,  100,   46,
175 |    31,  120,    7,  121,  172,  173,    8,  122,  123,  186,
176 |     9,   45,   50,   10,   11,   61,   50,  124,  169,  170,
177 |   124,  108,   85,   50,   50,  129,   59,  110,   12,   59,
178 |    86,   85,  141,  109,   61,  124,   87,  139,  201,   90,
179 |    91,  115,  140,   91,   59,   95,   14,  116,  207,   91,
180 |   208,   93,  143,   63,  142,  211,   94,  111,   91,  116,
181 |    15,  119,  127,  127,  118,  119,  120,  120,  126,  121,
182 |   151,  127,   63,  122,  123,  154,  152,  114,   84,   84,
183 |    84,   84,   84,   84,  128,  128,   58,  121,  122,   94,
184 |    94,   94,   94,   94,   94,   94,   94,  138,   61,   44,
185 |    61,  124,   35,  159,   58,   57,  162,   52,   53,   54,
186 |    55,   56,  163,  177,  164,  176,  100,  100,  100,  100,
187 |   100,  100,  127,  127,  178,   99,   99,   99,   99,   99,
188 |    99,  179,  117,  117,  117,  117,   63,   58,   63,  182,
189 |   118,  118,  118,  118,  158,  127,  127,  187,  192,  100,
190 |   100,  100,  100,  100,  100,   35,   57,  193,  144,  145,
191 |    52,   53,   54,   55,   56,  196,  165,  135,  136,   32,
192 |   197,  203,  108,  108,  108,  108,  108,  108,  110,  110,
193 |   110,  110,  110,  110,  109,  109,  109,  109,  109,  109,
194 |   205,  206,  115,  115,  115,  115,  115,  115,  116,  116,
195 |   116,  116,  116,  116,  210,   14,   28,   26,   38,  190,
196 |   191,  166,  167,  168,  119,  119,  119,  119,   27,  100,
197 |    32,   74,  120,  120,  121,  121,   37,  112,   35,  122,
198 |   123,   72,   61,   61,   77,   61,   61,   61,   61,   44,
199 |    61,   61,   35,   70,   61,   61,   61,   61,   61,   61,
200 |    61,   76,   75,   27,  113,  117,  161,  125,  183,  128,
201 |   188,  204,  199,  132,  171,   77,   78,  175,   80,  174,
202 |    63,   63,    0,   63,   63,   63,   63,    0,   63,   63,
203 |   153,    0,   63,   63,   63,   63,   63,   63,   63,    0,
204 |     7,    0,    0,  160,    8,   77,   40,   78,   35,   80,
205 |     0,   10,   11,   47,    7,    0,   48,   49,    8,   50,
206 |     0,   51,   35,    0,    0,   10,   11,   52,   53,   54,
207 |    55,   56,    7,   20,    0,    0,    8,   78,    0,   80,
208 |    35,  100,   20,   10,   11,   52,   53,   54,   55,   56,
209 |     7,    0,   20,   20,    8,    0,    0,  189,    9,    0,
210 |    60,   10,   11,    0,   47,    0,    0,   48,   49,    0,
211 |    50,    0,   51,   35,   19,   77,   12,    0,   52,   53,
212 |    54,   55,   56,   19,    0,  209,    0,    0,   77,    0,
213 |     0,   60,    0,    0,   41,  134,  134,    0,    0,    0,
214 |     0,   59,    0,    0,   77,    0,    0,   78,    0,   80,
215 |     0,    0,    0,    0,   20,    0,    0,    0,    0,    0,
216 |    78,   60,   80,  133,  133,    0,    0,    0,    0,    0,
217 |     0,    0,   59,    0,    0,    0,   78,    0,   80,  134,
218 |   134,  134,  134,  134,    0,    0,    0,    0,  134,  134,
219 |   134,  134,  134,    7,   20,    0,    0,    8,    0,    0,
220 |     0,   35,   59,    0,   10,   11,    0,  133,  133,  133,
221 |   133,  133,    0,    0,    0,    0,  133,  133,  133,  133,
222 |   133,    0,    0,    0,    0,    0,    0,    0,    0,    0,
223 |     0,  184,    0,    0,    0,    0,    0,    0,    0,    0,
224 |     0,    0,    0,    0,  184,    0,    0,    0,    0,    0,
225 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
226 |   184,
227 |   ]
228 |   yycheck := [                         37,
229 |    46,   61,   59,   41,   42,   43,   44,   45,   46,   47,
230 |    37,  284,   41,  123,   41,   42,   43,   44,   45,   46,
231 |    47,   59,   60,   61,   62,   40,   61,   22,   23,  125,
232 |   193,   46,   59,   60,   61,   62,   40,   37,  268,  125,
233 |   203,   41,   42,   43,   44,   45,   37,   47,   40,  266,
234 |    41,   42,   43,   44,   45,   41,   47,   44,   44,   59,
235 |    60,   61,   62,   41,   44,  123,   44,   40,   59,   60,
236 |    37,   62,   59,   59,   41,   42,   43,   44,   45,   59,
237 |    47,   59,   33,   36,   61,   41,   93,  125,   44,   40,
238 |   285,   44,   59,   60,   45,   62,  125,   41,  125,   43,
239 |    44,   45,   60,   41,   62,   43,   44,   45,  123,   41,
240 |   266,   43,   44,   45,   44,   59,   60,   41,   62,   46,
241 |    44,   59,   60,   41,   62,  125,   44,   59,   60,   59,
242 |    62,  123,  278,  279,  125,   59,   60,   41,   62,  125,
243 |    44,   59,   60,   41,   62,   41,   44,  125,   44,   41,
244 |    41,  261,   44,   44,   40,   59,  163,  123,  125,  266,
245 |    46,   59,  258,   59,  149,  150,  262,   59,   59,  164,
246 |   266,   91,  258,  269,  270,   40,  262,   41,  142,  143,
247 |    44,  125,   41,  269,  270,  192,   41,  125,  284,   44,
248 |    44,   46,   37,  125,   59,   59,  266,   42,  193,   93,
249 |    41,  125,   47,   44,   59,   46,  266,  125,  203,  266,
250 |   205,   40,   43,   40,   45,  210,   40,   40,   59,  125,
251 |   266,  125,  282,  283,   59,   59,   46,  125,   40,  125,
252 |   280,   59,   59,  125,  125,   41,  281,  123,  276,  277,
253 |   278,  279,  280,  281,  282,  283,   40,  282,  283,  276,
254 |   277,  278,  279,  280,  281,  282,  283,   59,  123,   44,
255 |   125,  125,  266,  266,   40,   59,   59,  271,  272,  273,
256 |   274,  275,   44,  125,   41,   41,  276,  277,  278,  279,
257 |   280,  281,  282,  283,   44,  276,  277,  278,  279,  280,
258 |   281,   41,  278,  279,  280,  281,  123,   40,  125,   41,
259 |   278,  279,  280,  281,  115,  282,  283,   41,   59,  276,
260 |   277,  278,  279,  280,  281,  266,   59,  259,  276,  277,
261 |   271,  272,  273,  274,  275,  125,  137,   95,   96,  123,
262 |    41,  259,  276,  277,  278,  279,  280,  281,  276,  277,
263 |   278,  279,  280,  281,  276,  277,  278,  279,  280,  281,
264 |    41,   40,  276,  277,  278,  279,  280,  281,  276,  277,
265 |   278,  279,  280,  281,   41,  266,   41,  125,  125,  180,
266 |   181,  139,  140,  141,  278,  279,  280,  281,   41,   50,
267 |   123,   59,  280,  281,  280,  281,  125,   58,  125,  281,
268 |   281,   59,  257,  258,   32,  260,  261,  262,  263,   59,
269 |   265,  266,   41,   59,  269,  270,  271,  272,  273,  274,
270 |   275,   41,   41,   14,   59,   63,  126,   86,  162,   93,
271 |   176,  194,  192,   94,  148,   63,   32,  152,   32,  151,
272 |   257,  258,   -1,  260,  261,  262,  263,   -1,  265,  266,
273 |   111,   -1,  269,  270,  271,  272,  273,  274,  275,   -1,
274 |   258,   -1,   -1,  124,  262,   93,  264,   63,  266,   63,
275 |    -1,  269,  270,  257,  258,   -1,  260,  261,  262,  263,
276 |    -1,  265,  266,   -1,   -1,  269,  270,  271,  272,  273,
277 |   274,  275,  258,    5,   -1,   -1,  262,   93,   -1,   93,
278 |   266,  162,   14,  269,  270,  271,  272,  273,  274,  275,
279 |   258,   -1,   24,   25,  262,   -1,   -1,  178,  266,   -1,
280 |    32,  269,  270,   -1,  257,   -1,   -1,  260,  261,   -1,
281 |   263,   -1,  265,  266,    5,  163,  284,   -1,  271,  272,
282 |   273,  274,  275,   14,   -1,  206,   -1,   -1,  176,   -1,
283 |    -1,   63,   -1,   -1,   25,   95,   96,   -1,   -1,   -1,
284 |    -1,   32,   -1,   -1,  192,   -1,   -1,  163,   -1,  163,
285 |    -1,   -1,   -1,   -1,   86,   -1,   -1,   -1,   -1,   -1,
286 |   176,   93,  176,   95,   96,   -1,   -1,   -1,   -1,   -1,
287 |    -1,   -1,   63,   -1,   -1,   -1,  192,   -1,  192,  139,
288 |   140,  141,  142,  143,   -1,   -1,   -1,   -1,  148,  149,
289 |   150,  151,  152,  258,  126,   -1,   -1,  262,   -1,   -1,
290 |    -1,  266,   93,   -1,  269,  270,   -1,  139,  140,  141,
291 |   142,  143,   -1,   -1,   -1,   -1,  148,  149,  150,  151,
292 |   152,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
293 |    -1,  163,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
294 |    -1,   -1,   -1,   -1,  176,   -1,   -1,   -1,   -1,   -1,
295 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
296 |   192,
297 |   ]
298 | $define YYFINAL 2
299 | $define YYMAXTOKEN 285
300 |   yyname := [
301 | "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
302 | "'!'",0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,
303 | 0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
304 | 0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
305 | 0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
306 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
307 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
308 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"BREAK","DOUBLE","ELSE","FOR","IF",
309 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
310 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
311 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
312 | "INCREMENT","DECREMENT","PUBLIC","STATIC",
313 |   ]
314 |   yyrule := [
315 | "$accept : ClassDecl",
316 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
317 | "ClassBody : '{' ClassBodyDecls '}'",
318 | "ClassBody : '{' '}'",
319 | "ClassBodyDecls : ClassBodyDecl",
320 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
321 | "ClassBodyDecl : FieldDecl",
322 | "ClassBodyDecl : MethodDecl",
323 | "ClassBodyDecl : ConstructorDecl",
324 | "FieldDecl : Type VarDecls ';'",
325 | "Type : INT",
326 | "Type : DOUBLE",
327 | "Type : BOOL",
328 | "Type : STRING",
329 | "Type : Name",
330 | "Name : IDENTIFIER",
331 | "Name : QualifiedName",
332 | "QualifiedName : Name '.' IDENTIFIER",
333 | "VarDecls : VarDeclarator",
334 | "VarDecls : VarDecls ',' VarDeclarator",
335 | "VarDeclarator : IDENTIFIER",
336 | "VarDeclarator : VarDeclarator '[' ']'",
337 | "MethodReturnVal : Type",
338 | "MethodReturnVal : VOID",
339 | "MethodDecl : MethodHeader Block",
340 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
341 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
342 | "FormalParmListOpt : FormalParmList",
343 | "FormalParmListOpt :",
344 | "FormalParmList : FormalParm",
345 | "FormalParmList : FormalParmList ',' FormalParm",
346 | "FormalParm : Type VarDeclarator",
347 | "ConstructorDecl : ConstructorDeclarator Block",
348 | "ConstructorDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
349 | "ArgListOpt : ArgList",
350 | "ArgListOpt :",
351 | "Block : '{' BlockStmtsOpt '}'",
352 | "BlockStmtsOpt : BlockStmts",
353 | "BlockStmtsOpt :",
354 | "BlockStmts : BlockStmt",
355 | "BlockStmts : BlockStmts BlockStmt",
356 | "BlockStmt : LocalVarDeclStmt",
357 | "BlockStmt : Stmt",
358 | "LocalVarDeclStmt : LocalVarDecl ';'",
359 | "LocalVarDecl : Type VarDecls",
360 | "Stmt : Block",
361 | "Stmt : ';'",
362 | "Stmt : ExprStmt",
363 | "Stmt : BreakStmt",
364 | "Stmt : ReturnStmt",
365 | "Stmt :",
366 | "Stmt : IfThenStmt",
367 | "Stmt : IfThenElseStmt",
368 | "Stmt : IfThenElseIfStmt",
369 | "Stmt : WhileStmt",
370 | "Stmt : ForStmt",
371 | "StmtWithoutTrailingSubstatement :",
372 | "ExprStmt : StmtExpr ';'",
373 | "StmtExpr : Assignment",
374 | "StmtExpr : MethodCall",
375 | "StmtExpr : InstantiationExpr",
376 | "IfThenStmt : IF '(' Expr ')' Block",
377 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
378 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
379 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
380 | "ElseIfSequence : ElseIfStmt",
381 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
382 | "ElseIfStmt : ELSE IfThenStmt",
383 | "WhileStmt : WHILE '(' Expr ')' Stmt",
384 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
385 | "ForInit : StmtExprList",
386 | "ForInit : LocalVarDecl",
387 | "ForInit :",
388 | "ExprOpt : Expr",
389 | "ExprOpt :",
390 | "ForUpdate : StmtExprList",
391 | "ForUpdate :",
392 | "StmtExprList : StmtExpr",
393 | "StmtExprList : StmtExprList ',' StmtExpr",
394 | "BreakStmt : BREAK ';'",
395 | "BreakStmt : BREAK IDENTIFIER ';'",
396 | "ReturnStmt : RETURN ExprOpt ';'",
397 | "Primary : Literal",
398 | "Primary : '(' Expr ')'",
399 | "Primary : FieldAccess",
400 | "Primary : MethodCall",
401 | "Literal : INTLIT",
402 | "Literal : DOUBLELIT",
403 | "Literal : BOOLLIT",
404 | "Literal : STRINGLIT",
405 | "Literal : NULLVAL",
406 | "InstantiationExpr : Name '(' ArgListOpt ')'",
407 | "ArgList : Expr",
408 | "ArgList : ArgList ',' Expr",
409 | "FieldAccess : Primary '.' IDENTIFIER",
410 | "MethodCall : Name '(' ArgListOpt ')'",
411 | "MethodCall : Name '{' ArgListOpt '}'",
412 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
413 | "MethodCall : Primary '.' IDENTIFIER '{' ArgListOpt '}'",
414 | "PostFixExpr : Primary",
415 | "PostFixExpr : Name",
416 | "UnaryExpr : '-' UnaryExpr",
417 | "UnaryExpr : '!' UnaryExpr",
418 | "UnaryExpr : PostFixExpr",
419 | "MulExpr : UnaryExpr",
420 | "MulExpr : MulExpr '*' UnaryExpr",
421 | "MulExpr : MulExpr '/' UnaryExpr",
422 | "MulExpr : MulExpr '%' UnaryExpr",
423 | "AddExpr : MulExpr",
424 | "AddExpr : AddExpr '+' MulExpr",
425 | "AddExpr : AddExpr '-' MulExpr",
426 | "RelOp : LESSTHANOREQUAL",
427 | "RelOp : GREATERTHANOREQUAL",
428 | "RelOp : '<'",
429 | "RelOp : '>'",
430 | "RelExpr : AddExpr",
431 | "RelExpr : RelExpr RelOp AddExpr",
432 | "EqExpr : RelExpr",
433 | "EqExpr : EqExpr ISEQUALTO RelExpr",
434 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
435 | "CondAndExpr : EqExpr",
436 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
437 | "CondOrExpr : CondAndExpr",
438 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
439 | "Expr : CondOrExpr",
440 | "Expr : Assignment",
441 | "Assignment : LeftHandSide AssignOp Expr",
442 | "LeftHandSide : Name",
443 | "LeftHandSide : FieldAccess",
444 | "AssignOp : '='",
445 | "AssignOp : INCREMENT",
446 | "AssignOp : DECREMENT",
447 |   ]
448 | 
449 | end
450 | 
451 | #####################################################################
452 | #####################################################################
453 | invocable all    # need to look up semantic actions by name
454 | 
455 | global yytext    # user variable to return contextual strings
456 | global yyval     # used to return semantic vals from action routines
457 | global yylval    # the 'lval' (result) I got from yylex()
458 | global yydebug   # (boolean) do I want debug output?
459 | global yynerrs   # (integer) number of errors so far
460 | global yyerrflag # (integer) was there an error?
461 | global yychar    # (integer) the current working character
462 | global action    # maps an integer to a semantic action procedure
463 | 
464 | global yylhs
465 | global yylen
466 | global yydefred
467 | global yydgoto
468 | global yysindex
469 | global yyrindex
470 | global yygindex
471 | global yytable
472 | global yycheck
473 | global yyname
474 | global yyrule
475 | 
476 | global statestk         # state stack
477 | global valstk           # value stack
478 | ################################################################
479 | # procedure: init_stacks : allocate and prepare stacks
480 | ################################################################
481 | procedure init_stacks()
482 |   local i
483 |   statestk := []
484 |   valstk := []
485 |   yyval  := 0 
486 |   yylval := 0 
487 |   action := list(1000, action_null)  # remove hard coded 1000 later
488 |   every i := 1 to 1000 do action[i] := proc("action_" || i)
489 | end
490 | 
491 | $define YYACCEPT return 0
492 | $define YYABORT return 1
493 | ################################################################
494 | # procedure: yyparse : parse input and execute indicated items
495 | ################################################################
496 | procedure yyparse()
497 |   local yyn        # next next thing to do
498 |   local yym        #
499 |   local yystate    # current parsing state from state table
500 |   local yys        # current token string
501 |   local doaction   # set to 1 if there need to execute action
502 |   local token      # current token
503 | 
504 |   if /yytable then init() 
505 |   init_stacks() 
506 |   yynerrs   := 0 
507 |   yyerrflag := 0 
508 |   yychar    := -1           # impossible char forces a read
509 |   yystate   := 0            # initial state
510 |   push(statestk, yystate)   # save it
511 | 
512 |   repeat { # until parsing is done, either correctly, or w/error
513 |     doaction := 1 
514 | 
515 |     ##### NEXT ACTION (from reduction table)
516 | 	yyn := yydefred[yystate+1]
517 | 
518 |     while yyn = 0 do {
519 | 
520 |       if yychar < 0 then {   # we want a char?
521 |         yychar := yylex()    # get next token
522 |         ##### ERROR CHECK ####
523 |         if yychar < 0 then { # it it didn't work/error
524 |           yychar := 0        # change it to default string (no -1!)
525 |           if \yydebug = 1 then yylexdebug(yystate, yychar) 
526 |           }
527 |         } # yychar < 0
528 | 	  
529 |       yyn := yysindex[yystate+1]  # get amount to shift by (shift index)
530 | 
531 |       if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
532 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
533 | 		
534 |         ##### NEXT STATE ####
535 |         yystate := yytable[yyn+1] # we are in a new state
536 |         push(statestk, yystate)   # save it
537 |         push(valstk, yylval)      # push our lval as the input for next rule
538 |         yychar := -1              # since we have 'eaten' a token, say we need another
539 |         if yyerrflag > 0 then     # have we recovered an error?
540 |            yyerrflag -:= 1        # give ourselves credit
541 |         doaction := 0             # but don't process yet
542 |         break                     # quit the yyn=0 loop
543 |         }
544 | 
545 |     yyn := yyrindex[yystate+1]    # reduce
546 | 
547 |     if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
548 |        (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
549 |       # e reduced!
550 |       yyn      := yytable[yyn+1] 
551 |       doaction := 1  # get ready to execute
552 |       break          # drop down to actions
553 |       }
554 |     else { #ERROR RECOVERY
555 |       if yyerrflag == 0 then {
556 |         (\yyerror | write)("syntax error") 
557 |         yynerrs +:= 1 
558 |       }
559 |       if yyerrflag < 3 then {     # low error count?
560 |         yyerrflag := 3 
561 |         repeat { #do until break
562 |           if *statestk < 1 then {  # check for under & overflow here
563 |             (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
564 |             return 1 
565 |           }
566 |           yyn := yysindex[statestk[1]] 
567 |           if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
568 |                     yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
569 |             yystate := yytable[yyn+1] 
570 |             push(statestk, yystate) 
571 |             push(valstk, yylval) 
572 |             doaction := 0 
573 |             break 
574 |           }
575 |           else {
576 |             if *statestk = 0 then { # check for under & overflow here
577 |               write("Stack underflow. aborting...") # capital 'S'
578 |               return 1 
579 |             }
580 |             pop(statestk) 
581 |             pop(valstk) 
582 |             }
583 |           }
584 |         }
585 |       else  # discard this token
586 |         {
587 |         if yychar = 0 then return 1  # yyabort
588 |         if \yydebug = 1 then {
589 |           yys := &null 
590 |           if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
591 |           if integer(yys) & yys = 0 then yys := "illegal-symbol" 
592 |           write("state ",  yystate, ", error recovery discards token ",
593 |                 yychar, " (", yys, ")") 
594 |           }
595 |         yychar := -1       # read another
596 |         }
597 |       } # end error recovery
598 |       yyn := yydefred[yystate+1] 
599 |     }# yyn = 0 loop
600 | 
601 |     if doaction = 0 then   # any reason not to proceed?
602 |       next                 # skip action
603 | 
604 |     yym := yylen[yyn+1]    # get count of terminals on rhs
605 |     yyval := valstk[yym]   # get current semantic value
606 |     if arv := action[yyn]() then return arv # execute the semantic action
607 | 
608 |     ##### Now let's reduce... ####
609 |     every 1 to yym do pop(statestk)# we just reduced yylen states
610 |     yystate := statestk[1]        # get new state
611 | 
612 |     every 1 to yym do pop(valstk) # corresponding value drop
613 |     yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
614 |     if yystate = 0 & yym = 0 then {
615 |                                   # done? 'rest' state and at first TERMINAL
616 |       yystate := YYFINAL          # explicitly say we're done
617 |       push(statestk, YYFINAL)     # and save it
618 |       push(valstk, yyval)         # also save the semantic value of parsing
619 |       if yychar < 0 then {        # we want another character?
620 |         yychar := yylex()         # get next character
621 |         if yychar < 0 then yychar := 0   #clean, if necessary
622 |       }
623 |       if yychar = 0 then break    # Good exit (if lex returns 0  -)
624 |                                   # quit the loop--all DONE
625 |     } # if yystate
626 |     else {                        #else not done yet
627 |       # get next state and push, for next yydefred[]
628 |       yyn := yygindex[yym+1]        # find out where to go
629 |       if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
630 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
631 |         yystate := yytable[yyn+1]   # get new state
632 |         }
633 |       else {
634 |         yystate := yydgoto[yym+1]   # else go to new defred
635 | 	     }
636 |       push(statestk, yystate)       # going again, so push state & val...
637 |       push(valstk, yyval)           # for next action
638 |       }
639 |     } # main loop
640 | 
641 |   return 0 # yyaccept!!
642 | end
643 | 
644 | ### end of procedure parse() ######################################
645 | 
646 | ### start semantic actions ########################################
647 | 
648 | procedure action_null()
649 |   #write("null action")
650 | end
651 | 
652 | 


--------------------------------------------------------------------------------
/ch4/j0gram.y:
--------------------------------------------------------------------------------
 1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
 2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
 3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
 4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
 5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
 6 | %token INCREMENT DECREMENT PUBLIC STATIC
 7 | %%
 8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody;
 9 | ClassBody: '{' ClassBodyDecls '}' | '{' '}' ;
10 | ClassBodyDecls: ClassBodyDecl | ClassBodyDecls ClassBodyDecl ;
11 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
12 | FieldDecl: Type VarDecls ';' ;
13 | Type: INT | DOUBLE | BOOL | STRING | Name ;
14 | 
15 | Name: IDENTIFIER | QualifiedName ;
16 | QualifiedName: Name '.' IDENTIFIER ;
17 | 
18 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator ;
19 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' ;
20 | 
21 | MethodReturnVal : Type | VOID ;
22 | MethodDecl: MethodHeader Block ;
23 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator ;
24 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' ;
25 | FormalParmListOpt: FormalParmList | ;
26 | FormalParmList: FormalParm | FormalParmList ',' FormalParm ;
27 | FormalParm: Type VarDeclarator ;
28 | 
29 | ConstructorDecl: ConstructorDeclarator Block ;
30 | ConstructorDeclarator: IDENTIFIER '(' FormalParmListOpt ')' ;
31 | ArgListOpt:  ArgList | ;
32 | 
33 | Block: '{' BlockStmtsOpt '}' ;
34 | BlockStmtsOpt: BlockStmts | ;
35 | BlockStmts:  BlockStmt | BlockStmts BlockStmt ;
36 | BlockStmt:   LocalVarDeclStmt | Stmt ;
37 | 
38 | LocalVarDeclStmt: LocalVarDecl ';' ;
39 | LocalVarDecl: Type VarDecls ;
40 | 
41 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt |
42 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
43 |       | WhileStmt | ForStmt ;
44 | 
45 | StmtWithoutTrailingSubstatement: 
46 | 
47 | ExprStmt: StmtExpr ';' ;
48 | 
49 | StmtExpr: Assignment | MethodCall | InstantiationExpr ;
50 | 
51 | IfThenStmt: IF '(' Expr ')' Block ;
52 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block ;
53 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence
54 |        |  IF '(' Expr ')' Block ElseIfSequence ELSE Block ;
55 | 
56 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt ;
57 | ElseIfStmt: ELSE IfThenStmt ;
58 | WhileStmt: WHILE '(' Expr ')' Stmt ;
59 | 
60 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block ;
61 | ForInit: StmtExprList | LocalVarDecl | ;
62 | ExprOpt: Expr |  ;
63 | ForUpdate: StmtExprList | ;
64 | 
65 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr ;
66 | 
67 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' ;
68 | ReturnStmt: RETURN ExprOpt ';' ;
69 | 
70 | Primary:  Literal | '(' Expr ')' | FieldAccess | MethodCall ;
71 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
72 | 
73 | InstantiationExpr: Name '(' ArgListOpt ')' ;
74 | ArgList: Expr | ArgList ',' Expr ;
75 | FieldAccess: Primary '.' IDENTIFIER ;
76 | 
77 | MethodCall: Name '(' ArgListOpt ')'
78 | 	| Name '{' ArgListOpt '}'
79 | 	| Primary '.' IDENTIFIER '(' ArgListOpt ')'
80 | 	| Primary '.' IDENTIFIER '{' ArgListOpt '}' ;
81 | 
82 | PostFixExpr: Primary | Name ;
83 | UnaryExpr:  '-' UnaryExpr | '!' UnaryExpr | PostFixExpr ;
84 | MulExpr: UnaryExpr | MulExpr '*' UnaryExpr
85 |     | MulExpr '/' UnaryExpr | MulExpr '%' UnaryExpr ;
86 | AddExpr: MulExpr | AddExpr '+' MulExpr | AddExpr '-' MulExpr ;
87 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
88 | RelExpr: AddExpr | RelExpr RelOp AddExpr ;
89 | 
90 | EqExpr: RelExpr | EqExpr ISEQUALTO RelExpr | EqExpr NOTEQUALTO RelExpr ;
91 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr ;
92 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr ;
93 | 
94 | Expr: CondOrExpr | Assignment ;
95 | Assignment: LeftHandSide AssignOp Expr ;
96 | LeftHandSide: Name | FieldAccess ;
97 | AssignOp: '=' | INCREMENT | DECREMENT ;
98 | 


--------------------------------------------------------------------------------
/ch4/j0gram_tab.icn:
--------------------------------------------------------------------------------
 1 | class Parser(BREAK, DOUBLE, ELSE, FOR, IF, INT, RETURN, VOID, WHILE, IDENTIFIER, CLASSNAME, CLASS, STRING, BOOL, INTLIT, DOUBLELIT, STRINGLIT, BOOLLIT, NULLVAL, LESSTHANOREQUAL, GREATERTHANOREQUAL, ISEQUALTO, NOTEQUALTO, LOGICALAND, LOGICALOR, INCREMENT, DECREMENT, PUBLIC, STATIC)
 2 | initially
 3 |    BREAK := 257
 4 |    DOUBLE := 258
 5 |    ELSE := 259
 6 |    FOR := 260
 7 |    IF := 261
 8 |    INT := 262
 9 |    RETURN := 263
10 |    VOID := 264
11 |    WHILE := 265
12 |    IDENTIFIER := 266
13 |    CLASSNAME := 267
14 |    CLASS := 268
15 |    STRING := 269
16 |    BOOL := 270
17 |    INTLIT := 271
18 |    DOUBLELIT := 272
19 |    STRINGLIT := 273
20 |    BOOLLIT := 274
21 |    NULLVAL := 275
22 |    LESSTHANOREQUAL := 276
23 |    GREATERTHANOREQUAL := 277
24 |    ISEQUALTO := 278
25 |    NOTEQUALTO := 279
26 |    LOGICALAND := 280
27 |    LOGICALOR := 281
28 |    INCREMENT := 282
29 |    DECREMENT := 283
30 |    PUBLIC := 284
31 |    STATIC := 285
32 | end
33 | 


--------------------------------------------------------------------------------
/ch4/javalex.icn:
--------------------------------------------------------------------------------
   1 | #
   2 | # uflex skeleton.
   3 | # do not edit by hand, this file is machine-generated
   4 | #
   5 | 
   6 | record edge(symbol, destinations)
   7 | record anode(label, rulenum, edges, epsilon, dot)
   8 | record automata(start, states, accepting)
   9 | 
  10 | global yychar, yytext, yyin, yyleng
  11 | 
  12 | #
  13 | # matchstrings reads from a specified input file and calls the simulate
  14 | # function repeatedly on smaller and smaller pieces of the input until
  15 | # it finds a match. It reports what parts of the input
  16 | # it could parse and what rule accepted the string.
  17 | #
  18 | 
  19 | global stringseq
  20 | 
  21 | procedure yyulex(aut)
  22 | local rulenum, readfrom, position, less, currstring, getln
  23 | local maxrule, maxleng
  24 | 
  25 | initial {
  26 |    if /yyin then yyin := &input
  27 |    readfrom := yyin
  28 | 
  29 |    stringseq := read(readfrom) || "\n"
  30 | 
  31 |    while getln := read(readfrom) do
  32 |       stringseq ||:= getln || "\n"
  33 | 
  34 |    close(readfrom)
  35 |    }
  36 | 
  37 |    repeat {
  38 |       if stringseq == "" then {
  39 |          yychar := -1
  40 |          fail
  41 |          }
  42 | 
  43 |       leng := 1
  44 |       while i := simulate(aut, stringseq[1:leng+1]) do {
  45 |          if i > 0 then {
  46 |             maxrule := i
  47 |             maxleng := leng
  48 |          }
  49 |          leng +:= 1
  50 |       }
  51 |       if \maxrule then {
  52 |          yytext := stringseq[1 : maxleng+1]; yyleng := maxleng
  53 |          stringseq := stringseq[maxleng+1:0]
  54 |          if yychar := (semantic_action)[maxrule] () then return yychar
  55 |       } else {
  56 |          writes(stringseq[1])
  57 |          stringseq := stringseq[2:0]
  58 |       }
  59 |    }
  60 | end
  61 | 
  62 | #
  63 | # simulate(automata, word) determines whether or not the word
  64 | # would be accepted by the given automata. It gets the possible
  65 | # destinations at each symbol of the string and then adds on wherever it
  66 | # could also get if we use any epsilon transitions out of those states.
  67 | # Then the list of accepting states is compared to the reachable set
  68 | # of states to determine if the word was accepted and by which rule.
  69 | #
  70 | procedure simulate(myaut, word)
  71 | local first, currstates, acceptcheck, currsymbol, build, rv
  72 |    currstates := list(0) # should be set()
  73 |    put(currstates, myaut.start) # insert(currstates, myaut.start)
  74 |    acceptcheck := copy(myaut.accepting)
  75 |    currsymbol := word
  76 |    while *currsymbol > 0 do {
  77 |       currstates := getdestinations(currstates, currsymbol)
  78 |       if *currstates = 0 then
  79 |          fail
  80 |       currsymbol := currsymbol[2:0]
  81 |       }
  82 |    while *acceptcheck > 0 do {
  83 |       value1 := pop(acceptcheck)
  84 |       check2 := copy(currstates)
  85 | 
  86 |       while *check2 > 0 do {
  87 |          value2 := pop(check2)
  88 | 
  89 |          if value1.label = value2.label then {
  90 |             if /rv | rv > value1.rulenum then
  91 |                rv := value1.rulenum
  92 |             }
  93 |          }
  94 |       }
  95 |    if \yydebug>0 then write("simulate() returns ", image(\rv)|0)
  96 |    return \rv | -(currstates[1].label)
  97 | end
  98 | 
  99 | #
 100 | # like |||:= except no duplicates. Destructive of L1 but not L2
 101 | #
 102 | procedure yyunionin(L1, L2)
 103 | t1 := table()
 104 |   every x := !L1 do {
 105 |      t1[x.label] := x
 106 |      }
 107 |   every x := !L2 do {
 108 |      if /t1[x.label] then {
 109 |         t1[x.label] := x
 110 |          put(L1, x)
 111 |          }
 112 |       }
 113 | end
 114 | procedure yyonein(L1, L2)
 115 |   if (!L1).label === L2[1].label then fail
 116 |   put(L1, L2[1])
 117 | end
 118 | 
 119 | #
 120 | # getdestinations uses the current set of states and
 121 | # simulates one step of automata computation on the given
 122 | # string and returns the resulting set of destinations
 123 | #
 124 | procedure getdestinations(currstates, currsymbol)
 125 | local result, current, buildresult, reached
 126 | 
 127 |    result := list(0)
 128 |    if *currstates ~= 0 then {
 129 | 
 130 |       buildresult := copy(currstates)
 131 |       while *buildresult > 0 do {
 132 |           reached := reach(pop(buildresult), currsymbol)
 133 |           if *reached>0 then {
 134 |              yyunionin(result, reached)
 135 |              }
 136 |           }
 137 |        }
 138 |     return result
 139 | end
 140 | 
 141 | #
 142 | # reach returns the list of states that can be reached
 143 | # on character symbol from the state state.
 144 | #
 145 | procedure reach(state, symbol)
 146 | local edgeset, answer, edgesymbol, bound1, bound2, curredge
 147 | 
 148 |    edgeset := copy(state.edges)
 149 |    answer := list(0)
 150 | 
 151 |    while *edgeset > 0 do {
 152 |       curredge := pop(edgeset)
 153 |       edgesymbol := copy(curredge.symbol)
 154 |       if type(edgesymbol) == "cset" then {
 155 |          if any(edgesymbol, symbol[1]) then {
 156 |             yyunionin(answer, curredge.destinations)
 157 |           }
 158 |       }
 159 |       else {
 160 |       if (edgesymbol[1] == symbol[1] ~== "[") |
 161 |          (edgesymbol == symbol[1] == "[") then # sometimes a [ is just a [
 162 |              yyunionin(answer, curredge.destinations)
 163 | 
 164 |       else if edgesymbol[1] == "\\" then {
 165 |          if (edgesymbol[2] == "n") & (symbol[1] == "\n") then
 166 |             yyunionin(answer, curredge.destinations)
 167 |          else if (edgesymbol[2] == "t") & (symbol[1] == "\t") then
 168 |             yyunionin(answer, curredge.destinations)
 169 |          else if (edgesymbol[2] == "r") & (symbol[1] == "\r") then
 170 |             yyunionin(answer, curredge.destinations)
 171 |          else if (edgesymbol[2] == "f") & (symbol[1] == "\f") then
 172 |             yyunionin(answer, curredge.destinations)
 173 |          else if (edgesymbol[2] == "\\") & (symbol[1] == "\\") then
 174 |             yyunionin(answer, curredge.destinations)
 175 |          # should handle all escapes here, and error on bogus ones
 176 |          else if edgesymbol[2] == symbol[1] then
 177 |             yyunionin(answer, curredge.destinations)
 178 |          } # escape
 179 | 
 180 | 
 181 |       }
 182 | 
 183 |       } # while edgeset > 0
 184 |    if *(state.dot)>0 then {
 185 |       yyunionin(answer, state.dot)
 186 |       }
 187 |    return answer
 188 | end
 189 | 
 190 | # "recset" == "regular expression cset"
 191 | procedure csetfromrecset(recset)
 192 | local rv, lastchar, origcset := recset
 193 |    if not (recset[1]=="[" & recset[-1]=="]") then
 194 |       stop("malformed recset ", image(recset))
 195 |    recset := recset[2:-1]
 196 | 
 197 |    if recset[1]=="^" then { # not in this cset, subtract from &cset
 198 |       rv := &cset -- csetfromrecset("["||recset[2:0]||"]")
 199 |       return rv
 200 |       }
 201 |    # positive cset construction
 202 |    rv := ''
 203 |    while *recset>0 do {
 204 | 
 205 |       if recset[1] == "-" & \lastchar & *recset>1 then
 206 |          genrangefrom := lastchar
 207 |       else {
 208 |          # did not trigger a new range. Process one char
 209 | 
 210 |          if recset[1] == "\\" then { # escape
 211 |             recset := recset[2:0]
 212 |             case recset[1] of {
 213 |                "n":  recset[1] := "\n"
 214 |                "t":  recset[1] := "\t"
 215 |                "r":  recset[1] := "\r"
 216 |                "v":  recset[1] := "\v"
 217 |                "-":  recset[1] := "\-"
 218 |                "f":  recset[1] := "\f"
 219 |                "'":  recset[1] := "\'"
 220 |                "\"":  recset[1] := "\""
 221 |                "\\": recset[1] := "\\"
 222 |                "0": {
 223 |                   if any('01234567', recset[2]) then {
 224 |                      if any('01234567', recset[3]) then {
 225 |                         o := char(recset[1]*64+recset[2]*8+recset[3])
 226 |                         recset := o || recset[4:0]
 227 |                      }
 228 |                      else stop("argh2 ", image(recset))
 229 |                      }
 230 |                   else recset[1] := "\0"
 231 |                }
 232 |                # should handle all escapes here, and error on bogus ones
 233 |                default: stop("unrecognized escape ", image(recset[1]))
 234 |                }
 235 |             }
 236 | 
 237 |          rv ++:= recset[1]
 238 | 
 239 |          if \genrangefrom then { #if we have a pending range
 240 |             ord1 := ord(genrangefrom)
 241 |              ord2 := ord(recset[1])
 242 |              while ord1 < ord2 do {
 243 |                rv ++:= char(ord1)
 244 |                ord1 +:= 1
 245 |                }
 246 |             genrangefrom := &null
 247 |             }
 248 |          lastchar := recset[1]
 249 |           }
 250 |        recset := recset[2:0]
 251 |        }
 252 | 
 253 |    return rv
 254 | end
 255 | 
 256 | procedure printautomaton(a)
 257 |    write("Automaton:")
 258 |    write("start: ", image(a.start.label),
 259 |          " for rulenum ", image(a.start.rulenum))
 260 |    write("states:")
 261 |    every printstate(!a.states)
 262 |    writes("accepting: ")
 263 |    every writes((!a.accepting).label, " ")
 264 |    write()
 265 | end
 266 | 
 267 | procedure printstate(state)
 268 |    write("state ", state.label, " is for rule #", state.rulenum)
 269 |    if (*state.edges)>0 then {
 270 |       writes("\tedges: "); every printedge(!state.edges); write()
 271 |       }
 272 |    if *state.epsilon>0 then {
 273 |       writes("\tepsilon: ")
 274 |       every writes((!state.epsilon).label, " "); write()
 275 |       }
 276 |    if (*state.dot)>0 then {
 277 |       writes("\tdot: ")
 278 |       every writes((!state.dot).label, " "); write()
 279 |       }
 280 | end
 281 | 
 282 | procedure printedge(edge)
 283 |    writes(image(edge.symbol), " -> ")
 284 |    every writes((!edge.destinations).label)
 285 |    writes("; ")
 286 | end
 287 | 
 288 | procedure printstates(states)
 289 | local statecopy, current
 290 | 
 291 |    write("printstates size ", *states, " in entity ", image(states))
 292 |    statecopy := copy(states)
 293 | 
 294 |    while *statecopy > 1 do {
 295 |       current := pop(statecopy)
 296 |       write(current.label, ", ")
 297 |       }
 298 | 
 299 |    if *statecopy > 0 then {
 300 |       current := pop(statecopy)
 301 |       write(current.label)
 302 |       }
 303 |     else write("state list is empty")
 304 | end
 305 | global semantic_action
 306 | 
 307 | procedure yylex()
 308 | static myautomata
 309 | local currstate, state2, tempedge
 310 | 
 311 |  initial {
 312 |    myautomata := automata()
 313 | 
 314 |    myautomata.states := []
 315 |    myautomata.accepting := []
 316 |    put(myautomata.states, currstate := anode(1, 0, [], [], []))
 317 |    myautomata.start := currstate
 318 | 
 319 |    put(myautomata.states, currstate := anode(2, 3, [], [], []))
 320 |    put(myautomata.accepting, currstate)
 321 | 
 322 |    put(myautomata.states, currstate := anode(3, 4, [], [], []))
 323 |    put(myautomata.accepting, currstate)
 324 | 
 325 |    put(myautomata.states, currstate := anode(4, 0, [], [], []))
 326 | 
 327 |    put(myautomata.states, currstate := anode(5, 0, [], [], []))
 328 | 
 329 |    put(myautomata.states, currstate := anode(6, 0, [], [], []))
 330 | 
 331 |    put(myautomata.states, currstate := anode(7, 0, [], [], []))
 332 | 
 333 |    put(myautomata.states, currstate := anode(8, 0, [], [], []))
 334 | 
 335 |    put(myautomata.states, currstate := anode(9, 0, [], [], []))
 336 | 
 337 |    put(myautomata.states, currstate := anode(10, 0, [], [], []))
 338 | 
 339 |    put(myautomata.states, currstate := anode(11, 0, [], [], []))
 340 | 
 341 |    put(myautomata.states, currstate := anode(12, 0, [], [], []))
 342 | 
 343 |    put(myautomata.states, currstate := anode(13, 0, [], [], []))
 344 | 
 345 |    put(myautomata.states, currstate := anode(14, 0, [], [], []))
 346 | 
 347 |    put(myautomata.states, currstate := anode(15, 0, [], [], []))
 348 | 
 349 |    put(myautomata.states, currstate := anode(16, 0, [], [], []))
 350 | 
 351 |    put(myautomata.states, currstate := anode(17, 22, [], [], []))
 352 |    put(myautomata.accepting, currstate)
 353 | 
 354 |    put(myautomata.states, currstate := anode(18, 23, [], [], []))
 355 |    put(myautomata.accepting, currstate)
 356 | 
 357 |    put(myautomata.states, currstate := anode(19, 24, [], [], []))
 358 |    put(myautomata.accepting, currstate)
 359 | 
 360 |    put(myautomata.states, currstate := anode(20, 25, [], [], []))
 361 |    put(myautomata.accepting, currstate)
 362 | 
 363 |    put(myautomata.states, currstate := anode(21, 26, [], [], []))
 364 |    put(myautomata.accepting, currstate)
 365 | 
 366 |    put(myautomata.states, currstate := anode(22, 27, [], [], []))
 367 |    put(myautomata.accepting, currstate)
 368 | 
 369 |    put(myautomata.states, currstate := anode(23, 28, [], [], []))
 370 |    put(myautomata.accepting, currstate)
 371 | 
 372 |    put(myautomata.states, currstate := anode(24, 29, [], [], []))
 373 |    put(myautomata.accepting, currstate)
 374 | 
 375 |    put(myautomata.states, currstate := anode(25, 31, [], [], []))
 376 |    put(myautomata.accepting, currstate)
 377 | 
 378 |    put(myautomata.states, currstate := anode(26, 32, [], [], []))
 379 |    put(myautomata.accepting, currstate)
 380 | 
 381 |    put(myautomata.states, currstate := anode(27, 33, [], [], []))
 382 |    put(myautomata.accepting, currstate)
 383 | 
 384 |    put(myautomata.states, currstate := anode(28, 36, [], [], []))
 385 |    put(myautomata.accepting, currstate)
 386 | 
 387 |    put(myautomata.states, currstate := anode(29, 38, [], [], []))
 388 |    put(myautomata.accepting, currstate)
 389 | 
 390 |    put(myautomata.states, currstate := anode(30, 30, [], [], []))
 391 |    put(myautomata.accepting, currstate)
 392 | 
 393 |    put(myautomata.states, currstate := anode(31, 0, [], [], []))
 394 | 
 395 |    put(myautomata.states, currstate := anode(32, 0, [], [], []))
 396 | 
 397 |    put(myautomata.states, currstate := anode(33, 34, [], [], []))
 398 |    put(myautomata.accepting, currstate)
 399 | 
 400 |    put(myautomata.states, currstate := anode(34, 35, [], [], []))
 401 |    put(myautomata.accepting, currstate)
 402 | 
 403 |    put(myautomata.states, currstate := anode(35, 44, [], [], []))
 404 |    put(myautomata.accepting, currstate)
 405 | 
 406 |    put(myautomata.states, currstate := anode(36, 47, [], [], []))
 407 |    put(myautomata.accepting, currstate)
 408 | 
 409 |    put(myautomata.states, currstate := anode(37, 49, [], [], []))
 410 |    put(myautomata.accepting, currstate)
 411 | 
 412 |    put(myautomata.states, currstate := anode(38, 48, [], [], []))
 413 |    put(myautomata.accepting, currstate)
 414 | 
 415 |    put(myautomata.states, currstate := anode(39, 50, [], [], []))
 416 |    put(myautomata.accepting, currstate)
 417 | 
 418 |    put(myautomata.states, currstate := anode(40, 0, [], [], []))
 419 | 
 420 |    put(myautomata.states, currstate := anode(41, 54, [], [], []))
 421 |    put(myautomata.accepting, currstate)
 422 | 
 423 |    put(myautomata.states, currstate := anode(42, 0, [], [], []))
 424 | 
 425 |    put(myautomata.states, currstate := anode(43, 0, [], [], []))
 426 | 
 427 |    put(myautomata.states, currstate := anode(44, 0, [], [], []))
 428 | 
 429 |    put(myautomata.states, currstate := anode(45, 0, [], [], []))
 430 | 
 431 |    put(myautomata.states, currstate := anode(46, 0, [], [], []))
 432 | 
 433 |    put(myautomata.states, currstate := anode(47, 0, [], [], []))
 434 | 
 435 |    put(myautomata.states, currstate := anode(48, 0, [], [], []))
 436 | 
 437 |    put(myautomata.states, currstate := anode(49, 0, [], [], []))
 438 | 
 439 |    put(myautomata.states, currstate := anode(50, 0, [], [], []))
 440 | 
 441 |    put(myautomata.states, currstate := anode(51, 0, [], [], []))
 442 | 
 443 |    put(myautomata.states, currstate := anode(52, 0, [], [], []))
 444 | 
 445 |    put(myautomata.states, currstate := anode(53, 10, [], [], []))
 446 |    put(myautomata.accepting, currstate)
 447 | 
 448 |    put(myautomata.states, currstate := anode(54, 0, [], [], []))
 449 | 
 450 |    put(myautomata.states, currstate := anode(55, 0, [], [], []))
 451 | 
 452 |    put(myautomata.states, currstate := anode(56, 0, [], [], []))
 453 | 
 454 |    put(myautomata.states, currstate := anode(57, 0, [], [], []))
 455 | 
 456 |    put(myautomata.states, currstate := anode(58, 0, [], [], []))
 457 | 
 458 |    put(myautomata.states, currstate := anode(59, 0, [], [], []))
 459 | 
 460 |    put(myautomata.states, currstate := anode(60, 37, [], [], []))
 461 |    put(myautomata.accepting, currstate)
 462 | 
 463 |    put(myautomata.states, currstate := anode(61, 39, [], [], []))
 464 |    put(myautomata.accepting, currstate)
 465 | 
 466 |    put(myautomata.states, currstate := anode(62, 41, [], [], []))
 467 |    put(myautomata.accepting, currstate)
 468 | 
 469 |    put(myautomata.states, currstate := anode(63, 42, [], [], []))
 470 |    put(myautomata.accepting, currstate)
 471 | 
 472 |    put(myautomata.states, currstate := anode(64, 43, [], [], []))
 473 |    put(myautomata.accepting, currstate)
 474 | 
 475 |    put(myautomata.states, currstate := anode(65, 45, [], [], []))
 476 |    put(myautomata.accepting, currstate)
 477 | 
 478 |    put(myautomata.states, currstate := anode(66, 46, [], [], []))
 479 |    put(myautomata.accepting, currstate)
 480 | 
 481 |    put(myautomata.states, currstate := anode(67, 40, [], [], []))
 482 |    put(myautomata.accepting, currstate)
 483 | 
 484 |    put(myautomata.states, currstate := anode(68, 49, [], [], []))
 485 |    put(myautomata.accepting, currstate)
 486 | 
 487 |    put(myautomata.states, currstate := anode(69, 0, [], [], []))
 488 | 
 489 |    put(myautomata.states, currstate := anode(70, 0, [], [], []))
 490 | 
 491 |    put(myautomata.states, currstate := anode(71, 0, [], [], []))
 492 | 
 493 |    put(myautomata.states, currstate := anode(72, 0, [], [], []))
 494 | 
 495 |    put(myautomata.states, currstate := anode(73, 0, [], [], []))
 496 | 
 497 |    put(myautomata.states, currstate := anode(74, 0, [], [], []))
 498 | 
 499 |    put(myautomata.states, currstate := anode(75, 53, [], [], []))
 500 |    put(myautomata.accepting, currstate)
 501 | 
 502 |    put(myautomata.states, currstate := anode(76, 9, [], [], []))
 503 |    put(myautomata.accepting, currstate)
 504 | 
 505 |    put(myautomata.states, currstate := anode(77, 0, [], [], []))
 506 | 
 507 |    put(myautomata.states, currstate := anode(78, 0, [], [], []))
 508 | 
 509 |    put(myautomata.states, currstate := anode(79, 0, [], [], []))
 510 | 
 511 |    put(myautomata.states, currstate := anode(80, 0, [], [], []))
 512 | 
 513 |    put(myautomata.states, currstate := anode(81, 0, [], [], []))
 514 | 
 515 |    put(myautomata.states, currstate := anode(82, 0, [], [], []))
 516 | 
 517 |    put(myautomata.states, currstate := anode(83, 0, [], [], []))
 518 | 
 519 |    put(myautomata.states, currstate := anode(84, 0, [], [], []))
 520 | 
 521 |    put(myautomata.states, currstate := anode(85, 0, [], [], []))
 522 | 
 523 |    put(myautomata.states, currstate := anode(86, 0, [], [], []))
 524 | 
 525 |    put(myautomata.states, currstate := anode(87, 11, [], [], []))
 526 |    put(myautomata.accepting, currstate)
 527 | 
 528 |    put(myautomata.states, currstate := anode(88, 0, [], [], []))
 529 | 
 530 |    put(myautomata.states, currstate := anode(89, 0, [], [], []))
 531 | 
 532 |    put(myautomata.states, currstate := anode(90, 0, [], [], []))
 533 | 
 534 |    put(myautomata.states, currstate := anode(91, 0, [], [], []))
 535 | 
 536 |    put(myautomata.states, currstate := anode(92, 0, [], [], []))
 537 | 
 538 |    put(myautomata.states, currstate := anode(93, 0, [], [], []))
 539 | 
 540 |    put(myautomata.states, currstate := anode(94, 2, [], [], []))
 541 |    put(myautomata.accepting, currstate)
 542 | 
 543 |    put(myautomata.states, currstate := anode(95, 0, [], [], []))
 544 | 
 545 |    put(myautomata.states, currstate := anode(96, 0, [], [], []))
 546 | 
 547 |    put(myautomata.states, currstate := anode(97, 0, [], [], []))
 548 | 
 549 |    put(myautomata.states, currstate := anode(98, 51, [], [], []))
 550 |    put(myautomata.accepting, currstate)
 551 | 
 552 |    put(myautomata.states, currstate := anode(99, 0, [], [], []))
 553 | 
 554 |    put(myautomata.states, currstate := anode(100, 52, [], [], []))
 555 |    put(myautomata.accepting, currstate)
 556 | 
 557 |    put(myautomata.states, currstate := anode(101, 0, [], [], []))
 558 | 
 559 |    put(myautomata.states, currstate := anode(102, 0, [], [], []))
 560 | 
 561 |    put(myautomata.states, currstate := anode(103, 0, [], [], []))
 562 | 
 563 |    put(myautomata.states, currstate := anode(104, 12, [], [], []))
 564 |    put(myautomata.accepting, currstate)
 565 | 
 566 |    put(myautomata.states, currstate := anode(105, 17, [], [], []))
 567 |    put(myautomata.accepting, currstate)
 568 | 
 569 |    put(myautomata.states, currstate := anode(106, 0, [], [], []))
 570 | 
 571 |    put(myautomata.states, currstate := anode(107, 0, [], [], []))
 572 | 
 573 |    put(myautomata.states, currstate := anode(108, 18, [], [], []))
 574 |    put(myautomata.accepting, currstate)
 575 | 
 576 |    put(myautomata.states, currstate := anode(109, 19, [], [], []))
 577 |    put(myautomata.accepting, currstate)
 578 | 
 579 |    put(myautomata.states, currstate := anode(110, 0, [], [], []))
 580 | 
 581 |    put(myautomata.states, currstate := anode(111, 0, [], [], []))
 582 | 
 583 |    put(myautomata.states, currstate := anode(112, 7, [], [], []))
 584 |    put(myautomata.accepting, currstate)
 585 | 
 586 |    put(myautomata.states, currstate := anode(113, 0, [], [], []))
 587 | 
 588 |    put(myautomata.states, currstate := anode(114, 0, [], [], []))
 589 | 
 590 |    put(myautomata.states, currstate := anode(115, 0, [], [], []))
 591 | 
 592 |    put(myautomata.states, currstate := anode(116, 0, [], [], []))
 593 | 
 594 |    put(myautomata.states, currstate := anode(117, 1, [], [], []))
 595 |    put(myautomata.accepting, currstate)
 596 | 
 597 |    put(myautomata.states, currstate := anode(118, 8, [], [], []))
 598 |    put(myautomata.accepting, currstate)
 599 | 
 600 |    put(myautomata.states, currstate := anode(119, 0, [], [], []))
 601 | 
 602 |    put(myautomata.states, currstate := anode(120, 0, [], [], []))
 603 | 
 604 |    put(myautomata.states, currstate := anode(121, 5, [], [], []))
 605 |    put(myautomata.accepting, currstate)
 606 | 
 607 |    put(myautomata.states, currstate := anode(122, 0, [], [], []))
 608 | 
 609 |    put(myautomata.states, currstate := anode(123, 20, [], [], []))
 610 |    put(myautomata.accepting, currstate)
 611 | 
 612 |    put(myautomata.states, currstate := anode(124, 21, [], [], []))
 613 |    put(myautomata.accepting, currstate)
 614 | 
 615 |    put(myautomata.states, currstate := anode(125, 0, [], [], []))
 616 | 
 617 |    put(myautomata.states, currstate := anode(126, 0, [], [], []))
 618 | 
 619 |    put(myautomata.states, currstate := anode(127, 13, [], [], []))
 620 |    put(myautomata.accepting, currstate)
 621 | 
 622 |    put(myautomata.states, currstate := anode(128, 14, [], [], []))
 623 |    put(myautomata.accepting, currstate)
 624 | 
 625 |    put(myautomata.states, currstate := anode(129, 6, [], [], []))
 626 |    put(myautomata.accepting, currstate)
 627 | 
 628 |    put(myautomata.states, currstate := anode(130, 16, [], [], []))
 629 |    put(myautomata.accepting, currstate)
 630 | 
 631 |    put(myautomata.states, currstate := anode(131, 15, [], [], []))
 632 |    put(myautomata.accepting, currstate)
 633 | 
 634 |    currstate := pop(myautomata.states)
 635 |    put(myautomata.states, currstate)
 636 | 
 637 |    while currstate.label ~= 1 do {
 638 |       currstate := pop(myautomata.states)
 639 |       put(myautomata.states, currstate)
 640 |       }
 641 |    state2 := currstate
 642 | 
 643 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
 644 |    currstate := pop(myautomata.states)
 645 |    put(myautomata.states, currstate)
 646 | 
 647 |    while currstate.label ~= 2 do {
 648 |       currstate := pop(myautomata.states)
 649 |       put(myautomata.states, currstate)
 650 |       }
 651 |    put(tempedge.destinations, currstate)
 652 | 
 653 |    put(state2.edges, tempedge)
 654 |    tempedge := edge("\n"
 655 | , [])
 656 |    currstate := pop(myautomata.states)
 657 |    put(myautomata.states, currstate)
 658 | 
 659 |    while currstate.label ~= 3 do {
 660 |       currstate := pop(myautomata.states)
 661 |       put(myautomata.states, currstate)
 662 |       }
 663 |    put(tempedge.destinations, currstate)
 664 | 
 665 |    put(state2.edges, tempedge)
 666 |    tempedge := edge("f", [])
 667 |    currstate := pop(myautomata.states)
 668 |    put(myautomata.states, currstate)
 669 | 
 670 |    while currstate.label ~= 4 do {
 671 |       currstate := pop(myautomata.states)
 672 |       put(myautomata.states, currstate)
 673 |       }
 674 |    put(tempedge.destinations, currstate)
 675 | 
 676 |    put(state2.edges, tempedge)
 677 |    tempedge := edge("p", [])
 678 |    currstate := pop(myautomata.states)
 679 |    put(myautomata.states, currstate)
 680 | 
 681 |    while currstate.label ~= 5 do {
 682 |       currstate := pop(myautomata.states)
 683 |       put(myautomata.states, currstate)
 684 |       }
 685 |    put(tempedge.destinations, currstate)
 686 | 
 687 |    put(state2.edges, tempedge)
 688 |    tempedge := edge("n", [])
 689 |    currstate := pop(myautomata.states)
 690 |    put(myautomata.states, currstate)
 691 | 
 692 |    while currstate.label ~= 6 do {
 693 |       currstate := pop(myautomata.states)
 694 |       put(myautomata.states, currstate)
 695 |       }
 696 |    put(tempedge.destinations, currstate)
 697 | 
 698 |    put(state2.edges, tempedge)
 699 |    tempedge := edge("t", [])
 700 |    currstate := pop(myautomata.states)
 701 |    put(myautomata.states, currstate)
 702 | 
 703 |    while currstate.label ~= 7 do {
 704 |       currstate := pop(myautomata.states)
 705 |       put(myautomata.states, currstate)
 706 |       }
 707 |    put(tempedge.destinations, currstate)
 708 | 
 709 |    put(state2.edges, tempedge)
 710 |    tempedge := edge("r", [])
 711 |    currstate := pop(myautomata.states)
 712 |    put(myautomata.states, currstate)
 713 | 
 714 |    while currstate.label ~= 8 do {
 715 |       currstate := pop(myautomata.states)
 716 |       put(myautomata.states, currstate)
 717 |       }
 718 |    put(tempedge.destinations, currstate)
 719 | 
 720 |    put(state2.edges, tempedge)
 721 |    tempedge := edge("b", [])
 722 |    currstate := pop(myautomata.states)
 723 |    put(myautomata.states, currstate)
 724 | 
 725 |    while currstate.label ~= 9 do {
 726 |       currstate := pop(myautomata.states)
 727 |       put(myautomata.states, currstate)
 728 |       }
 729 |    put(tempedge.destinations, currstate)
 730 | 
 731 |    put(state2.edges, tempedge)
 732 |    tempedge := edge("v", [])
 733 |    currstate := pop(myautomata.states)
 734 |    put(myautomata.states, currstate)
 735 | 
 736 |    while currstate.label ~= 10 do {
 737 |       currstate := pop(myautomata.states)
 738 |       put(myautomata.states, currstate)
 739 |       }
 740 |    put(tempedge.destinations, currstate)
 741 | 
 742 |    put(state2.edges, tempedge)
 743 |    tempedge := edge("d", [])
 744 |    currstate := pop(myautomata.states)
 745 |    put(myautomata.states, currstate)
 746 | 
 747 |    while currstate.label ~= 11 do {
 748 |       currstate := pop(myautomata.states)
 749 |       put(myautomata.states, currstate)
 750 |       }
 751 |    put(tempedge.destinations, currstate)
 752 | 
 753 |    put(state2.edges, tempedge)
 754 |    tempedge := edge("w", [])
 755 |    currstate := pop(myautomata.states)
 756 |    put(myautomata.states, currstate)
 757 | 
 758 |    while currstate.label ~= 12 do {
 759 |       currstate := pop(myautomata.states)
 760 |       put(myautomata.states, currstate)
 761 |       }
 762 |    put(tempedge.destinations, currstate)
 763 | 
 764 |    put(state2.edges, tempedge)
 765 |    tempedge := edge("i", [])
 766 |    currstate := pop(myautomata.states)
 767 |    put(myautomata.states, currstate)
 768 | 
 769 |    while currstate.label ~= 13 do {
 770 |       currstate := pop(myautomata.states)
 771 |       put(myautomata.states, currstate)
 772 |       }
 773 |    put(tempedge.destinations, currstate)
 774 | 
 775 |    put(state2.edges, tempedge)
 776 |    tempedge := edge("e", [])
 777 |    currstate := pop(myautomata.states)
 778 |    put(myautomata.states, currstate)
 779 | 
 780 |    while currstate.label ~= 14 do {
 781 |       currstate := pop(myautomata.states)
 782 |       put(myautomata.states, currstate)
 783 |       }
 784 |    put(tempedge.destinations, currstate)
 785 | 
 786 |    put(state2.edges, tempedge)
 787 |    tempedge := edge("c", [])
 788 |    currstate := pop(myautomata.states)
 789 |    put(myautomata.states, currstate)
 790 | 
 791 |    while currstate.label ~= 15 do {
 792 |       currstate := pop(myautomata.states)
 793 |       put(myautomata.states, currstate)
 794 |       }
 795 |    put(tempedge.destinations, currstate)
 796 | 
 797 |    put(state2.edges, tempedge)
 798 |    tempedge := edge("s", [])
 799 |    currstate := pop(myautomata.states)
 800 |    put(myautomata.states, currstate)
 801 | 
 802 |    while currstate.label ~= 16 do {
 803 |       currstate := pop(myautomata.states)
 804 |       put(myautomata.states, currstate)
 805 |       }
 806 |    put(tempedge.destinations, currstate)
 807 | 
 808 |    put(state2.edges, tempedge)
 809 |    tempedge := edge("(", [])
 810 |    currstate := pop(myautomata.states)
 811 |    put(myautomata.states, currstate)
 812 | 
 813 |    while currstate.label ~= 17 do {
 814 |       currstate := pop(myautomata.states)
 815 |       put(myautomata.states, currstate)
 816 |       }
 817 |    put(tempedge.destinations, currstate)
 818 | 
 819 |    put(state2.edges, tempedge)
 820 |    tempedge := edge(")", [])
 821 |    currstate := pop(myautomata.states)
 822 |    put(myautomata.states, currstate)
 823 | 
 824 |    while currstate.label ~= 18 do {
 825 |       currstate := pop(myautomata.states)
 826 |       put(myautomata.states, currstate)
 827 |       }
 828 |    put(tempedge.destinations, currstate)
 829 | 
 830 |    put(state2.edges, tempedge)
 831 |    tempedge := edge("[", [])
 832 |    currstate := pop(myautomata.states)
 833 |    put(myautomata.states, currstate)
 834 | 
 835 |    while currstate.label ~= 19 do {
 836 |       currstate := pop(myautomata.states)
 837 |       put(myautomata.states, currstate)
 838 |       }
 839 |    put(tempedge.destinations, currstate)
 840 | 
 841 |    put(state2.edges, tempedge)
 842 |    tempedge := edge("]", [])
 843 |    currstate := pop(myautomata.states)
 844 |    put(myautomata.states, currstate)
 845 | 
 846 |    while currstate.label ~= 20 do {
 847 |       currstate := pop(myautomata.states)
 848 |       put(myautomata.states, currstate)
 849 |       }
 850 |    put(tempedge.destinations, currstate)
 851 | 
 852 |    put(state2.edges, tempedge)
 853 |    tempedge := edge("{", [])
 854 |    currstate := pop(myautomata.states)
 855 |    put(myautomata.states, currstate)
 856 | 
 857 |    while currstate.label ~= 21 do {
 858 |       currstate := pop(myautomata.states)
 859 |       put(myautomata.states, currstate)
 860 |       }
 861 |    put(tempedge.destinations, currstate)
 862 | 
 863 |    put(state2.edges, tempedge)
 864 |    tempedge := edge("}", [])
 865 |    currstate := pop(myautomata.states)
 866 |    put(myautomata.states, currstate)
 867 | 
 868 |    while currstate.label ~= 22 do {
 869 |       currstate := pop(myautomata.states)
 870 |       put(myautomata.states, currstate)
 871 |       }
 872 |    put(tempedge.destinations, currstate)
 873 | 
 874 |    put(state2.edges, tempedge)
 875 |    tempedge := edge(";", [])
 876 |    currstate := pop(myautomata.states)
 877 |    put(myautomata.states, currstate)
 878 | 
 879 |    while currstate.label ~= 23 do {
 880 |       currstate := pop(myautomata.states)
 881 |       put(myautomata.states, currstate)
 882 |       }
 883 |    put(tempedge.destinations, currstate)
 884 | 
 885 |    put(state2.edges, tempedge)
 886 |    tempedge := edge(":", [])
 887 |    currstate := pop(myautomata.states)
 888 |    put(myautomata.states, currstate)
 889 | 
 890 |    while currstate.label ~= 24 do {
 891 |       currstate := pop(myautomata.states)
 892 |       put(myautomata.states, currstate)
 893 |       }
 894 |    put(tempedge.destinations, currstate)
 895 | 
 896 |    put(state2.edges, tempedge)
 897 |    tempedge := edge("*", [])
 898 |    currstate := pop(myautomata.states)
 899 |    put(myautomata.states, currstate)
 900 | 
 901 |    while currstate.label ~= 25 do {
 902 |       currstate := pop(myautomata.states)
 903 |       put(myautomata.states, currstate)
 904 |       }
 905 |    put(tempedge.destinations, currstate)
 906 | 
 907 |    put(state2.edges, tempedge)
 908 |    tempedge := edge("/", [])
 909 |    currstate := pop(myautomata.states)
 910 |    put(myautomata.states, currstate)
 911 | 
 912 |    while currstate.label ~= 26 do {
 913 |       currstate := pop(myautomata.states)
 914 |       put(myautomata.states, currstate)
 915 |       }
 916 |    put(tempedge.destinations, currstate)
 917 | 
 918 |    put(state2.edges, tempedge)
 919 |    tempedge := edge("%", [])
 920 |    currstate := pop(myautomata.states)
 921 |    put(myautomata.states, currstate)
 922 | 
 923 |    while currstate.label ~= 27 do {
 924 |       currstate := pop(myautomata.states)
 925 |       put(myautomata.states, currstate)
 926 |       }
 927 |    put(tempedge.destinations, currstate)
 928 | 
 929 |    put(state2.edges, tempedge)
 930 |    tempedge := edge("<", [])
 931 |    currstate := pop(myautomata.states)
 932 |    put(myautomata.states, currstate)
 933 | 
 934 |    while currstate.label ~= 28 do {
 935 |       currstate := pop(myautomata.states)
 936 |       put(myautomata.states, currstate)
 937 |       }
 938 |    put(tempedge.destinations, currstate)
 939 | 
 940 |    put(state2.edges, tempedge)
 941 |    tempedge := edge(">", [])
 942 |    currstate := pop(myautomata.states)
 943 |    put(myautomata.states, currstate)
 944 | 
 945 |    while currstate.label ~= 29 do {
 946 |       currstate := pop(myautomata.states)
 947 |       put(myautomata.states, currstate)
 948 |       }
 949 |    put(tempedge.destinations, currstate)
 950 | 
 951 |    put(state2.edges, tempedge)
 952 |    tempedge := edge("!", [])
 953 |    currstate := pop(myautomata.states)
 954 |    put(myautomata.states, currstate)
 955 | 
 956 |    while currstate.label ~= 30 do {
 957 |       currstate := pop(myautomata.states)
 958 |       put(myautomata.states, currstate)
 959 |       }
 960 |    put(tempedge.destinations, currstate)
 961 | 
 962 |    put(state2.edges, tempedge)
 963 |    tempedge := edge("&", [])
 964 |    currstate := pop(myautomata.states)
 965 |    put(myautomata.states, currstate)
 966 | 
 967 |    while currstate.label ~= 31 do {
 968 |       currstate := pop(myautomata.states)
 969 |       put(myautomata.states, currstate)
 970 |       }
 971 |    put(tempedge.destinations, currstate)
 972 | 
 973 |    put(state2.edges, tempedge)
 974 |    tempedge := edge("|", [])
 975 |    currstate := pop(myautomata.states)
 976 |    put(myautomata.states, currstate)
 977 | 
 978 |    while currstate.label ~= 32 do {
 979 |       currstate := pop(myautomata.states)
 980 |       put(myautomata.states, currstate)
 981 |       }
 982 |    put(tempedge.destinations, currstate)
 983 | 
 984 |    put(state2.edges, tempedge)
 985 |    tempedge := edge("+", [])
 986 |    currstate := pop(myautomata.states)
 987 |    put(myautomata.states, currstate)
 988 | 
 989 |    while currstate.label ~= 33 do {
 990 |       currstate := pop(myautomata.states)
 991 |       put(myautomata.states, currstate)
 992 |       }
 993 |    put(tempedge.destinations, currstate)
 994 | 
 995 |    put(state2.edges, tempedge)
 996 |    tempedge := edge("-", [])
 997 |    currstate := pop(myautomata.states)
 998 |    put(myautomata.states, currstate)
 999 | 
1000 |    while currstate.label ~= 34 do {
1001 |       currstate := pop(myautomata.states)
1002 |       put(myautomata.states, currstate)
1003 |       }
1004 |    put(tempedge.destinations, currstate)
1005 | 
1006 |    put(state2.edges, tempedge)
1007 |    tempedge := edge("=", [])
1008 |    currstate := pop(myautomata.states)
1009 |    put(myautomata.states, currstate)
1010 | 
1011 |    while currstate.label ~= 35 do {
1012 |       currstate := pop(myautomata.states)
1013 |       put(myautomata.states, currstate)
1014 |       }
1015 |    put(tempedge.destinations, currstate)
1016 | 
1017 |    put(state2.edges, tempedge)
1018 |    tempedge := edge(",", [])
1019 |    currstate := pop(myautomata.states)
1020 |    put(myautomata.states, currstate)
1021 | 
1022 |    while currstate.label ~= 36 do {
1023 |       currstate := pop(myautomata.states)
1024 |       put(myautomata.states, currstate)
1025 |       }
1026 |    put(tempedge.destinations, currstate)
1027 | 
1028 |    put(state2.edges, tempedge)
1029 |    tempedge := edge(csetfromrecset("[\a-zA-Z_]"), [])
1030 |    currstate := pop(myautomata.states)
1031 |    put(myautomata.states, currstate)
1032 | 
1033 |    while currstate.label ~= 37 do {
1034 |       currstate := pop(myautomata.states)
1035 |       put(myautomata.states, currstate)
1036 |       }
1037 |    put(tempedge.destinations, currstate)
1038 | 
1039 |    put(state2.edges, tempedge)
1040 |    tempedge := edge(".", [])
1041 |    currstate := pop(myautomata.states)
1042 |    put(myautomata.states, currstate)
1043 | 
1044 |    while currstate.label ~= 38 do {
1045 |       currstate := pop(myautomata.states)
1046 |       put(myautomata.states, currstate)
1047 |       }
1048 |    put(tempedge.destinations, currstate)
1049 | 
1050 |    put(state2.edges, tempedge)
1051 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1052 |    currstate := pop(myautomata.states)
1053 |    put(myautomata.states, currstate)
1054 | 
1055 |    while currstate.label ~= 39 do {
1056 |       currstate := pop(myautomata.states)
1057 |       put(myautomata.states, currstate)
1058 |       }
1059 |    put(tempedge.destinations, currstate)
1060 | 
1061 |    put(state2.edges, tempedge)
1062 |    tempedge := edge("\"", [])
1063 |    currstate := pop(myautomata.states)
1064 |    put(myautomata.states, currstate)
1065 | 
1066 |    while currstate.label ~= 40 do {
1067 |       currstate := pop(myautomata.states)
1068 |       put(myautomata.states, currstate)
1069 |       }
1070 |    put(tempedge.destinations, currstate)
1071 | 
1072 |    put(state2.edges, tempedge)
1073 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
1074 |    currstate := pop(myautomata.states)
1075 |    put(myautomata.states, currstate)
1076 | 
1077 |    while currstate.label ~= 41 do {
1078 |       currstate := pop(myautomata.states)
1079 |       put(myautomata.states, currstate)
1080 |       }
1081 |    put(tempedge.destinations, currstate)
1082 | 
1083 |    put(state2.edges, tempedge)
1084 |    currstate := pop(myautomata.states)
1085 |    put(myautomata.states, currstate)
1086 | 
1087 |    while currstate.label ~= 2 do {
1088 |       currstate := pop(myautomata.states)
1089 |       put(myautomata.states, currstate)
1090 |       }
1091 |    state2 := currstate
1092 | 
1093 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
1094 |    currstate := pop(myautomata.states)
1095 |    put(myautomata.states, currstate)
1096 | 
1097 |    while currstate.label ~= 2 do {
1098 |       currstate := pop(myautomata.states)
1099 |       put(myautomata.states, currstate)
1100 |       }
1101 |    put(tempedge.destinations, currstate)
1102 | 
1103 |    put(state2.edges, tempedge)
1104 |    currstate := pop(myautomata.states)
1105 |    put(myautomata.states, currstate)
1106 | 
1107 |    while currstate.label ~= 3 do {
1108 |       currstate := pop(myautomata.states)
1109 |       put(myautomata.states, currstate)
1110 |       }
1111 |    state2 := currstate
1112 | 
1113 |    currstate := pop(myautomata.states)
1114 |    put(myautomata.states, currstate)
1115 | 
1116 |    while currstate.label ~= 4 do {
1117 |       currstate := pop(myautomata.states)
1118 |       put(myautomata.states, currstate)
1119 |       }
1120 |    state2 := currstate
1121 | 
1122 |    tempedge := edge("o", [])
1123 |    currstate := pop(myautomata.states)
1124 |    put(myautomata.states, currstate)
1125 | 
1126 |    while currstate.label ~= 42 do {
1127 |       currstate := pop(myautomata.states)
1128 |       put(myautomata.states, currstate)
1129 |       }
1130 |    put(tempedge.destinations, currstate)
1131 | 
1132 |    put(state2.edges, tempedge)
1133 |    tempedge := edge("\a", [])
1134 |    currstate := pop(myautomata.states)
1135 |    put(myautomata.states, currstate)
1136 | 
1137 |    while currstate.label ~= 43 do {
1138 |       currstate := pop(myautomata.states)
1139 |       put(myautomata.states, currstate)
1140 |       }
1141 |    put(tempedge.destinations, currstate)
1142 | 
1143 |    put(state2.edges, tempedge)
1144 |    currstate := pop(myautomata.states)
1145 |    put(myautomata.states, currstate)
1146 | 
1147 |    while currstate.label ~= 5 do {
1148 |       currstate := pop(myautomata.states)
1149 |       put(myautomata.states, currstate)
1150 |       }
1151 |    state2 := currstate
1152 | 
1153 |    tempedge := edge("u", [])
1154 |    currstate := pop(myautomata.states)
1155 |    put(myautomata.states, currstate)
1156 | 
1157 |    while currstate.label ~= 44 do {
1158 |       currstate := pop(myautomata.states)
1159 |       put(myautomata.states, currstate)
1160 |       }
1161 |    put(tempedge.destinations, currstate)
1162 | 
1163 |    put(state2.edges, tempedge)
1164 |    currstate := pop(myautomata.states)
1165 |    put(myautomata.states, currstate)
1166 | 
1167 |    while currstate.label ~= 6 do {
1168 |       currstate := pop(myautomata.states)
1169 |       put(myautomata.states, currstate)
1170 |       }
1171 |    state2 := currstate
1172 | 
1173 |    tempedge := edge("u", [])
1174 |    currstate := pop(myautomata.states)
1175 |    put(myautomata.states, currstate)
1176 | 
1177 |    while currstate.label ~= 45 do {
1178 |       currstate := pop(myautomata.states)
1179 |       put(myautomata.states, currstate)
1180 |       }
1181 |    put(tempedge.destinations, currstate)
1182 | 
1183 |    put(state2.edges, tempedge)
1184 |    currstate := pop(myautomata.states)
1185 |    put(myautomata.states, currstate)
1186 | 
1187 |    while currstate.label ~= 7 do {
1188 |       currstate := pop(myautomata.states)
1189 |       put(myautomata.states, currstate)
1190 |       }
1191 |    state2 := currstate
1192 | 
1193 |    tempedge := edge("r", [])
1194 |    currstate := pop(myautomata.states)
1195 |    put(myautomata.states, currstate)
1196 | 
1197 |    while currstate.label ~= 46 do {
1198 |       currstate := pop(myautomata.states)
1199 |       put(myautomata.states, currstate)
1200 |       }
1201 |    put(tempedge.destinations, currstate)
1202 | 
1203 |    put(state2.edges, tempedge)
1204 |    currstate := pop(myautomata.states)
1205 |    put(myautomata.states, currstate)
1206 | 
1207 |    while currstate.label ~= 8 do {
1208 |       currstate := pop(myautomata.states)
1209 |       put(myautomata.states, currstate)
1210 |       }
1211 |    state2 := currstate
1212 | 
1213 |    tempedge := edge("e", [])
1214 |    currstate := pop(myautomata.states)
1215 |    put(myautomata.states, currstate)
1216 | 
1217 |    while currstate.label ~= 47 do {
1218 |       currstate := pop(myautomata.states)
1219 |       put(myautomata.states, currstate)
1220 |       }
1221 |    put(tempedge.destinations, currstate)
1222 | 
1223 |    put(state2.edges, tempedge)
1224 |    currstate := pop(myautomata.states)
1225 |    put(myautomata.states, currstate)
1226 | 
1227 |    while currstate.label ~= 9 do {
1228 |       currstate := pop(myautomata.states)
1229 |       put(myautomata.states, currstate)
1230 |       }
1231 |    state2 := currstate
1232 | 
1233 |    tempedge := edge("r", [])
1234 |    currstate := pop(myautomata.states)
1235 |    put(myautomata.states, currstate)
1236 | 
1237 |    while currstate.label ~= 48 do {
1238 |       currstate := pop(myautomata.states)
1239 |       put(myautomata.states, currstate)
1240 |       }
1241 |    put(tempedge.destinations, currstate)
1242 | 
1243 |    put(state2.edges, tempedge)
1244 |    tempedge := edge("o", [])
1245 |    currstate := pop(myautomata.states)
1246 |    put(myautomata.states, currstate)
1247 | 
1248 |    while currstate.label ~= 49 do {
1249 |       currstate := pop(myautomata.states)
1250 |       put(myautomata.states, currstate)
1251 |       }
1252 |    put(tempedge.destinations, currstate)
1253 | 
1254 |    put(state2.edges, tempedge)
1255 |    currstate := pop(myautomata.states)
1256 |    put(myautomata.states, currstate)
1257 | 
1258 |    while currstate.label ~= 10 do {
1259 |       currstate := pop(myautomata.states)
1260 |       put(myautomata.states, currstate)
1261 |       }
1262 |    state2 := currstate
1263 | 
1264 |    tempedge := edge("o", [])
1265 |    currstate := pop(myautomata.states)
1266 |    put(myautomata.states, currstate)
1267 | 
1268 |    while currstate.label ~= 50 do {
1269 |       currstate := pop(myautomata.states)
1270 |       put(myautomata.states, currstate)
1271 |       }
1272 |    put(tempedge.destinations, currstate)
1273 | 
1274 |    put(state2.edges, tempedge)
1275 |    currstate := pop(myautomata.states)
1276 |    put(myautomata.states, currstate)
1277 | 
1278 |    while currstate.label ~= 11 do {
1279 |       currstate := pop(myautomata.states)
1280 |       put(myautomata.states, currstate)
1281 |       }
1282 |    state2 := currstate
1283 | 
1284 |    tempedge := edge("o", [])
1285 |    currstate := pop(myautomata.states)
1286 |    put(myautomata.states, currstate)
1287 | 
1288 |    while currstate.label ~= 51 do {
1289 |       currstate := pop(myautomata.states)
1290 |       put(myautomata.states, currstate)
1291 |       }
1292 |    put(tempedge.destinations, currstate)
1293 | 
1294 |    put(state2.edges, tempedge)
1295 |    currstate := pop(myautomata.states)
1296 |    put(myautomata.states, currstate)
1297 | 
1298 |    while currstate.label ~= 12 do {
1299 |       currstate := pop(myautomata.states)
1300 |       put(myautomata.states, currstate)
1301 |       }
1302 |    state2 := currstate
1303 | 
1304 |    tempedge := edge("h", [])
1305 |    currstate := pop(myautomata.states)
1306 |    put(myautomata.states, currstate)
1307 | 
1308 |    while currstate.label ~= 52 do {
1309 |       currstate := pop(myautomata.states)
1310 |       put(myautomata.states, currstate)
1311 |       }
1312 |    put(tempedge.destinations, currstate)
1313 | 
1314 |    put(state2.edges, tempedge)
1315 |    currstate := pop(myautomata.states)
1316 |    put(myautomata.states, currstate)
1317 | 
1318 |    while currstate.label ~= 13 do {
1319 |       currstate := pop(myautomata.states)
1320 |       put(myautomata.states, currstate)
1321 |       }
1322 |    state2 := currstate
1323 | 
1324 |    tempedge := edge("f", [])
1325 |    currstate := pop(myautomata.states)
1326 |    put(myautomata.states, currstate)
1327 | 
1328 |    while currstate.label ~= 53 do {
1329 |       currstate := pop(myautomata.states)
1330 |       put(myautomata.states, currstate)
1331 |       }
1332 |    put(tempedge.destinations, currstate)
1333 | 
1334 |    put(state2.edges, tempedge)
1335 |    tempedge := edge("n", [])
1336 |    currstate := pop(myautomata.states)
1337 |    put(myautomata.states, currstate)
1338 | 
1339 |    while currstate.label ~= 54 do {
1340 |       currstate := pop(myautomata.states)
1341 |       put(myautomata.states, currstate)
1342 |       }
1343 |    put(tempedge.destinations, currstate)
1344 | 
1345 |    put(state2.edges, tempedge)
1346 |    currstate := pop(myautomata.states)
1347 |    put(myautomata.states, currstate)
1348 | 
1349 |    while currstate.label ~= 14 do {
1350 |       currstate := pop(myautomata.states)
1351 |       put(myautomata.states, currstate)
1352 |       }
1353 |    state2 := currstate
1354 | 
1355 |    tempedge := edge("l", [])
1356 |    currstate := pop(myautomata.states)
1357 |    put(myautomata.states, currstate)
1358 | 
1359 |    while currstate.label ~= 55 do {
1360 |       currstate := pop(myautomata.states)
1361 |       put(myautomata.states, currstate)
1362 |       }
1363 |    put(tempedge.destinations, currstate)
1364 | 
1365 |    put(state2.edges, tempedge)
1366 |    currstate := pop(myautomata.states)
1367 |    put(myautomata.states, currstate)
1368 | 
1369 |    while currstate.label ~= 15 do {
1370 |       currstate := pop(myautomata.states)
1371 |       put(myautomata.states, currstate)
1372 |       }
1373 |    state2 := currstate
1374 | 
1375 |    tempedge := edge("l", [])
1376 |    currstate := pop(myautomata.states)
1377 |    put(myautomata.states, currstate)
1378 | 
1379 |    while currstate.label ~= 56 do {
1380 |       currstate := pop(myautomata.states)
1381 |       put(myautomata.states, currstate)
1382 |       }
1383 |    put(tempedge.destinations, currstate)
1384 | 
1385 |    put(state2.edges, tempedge)
1386 |    currstate := pop(myautomata.states)
1387 |    put(myautomata.states, currstate)
1388 | 
1389 |    while currstate.label ~= 16 do {
1390 |       currstate := pop(myautomata.states)
1391 |       put(myautomata.states, currstate)
1392 |       }
1393 |    state2 := currstate
1394 | 
1395 |    tempedge := edge("t", [])
1396 |    currstate := pop(myautomata.states)
1397 |    put(myautomata.states, currstate)
1398 | 
1399 |    while currstate.label ~= 57 do {
1400 |       currstate := pop(myautomata.states)
1401 |       put(myautomata.states, currstate)
1402 |       }
1403 |    put(tempedge.destinations, currstate)
1404 | 
1405 |    put(state2.edges, tempedge)
1406 |    currstate := pop(myautomata.states)
1407 |    put(myautomata.states, currstate)
1408 | 
1409 |    while currstate.label ~= 17 do {
1410 |       currstate := pop(myautomata.states)
1411 |       put(myautomata.states, currstate)
1412 |       }
1413 |    state2 := currstate
1414 | 
1415 |    currstate := pop(myautomata.states)
1416 |    put(myautomata.states, currstate)
1417 | 
1418 |    while currstate.label ~= 18 do {
1419 |       currstate := pop(myautomata.states)
1420 |       put(myautomata.states, currstate)
1421 |       }
1422 |    state2 := currstate
1423 | 
1424 |    currstate := pop(myautomata.states)
1425 |    put(myautomata.states, currstate)
1426 | 
1427 |    while currstate.label ~= 19 do {
1428 |       currstate := pop(myautomata.states)
1429 |       put(myautomata.states, currstate)
1430 |       }
1431 |    state2 := currstate
1432 | 
1433 |    currstate := pop(myautomata.states)
1434 |    put(myautomata.states, currstate)
1435 | 
1436 |    while currstate.label ~= 20 do {
1437 |       currstate := pop(myautomata.states)
1438 |       put(myautomata.states, currstate)
1439 |       }
1440 |    state2 := currstate
1441 | 
1442 |    currstate := pop(myautomata.states)
1443 |    put(myautomata.states, currstate)
1444 | 
1445 |    while currstate.label ~= 21 do {
1446 |       currstate := pop(myautomata.states)
1447 |       put(myautomata.states, currstate)
1448 |       }
1449 |    state2 := currstate
1450 | 
1451 |    currstate := pop(myautomata.states)
1452 |    put(myautomata.states, currstate)
1453 | 
1454 |    while currstate.label ~= 22 do {
1455 |       currstate := pop(myautomata.states)
1456 |       put(myautomata.states, currstate)
1457 |       }
1458 |    state2 := currstate
1459 | 
1460 |    currstate := pop(myautomata.states)
1461 |    put(myautomata.states, currstate)
1462 | 
1463 |    while currstate.label ~= 23 do {
1464 |       currstate := pop(myautomata.states)
1465 |       put(myautomata.states, currstate)
1466 |       }
1467 |    state2 := currstate
1468 | 
1469 |    currstate := pop(myautomata.states)
1470 |    put(myautomata.states, currstate)
1471 | 
1472 |    while currstate.label ~= 24 do {
1473 |       currstate := pop(myautomata.states)
1474 |       put(myautomata.states, currstate)
1475 |       }
1476 |    state2 := currstate
1477 | 
1478 |    currstate := pop(myautomata.states)
1479 |    put(myautomata.states, currstate)
1480 | 
1481 |    while currstate.label ~= 25 do {
1482 |       currstate := pop(myautomata.states)
1483 |       put(myautomata.states, currstate)
1484 |       }
1485 |    state2 := currstate
1486 | 
1487 |    currstate := pop(myautomata.states)
1488 |    put(myautomata.states, currstate)
1489 | 
1490 |    while currstate.label ~= 26 do {
1491 |       currstate := pop(myautomata.states)
1492 |       put(myautomata.states, currstate)
1493 |       }
1494 |    state2 := currstate
1495 | 
1496 |    tempedge := edge("*", [])
1497 |    currstate := pop(myautomata.states)
1498 |    put(myautomata.states, currstate)
1499 | 
1500 |    while currstate.label ~= 58 do {
1501 |       currstate := pop(myautomata.states)
1502 |       put(myautomata.states, currstate)
1503 |       }
1504 |    put(tempedge.destinations, currstate)
1505 | 
1506 |    put(state2.edges, tempedge)
1507 |    tempedge := edge("/", [])
1508 |    currstate := pop(myautomata.states)
1509 |    put(myautomata.states, currstate)
1510 | 
1511 |    while currstate.label ~= 59 do {
1512 |       currstate := pop(myautomata.states)
1513 |       put(myautomata.states, currstate)
1514 |       }
1515 |    put(tempedge.destinations, currstate)
1516 | 
1517 |    put(state2.edges, tempedge)
1518 |    currstate := pop(myautomata.states)
1519 |    put(myautomata.states, currstate)
1520 | 
1521 |    while currstate.label ~= 27 do {
1522 |       currstate := pop(myautomata.states)
1523 |       put(myautomata.states, currstate)
1524 |       }
1525 |    state2 := currstate
1526 | 
1527 |    currstate := pop(myautomata.states)
1528 |    put(myautomata.states, currstate)
1529 | 
1530 |    while currstate.label ~= 28 do {
1531 |       currstate := pop(myautomata.states)
1532 |       put(myautomata.states, currstate)
1533 |       }
1534 |    state2 := currstate
1535 | 
1536 |    tempedge := edge("=", [])
1537 |    currstate := pop(myautomata.states)
1538 |    put(myautomata.states, currstate)
1539 | 
1540 |    while currstate.label ~= 60 do {
1541 |       currstate := pop(myautomata.states)
1542 |       put(myautomata.states, currstate)
1543 |       }
1544 |    put(tempedge.destinations, currstate)
1545 | 
1546 |    put(state2.edges, tempedge)
1547 |    currstate := pop(myautomata.states)
1548 |    put(myautomata.states, currstate)
1549 | 
1550 |    while currstate.label ~= 29 do {
1551 |       currstate := pop(myautomata.states)
1552 |       put(myautomata.states, currstate)
1553 |       }
1554 |    state2 := currstate
1555 | 
1556 |    tempedge := edge("=", [])
1557 |    currstate := pop(myautomata.states)
1558 |    put(myautomata.states, currstate)
1559 | 
1560 |    while currstate.label ~= 61 do {
1561 |       currstate := pop(myautomata.states)
1562 |       put(myautomata.states, currstate)
1563 |       }
1564 |    put(tempedge.destinations, currstate)
1565 | 
1566 |    put(state2.edges, tempedge)
1567 |    currstate := pop(myautomata.states)
1568 |    put(myautomata.states, currstate)
1569 | 
1570 |    while currstate.label ~= 30 do {
1571 |       currstate := pop(myautomata.states)
1572 |       put(myautomata.states, currstate)
1573 |       }
1574 |    state2 := currstate
1575 | 
1576 |    tempedge := edge("=", [])
1577 |    currstate := pop(myautomata.states)
1578 |    put(myautomata.states, currstate)
1579 | 
1580 |    while currstate.label ~= 62 do {
1581 |       currstate := pop(myautomata.states)
1582 |       put(myautomata.states, currstate)
1583 |       }
1584 |    put(tempedge.destinations, currstate)
1585 | 
1586 |    put(state2.edges, tempedge)
1587 |    currstate := pop(myautomata.states)
1588 |    put(myautomata.states, currstate)
1589 | 
1590 |    while currstate.label ~= 31 do {
1591 |       currstate := pop(myautomata.states)
1592 |       put(myautomata.states, currstate)
1593 |       }
1594 |    state2 := currstate
1595 | 
1596 |    tempedge := edge("&", [])
1597 |    currstate := pop(myautomata.states)
1598 |    put(myautomata.states, currstate)
1599 | 
1600 |    while currstate.label ~= 63 do {
1601 |       currstate := pop(myautomata.states)
1602 |       put(myautomata.states, currstate)
1603 |       }
1604 |    put(tempedge.destinations, currstate)
1605 | 
1606 |    put(state2.edges, tempedge)
1607 |    currstate := pop(myautomata.states)
1608 |    put(myautomata.states, currstate)
1609 | 
1610 |    while currstate.label ~= 32 do {
1611 |       currstate := pop(myautomata.states)
1612 |       put(myautomata.states, currstate)
1613 |       }
1614 |    state2 := currstate
1615 | 
1616 |    tempedge := edge("|", [])
1617 |    currstate := pop(myautomata.states)
1618 |    put(myautomata.states, currstate)
1619 | 
1620 |    while currstate.label ~= 64 do {
1621 |       currstate := pop(myautomata.states)
1622 |       put(myautomata.states, currstate)
1623 |       }
1624 |    put(tempedge.destinations, currstate)
1625 | 
1626 |    put(state2.edges, tempedge)
1627 |    currstate := pop(myautomata.states)
1628 |    put(myautomata.states, currstate)
1629 | 
1630 |    while currstate.label ~= 33 do {
1631 |       currstate := pop(myautomata.states)
1632 |       put(myautomata.states, currstate)
1633 |       }
1634 |    state2 := currstate
1635 | 
1636 |    tempedge := edge("=", [])
1637 |    currstate := pop(myautomata.states)
1638 |    put(myautomata.states, currstate)
1639 | 
1640 |    while currstate.label ~= 65 do {
1641 |       currstate := pop(myautomata.states)
1642 |       put(myautomata.states, currstate)
1643 |       }
1644 |    put(tempedge.destinations, currstate)
1645 | 
1646 |    put(state2.edges, tempedge)
1647 |    currstate := pop(myautomata.states)
1648 |    put(myautomata.states, currstate)
1649 | 
1650 |    while currstate.label ~= 34 do {
1651 |       currstate := pop(myautomata.states)
1652 |       put(myautomata.states, currstate)
1653 |       }
1654 |    state2 := currstate
1655 | 
1656 |    tempedge := edge("=", [])
1657 |    currstate := pop(myautomata.states)
1658 |    put(myautomata.states, currstate)
1659 | 
1660 |    while currstate.label ~= 66 do {
1661 |       currstate := pop(myautomata.states)
1662 |       put(myautomata.states, currstate)
1663 |       }
1664 |    put(tempedge.destinations, currstate)
1665 | 
1666 |    put(state2.edges, tempedge)
1667 |    currstate := pop(myautomata.states)
1668 |    put(myautomata.states, currstate)
1669 | 
1670 |    while currstate.label ~= 35 do {
1671 |       currstate := pop(myautomata.states)
1672 |       put(myautomata.states, currstate)
1673 |       }
1674 |    state2 := currstate
1675 | 
1676 |    tempedge := edge("=", [])
1677 |    currstate := pop(myautomata.states)
1678 |    put(myautomata.states, currstate)
1679 | 
1680 |    while currstate.label ~= 67 do {
1681 |       currstate := pop(myautomata.states)
1682 |       put(myautomata.states, currstate)
1683 |       }
1684 |    put(tempedge.destinations, currstate)
1685 | 
1686 |    put(state2.edges, tempedge)
1687 |    currstate := pop(myautomata.states)
1688 |    put(myautomata.states, currstate)
1689 | 
1690 |    while currstate.label ~= 36 do {
1691 |       currstate := pop(myautomata.states)
1692 |       put(myautomata.states, currstate)
1693 |       }
1694 |    state2 := currstate
1695 | 
1696 |    currstate := pop(myautomata.states)
1697 |    put(myautomata.states, currstate)
1698 | 
1699 |    while currstate.label ~= 37 do {
1700 |       currstate := pop(myautomata.states)
1701 |       put(myautomata.states, currstate)
1702 |       }
1703 |    state2 := currstate
1704 | 
1705 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
1706 |    currstate := pop(myautomata.states)
1707 |    put(myautomata.states, currstate)
1708 | 
1709 |    while currstate.label ~= 68 do {
1710 |       currstate := pop(myautomata.states)
1711 |       put(myautomata.states, currstate)
1712 |       }
1713 |    put(tempedge.destinations, currstate)
1714 | 
1715 |    put(state2.edges, tempedge)
1716 |    currstate := pop(myautomata.states)
1717 |    put(myautomata.states, currstate)
1718 | 
1719 |    while currstate.label ~= 38 do {
1720 |       currstate := pop(myautomata.states)
1721 |       put(myautomata.states, currstate)
1722 |       }
1723 |    state2 := currstate
1724 | 
1725 |    tempedge := edge(csetfromrecset("[eE]"), [])
1726 |    currstate := pop(myautomata.states)
1727 |    put(myautomata.states, currstate)
1728 | 
1729 |    while currstate.label ~= 69 do {
1730 |       currstate := pop(myautomata.states)
1731 |       put(myautomata.states, currstate)
1732 |       }
1733 |    put(tempedge.destinations, currstate)
1734 | 
1735 |    put(state2.edges, tempedge)
1736 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1737 |    currstate := pop(myautomata.states)
1738 |    put(myautomata.states, currstate)
1739 | 
1740 |    while currstate.label ~= 70 do {
1741 |       currstate := pop(myautomata.states)
1742 |       put(myautomata.states, currstate)
1743 |       }
1744 |    put(tempedge.destinations, currstate)
1745 | 
1746 |    put(state2.edges, tempedge)
1747 |    currstate := pop(myautomata.states)
1748 |    put(myautomata.states, currstate)
1749 | 
1750 |    while currstate.label ~= 39 do {
1751 |       currstate := pop(myautomata.states)
1752 |       put(myautomata.states, currstate)
1753 |       }
1754 |    state2 := currstate
1755 | 
1756 |    tempedge := edge(".", [])
1757 |    currstate := pop(myautomata.states)
1758 |    put(myautomata.states, currstate)
1759 | 
1760 |    while currstate.label ~= 71 do {
1761 |       currstate := pop(myautomata.states)
1762 |       put(myautomata.states, currstate)
1763 |       }
1764 |    put(tempedge.destinations, currstate)
1765 | 
1766 |    put(state2.edges, tempedge)
1767 |    tempedge := edge(csetfromrecset("[eE]"), [])
1768 |    currstate := pop(myautomata.states)
1769 |    put(myautomata.states, currstate)
1770 | 
1771 |    while currstate.label ~= 72 do {
1772 |       currstate := pop(myautomata.states)
1773 |       put(myautomata.states, currstate)
1774 |       }
1775 |    put(tempedge.destinations, currstate)
1776 | 
1777 |    put(state2.edges, tempedge)
1778 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1779 |    currstate := pop(myautomata.states)
1780 |    put(myautomata.states, currstate)
1781 | 
1782 |    while currstate.label ~= 39 do {
1783 |       currstate := pop(myautomata.states)
1784 |       put(myautomata.states, currstate)
1785 |       }
1786 |    put(tempedge.destinations, currstate)
1787 | 
1788 |    put(state2.edges, tempedge)
1789 |    currstate := pop(myautomata.states)
1790 |    put(myautomata.states, currstate)
1791 | 
1792 |    while currstate.label ~= 40 do {
1793 |       currstate := pop(myautomata.states)
1794 |       put(myautomata.states, currstate)
1795 |       }
1796 |    state2 := currstate
1797 | 
1798 |    tempedge := edge(csetfromrecset("[^\"]"), [])
1799 |    currstate := pop(myautomata.states)
1800 |    put(myautomata.states, currstate)
1801 | 
1802 |    while currstate.label ~= 73 do {
1803 |       currstate := pop(myautomata.states)
1804 |       put(myautomata.states, currstate)
1805 |       }
1806 |    put(tempedge.destinations, currstate)
1807 | 
1808 |    put(state2.edges, tempedge)
1809 |    tempedge := edge("\\", [])
1810 |    currstate := pop(myautomata.states)
1811 |    put(myautomata.states, currstate)
1812 | 
1813 |    while currstate.label ~= 74 do {
1814 |       currstate := pop(myautomata.states)
1815 |       put(myautomata.states, currstate)
1816 |       }
1817 |    put(tempedge.destinations, currstate)
1818 | 
1819 |    put(state2.edges, tempedge)
1820 |    tempedge := edge("\"", [])
1821 |    currstate := pop(myautomata.states)
1822 |    put(myautomata.states, currstate)
1823 | 
1824 |    while currstate.label ~= 75 do {
1825 |       currstate := pop(myautomata.states)
1826 |       put(myautomata.states, currstate)
1827 |       }
1828 |    put(tempedge.destinations, currstate)
1829 | 
1830 |    put(state2.edges, tempedge)
1831 |    currstate := pop(myautomata.states)
1832 |    put(myautomata.states, currstate)
1833 | 
1834 |    while currstate.label ~= 41 do {
1835 |       currstate := pop(myautomata.states)
1836 |       put(myautomata.states, currstate)
1837 |       }
1838 |    state2 := currstate
1839 | 
1840 |    currstate := pop(myautomata.states)
1841 |    put(myautomata.states, currstate)
1842 | 
1843 |    while currstate.label ~= 42 do {
1844 |       currstate := pop(myautomata.states)
1845 |       put(myautomata.states, currstate)
1846 |       }
1847 |    state2 := currstate
1848 | 
1849 |    tempedge := edge("r", [])
1850 |    currstate := pop(myautomata.states)
1851 |    put(myautomata.states, currstate)
1852 | 
1853 |    while currstate.label ~= 76 do {
1854 |       currstate := pop(myautomata.states)
1855 |       put(myautomata.states, currstate)
1856 |       }
1857 |    put(tempedge.destinations, currstate)
1858 | 
1859 |    put(state2.edges, tempedge)
1860 |    currstate := pop(myautomata.states)
1861 |    put(myautomata.states, currstate)
1862 | 
1863 |    while currstate.label ~= 43 do {
1864 |       currstate := pop(myautomata.states)
1865 |       put(myautomata.states, currstate)
1866 |       }
1867 |    state2 := currstate
1868 | 
1869 |    tempedge := edge("l", [])
1870 |    currstate := pop(myautomata.states)
1871 |    put(myautomata.states, currstate)
1872 | 
1873 |    while currstate.label ~= 77 do {
1874 |       currstate := pop(myautomata.states)
1875 |       put(myautomata.states, currstate)
1876 |       }
1877 |    put(tempedge.destinations, currstate)
1878 | 
1879 |    put(state2.edges, tempedge)
1880 |    currstate := pop(myautomata.states)
1881 |    put(myautomata.states, currstate)
1882 | 
1883 |    while currstate.label ~= 44 do {
1884 |       currstate := pop(myautomata.states)
1885 |       put(myautomata.states, currstate)
1886 |       }
1887 |    state2 := currstate
1888 | 
1889 |    tempedge := edge("b", [])
1890 |    currstate := pop(myautomata.states)
1891 |    put(myautomata.states, currstate)
1892 | 
1893 |    while currstate.label ~= 78 do {
1894 |       currstate := pop(myautomata.states)
1895 |       put(myautomata.states, currstate)
1896 |       }
1897 |    put(tempedge.destinations, currstate)
1898 | 
1899 |    put(state2.edges, tempedge)
1900 |    currstate := pop(myautomata.states)
1901 |    put(myautomata.states, currstate)
1902 | 
1903 |    while currstate.label ~= 45 do {
1904 |       currstate := pop(myautomata.states)
1905 |       put(myautomata.states, currstate)
1906 |       }
1907 |    state2 := currstate
1908 | 
1909 |    tempedge := edge("l", [])
1910 |    currstate := pop(myautomata.states)
1911 |    put(myautomata.states, currstate)
1912 | 
1913 |    while currstate.label ~= 79 do {
1914 |       currstate := pop(myautomata.states)
1915 |       put(myautomata.states, currstate)
1916 |       }
1917 |    put(tempedge.destinations, currstate)
1918 | 
1919 |    put(state2.edges, tempedge)
1920 |    currstate := pop(myautomata.states)
1921 |    put(myautomata.states, currstate)
1922 | 
1923 |    while currstate.label ~= 46 do {
1924 |       currstate := pop(myautomata.states)
1925 |       put(myautomata.states, currstate)
1926 |       }
1927 |    state2 := currstate
1928 | 
1929 |    tempedge := edge("u", [])
1930 |    currstate := pop(myautomata.states)
1931 |    put(myautomata.states, currstate)
1932 | 
1933 |    while currstate.label ~= 80 do {
1934 |       currstate := pop(myautomata.states)
1935 |       put(myautomata.states, currstate)
1936 |       }
1937 |    put(tempedge.destinations, currstate)
1938 | 
1939 |    put(state2.edges, tempedge)
1940 |    currstate := pop(myautomata.states)
1941 |    put(myautomata.states, currstate)
1942 | 
1943 |    while currstate.label ~= 47 do {
1944 |       currstate := pop(myautomata.states)
1945 |       put(myautomata.states, currstate)
1946 |       }
1947 |    state2 := currstate
1948 | 
1949 |    tempedge := edge("t", [])
1950 |    currstate := pop(myautomata.states)
1951 |    put(myautomata.states, currstate)
1952 | 
1953 |    while currstate.label ~= 81 do {
1954 |       currstate := pop(myautomata.states)
1955 |       put(myautomata.states, currstate)
1956 |       }
1957 |    put(tempedge.destinations, currstate)
1958 | 
1959 |    put(state2.edges, tempedge)
1960 |    currstate := pop(myautomata.states)
1961 |    put(myautomata.states, currstate)
1962 | 
1963 |    while currstate.label ~= 48 do {
1964 |       currstate := pop(myautomata.states)
1965 |       put(myautomata.states, currstate)
1966 |       }
1967 |    state2 := currstate
1968 | 
1969 |    tempedge := edge("e", [])
1970 |    currstate := pop(myautomata.states)
1971 |    put(myautomata.states, currstate)
1972 | 
1973 |    while currstate.label ~= 82 do {
1974 |       currstate := pop(myautomata.states)
1975 |       put(myautomata.states, currstate)
1976 |       }
1977 |    put(tempedge.destinations, currstate)
1978 | 
1979 |    put(state2.edges, tempedge)
1980 |    currstate := pop(myautomata.states)
1981 |    put(myautomata.states, currstate)
1982 | 
1983 |    while currstate.label ~= 49 do {
1984 |       currstate := pop(myautomata.states)
1985 |       put(myautomata.states, currstate)
1986 |       }
1987 |    state2 := currstate
1988 | 
1989 |    tempedge := edge("o", [])
1990 |    currstate := pop(myautomata.states)
1991 |    put(myautomata.states, currstate)
1992 | 
1993 |    while currstate.label ~= 83 do {
1994 |       currstate := pop(myautomata.states)
1995 |       put(myautomata.states, currstate)
1996 |       }
1997 |    put(tempedge.destinations, currstate)
1998 | 
1999 |    put(state2.edges, tempedge)
2000 |    currstate := pop(myautomata.states)
2001 |    put(myautomata.states, currstate)
2002 | 
2003 |    while currstate.label ~= 50 do {
2004 |       currstate := pop(myautomata.states)
2005 |       put(myautomata.states, currstate)
2006 |       }
2007 |    state2 := currstate
2008 | 
2009 |    tempedge := edge("i", [])
2010 |    currstate := pop(myautomata.states)
2011 |    put(myautomata.states, currstate)
2012 | 
2013 |    while currstate.label ~= 84 do {
2014 |       currstate := pop(myautomata.states)
2015 |       put(myautomata.states, currstate)
2016 |       }
2017 |    put(tempedge.destinations, currstate)
2018 | 
2019 |    put(state2.edges, tempedge)
2020 |    currstate := pop(myautomata.states)
2021 |    put(myautomata.states, currstate)
2022 | 
2023 |    while currstate.label ~= 51 do {
2024 |       currstate := pop(myautomata.states)
2025 |       put(myautomata.states, currstate)
2026 |       }
2027 |    state2 := currstate
2028 | 
2029 |    tempedge := edge("u", [])
2030 |    currstate := pop(myautomata.states)
2031 |    put(myautomata.states, currstate)
2032 | 
2033 |    while currstate.label ~= 85 do {
2034 |       currstate := pop(myautomata.states)
2035 |       put(myautomata.states, currstate)
2036 |       }
2037 |    put(tempedge.destinations, currstate)
2038 | 
2039 |    put(state2.edges, tempedge)
2040 |    currstate := pop(myautomata.states)
2041 |    put(myautomata.states, currstate)
2042 | 
2043 |    while currstate.label ~= 52 do {
2044 |       currstate := pop(myautomata.states)
2045 |       put(myautomata.states, currstate)
2046 |       }
2047 |    state2 := currstate
2048 | 
2049 |    tempedge := edge("i", [])
2050 |    currstate := pop(myautomata.states)
2051 |    put(myautomata.states, currstate)
2052 | 
2053 |    while currstate.label ~= 86 do {
2054 |       currstate := pop(myautomata.states)
2055 |       put(myautomata.states, currstate)
2056 |       }
2057 |    put(tempedge.destinations, currstate)
2058 | 
2059 |    put(state2.edges, tempedge)
2060 |    currstate := pop(myautomata.states)
2061 |    put(myautomata.states, currstate)
2062 | 
2063 |    while currstate.label ~= 53 do {
2064 |       currstate := pop(myautomata.states)
2065 |       put(myautomata.states, currstate)
2066 |       }
2067 |    state2 := currstate
2068 | 
2069 |    currstate := pop(myautomata.states)
2070 |    put(myautomata.states, currstate)
2071 | 
2072 |    while currstate.label ~= 54 do {
2073 |       currstate := pop(myautomata.states)
2074 |       put(myautomata.states, currstate)
2075 |       }
2076 |    state2 := currstate
2077 | 
2078 |    tempedge := edge("t", [])
2079 |    currstate := pop(myautomata.states)
2080 |    put(myautomata.states, currstate)
2081 | 
2082 |    while currstate.label ~= 87 do {
2083 |       currstate := pop(myautomata.states)
2084 |       put(myautomata.states, currstate)
2085 |       }
2086 |    put(tempedge.destinations, currstate)
2087 | 
2088 |    put(state2.edges, tempedge)
2089 |    currstate := pop(myautomata.states)
2090 |    put(myautomata.states, currstate)
2091 | 
2092 |    while currstate.label ~= 55 do {
2093 |       currstate := pop(myautomata.states)
2094 |       put(myautomata.states, currstate)
2095 |       }
2096 |    state2 := currstate
2097 | 
2098 |    tempedge := edge("s", [])
2099 |    currstate := pop(myautomata.states)
2100 |    put(myautomata.states, currstate)
2101 | 
2102 |    while currstate.label ~= 88 do {
2103 |       currstate := pop(myautomata.states)
2104 |       put(myautomata.states, currstate)
2105 |       }
2106 |    put(tempedge.destinations, currstate)
2107 | 
2108 |    put(state2.edges, tempedge)
2109 |    currstate := pop(myautomata.states)
2110 |    put(myautomata.states, currstate)
2111 | 
2112 |    while currstate.label ~= 56 do {
2113 |       currstate := pop(myautomata.states)
2114 |       put(myautomata.states, currstate)
2115 |       }
2116 |    state2 := currstate
2117 | 
2118 |    tempedge := edge("\a", [])
2119 |    currstate := pop(myautomata.states)
2120 |    put(myautomata.states, currstate)
2121 | 
2122 |    while currstate.label ~= 89 do {
2123 |       currstate := pop(myautomata.states)
2124 |       put(myautomata.states, currstate)
2125 |       }
2126 |    put(tempedge.destinations, currstate)
2127 | 
2128 |    put(state2.edges, tempedge)
2129 |    currstate := pop(myautomata.states)
2130 |    put(myautomata.states, currstate)
2131 | 
2132 |    while currstate.label ~= 57 do {
2133 |       currstate := pop(myautomata.states)
2134 |       put(myautomata.states, currstate)
2135 |       }
2136 |    state2 := currstate
2137 | 
2138 |    tempedge := edge("r", [])
2139 |    currstate := pop(myautomata.states)
2140 |    put(myautomata.states, currstate)
2141 | 
2142 |    while currstate.label ~= 90 do {
2143 |       currstate := pop(myautomata.states)
2144 |       put(myautomata.states, currstate)
2145 |       }
2146 |    put(tempedge.destinations, currstate)
2147 | 
2148 |    put(state2.edges, tempedge)
2149 |    tempedge := edge("\a", [])
2150 |    currstate := pop(myautomata.states)
2151 |    put(myautomata.states, currstate)
2152 | 
2153 |    while currstate.label ~= 91 do {
2154 |       currstate := pop(myautomata.states)
2155 |       put(myautomata.states, currstate)
2156 |       }
2157 |    put(tempedge.destinations, currstate)
2158 | 
2159 |    put(state2.edges, tempedge)
2160 |    currstate := pop(myautomata.states)
2161 |    put(myautomata.states, currstate)
2162 | 
2163 |    while currstate.label ~= 58 do {
2164 |       currstate := pop(myautomata.states)
2165 |       put(myautomata.states, currstate)
2166 |       }
2167 |    state2 := currstate
2168 | 
2169 |    tempedge := edge(csetfromrecset("[^*]"), [])
2170 |    currstate := pop(myautomata.states)
2171 |    put(myautomata.states, currstate)
2172 | 
2173 |    while currstate.label ~= 92 do {
2174 |       currstate := pop(myautomata.states)
2175 |       put(myautomata.states, currstate)
2176 |       }
2177 |    put(tempedge.destinations, currstate)
2178 | 
2179 |    put(state2.edges, tempedge)
2180 |    tempedge := edge("*", [])
2181 |    currstate := pop(myautomata.states)
2182 |    put(myautomata.states, currstate)
2183 | 
2184 |    while currstate.label ~= 93 do {
2185 |       currstate := pop(myautomata.states)
2186 |       put(myautomata.states, currstate)
2187 |       }
2188 |    put(tempedge.destinations, currstate)
2189 | 
2190 |    put(state2.edges, tempedge)
2191 |    currstate := pop(myautomata.states)
2192 |    put(myautomata.states, currstate)
2193 | 
2194 |    while currstate.label ~= 59 do {
2195 |       currstate := pop(myautomata.states)
2196 |       put(myautomata.states, currstate)
2197 |       }
2198 |    state2 := currstate
2199 | 
2200 |    tempedge := edge("\n"
2201 | , [])
2202 |    currstate := pop(myautomata.states)
2203 |    put(myautomata.states, currstate)
2204 | 
2205 |    while currstate.label ~= 94 do {
2206 |       currstate := pop(myautomata.states)
2207 |       put(myautomata.states, currstate)
2208 |       }
2209 |    put(tempedge.destinations, currstate)
2210 | 
2211 |    put(state2.edges, tempedge)
2212 |    tempedge := edge("r", [])
2213 |    currstate := pop(myautomata.states)
2214 |    put(myautomata.states, currstate)
2215 | 
2216 |    while currstate.label ~= 95 do {
2217 |       currstate := pop(myautomata.states)
2218 |       put(myautomata.states, currstate)
2219 |       }
2220 |    put(tempedge.destinations, currstate)
2221 | 
2222 |    put(state2.edges, tempedge)
2223 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2224 |    currstate := pop(myautomata.states)
2225 |    put(myautomata.states, currstate)
2226 | 
2227 |    while currstate.label ~= 96 do {
2228 |       currstate := pop(myautomata.states)
2229 |       put(myautomata.states, currstate)
2230 |       }
2231 |    put(tempedge.destinations, currstate)
2232 | 
2233 |    put(state2.edges, tempedge)
2234 |    currstate := pop(myautomata.states)
2235 |    put(myautomata.states, currstate)
2236 | 
2237 |    while currstate.label ~= 60 do {
2238 |       currstate := pop(myautomata.states)
2239 |       put(myautomata.states, currstate)
2240 |       }
2241 |    state2 := currstate
2242 | 
2243 |    currstate := pop(myautomata.states)
2244 |    put(myautomata.states, currstate)
2245 | 
2246 |    while currstate.label ~= 61 do {
2247 |       currstate := pop(myautomata.states)
2248 |       put(myautomata.states, currstate)
2249 |       }
2250 |    state2 := currstate
2251 | 
2252 |    currstate := pop(myautomata.states)
2253 |    put(myautomata.states, currstate)
2254 | 
2255 |    while currstate.label ~= 62 do {
2256 |       currstate := pop(myautomata.states)
2257 |       put(myautomata.states, currstate)
2258 |       }
2259 |    state2 := currstate
2260 | 
2261 |    currstate := pop(myautomata.states)
2262 |    put(myautomata.states, currstate)
2263 | 
2264 |    while currstate.label ~= 63 do {
2265 |       currstate := pop(myautomata.states)
2266 |       put(myautomata.states, currstate)
2267 |       }
2268 |    state2 := currstate
2269 | 
2270 |    currstate := pop(myautomata.states)
2271 |    put(myautomata.states, currstate)
2272 | 
2273 |    while currstate.label ~= 64 do {
2274 |       currstate := pop(myautomata.states)
2275 |       put(myautomata.states, currstate)
2276 |       }
2277 |    state2 := currstate
2278 | 
2279 |    currstate := pop(myautomata.states)
2280 |    put(myautomata.states, currstate)
2281 | 
2282 |    while currstate.label ~= 65 do {
2283 |       currstate := pop(myautomata.states)
2284 |       put(myautomata.states, currstate)
2285 |       }
2286 |    state2 := currstate
2287 | 
2288 |    currstate := pop(myautomata.states)
2289 |    put(myautomata.states, currstate)
2290 | 
2291 |    while currstate.label ~= 66 do {
2292 |       currstate := pop(myautomata.states)
2293 |       put(myautomata.states, currstate)
2294 |       }
2295 |    state2 := currstate
2296 | 
2297 |    currstate := pop(myautomata.states)
2298 |    put(myautomata.states, currstate)
2299 | 
2300 |    while currstate.label ~= 67 do {
2301 |       currstate := pop(myautomata.states)
2302 |       put(myautomata.states, currstate)
2303 |       }
2304 |    state2 := currstate
2305 | 
2306 |    currstate := pop(myautomata.states)
2307 |    put(myautomata.states, currstate)
2308 | 
2309 |    while currstate.label ~= 68 do {
2310 |       currstate := pop(myautomata.states)
2311 |       put(myautomata.states, currstate)
2312 |       }
2313 |    state2 := currstate
2314 | 
2315 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
2316 |    currstate := pop(myautomata.states)
2317 |    put(myautomata.states, currstate)
2318 | 
2319 |    while currstate.label ~= 68 do {
2320 |       currstate := pop(myautomata.states)
2321 |       put(myautomata.states, currstate)
2322 |       }
2323 |    put(tempedge.destinations, currstate)
2324 | 
2325 |    put(state2.edges, tempedge)
2326 |    currstate := pop(myautomata.states)
2327 |    put(myautomata.states, currstate)
2328 | 
2329 |    while currstate.label ~= 69 do {
2330 |       currstate := pop(myautomata.states)
2331 |       put(myautomata.states, currstate)
2332 |       }
2333 |    state2 := currstate
2334 | 
2335 |    tempedge := edge(csetfromrecset("[+-]"), [])
2336 |    currstate := pop(myautomata.states)
2337 |    put(myautomata.states, currstate)
2338 | 
2339 |    while currstate.label ~= 97 do {
2340 |       currstate := pop(myautomata.states)
2341 |       put(myautomata.states, currstate)
2342 |       }
2343 |    put(tempedge.destinations, currstate)
2344 | 
2345 |    put(state2.edges, tempedge)
2346 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2347 |    currstate := pop(myautomata.states)
2348 |    put(myautomata.states, currstate)
2349 | 
2350 |    while currstate.label ~= 98 do {
2351 |       currstate := pop(myautomata.states)
2352 |       put(myautomata.states, currstate)
2353 |       }
2354 |    put(tempedge.destinations, currstate)
2355 | 
2356 |    put(state2.edges, tempedge)
2357 |    currstate := pop(myautomata.states)
2358 |    put(myautomata.states, currstate)
2359 | 
2360 |    while currstate.label ~= 70 do {
2361 |       currstate := pop(myautomata.states)
2362 |       put(myautomata.states, currstate)
2363 |       }
2364 |    state2 := currstate
2365 | 
2366 |    tempedge := edge(csetfromrecset("[eE]"), [])
2367 |    currstate := pop(myautomata.states)
2368 |    put(myautomata.states, currstate)
2369 | 
2370 |    while currstate.label ~= 69 do {
2371 |       currstate := pop(myautomata.states)
2372 |       put(myautomata.states, currstate)
2373 |       }
2374 |    put(tempedge.destinations, currstate)
2375 | 
2376 |    put(state2.edges, tempedge)
2377 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2378 |    currstate := pop(myautomata.states)
2379 |    put(myautomata.states, currstate)
2380 | 
2381 |    while currstate.label ~= 70 do {
2382 |       currstate := pop(myautomata.states)
2383 |       put(myautomata.states, currstate)
2384 |       }
2385 |    put(tempedge.destinations, currstate)
2386 | 
2387 |    put(state2.edges, tempedge)
2388 |    currstate := pop(myautomata.states)
2389 |    put(myautomata.states, currstate)
2390 | 
2391 |    while currstate.label ~= 71 do {
2392 |       currstate := pop(myautomata.states)
2393 |       put(myautomata.states, currstate)
2394 |       }
2395 |    state2 := currstate
2396 | 
2397 |    tempedge := edge(csetfromrecset("[eE]"), [])
2398 |    currstate := pop(myautomata.states)
2399 |    put(myautomata.states, currstate)
2400 | 
2401 |    while currstate.label ~= 69 do {
2402 |       currstate := pop(myautomata.states)
2403 |       put(myautomata.states, currstate)
2404 |       }
2405 |    put(tempedge.destinations, currstate)
2406 | 
2407 |    put(state2.edges, tempedge)
2408 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2409 |    currstate := pop(myautomata.states)
2410 |    put(myautomata.states, currstate)
2411 | 
2412 |    while currstate.label ~= 70 do {
2413 |       currstate := pop(myautomata.states)
2414 |       put(myautomata.states, currstate)
2415 |       }
2416 |    put(tempedge.destinations, currstate)
2417 | 
2418 |    put(state2.edges, tempedge)
2419 |    currstate := pop(myautomata.states)
2420 |    put(myautomata.states, currstate)
2421 | 
2422 |    while currstate.label ~= 72 do {
2423 |       currstate := pop(myautomata.states)
2424 |       put(myautomata.states, currstate)
2425 |       }
2426 |    state2 := currstate
2427 | 
2428 |    tempedge := edge(csetfromrecset("[+-]"), [])
2429 |    currstate := pop(myautomata.states)
2430 |    put(myautomata.states, currstate)
2431 | 
2432 |    while currstate.label ~= 99 do {
2433 |       currstate := pop(myautomata.states)
2434 |       put(myautomata.states, currstate)
2435 |       }
2436 |    put(tempedge.destinations, currstate)
2437 | 
2438 |    put(state2.edges, tempedge)
2439 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2440 |    currstate := pop(myautomata.states)
2441 |    put(myautomata.states, currstate)
2442 | 
2443 |    while currstate.label ~= 100 do {
2444 |       currstate := pop(myautomata.states)
2445 |       put(myautomata.states, currstate)
2446 |       }
2447 |    put(tempedge.destinations, currstate)
2448 | 
2449 |    put(state2.edges, tempedge)
2450 |    currstate := pop(myautomata.states)
2451 |    put(myautomata.states, currstate)
2452 | 
2453 |    while currstate.label ~= 73 do {
2454 |       currstate := pop(myautomata.states)
2455 |       put(myautomata.states, currstate)
2456 |       }
2457 |    state2 := currstate
2458 | 
2459 |    tempedge := edge(csetfromrecset("[^\"]"), [])
2460 |    currstate := pop(myautomata.states)
2461 |    put(myautomata.states, currstate)
2462 | 
2463 |    while currstate.label ~= 73 do {
2464 |       currstate := pop(myautomata.states)
2465 |       put(myautomata.states, currstate)
2466 |       }
2467 |    put(tempedge.destinations, currstate)
2468 | 
2469 |    put(state2.edges, tempedge)
2470 |    tempedge := edge("\\", [])
2471 |    currstate := pop(myautomata.states)
2472 |    put(myautomata.states, currstate)
2473 | 
2474 |    while currstate.label ~= 74 do {
2475 |       currstate := pop(myautomata.states)
2476 |       put(myautomata.states, currstate)
2477 |       }
2478 |    put(tempedge.destinations, currstate)
2479 | 
2480 |    put(state2.edges, tempedge)
2481 |    tempedge := edge("\"", [])
2482 |    currstate := pop(myautomata.states)
2483 |    put(myautomata.states, currstate)
2484 | 
2485 |    while currstate.label ~= 75 do {
2486 |       currstate := pop(myautomata.states)
2487 |       put(myautomata.states, currstate)
2488 |       }
2489 |    put(tempedge.destinations, currstate)
2490 | 
2491 |    put(state2.edges, tempedge)
2492 |    currstate := pop(myautomata.states)
2493 |    put(myautomata.states, currstate)
2494 | 
2495 |    while currstate.label ~= 74 do {
2496 |       currstate := pop(myautomata.states)
2497 |       put(myautomata.states, currstate)
2498 |       }
2499 |    state2 := currstate
2500 | 
2501 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2502 |    currstate := pop(myautomata.states)
2503 |    put(myautomata.states, currstate)
2504 | 
2505 |    while currstate.label ~= 101 do {
2506 |       currstate := pop(myautomata.states)
2507 |       put(myautomata.states, currstate)
2508 |       }
2509 |    put(tempedge.destinations, currstate)
2510 | 
2511 |    put(state2.edges, tempedge)
2512 |    currstate := pop(myautomata.states)
2513 |    put(myautomata.states, currstate)
2514 | 
2515 |    while currstate.label ~= 75 do {
2516 |       currstate := pop(myautomata.states)
2517 |       put(myautomata.states, currstate)
2518 |       }
2519 |    state2 := currstate
2520 | 
2521 |    currstate := pop(myautomata.states)
2522 |    put(myautomata.states, currstate)
2523 | 
2524 |    while currstate.label ~= 76 do {
2525 |       currstate := pop(myautomata.states)
2526 |       put(myautomata.states, currstate)
2527 |       }
2528 |    state2 := currstate
2529 | 
2530 |    currstate := pop(myautomata.states)
2531 |    put(myautomata.states, currstate)
2532 | 
2533 |    while currstate.label ~= 77 do {
2534 |       currstate := pop(myautomata.states)
2535 |       put(myautomata.states, currstate)
2536 |       }
2537 |    state2 := currstate
2538 | 
2539 |    tempedge := edge("s", [])
2540 |    currstate := pop(myautomata.states)
2541 |    put(myautomata.states, currstate)
2542 | 
2543 |    while currstate.label ~= 102 do {
2544 |       currstate := pop(myautomata.states)
2545 |       put(myautomata.states, currstate)
2546 |       }
2547 |    put(tempedge.destinations, currstate)
2548 | 
2549 |    put(state2.edges, tempedge)
2550 |    currstate := pop(myautomata.states)
2551 |    put(myautomata.states, currstate)
2552 | 
2553 |    while currstate.label ~= 78 do {
2554 |       currstate := pop(myautomata.states)
2555 |       put(myautomata.states, currstate)
2556 |       }
2557 |    state2 := currstate
2558 | 
2559 |    tempedge := edge("l", [])
2560 |    currstate := pop(myautomata.states)
2561 |    put(myautomata.states, currstate)
2562 | 
2563 |    while currstate.label ~= 103 do {
2564 |       currstate := pop(myautomata.states)
2565 |       put(myautomata.states, currstate)
2566 |       }
2567 |    put(tempedge.destinations, currstate)
2568 | 
2569 |    put(state2.edges, tempedge)
2570 |    currstate := pop(myautomata.states)
2571 |    put(myautomata.states, currstate)
2572 | 
2573 |    while currstate.label ~= 79 do {
2574 |       currstate := pop(myautomata.states)
2575 |       put(myautomata.states, currstate)
2576 |       }
2577 |    state2 := currstate
2578 | 
2579 |    tempedge := edge("l", [])
2580 |    currstate := pop(myautomata.states)
2581 |    put(myautomata.states, currstate)
2582 | 
2583 |    while currstate.label ~= 104 do {
2584 |       currstate := pop(myautomata.states)
2585 |       put(myautomata.states, currstate)
2586 |       }
2587 |    put(tempedge.destinations, currstate)
2588 | 
2589 |    put(state2.edges, tempedge)
2590 |    currstate := pop(myautomata.states)
2591 |    put(myautomata.states, currstate)
2592 | 
2593 |    while currstate.label ~= 80 do {
2594 |       currstate := pop(myautomata.states)
2595 |       put(myautomata.states, currstate)
2596 |       }
2597 |    state2 := currstate
2598 | 
2599 |    tempedge := edge("e", [])
2600 |    currstate := pop(myautomata.states)
2601 |    put(myautomata.states, currstate)
2602 | 
2603 |    while currstate.label ~= 105 do {
2604 |       currstate := pop(myautomata.states)
2605 |       put(myautomata.states, currstate)
2606 |       }
2607 |    put(tempedge.destinations, currstate)
2608 | 
2609 |    put(state2.edges, tempedge)
2610 |    currstate := pop(myautomata.states)
2611 |    put(myautomata.states, currstate)
2612 | 
2613 |    while currstate.label ~= 81 do {
2614 |       currstate := pop(myautomata.states)
2615 |       put(myautomata.states, currstate)
2616 |       }
2617 |    state2 := currstate
2618 | 
2619 |    tempedge := edge("u", [])
2620 |    currstate := pop(myautomata.states)
2621 |    put(myautomata.states, currstate)
2622 | 
2623 |    while currstate.label ~= 106 do {
2624 |       currstate := pop(myautomata.states)
2625 |       put(myautomata.states, currstate)
2626 |       }
2627 |    put(tempedge.destinations, currstate)
2628 | 
2629 |    put(state2.edges, tempedge)
2630 |    currstate := pop(myautomata.states)
2631 |    put(myautomata.states, currstate)
2632 | 
2633 |    while currstate.label ~= 82 do {
2634 |       currstate := pop(myautomata.states)
2635 |       put(myautomata.states, currstate)
2636 |       }
2637 |    state2 := currstate
2638 | 
2639 |    tempedge := edge("\a", [])
2640 |    currstate := pop(myautomata.states)
2641 |    put(myautomata.states, currstate)
2642 | 
2643 |    while currstate.label ~= 107 do {
2644 |       currstate := pop(myautomata.states)
2645 |       put(myautomata.states, currstate)
2646 |       }
2647 |    put(tempedge.destinations, currstate)
2648 | 
2649 |    put(state2.edges, tempedge)
2650 |    currstate := pop(myautomata.states)
2651 |    put(myautomata.states, currstate)
2652 | 
2653 |    while currstate.label ~= 83 do {
2654 |       currstate := pop(myautomata.states)
2655 |       put(myautomata.states, currstate)
2656 |       }
2657 |    state2 := currstate
2658 | 
2659 |    tempedge := edge("l", [])
2660 |    currstate := pop(myautomata.states)
2661 |    put(myautomata.states, currstate)
2662 | 
2663 |    while currstate.label ~= 108 do {
2664 |       currstate := pop(myautomata.states)
2665 |       put(myautomata.states, currstate)
2666 |       }
2667 |    put(tempedge.destinations, currstate)
2668 | 
2669 |    put(state2.edges, tempedge)
2670 |    currstate := pop(myautomata.states)
2671 |    put(myautomata.states, currstate)
2672 | 
2673 |    while currstate.label ~= 84 do {
2674 |       currstate := pop(myautomata.states)
2675 |       put(myautomata.states, currstate)
2676 |       }
2677 |    state2 := currstate
2678 | 
2679 |    tempedge := edge("d", [])
2680 |    currstate := pop(myautomata.states)
2681 |    put(myautomata.states, currstate)
2682 | 
2683 |    while currstate.label ~= 109 do {
2684 |       currstate := pop(myautomata.states)
2685 |       put(myautomata.states, currstate)
2686 |       }
2687 |    put(tempedge.destinations, currstate)
2688 | 
2689 |    put(state2.edges, tempedge)
2690 |    currstate := pop(myautomata.states)
2691 |    put(myautomata.states, currstate)
2692 | 
2693 |    while currstate.label ~= 85 do {
2694 |       currstate := pop(myautomata.states)
2695 |       put(myautomata.states, currstate)
2696 |       }
2697 |    state2 := currstate
2698 | 
2699 |    tempedge := edge("b", [])
2700 |    currstate := pop(myautomata.states)
2701 |    put(myautomata.states, currstate)
2702 | 
2703 |    while currstate.label ~= 110 do {
2704 |       currstate := pop(myautomata.states)
2705 |       put(myautomata.states, currstate)
2706 |       }
2707 |    put(tempedge.destinations, currstate)
2708 | 
2709 |    put(state2.edges, tempedge)
2710 |    currstate := pop(myautomata.states)
2711 |    put(myautomata.states, currstate)
2712 | 
2713 |    while currstate.label ~= 86 do {
2714 |       currstate := pop(myautomata.states)
2715 |       put(myautomata.states, currstate)
2716 |       }
2717 |    state2 := currstate
2718 | 
2719 |    tempedge := edge("l", [])
2720 |    currstate := pop(myautomata.states)
2721 |    put(myautomata.states, currstate)
2722 | 
2723 |    while currstate.label ~= 111 do {
2724 |       currstate := pop(myautomata.states)
2725 |       put(myautomata.states, currstate)
2726 |       }
2727 |    put(tempedge.destinations, currstate)
2728 | 
2729 |    put(state2.edges, tempedge)
2730 |    currstate := pop(myautomata.states)
2731 |    put(myautomata.states, currstate)
2732 | 
2733 |    while currstate.label ~= 87 do {
2734 |       currstate := pop(myautomata.states)
2735 |       put(myautomata.states, currstate)
2736 |       }
2737 |    state2 := currstate
2738 | 
2739 |    currstate := pop(myautomata.states)
2740 |    put(myautomata.states, currstate)
2741 | 
2742 |    while currstate.label ~= 88 do {
2743 |       currstate := pop(myautomata.states)
2744 |       put(myautomata.states, currstate)
2745 |       }
2746 |    state2 := currstate
2747 | 
2748 |    tempedge := edge("e", [])
2749 |    currstate := pop(myautomata.states)
2750 |    put(myautomata.states, currstate)
2751 | 
2752 |    while currstate.label ~= 112 do {
2753 |       currstate := pop(myautomata.states)
2754 |       put(myautomata.states, currstate)
2755 |       }
2756 |    put(tempedge.destinations, currstate)
2757 | 
2758 |    put(state2.edges, tempedge)
2759 |    currstate := pop(myautomata.states)
2760 |    put(myautomata.states, currstate)
2761 | 
2762 |    while currstate.label ~= 89 do {
2763 |       currstate := pop(myautomata.states)
2764 |       put(myautomata.states, currstate)
2765 |       }
2766 |    state2 := currstate
2767 | 
2768 |    tempedge := edge("s", [])
2769 |    currstate := pop(myautomata.states)
2770 |    put(myautomata.states, currstate)
2771 | 
2772 |    while currstate.label ~= 113 do {
2773 |       currstate := pop(myautomata.states)
2774 |       put(myautomata.states, currstate)
2775 |       }
2776 |    put(tempedge.destinations, currstate)
2777 | 
2778 |    put(state2.edges, tempedge)
2779 |    currstate := pop(myautomata.states)
2780 |    put(myautomata.states, currstate)
2781 | 
2782 |    while currstate.label ~= 90 do {
2783 |       currstate := pop(myautomata.states)
2784 |       put(myautomata.states, currstate)
2785 |       }
2786 |    state2 := currstate
2787 | 
2788 |    tempedge := edge("i", [])
2789 |    currstate := pop(myautomata.states)
2790 |    put(myautomata.states, currstate)
2791 | 
2792 |    while currstate.label ~= 114 do {
2793 |       currstate := pop(myautomata.states)
2794 |       put(myautomata.states, currstate)
2795 |       }
2796 |    put(tempedge.destinations, currstate)
2797 | 
2798 |    put(state2.edges, tempedge)
2799 |    currstate := pop(myautomata.states)
2800 |    put(myautomata.states, currstate)
2801 | 
2802 |    while currstate.label ~= 91 do {
2803 |       currstate := pop(myautomata.states)
2804 |       put(myautomata.states, currstate)
2805 |       }
2806 |    state2 := currstate
2807 | 
2808 |    tempedge := edge("t", [])
2809 |    currstate := pop(myautomata.states)
2810 |    put(myautomata.states, currstate)
2811 | 
2812 |    while currstate.label ~= 115 do {
2813 |       currstate := pop(myautomata.states)
2814 |       put(myautomata.states, currstate)
2815 |       }
2816 |    put(tempedge.destinations, currstate)
2817 | 
2818 |    put(state2.edges, tempedge)
2819 |    currstate := pop(myautomata.states)
2820 |    put(myautomata.states, currstate)
2821 | 
2822 |    while currstate.label ~= 92 do {
2823 |       currstate := pop(myautomata.states)
2824 |       put(myautomata.states, currstate)
2825 |       }
2826 |    state2 := currstate
2827 | 
2828 |    tempedge := edge(csetfromrecset("[^*]"), [])
2829 |    currstate := pop(myautomata.states)
2830 |    put(myautomata.states, currstate)
2831 | 
2832 |    while currstate.label ~= 92 do {
2833 |       currstate := pop(myautomata.states)
2834 |       put(myautomata.states, currstate)
2835 |       }
2836 |    put(tempedge.destinations, currstate)
2837 | 
2838 |    put(state2.edges, tempedge)
2839 |    tempedge := edge("*", [])
2840 |    currstate := pop(myautomata.states)
2841 |    put(myautomata.states, currstate)
2842 | 
2843 |    while currstate.label ~= 93 do {
2844 |       currstate := pop(myautomata.states)
2845 |       put(myautomata.states, currstate)
2846 |       }
2847 |    put(tempedge.destinations, currstate)
2848 | 
2849 |    put(state2.edges, tempedge)
2850 |    currstate := pop(myautomata.states)
2851 |    put(myautomata.states, currstate)
2852 | 
2853 |    while currstate.label ~= 93 do {
2854 |       currstate := pop(myautomata.states)
2855 |       put(myautomata.states, currstate)
2856 |       }
2857 |    state2 := currstate
2858 | 
2859 |    tempedge := edge(csetfromrecset("[^/*]"), [])
2860 |    currstate := pop(myautomata.states)
2861 |    put(myautomata.states, currstate)
2862 | 
2863 |    while currstate.label ~= 116 do {
2864 |       currstate := pop(myautomata.states)
2865 |       put(myautomata.states, currstate)
2866 |       }
2867 |    put(tempedge.destinations, currstate)
2868 | 
2869 |    put(state2.edges, tempedge)
2870 |    tempedge := edge("*", [])
2871 |    currstate := pop(myautomata.states)
2872 |    put(myautomata.states, currstate)
2873 | 
2874 |    while currstate.label ~= 93 do {
2875 |       currstate := pop(myautomata.states)
2876 |       put(myautomata.states, currstate)
2877 |       }
2878 |    put(tempedge.destinations, currstate)
2879 | 
2880 |    put(state2.edges, tempedge)
2881 |    tempedge := edge("/", [])
2882 |    currstate := pop(myautomata.states)
2883 |    put(myautomata.states, currstate)
2884 | 
2885 |    while currstate.label ~= 117 do {
2886 |       currstate := pop(myautomata.states)
2887 |       put(myautomata.states, currstate)
2888 |       }
2889 |    put(tempedge.destinations, currstate)
2890 | 
2891 |    put(state2.edges, tempedge)
2892 |    currstate := pop(myautomata.states)
2893 |    put(myautomata.states, currstate)
2894 | 
2895 |    while currstate.label ~= 94 do {
2896 |       currstate := pop(myautomata.states)
2897 |       put(myautomata.states, currstate)
2898 |       }
2899 |    state2 := currstate
2900 | 
2901 |    currstate := pop(myautomata.states)
2902 |    put(myautomata.states, currstate)
2903 | 
2904 |    while currstate.label ~= 95 do {
2905 |       currstate := pop(myautomata.states)
2906 |       put(myautomata.states, currstate)
2907 |       }
2908 |    state2 := currstate
2909 | 
2910 |    tempedge := edge("\n"
2911 | , [])
2912 |    currstate := pop(myautomata.states)
2913 |    put(myautomata.states, currstate)
2914 | 
2915 |    while currstate.label ~= 94 do {
2916 |       currstate := pop(myautomata.states)
2917 |       put(myautomata.states, currstate)
2918 |       }
2919 |    put(tempedge.destinations, currstate)
2920 | 
2921 |    put(state2.edges, tempedge)
2922 |    currstate := pop(myautomata.states)
2923 |    put(myautomata.states, currstate)
2924 | 
2925 |    while currstate.label ~= 96 do {
2926 |       currstate := pop(myautomata.states)
2927 |       put(myautomata.states, currstate)
2928 |       }
2929 |    state2 := currstate
2930 | 
2931 |    tempedge := edge("\n"
2932 | , [])
2933 |    currstate := pop(myautomata.states)
2934 |    put(myautomata.states, currstate)
2935 | 
2936 |    while currstate.label ~= 94 do {
2937 |       currstate := pop(myautomata.states)
2938 |       put(myautomata.states, currstate)
2939 |       }
2940 |    put(tempedge.destinations, currstate)
2941 | 
2942 |    put(state2.edges, tempedge)
2943 |    tempedge := edge("r", [])
2944 |    currstate := pop(myautomata.states)
2945 |    put(myautomata.states, currstate)
2946 | 
2947 |    while currstate.label ~= 95 do {
2948 |       currstate := pop(myautomata.states)
2949 |       put(myautomata.states, currstate)
2950 |       }
2951 |    put(tempedge.destinations, currstate)
2952 | 
2953 |    put(state2.edges, tempedge)
2954 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2955 |    currstate := pop(myautomata.states)
2956 |    put(myautomata.states, currstate)
2957 | 
2958 |    while currstate.label ~= 96 do {
2959 |       currstate := pop(myautomata.states)
2960 |       put(myautomata.states, currstate)
2961 |       }
2962 |    put(tempedge.destinations, currstate)
2963 | 
2964 |    put(state2.edges, tempedge)
2965 |    currstate := pop(myautomata.states)
2966 |    put(myautomata.states, currstate)
2967 | 
2968 |    while currstate.label ~= 97 do {
2969 |       currstate := pop(myautomata.states)
2970 |       put(myautomata.states, currstate)
2971 |       }
2972 |    state2 := currstate
2973 | 
2974 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2975 |    currstate := pop(myautomata.states)
2976 |    put(myautomata.states, currstate)
2977 | 
2978 |    while currstate.label ~= 98 do {
2979 |       currstate := pop(myautomata.states)
2980 |       put(myautomata.states, currstate)
2981 |       }
2982 |    put(tempedge.destinations, currstate)
2983 | 
2984 |    put(state2.edges, tempedge)
2985 |    currstate := pop(myautomata.states)
2986 |    put(myautomata.states, currstate)
2987 | 
2988 |    while currstate.label ~= 98 do {
2989 |       currstate := pop(myautomata.states)
2990 |       put(myautomata.states, currstate)
2991 |       }
2992 |    state2 := currstate
2993 | 
2994 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2995 |    currstate := pop(myautomata.states)
2996 |    put(myautomata.states, currstate)
2997 | 
2998 |    while currstate.label ~= 98 do {
2999 |       currstate := pop(myautomata.states)
3000 |       put(myautomata.states, currstate)
3001 |       }
3002 |    put(tempedge.destinations, currstate)
3003 | 
3004 |    put(state2.edges, tempedge)
3005 |    currstate := pop(myautomata.states)
3006 |    put(myautomata.states, currstate)
3007 | 
3008 |    while currstate.label ~= 99 do {
3009 |       currstate := pop(myautomata.states)
3010 |       put(myautomata.states, currstate)
3011 |       }
3012 |    state2 := currstate
3013 | 
3014 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3015 |    currstate := pop(myautomata.states)
3016 |    put(myautomata.states, currstate)
3017 | 
3018 |    while currstate.label ~= 100 do {
3019 |       currstate := pop(myautomata.states)
3020 |       put(myautomata.states, currstate)
3021 |       }
3022 |    put(tempedge.destinations, currstate)
3023 | 
3024 |    put(state2.edges, tempedge)
3025 |    currstate := pop(myautomata.states)
3026 |    put(myautomata.states, currstate)
3027 | 
3028 |    while currstate.label ~= 100 do {
3029 |       currstate := pop(myautomata.states)
3030 |       put(myautomata.states, currstate)
3031 |       }
3032 |    state2 := currstate
3033 | 
3034 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3035 |    currstate := pop(myautomata.states)
3036 |    put(myautomata.states, currstate)
3037 | 
3038 |    while currstate.label ~= 100 do {
3039 |       currstate := pop(myautomata.states)
3040 |       put(myautomata.states, currstate)
3041 |       }
3042 |    put(tempedge.destinations, currstate)
3043 | 
3044 |    put(state2.edges, tempedge)
3045 |    currstate := pop(myautomata.states)
3046 |    put(myautomata.states, currstate)
3047 | 
3048 |    while currstate.label ~= 101 do {
3049 |       currstate := pop(myautomata.states)
3050 |       put(myautomata.states, currstate)
3051 |       }
3052 |    state2 := currstate
3053 | 
3054 |    tempedge := edge(csetfromrecset("[^\"]"), [])
3055 |    currstate := pop(myautomata.states)
3056 |    put(myautomata.states, currstate)
3057 | 
3058 |    while currstate.label ~= 73 do {
3059 |       currstate := pop(myautomata.states)
3060 |       put(myautomata.states, currstate)
3061 |       }
3062 |    put(tempedge.destinations, currstate)
3063 | 
3064 |    put(state2.edges, tempedge)
3065 |    tempedge := edge("\\", [])
3066 |    currstate := pop(myautomata.states)
3067 |    put(myautomata.states, currstate)
3068 | 
3069 |    while currstate.label ~= 74 do {
3070 |       currstate := pop(myautomata.states)
3071 |       put(myautomata.states, currstate)
3072 |       }
3073 |    put(tempedge.destinations, currstate)
3074 | 
3075 |    put(state2.edges, tempedge)
3076 |    tempedge := edge("\"", [])
3077 |    currstate := pop(myautomata.states)
3078 |    put(myautomata.states, currstate)
3079 | 
3080 |    while currstate.label ~= 75 do {
3081 |       currstate := pop(myautomata.states)
3082 |       put(myautomata.states, currstate)
3083 |       }
3084 |    put(tempedge.destinations, currstate)
3085 | 
3086 |    put(state2.edges, tempedge)
3087 |    currstate := pop(myautomata.states)
3088 |    put(myautomata.states, currstate)
3089 | 
3090 |    while currstate.label ~= 102 do {
3091 |       currstate := pop(myautomata.states)
3092 |       put(myautomata.states, currstate)
3093 |       }
3094 |    state2 := currstate
3095 | 
3096 |    tempedge := edge("e", [])
3097 |    currstate := pop(myautomata.states)
3098 |    put(myautomata.states, currstate)
3099 | 
3100 |    while currstate.label ~= 118 do {
3101 |       currstate := pop(myautomata.states)
3102 |       put(myautomata.states, currstate)
3103 |       }
3104 |    put(tempedge.destinations, currstate)
3105 | 
3106 |    put(state2.edges, tempedge)
3107 |    currstate := pop(myautomata.states)
3108 |    put(myautomata.states, currstate)
3109 | 
3110 |    while currstate.label ~= 103 do {
3111 |       currstate := pop(myautomata.states)
3112 |       put(myautomata.states, currstate)
3113 |       }
3114 |    state2 := currstate
3115 | 
3116 |    tempedge := edge("i", [])
3117 |    currstate := pop(myautomata.states)
3118 |    put(myautomata.states, currstate)
3119 | 
3120 |    while currstate.label ~= 119 do {
3121 |       currstate := pop(myautomata.states)
3122 |       put(myautomata.states, currstate)
3123 |       }
3124 |    put(tempedge.destinations, currstate)
3125 | 
3126 |    put(state2.edges, tempedge)
3127 |    currstate := pop(myautomata.states)
3128 |    put(myautomata.states, currstate)
3129 | 
3130 |    while currstate.label ~= 104 do {
3131 |       currstate := pop(myautomata.states)
3132 |       put(myautomata.states, currstate)
3133 |       }
3134 |    state2 := currstate
3135 | 
3136 |    currstate := pop(myautomata.states)
3137 |    put(myautomata.states, currstate)
3138 | 
3139 |    while currstate.label ~= 105 do {
3140 |       currstate := pop(myautomata.states)
3141 |       put(myautomata.states, currstate)
3142 |       }
3143 |    state2 := currstate
3144 | 
3145 |    currstate := pop(myautomata.states)
3146 |    put(myautomata.states, currstate)
3147 | 
3148 |    while currstate.label ~= 106 do {
3149 |       currstate := pop(myautomata.states)
3150 |       put(myautomata.states, currstate)
3151 |       }
3152 |    state2 := currstate
3153 | 
3154 |    tempedge := edge("r", [])
3155 |    currstate := pop(myautomata.states)
3156 |    put(myautomata.states, currstate)
3157 | 
3158 |    while currstate.label ~= 120 do {
3159 |       currstate := pop(myautomata.states)
3160 |       put(myautomata.states, currstate)
3161 |       }
3162 |    put(tempedge.destinations, currstate)
3163 | 
3164 |    put(state2.edges, tempedge)
3165 |    currstate := pop(myautomata.states)
3166 |    put(myautomata.states, currstate)
3167 | 
3168 |    while currstate.label ~= 107 do {
3169 |       currstate := pop(myautomata.states)
3170 |       put(myautomata.states, currstate)
3171 |       }
3172 |    state2 := currstate
3173 | 
3174 |    tempedge := edge("k", [])
3175 |    currstate := pop(myautomata.states)
3176 |    put(myautomata.states, currstate)
3177 | 
3178 |    while currstate.label ~= 121 do {
3179 |       currstate := pop(myautomata.states)
3180 |       put(myautomata.states, currstate)
3181 |       }
3182 |    put(tempedge.destinations, currstate)
3183 | 
3184 |    put(state2.edges, tempedge)
3185 |    currstate := pop(myautomata.states)
3186 |    put(myautomata.states, currstate)
3187 | 
3188 |    while currstate.label ~= 108 do {
3189 |       currstate := pop(myautomata.states)
3190 |       put(myautomata.states, currstate)
3191 |       }
3192 |    state2 := currstate
3193 | 
3194 |    currstate := pop(myautomata.states)
3195 |    put(myautomata.states, currstate)
3196 | 
3197 |    while currstate.label ~= 109 do {
3198 |       currstate := pop(myautomata.states)
3199 |       put(myautomata.states, currstate)
3200 |       }
3201 |    state2 := currstate
3202 | 
3203 |    currstate := pop(myautomata.states)
3204 |    put(myautomata.states, currstate)
3205 | 
3206 |    while currstate.label ~= 110 do {
3207 |       currstate := pop(myautomata.states)
3208 |       put(myautomata.states, currstate)
3209 |       }
3210 |    state2 := currstate
3211 | 
3212 |    tempedge := edge("l", [])
3213 |    currstate := pop(myautomata.states)
3214 |    put(myautomata.states, currstate)
3215 | 
3216 |    while currstate.label ~= 122 do {
3217 |       currstate := pop(myautomata.states)
3218 |       put(myautomata.states, currstate)
3219 |       }
3220 |    put(tempedge.destinations, currstate)
3221 | 
3222 |    put(state2.edges, tempedge)
3223 |    currstate := pop(myautomata.states)
3224 |    put(myautomata.states, currstate)
3225 | 
3226 |    while currstate.label ~= 111 do {
3227 |       currstate := pop(myautomata.states)
3228 |       put(myautomata.states, currstate)
3229 |       }
3230 |    state2 := currstate
3231 | 
3232 |    tempedge := edge("e", [])
3233 |    currstate := pop(myautomata.states)
3234 |    put(myautomata.states, currstate)
3235 | 
3236 |    while currstate.label ~= 123 do {
3237 |       currstate := pop(myautomata.states)
3238 |       put(myautomata.states, currstate)
3239 |       }
3240 |    put(tempedge.destinations, currstate)
3241 | 
3242 |    put(state2.edges, tempedge)
3243 |    currstate := pop(myautomata.states)
3244 |    put(myautomata.states, currstate)
3245 | 
3246 |    while currstate.label ~= 112 do {
3247 |       currstate := pop(myautomata.states)
3248 |       put(myautomata.states, currstate)
3249 |       }
3250 |    state2 := currstate
3251 | 
3252 |    currstate := pop(myautomata.states)
3253 |    put(myautomata.states, currstate)
3254 | 
3255 |    while currstate.label ~= 113 do {
3256 |       currstate := pop(myautomata.states)
3257 |       put(myautomata.states, currstate)
3258 |       }
3259 |    state2 := currstate
3260 | 
3261 |    tempedge := edge("s", [])
3262 |    currstate := pop(myautomata.states)
3263 |    put(myautomata.states, currstate)
3264 | 
3265 |    while currstate.label ~= 124 do {
3266 |       currstate := pop(myautomata.states)
3267 |       put(myautomata.states, currstate)
3268 |       }
3269 |    put(tempedge.destinations, currstate)
3270 | 
3271 |    put(state2.edges, tempedge)
3272 |    currstate := pop(myautomata.states)
3273 |    put(myautomata.states, currstate)
3274 | 
3275 |    while currstate.label ~= 114 do {
3276 |       currstate := pop(myautomata.states)
3277 |       put(myautomata.states, currstate)
3278 |       }
3279 |    state2 := currstate
3280 | 
3281 |    tempedge := edge("n", [])
3282 |    currstate := pop(myautomata.states)
3283 |    put(myautomata.states, currstate)
3284 | 
3285 |    while currstate.label ~= 125 do {
3286 |       currstate := pop(myautomata.states)
3287 |       put(myautomata.states, currstate)
3288 |       }
3289 |    put(tempedge.destinations, currstate)
3290 | 
3291 |    put(state2.edges, tempedge)
3292 |    currstate := pop(myautomata.states)
3293 |    put(myautomata.states, currstate)
3294 | 
3295 |    while currstate.label ~= 115 do {
3296 |       currstate := pop(myautomata.states)
3297 |       put(myautomata.states, currstate)
3298 |       }
3299 |    state2 := currstate
3300 | 
3301 |    tempedge := edge("i", [])
3302 |    currstate := pop(myautomata.states)
3303 |    put(myautomata.states, currstate)
3304 | 
3305 |    while currstate.label ~= 126 do {
3306 |       currstate := pop(myautomata.states)
3307 |       put(myautomata.states, currstate)
3308 |       }
3309 |    put(tempedge.destinations, currstate)
3310 | 
3311 |    put(state2.edges, tempedge)
3312 |    currstate := pop(myautomata.states)
3313 |    put(myautomata.states, currstate)
3314 | 
3315 |    while currstate.label ~= 116 do {
3316 |       currstate := pop(myautomata.states)
3317 |       put(myautomata.states, currstate)
3318 |       }
3319 |    state2 := currstate
3320 | 
3321 |    tempedge := edge(csetfromrecset("[^*]"), [])
3322 |    currstate := pop(myautomata.states)
3323 |    put(myautomata.states, currstate)
3324 | 
3325 |    while currstate.label ~= 92 do {
3326 |       currstate := pop(myautomata.states)
3327 |       put(myautomata.states, currstate)
3328 |       }
3329 |    put(tempedge.destinations, currstate)
3330 | 
3331 |    put(state2.edges, tempedge)
3332 |    tempedge := edge("*", [])
3333 |    currstate := pop(myautomata.states)
3334 |    put(myautomata.states, currstate)
3335 | 
3336 |    while currstate.label ~= 93 do {
3337 |       currstate := pop(myautomata.states)
3338 |       put(myautomata.states, currstate)
3339 |       }
3340 |    put(tempedge.destinations, currstate)
3341 | 
3342 |    put(state2.edges, tempedge)
3343 |    currstate := pop(myautomata.states)
3344 |    put(myautomata.states, currstate)
3345 | 
3346 |    while currstate.label ~= 117 do {
3347 |       currstate := pop(myautomata.states)
3348 |       put(myautomata.states, currstate)
3349 |       }
3350 |    state2 := currstate
3351 | 
3352 |    currstate := pop(myautomata.states)
3353 |    put(myautomata.states, currstate)
3354 | 
3355 |    while currstate.label ~= 118 do {
3356 |       currstate := pop(myautomata.states)
3357 |       put(myautomata.states, currstate)
3358 |       }
3359 |    state2 := currstate
3360 | 
3361 |    currstate := pop(myautomata.states)
3362 |    put(myautomata.states, currstate)
3363 | 
3364 |    while currstate.label ~= 119 do {
3365 |       currstate := pop(myautomata.states)
3366 |       put(myautomata.states, currstate)
3367 |       }
3368 |    state2 := currstate
3369 | 
3370 |    tempedge := edge("c", [])
3371 |    currstate := pop(myautomata.states)
3372 |    put(myautomata.states, currstate)
3373 | 
3374 |    while currstate.label ~= 127 do {
3375 |       currstate := pop(myautomata.states)
3376 |       put(myautomata.states, currstate)
3377 |       }
3378 |    put(tempedge.destinations, currstate)
3379 | 
3380 |    put(state2.edges, tempedge)
3381 |    currstate := pop(myautomata.states)
3382 |    put(myautomata.states, currstate)
3383 | 
3384 |    while currstate.label ~= 120 do {
3385 |       currstate := pop(myautomata.states)
3386 |       put(myautomata.states, currstate)
3387 |       }
3388 |    state2 := currstate
3389 | 
3390 |    tempedge := edge("n", [])
3391 |    currstate := pop(myautomata.states)
3392 |    put(myautomata.states, currstate)
3393 | 
3394 |    while currstate.label ~= 128 do {
3395 |       currstate := pop(myautomata.states)
3396 |       put(myautomata.states, currstate)
3397 |       }
3398 |    put(tempedge.destinations, currstate)
3399 | 
3400 |    put(state2.edges, tempedge)
3401 |    currstate := pop(myautomata.states)
3402 |    put(myautomata.states, currstate)
3403 | 
3404 |    while currstate.label ~= 121 do {
3405 |       currstate := pop(myautomata.states)
3406 |       put(myautomata.states, currstate)
3407 |       }
3408 |    state2 := currstate
3409 | 
3410 |    currstate := pop(myautomata.states)
3411 |    put(myautomata.states, currstate)
3412 | 
3413 |    while currstate.label ~= 122 do {
3414 |       currstate := pop(myautomata.states)
3415 |       put(myautomata.states, currstate)
3416 |       }
3417 |    state2 := currstate
3418 | 
3419 |    tempedge := edge("e", [])
3420 |    currstate := pop(myautomata.states)
3421 |    put(myautomata.states, currstate)
3422 | 
3423 |    while currstate.label ~= 129 do {
3424 |       currstate := pop(myautomata.states)
3425 |       put(myautomata.states, currstate)
3426 |       }
3427 |    put(tempedge.destinations, currstate)
3428 | 
3429 |    put(state2.edges, tempedge)
3430 |    currstate := pop(myautomata.states)
3431 |    put(myautomata.states, currstate)
3432 | 
3433 |    while currstate.label ~= 123 do {
3434 |       currstate := pop(myautomata.states)
3435 |       put(myautomata.states, currstate)
3436 |       }
3437 |    state2 := currstate
3438 | 
3439 |    currstate := pop(myautomata.states)
3440 |    put(myautomata.states, currstate)
3441 | 
3442 |    while currstate.label ~= 124 do {
3443 |       currstate := pop(myautomata.states)
3444 |       put(myautomata.states, currstate)
3445 |       }
3446 |    state2 := currstate
3447 | 
3448 |    currstate := pop(myautomata.states)
3449 |    put(myautomata.states, currstate)
3450 | 
3451 |    while currstate.label ~= 125 do {
3452 |       currstate := pop(myautomata.states)
3453 |       put(myautomata.states, currstate)
3454 |       }
3455 |    state2 := currstate
3456 | 
3457 |    tempedge := edge("g", [])
3458 |    currstate := pop(myautomata.states)
3459 |    put(myautomata.states, currstate)
3460 | 
3461 |    while currstate.label ~= 130 do {
3462 |       currstate := pop(myautomata.states)
3463 |       put(myautomata.states, currstate)
3464 |       }
3465 |    put(tempedge.destinations, currstate)
3466 | 
3467 |    put(state2.edges, tempedge)
3468 |    currstate := pop(myautomata.states)
3469 |    put(myautomata.states, currstate)
3470 | 
3471 |    while currstate.label ~= 126 do {
3472 |       currstate := pop(myautomata.states)
3473 |       put(myautomata.states, currstate)
3474 |       }
3475 |    state2 := currstate
3476 | 
3477 |    tempedge := edge("c", [])
3478 |    currstate := pop(myautomata.states)
3479 |    put(myautomata.states, currstate)
3480 | 
3481 |    while currstate.label ~= 131 do {
3482 |       currstate := pop(myautomata.states)
3483 |       put(myautomata.states, currstate)
3484 |       }
3485 |    put(tempedge.destinations, currstate)
3486 | 
3487 |    put(state2.edges, tempedge)
3488 |    currstate := pop(myautomata.states)
3489 |    put(myautomata.states, currstate)
3490 | 
3491 |    while currstate.label ~= 127 do {
3492 |       currstate := pop(myautomata.states)
3493 |       put(myautomata.states, currstate)
3494 |       }
3495 |    state2 := currstate
3496 | 
3497 |    currstate := pop(myautomata.states)
3498 |    put(myautomata.states, currstate)
3499 | 
3500 |    while currstate.label ~= 128 do {
3501 |       currstate := pop(myautomata.states)
3502 |       put(myautomata.states, currstate)
3503 |       }
3504 |    state2 := currstate
3505 | 
3506 |    currstate := pop(myautomata.states)
3507 |    put(myautomata.states, currstate)
3508 | 
3509 |    while currstate.label ~= 129 do {
3510 |       currstate := pop(myautomata.states)
3511 |       put(myautomata.states, currstate)
3512 |       }
3513 |    state2 := currstate
3514 | 
3515 |    currstate := pop(myautomata.states)
3516 |    put(myautomata.states, currstate)
3517 | 
3518 |    while currstate.label ~= 130 do {
3519 |       currstate := pop(myautomata.states)
3520 |       put(myautomata.states, currstate)
3521 |       }
3522 |    state2 := currstate
3523 | 
3524 |    currstate := pop(myautomata.states)
3525 |    put(myautomata.states, currstate)
3526 | 
3527 |    while currstate.label ~= 131 do {
3528 |       currstate := pop(myautomata.states)
3529 |       put(myautomata.states, currstate)
3530 |       }
3531 |    state2 := currstate
3532 | 
3533 |    init_semantic_actions()
3534 |    }
3535 | 
3536 |    return yyulex(myautomata)
3537 | 
3538 | end
3539 | 
3540 | procedure init_semantic_actions()
3541 | 
3542 |    semantic_action := table()
3543 |    semantic_action[1] := semantic_action_1
3544 |    semantic_action[2] := semantic_action_2
3545 |    semantic_action[3] := semantic_action_3
3546 |    semantic_action[4] := semantic_action_4
3547 |    semantic_action[5] := semantic_action_5
3548 |    semantic_action[6] := semantic_action_6
3549 |    semantic_action[7] := semantic_action_7
3550 |    semantic_action[8] := semantic_action_8
3551 |    semantic_action[9] := semantic_action_9
3552 |    semantic_action[10] := semantic_action_10
3553 |    semantic_action[11] := semantic_action_11
3554 |    semantic_action[12] := semantic_action_12
3555 |    semantic_action[13] := semantic_action_13
3556 |    semantic_action[14] := semantic_action_14
3557 |    semantic_action[15] := semantic_action_15
3558 |    semantic_action[16] := semantic_action_16
3559 |    semantic_action[17] := semantic_action_17
3560 |    semantic_action[18] := semantic_action_18
3561 |    semantic_action[19] := semantic_action_19
3562 |    semantic_action[20] := semantic_action_20
3563 |    semantic_action[21] := semantic_action_21
3564 |    semantic_action[22] := semantic_action_22
3565 |    semantic_action[23] := semantic_action_23
3566 |    semantic_action[24] := semantic_action_24
3567 |    semantic_action[25] := semantic_action_25
3568 |    semantic_action[26] := semantic_action_26
3569 |    semantic_action[27] := semantic_action_27
3570 |    semantic_action[28] := semantic_action_28
3571 |    semantic_action[29] := semantic_action_29
3572 |    semantic_action[30] := semantic_action_30
3573 |    semantic_action[31] := semantic_action_31
3574 |    semantic_action[32] := semantic_action_32
3575 |    semantic_action[33] := semantic_action_33
3576 |    semantic_action[34] := semantic_action_34
3577 |    semantic_action[35] := semantic_action_35
3578 |    semantic_action[36] := semantic_action_36
3579 |    semantic_action[37] := semantic_action_37
3580 |    semantic_action[38] := semantic_action_38
3581 |    semantic_action[39] := semantic_action_39
3582 |    semantic_action[40] := semantic_action_40
3583 |    semantic_action[41] := semantic_action_41
3584 |    semantic_action[42] := semantic_action_42
3585 |    semantic_action[43] := semantic_action_43
3586 |    semantic_action[44] := semantic_action_44
3587 |    semantic_action[45] := semantic_action_45
3588 |    semantic_action[46] := semantic_action_46
3589 |    semantic_action[47] := semantic_action_47
3590 |    semantic_action[48] := semantic_action_48
3591 |    semantic_action[49] := semantic_action_49
3592 |    semantic_action[50] := semantic_action_50
3593 |    semantic_action[51] := semantic_action_51
3594 |    semantic_action[52] := semantic_action_52
3595 |    semantic_action[53] := semantic_action_53
3596 |    semantic_action[54] := semantic_action_54
3597 | 
3598 | end
3599 | 
3600 | procedure semantic_action_3()
3601 |    { j0.whitespace(); }
3602 | end
3603 | 
3604 | procedure semantic_action_4()
3605 |    { j0.newline(); }
3606 | end
3607 | 
3608 | procedure semantic_action_22()
3609 |    { return j0.scan(j0.ord("("));}
3610 | end
3611 | 
3612 | procedure semantic_action_23()
3613 |    { return j0.scan(j0.ord(")"));}
3614 | end
3615 | 
3616 | procedure semantic_action_24()
3617 |    { return j0.scan(j0.ord("["));}
3618 | end
3619 | 
3620 | procedure semantic_action_25()
3621 |    { return j0.scan(j0.ord("]"));}
3622 | end
3623 | 
3624 | procedure semantic_action_26()
3625 |    { return j0.scan(j0.ord("{"));}
3626 | end
3627 | 
3628 | procedure semantic_action_27()
3629 |    { return j0.scan(j0.ord("}"));}
3630 | end
3631 | 
3632 | procedure semantic_action_28()
3633 |    { return j0.scan(j0.ord(";"));}
3634 | end
3635 | 
3636 | procedure semantic_action_29()
3637 |    { return j0.scan(j0.ord(":"));}
3638 | end
3639 | 
3640 | procedure semantic_action_31()
3641 |    { return j0.scan(j0.ord("*"));}
3642 | end
3643 | 
3644 | procedure semantic_action_32()
3645 |    { return j0.scan(j0.ord("/"));}
3646 | end
3647 | 
3648 | procedure semantic_action_33()
3649 |    { return j0.scan(j0.ord("%"));}
3650 | end
3651 | 
3652 | procedure semantic_action_36()
3653 |    { return j0.scan(j0.ord("<"));}
3654 | end
3655 | 
3656 | procedure semantic_action_38()
3657 |    { return j0.scan(j0.ord(">"));}
3658 | end
3659 | 
3660 | procedure semantic_action_30()
3661 |    { return j0.scan(j0.ord("!"));}
3662 | end
3663 | 
3664 | procedure semantic_action_34()
3665 |    { return j0.scan(j0.ord("+"));}
3666 | end
3667 | 
3668 | procedure semantic_action_35()
3669 |    { return j0.scan(j0.ord("-"));}
3670 | end
3671 | 
3672 | procedure semantic_action_44()
3673 |    { return j0.scan(j0.ord("=")); }
3674 | end
3675 | 
3676 | procedure semantic_action_47()
3677 |    { return j0.scan(j0.ord(",")); }
3678 | end
3679 | 
3680 | procedure semantic_action_49()
3681 |    { return j0.scan(parser.IDENTIFIER); }
3682 | end
3683 | 
3684 | procedure semantic_action_48()
3685 |    { return j0.scan(j0.ord(".")); }
3686 | end
3687 | 
3688 | procedure semantic_action_50()
3689 |    { return j0.scan(parser.INTLIT); }
3690 | end
3691 | 
3692 | procedure semantic_action_54()
3693 |    { j0.lexErr("unrecognized character"); }
3694 | end
3695 | 
3696 | procedure semantic_action_10()
3697 |    { return j0.scan(parser.IF); }
3698 | end
3699 | 
3700 | procedure semantic_action_37()
3701 |    { return j0.scan(parser.LESSTHANOREQUAL);}
3702 | end
3703 | 
3704 | procedure semantic_action_39()
3705 |    { return j0.scan(parser.GREATERTHANOREQUAL);}
3706 | end
3707 | 
3708 | procedure semantic_action_41()
3709 |    { return j0.scan(parser.NOTEQUALTO);}
3710 | end
3711 | 
3712 | procedure semantic_action_42()
3713 |    { return j0.scan(parser.LOGICALAND);}
3714 | end
3715 | 
3716 | procedure semantic_action_43()
3717 |    { return j0.scan(parser.LOGICALOR);}
3718 | end
3719 | 
3720 | procedure semantic_action_45()
3721 |    { return j0.scan(parser.INCREMENT); }
3722 | end
3723 | 
3724 | procedure semantic_action_46()
3725 |    { return j0.scan(parser.DECREMENT); }
3726 | end
3727 | 
3728 | procedure semantic_action_40()
3729 |    { return j0.scan(parser.ISEQUALTO);}
3730 | end
3731 | 
3732 | procedure semantic_action_53()
3733 |    { return j0.scan(parser.STRINGLIT); }
3734 | end
3735 | 
3736 | procedure semantic_action_9()
3737 |    { return j0.scan(parser.FOR); }
3738 | end
3739 | 
3740 | procedure semantic_action_11()
3741 |    { return j0.scan(parser.INT); }
3742 | end
3743 | 
3744 | procedure semantic_action_2()
3745 |    { j0.comment(); }
3746 | end
3747 | 
3748 | procedure semantic_action_51()
3749 |    { return j0.scan(parser.DOUBLELIT); }
3750 | end
3751 | 
3752 | procedure semantic_action_52()
3753 |    { return j0.scan(parser.DOUBLELIT); }
3754 | end
3755 | 
3756 | procedure semantic_action_12()
3757 |    { return j0.scan(parser.NULLVAL); }
3758 | end
3759 | 
3760 | procedure semantic_action_17()
3761 |    { return j0.scan(parser.BOOLLIT); }
3762 | end
3763 | 
3764 | procedure semantic_action_18()
3765 |    { return j0.scan(parser.BOOL); }
3766 | end
3767 | 
3768 | procedure semantic_action_19()
3769 |    { return j0.scan(parser.VOID); }
3770 | end
3771 | 
3772 | procedure semantic_action_7()
3773 |    { return j0.scan(parser.ELSE); }
3774 | end
3775 | 
3776 | procedure semantic_action_1()
3777 |    { j0.comment(); }
3778 | end
3779 | 
3780 | procedure semantic_action_8()
3781 |    { return j0.scan(parser.BOOLLIT); }
3782 | end
3783 | 
3784 | procedure semantic_action_5()
3785 |    { return j0.scan(parser.BREAK); }
3786 | end
3787 | 
3788 | procedure semantic_action_20()
3789 |    { return j0.scan(parser.WHILE); }
3790 | end
3791 | 
3792 | procedure semantic_action_21()
3793 |    { return j0.scan(parser.CLASS); }
3794 | end
3795 | 
3796 | procedure semantic_action_13()
3797 |    { return j0.scan(parser.PUBLIC); }
3798 | end
3799 | 
3800 | procedure semantic_action_14()
3801 |    { return j0.scan(parser.RETURN); }
3802 | end
3803 | 
3804 | procedure semantic_action_6()
3805 |    { return j0.scan(parser.DOUBLE); }
3806 | end
3807 | 
3808 | procedure semantic_action_16()
3809 |    { return j0.scan(parser.STRING); }
3810 | end
3811 | 
3812 | procedure semantic_action_15()
3813 |    { return j0.scan(parser.STATIC); }
3814 | end
3815 | 
3816 | 


--------------------------------------------------------------------------------
/ch4/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "null"                 { return j0.scan(parser.NULLVAL); }
18 | "public"               { return j0.scan(parser.PUBLIC); }
19 | "return"               { return j0.scan(parser.RETURN); }
20 | "static"               { return j0.scan(parser.STATIC); }
21 | "string"               { return j0.scan(parser.STRING); }
22 | "true"                 { return j0.scan(parser.BOOLLIT); }
23 | "bool"                 { return j0.scan(parser.BOOL); }
24 | "void"                 { return j0.scan(parser.VOID); }
25 | "while"                { return j0.scan(parser.WHILE); }
26 | "class"                { return j0.scan(parser.CLASS); }
27 | "("                    { return j0.scan(j0.ord("("));}
28 | ")"                    { return j0.scan(j0.ord(")"));}
29 | "["                    { return j0.scan(j0.ord("["));}
30 | "]"                    { return j0.scan(j0.ord("]"));}
31 | "{"                    { return j0.scan(j0.ord("{"));}
32 | "}"                    { return j0.scan(j0.ord("}"));}
33 | ";"                    { return j0.scan(j0.ord(";"));}
34 | ":"                    { return j0.scan(j0.ord(":"));}
35 | "!"                    { return j0.scan(j0.ord("!"));}
36 | "*"                    { return j0.scan(j0.ord("*"));}
37 | "/"                    { return j0.scan(j0.ord("/"));}
38 | "%"                    { return j0.scan(j0.ord("%"));}
39 | "+"                    { return j0.scan(j0.ord("+"));}
40 | "-"                    { return j0.scan(j0.ord("-"));}
41 | "<"                    { return j0.scan(j0.ord("<"));}
42 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
43 | ">"                    { return j0.scan(j0.ord(">"));}
44 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
45 | "=="                   { return j0.scan(parser.ISEQUALTO);}
46 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
47 | "&&"                   { return j0.scan(parser.LOGICALAND);}
48 | "||"                   { return j0.scan(parser.LOGICALOR);}
49 | "="                    { return j0.scan(j0.ord("=")); }
50 | "+="                   { return j0.scan(parser.INCREMENT); }
51 | "-="                   { return j0.scan(parser.DECREMENT); }
52 | ","                    { return j0.scan(j0.ord(",")); }
53 | "."                    { return j0.scan(j0.ord(".")); }
54 | {id}                   { return j0.scan(parser.IDENTIFIER); }
55 | [0-9]+                 { return j0.scan(parser.INTLIT); }
56 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
57 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
58 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
59 | .                      { j0.lexErr("unrecognized character"); }
60 | 


--------------------------------------------------------------------------------
/ch4/jzero.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | public class jzero {
 3 |    public static ch4.parser par;
 4 |    public static void main(String argv[]) throws Exception {
 5 |       ch4.j0.init(argv[0]);
 6 |       par = new ch4.parser();
 7 |       yylineno = 1;
 8 |       int i = par.yyparse();
 9 |       if (i == 0)
10 |          System.out.println("no errors");
11 |    }
12 | }
13 | 


--------------------------------------------------------------------------------
/ch4/lexer.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | import java.io.FileReader;
 3 | public class lexer {
 4 |    public static Yylex yylexer;
 5 |    public static void init(String s) throws Exception {
 6 |       yylexer = new Yylex(new FileReader(s));
 7 |    }
 8 |    public static int YYEOF() { return Yylex.YYEOF; }
 9 |    public static int yylex() {
10 |       int rv = 0;
11 |       try {
12 |         rv = yylexer.yylex();
13 |       } catch(java.io.IOException ioException) {
14 |         rv = -1;
15 |       }
16 |       return rv;
17 |    }
18 |    public static String yytext() {
19 |       return yylexer.yytext();
20 |    }
21 |    public static void lexErr(String s) {
22 |       System.err.println(s);
23 |       System.exit(1);
24 |    }
25 | }
26 | 


--------------------------------------------------------------------------------
/ch4/nameseq.y:
--------------------------------------------------------------------------------
1 | %{
2 | import static ch4.lexer.yylex;
3 | %}
4 | %token NAME NUMBER
5 | %%
6 | sequence : pair sequence | ;
7 | pair : NAME NUMBER ;
8 | %%
9 | 


--------------------------------------------------------------------------------
/ch4/nnws.l:
--------------------------------------------------------------------------------
1 | package ch4;
2 | %%
3 | %int
4 | %%
5 | [a-zA-Z]+   { return Parser.NAME; }
6 | [0-9]+      { return Parser.NUMBER; }
7 | [ \t]+      { }
8 | .           { lexer.lexErr("unrecognized character"); }
9 | 


--------------------------------------------------------------------------------
/ch4/ns.icn:
--------------------------------------------------------------------------------
  1 | ### This file created by IYACC 1.1
  2 | ### Please send bug reports to jeffery@cs.nmt.edu
  3 | #define YYPREFIX "yy"
  4 | $define NAME 257
  5 | $define NUMBER 258
  6 | $define YYERRCODE 256
  7 | procedure init() 
  8 |   yylhs := [                                        -1,
  9 |     0,    0,    1,
 10 |   ]
 11 |   yylen := [                            2,
 12 |     2,    0,    2,
 13 |   ]
 14 |   yydefred := [                         0,
 15 |     0,    0,    0,    3,    1,
 16 |   ]
 17 |   yydgoto := [                          2,
 18 |     3,
 19 |   ]
 20 |   yysindex := [                      -257,
 21 |  -256,    0, -257,    0,    0,
 22 |   ]
 23 |   yyrindex := [                         1,
 24 |     0,    0,    1,    0,    0,
 25 |   ]
 26 |   yygindex := [                         2,
 27 |     0,
 28 |   ]
 29 | $define YYTABLESIZE 5
 30 |   yytable := [                          1,
 31 |     2,    4,    0,    0,    5,
 32 |   ]
 33 |   yycheck := [                        257,
 34 |     0,  258,   -1,   -1,    3,
 35 |   ]
 36 | $define YYFINAL 2
 37 | $define YYMAXTOKEN 258
 38 |   yyname := [
 39 | "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 40 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 41 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 42 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 43 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 44 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 45 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"NAME","NUMBER",
 46 |   ]
 47 |   yyrule := [
 48 | "$accept : sequence",
 49 | "sequence : pair sequence",
 50 | "sequence :",
 51 | "pair : NAME NUMBER",
 52 |   ]
 53 | 
 54 | end
 55 | 
 56 | #####################################################################
 57 | #####################################################################
 58 | invocable all    # need to look up semantic actions by name
 59 | 
 60 | global yytext    # user variable to return contextual strings
 61 | global yyval     # used to return semantic vals from action routines
 62 | global yylval    # the 'lval' (result) I got from yylex()
 63 | global yydebug   # (boolean) do I want debug output?
 64 | global yynerrs   # (integer) number of errors so far
 65 | global yyerrflag # (integer) was there an error?
 66 | global yychar    # (integer) the current working character
 67 | global action    # maps an integer to a semantic action procedure
 68 | 
 69 | global yylhs
 70 | global yylen
 71 | global yydefred
 72 | global yydgoto
 73 | global yysindex
 74 | global yyrindex
 75 | global yygindex
 76 | global yytable
 77 | global yycheck
 78 | global yyname
 79 | global yyrule
 80 | 
 81 | global statestk         # state stack
 82 | global valstk           # value stack
 83 | ################################################################
 84 | # procedure: init_stacks : allocate and prepare stacks
 85 | ################################################################
 86 | procedure init_stacks()
 87 |   local i
 88 |   statestk := []
 89 |   valstk := []
 90 |   yyval  := 0 
 91 |   yylval := 0 
 92 |   action := list(1000, action_null)  # remove hard coded 1000 later
 93 |   every i := 1 to 1000 do action[i] := proc("action_" || i)
 94 | end
 95 | 
 96 | $define YYACCEPT return 0
 97 | $define YYABORT return 1
 98 | ################################################################
 99 | # procedure: yyparse : parse input and execute indicated items
100 | ################################################################
101 | procedure yyparse()
102 |   local yyn        # next next thing to do
103 |   local yym        #
104 |   local yystate    # current parsing state from state table
105 |   local yys        # current token string
106 |   local doaction   # set to 1 if there need to execute action
107 |   local token      # current token
108 | 
109 |   if /yytable then init() 
110 |   init_stacks() 
111 |   yynerrs   := 0 
112 |   yyerrflag := 0 
113 |   yychar    := -1           # impossible char forces a read
114 |   yystate   := 0            # initial state
115 |   push(statestk, yystate)   # save it
116 | 
117 |   repeat { # until parsing is done, either correctly, or w/error
118 |     doaction := 1 
119 | 
120 |     ##### NEXT ACTION (from reduction table)
121 | 	yyn := yydefred[yystate+1]
122 | 
123 |     while yyn = 0 do {
124 | 
125 |       if yychar < 0 then {   # we want a char?
126 |         yychar := yylex()    # get next token
127 |         ##### ERROR CHECK ####
128 |         if yychar < 0 then { # it it didn't work/error
129 |           yychar := 0        # change it to default string (no -1!)
130 |           if \yydebug = 1 then yylexdebug(yystate, yychar) 
131 |           }
132 |         } # yychar < 0
133 | 	  
134 |       yyn := yysindex[yystate+1]  # get amount to shift by (shift index)
135 | 
136 |       if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
137 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
138 | 		
139 |         ##### NEXT STATE ####
140 |         yystate := yytable[yyn+1] # we are in a new state
141 |         push(statestk, yystate)   # save it
142 |         push(valstk, yylval)      # push our lval as the input for next rule
143 |         yychar := -1              # since we have 'eaten' a token, say we need another
144 |         if yyerrflag > 0 then     # have we recovered an error?
145 |            yyerrflag -:= 1        # give ourselves credit
146 |         doaction := 0             # but don't process yet
147 |         break                     # quit the yyn=0 loop
148 |         }
149 | 
150 |     yyn := yyrindex[yystate+1]    # reduce
151 | 
152 |     if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
153 |        (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
154 |       # e reduced!
155 |       yyn      := yytable[yyn+1] 
156 |       doaction := 1  # get ready to execute
157 |       break          # drop down to actions
158 |       }
159 |     else { #ERROR RECOVERY
160 |       if yyerrflag == 0 then {
161 |         (\yyerror | write)("syntax error") 
162 |         yynerrs +:= 1 
163 |       }
164 |       if yyerrflag < 3 then {     # low error count?
165 |         yyerrflag := 3 
166 |         repeat { #do until break
167 |           if *statestk < 1 then {  # check for under & overflow here
168 |             (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
169 |             return 1 
170 |           }
171 |           yyn := yysindex[statestk[1]] 
172 |           if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
173 |                     yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
174 |             yystate := yytable[yyn+1] 
175 |             push(statestk, yystate) 
176 |             push(valstk, yylval) 
177 |             doaction := 0 
178 |             break 
179 |           }
180 |           else {
181 |             if *statestk = 0 then { # check for under & overflow here
182 |               write("Stack underflow. aborting...") # capital 'S'
183 |               return 1 
184 |             }
185 |             pop(statestk) 
186 |             pop(valstk) 
187 |             }
188 |           }
189 |         }
190 |       else  # discard this token
191 |         {
192 |         if yychar = 0 then return 1  # yyabort
193 |         if \yydebug = 1 then {
194 |           yys := &null 
195 |           if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
196 |           if integer(yys) & yys = 0 then yys := "illegal-symbol" 
197 |           write("state ",  yystate, ", error recovery discards token ",
198 |                 yychar, " (", yys, ")") 
199 |           }
200 |         yychar := -1       # read another
201 |         }
202 |       } # end error recovery
203 |       yyn := yydefred[yystate+1] 
204 |     }# yyn = 0 loop
205 | 
206 |     if doaction = 0 then   # any reason not to proceed?
207 |       next                 # skip action
208 | 
209 |     yym := yylen[yyn+1]    # get count of terminals on rhs
210 |     yyval := valstk[yym]   # get current semantic value
211 |     if arv := action[yyn]() then return arv # execute the semantic action
212 | 
213 |     ##### Now let's reduce... ####
214 |     every 1 to yym do pop(statestk)# we just reduced yylen states
215 |     yystate := statestk[1]        # get new state
216 | 
217 |     every 1 to yym do pop(valstk) # corresponding value drop
218 |     yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
219 |     if yystate = 0 & yym = 0 then {
220 |                                   # done? 'rest' state and at first TERMINAL
221 |       yystate := YYFINAL          # explicitly say we're done
222 |       push(statestk, YYFINAL)     # and save it
223 |       push(valstk, yyval)         # also save the semantic value of parsing
224 |       if yychar < 0 then {        # we want another character?
225 |         yychar := yylex()         # get next character
226 |         if yychar < 0 then yychar := 0   #clean, if necessary
227 |       }
228 |       if yychar = 0 then break    # Good exit (if lex returns 0  -)
229 |                                   # quit the loop--all DONE
230 |     } # if yystate
231 |     else {                        #else not done yet
232 |       # get next state and push, for next yydefred[]
233 |       yyn := yygindex[yym+1]        # find out where to go
234 |       if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
235 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
236 |         yystate := yytable[yyn+1]   # get new state
237 |         }
238 |       else {
239 |         yystate := yydgoto[yym+1]   # else go to new defred
240 | 	     }
241 |       push(statestk, yystate)       # going again, so push state & val...
242 |       push(valstk, yyval)           # for next action
243 |       }
244 |     } # main loop
245 | 
246 |   return 0 # yyaccept!!
247 | end
248 | 
249 | ### end of procedure parse() ######################################
250 | 
251 | ### start semantic actions ########################################
252 | 
253 | procedure action_null()
254 |   #write("null action")
255 | end
256 | 
257 | 


--------------------------------------------------------------------------------
/ch4/ns.y:
--------------------------------------------------------------------------------
1 | %token NAME NUMBER
2 | %%
3 | sequence : pair sequence | ;
4 | pair : NAME NUMBER ;
5 | %%
6 | 


--------------------------------------------------------------------------------
/ch4/ns_tab.icn:
--------------------------------------------------------------------------------
1 | class Parser(NAME, NUMBER)
2 | initially
3 |    NAME := 257
4 |    NUMBER := 258
5 | end
6 | 


--------------------------------------------------------------------------------
/ch4/parserTokens.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | public interface parserTokens {
 3 | public final static short BREAK=257;
 4 | public final static short DOUBLE=258;
 5 | public final static short ELSE=259;
 6 | public final static short FOR=260;
 7 | public final static short IF=261;
 8 | public final static short INT=262;
 9 | public final static short RETURN=263;
10 | public final static short VOID=264;
11 | public final static short WHILE=265;
12 | public final static short IDENTIFIER=266;
13 | public final static short CLASSNAME=267;
14 | public final static short CLASS=268;
15 | public final static short STRING=269;
16 | public final static short BOOL=270;
17 | public final static short INTLIT=271;
18 | public final static short DOUBLELIT=272;
19 | public final static short STRINGLIT=273;
20 | public final static short BOOLLIT=274;
21 | public final static short NULLVAL=275;
22 | public final static short LESSTHANOREQUAL=276;
23 | public final static short GREATERTHANOREQUAL=277;
24 | public final static short ISEQUALTO=278;
25 | public final static short NOTEQUALTO=279;
26 | public final static short LOGICALAND=280;
27 | public final static short LOGICALOR=281;
28 | public final static short INCREMENT=282;
29 | public final static short DECREMENT=283;
30 | public final static short PUBLIC=284;
31 | public final static short STATIC=285;
32 | }
33 | 


--------------------------------------------------------------------------------
/ch4/parserVal.java:
--------------------------------------------------------------------------------
 1 | //#############################################
 2 | //## file: Parser.java
 3 | //## Generated by Byacc/j
 4 | //#############################################
 5 | package ch4;
 6 | 
 7 | /**
 8 |  * BYACC/J Semantic Value for parser: Parser
 9 |  * This class provides some of the functionality
10 |  * of the yacc/C 'union' directive
11 |  */
12 | public class ParserVal
13 | {
14 | /**
15 |  * integer value of this 'union'
16 |  */
17 | public int ival;
18 | 
19 | /**
20 |  * double value of this 'union'
21 |  */
22 | public double dval;
23 | 
24 | /**
25 |  * string value of this 'union'
26 |  */
27 | public String sval;
28 | 
29 | /**
30 |  * object value of this 'union'
31 |  */
32 | public Object obj;
33 | 
34 | //#############################################
35 | //## C O N S T R U C T O R S
36 | //#############################################
37 | /**
38 |  * Initialize me without a value
39 |  */
40 | public ParserVal()
41 | {
42 | }
43 | /**
44 |  * Initialize me as an int
45 |  */
46 | public ParserVal(int val)
47 | {
48 |   ival=val;
49 | }
50 | 
51 | /**
52 |  * Initialize me as a double
53 |  */
54 | public ParserVal(double val)
55 | {
56 |   dval=val;
57 | }
58 | 
59 | /**
60 |  * Initialize me as a string
61 |  */
62 | public ParserVal(String val)
63 | {
64 |   sval=val;
65 | }
66 | 
67 | /**
68 |  * Initialize me as an Object
69 |  */
70 | public ParserVal(Object val)
71 | {
72 |   obj=val;
73 | }
74 | }//end class
75 | 
76 | //#############################################
77 | //## E N D    O F    F I L E
78 | //#############################################
79 | 


--------------------------------------------------------------------------------
/ch4/token.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | public class token {
 3 |    public int cat;
 4 |    public String text;
 5 |    public int lineno;
 6 |    public token(int c, String s, int l) {
 7 |       cat = c; text = s; lineno = l;
 8 |    }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch4/trivial.icn:
--------------------------------------------------------------------------------
 1 | procedure main(argv)
 2 |    yyin := open(argv[1])
 3 |    lexer := lexer()
 4 |    Parser := Parser()
 5 |    if yyparse() = 0 then write("No errors")
 6 | end
 7 | procedure yyerror(s)
 8 |     stop(s)
 9 | end
10 | class lexer()
11 |    method lexErr(s)
12 |       stop("lexical error: ", s)
13 |    end
14 | end
15 | 


--------------------------------------------------------------------------------
/ch4/trivial.java:
--------------------------------------------------------------------------------
 1 | package ch4;
 2 | public class trivial {
 3 |    static ch4.Parser par;
 4 |    public static void main(String argv[]) throws Exception {
 5 |       ch4.lexer.init(argv[0]);
 6 |       par = new ch4.Parser();
 7 |       int i = par.yyparse();
 8 |       if (i == 0)
 9 |          System.out.println("no errors");
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch4/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     stop(s)
3 | end
4 | 


--------------------------------------------------------------------------------
/ch4/yyerror.java:
--------------------------------------------------------------------------------
1 | package ch4;
2 | public class yyerror {
3 |     public static void yyerror(String s) {
4 |       System.err.println(s);
5 |       System.exit(1);
6 |     }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch5/Yylex.java:
--------------------------------------------------------------------------------
  1 | // DO NOT EDIT
  2 | // Generated by JFlex 1.8.2 http://jflex.de/
  3 | // source: javalex.l
  4 | 
  5 | package ch5;
  6 | 
  7 | // See https://github.com/jflex-de/jflex/issues/222
  8 | @SuppressWarnings("FallThrough")
  9 | class Yylex {
 10 | 
 11 |   /** This character denotes the end of file. */
 12 |   public static final int YYEOF = -1;
 13 | 
 14 |   /** Initial size of the lookahead buffer. */
 15 |   private static final int ZZ_BUFFERSIZE = 16384;
 16 | 
 17 |   // Lexical states.
 18 |   public static final int YYINITIAL = 0;
 19 | 
 20 |   /**
 21 |    * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
 22 |    * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
 23 |    *                  at the beginning of a line
 24 |    * l is of the form l = 2*k, k a non negative integer
 25 |    */
 26 |   private static final int ZZ_LEXSTATE[] = {
 27 |      0, 0
 28 |   };
 29 | 
 30 |   /**
 31 |    * Top-level table for translating characters to character classes
 32 |    */
 33 |   private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
 34 | 
 35 |   private static final String ZZ_CMAP_TOP_PACKED_0 =
 36 |     "\1\0\37\u0100\1\u0200\267\u0100\10\u0300\u1020\u0100";
 37 | 
 38 |   private static int [] zzUnpackcmap_top() {
 39 |     int [] result = new int[4352];
 40 |     int offset = 0;
 41 |     offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
 42 |     return result;
 43 |   }
 44 | 
 45 |   private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
 46 |     int i = 0;       /* index in packed string  */
 47 |     int j = offset;  /* index in unpacked array */
 48 |     int l = packed.length();
 49 |     while (i < l) {
 50 |       int count = packed.charAt(i++);
 51 |       int value = packed.charAt(i++);
 52 |       do result[j++] = value; while (--count > 0);
 53 |     }
 54 |     return j;
 55 |   }
 56 | 
 57 | 
 58 |   /**
 59 |    * Second-level tables for translating characters to character classes
 60 |    */
 61 |   private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
 62 | 
 63 |   private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
 64 |     "\11\0\1\1\1\2\1\3\1\4\1\5\22\0\1\1"+
 65 |     "\1\6\1\7\2\0\1\10\1\11\1\0\1\12\1\13"+
 66 |     "\1\14\1\15\1\16\1\17\1\20\1\21\12\22\1\23"+
 67 |     "\1\24\1\25\1\26\1\27\2\0\4\30\1\31\25\30"+
 68 |     "\1\32\1\33\1\34\1\0\1\30\1\0\1\35\1\36"+
 69 |     "\1\37\1\40\1\41\1\42\1\43\1\44\1\45\1\30"+
 70 |     "\1\46\1\47\1\30\1\50\1\51\1\52\1\30\1\53"+
 71 |     "\1\54\1\55\1\56\1\57\1\60\3\30\1\61\1\62"+
 72 |     "\1\63\7\0\1\3\u01a2\0\2\3\326\0\u0100\3";
 73 | 
 74 |   private static int [] zzUnpackcmap_blocks() {
 75 |     int [] result = new int[1024];
 76 |     int offset = 0;
 77 |     offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
 78 |     return result;
 79 |   }
 80 | 
 81 |   private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
 82 |     int i = 0;       /* index in packed string  */
 83 |     int j = offset;  /* index in unpacked array */
 84 |     int l = packed.length();
 85 |     while (i < l) {
 86 |       int count = packed.charAt(i++);
 87 |       int value = packed.charAt(i++);
 88 |       do result[j++] = value; while (--count > 0);
 89 |     }
 90 |     return j;
 91 |   }
 92 | 
 93 |   /**
 94 |    * Translates DFA states to action switch labels.
 95 |    */
 96 |   private static final int [] ZZ_ACTION = zzUnpackAction();
 97 | 
 98 |   private static final String ZZ_ACTION_PACKED_0 =
 99 |     "\1\0\1\1\1\2\1\3\1\4\1\1\1\5\1\1"+
100 |     "\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1\15"+
101 |     "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
102 |     "\1\26\15\24\1\27\1\1\1\30\1\31\1\0\1\32"+
103 |     "\1\0\1\33\1\34\1\35\1\36\3\0\1\37\1\40"+
104 |     "\1\41\7\24\1\42\10\24\1\43\1\32\1\0\1\36"+
105 |     "\1\0\1\44\1\0\6\24\1\45\1\46\10\24\1\47"+
106 |     "\3\24\1\50\1\51\4\24\1\52\1\53\1\24\1\54"+
107 |     "\1\55\5\24\1\56\1\57\1\60\1\61\1\62\1\63";
108 | 
109 |   private static int [] zzUnpackAction() {
110 |     int [] result = new int[120];
111 |     int offset = 0;
112 |     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
113 |     return result;
114 |   }
115 | 
116 |   private static int zzUnpackAction(String packed, int offset, int [] result) {
117 |     int i = 0;       /* index in packed string  */
118 |     int j = offset;  /* index in unpacked array */
119 |     int l = packed.length();
120 |     while (i < l) {
121 |       int count = packed.charAt(i++);
122 |       int value = packed.charAt(i++);
123 |       do result[j++] = value; while (--count > 0);
124 |     }
125 |     return j;
126 |   }
127 | 
128 | 
129 |   /**
130 |    * Translates a state to a row index in the transition table
131 |    */
132 |   private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
133 | 
134 |   private static final String ZZ_ROWMAP_PACKED_0 =
135 |     "\0\0\0\64\0\150\0\64\0\234\0\320\0\64\0\u0104"+
136 |     "\0\64\0\64\0\64\0\u0138\0\64\0\u016c\0\u01a0\0\u01d4"+
137 |     "\0\u0208\0\64\0\64\0\u023c\0\u0270\0\u02a4\0\u02d8\0\64"+
138 |     "\0\64\0\u030c\0\u0340\0\u0374\0\u03a8\0\u03dc\0\u0410\0\u0444"+
139 |     "\0\u0478\0\u04ac\0\u04e0\0\u0514\0\u0548\0\u057c\0\64\0\u05b0"+
140 |     "\0\64\0\64\0\320\0\64\0\u05e4\0\64\0\64\0\64"+
141 |     "\0\u01a0\0\u0618\0\u064c\0\u0680\0\64\0\64\0\64\0\u06b4"+
142 |     "\0\u06e8\0\u071c\0\u0750\0\u0784\0\u07b8\0\u07ec\0\u02d8\0\u0820"+
143 |     "\0\u0854\0\u0888\0\u08bc\0\u08f0\0\u0924\0\u0958\0\u098c\0\64"+
144 |     "\0\320\0\u09c0\0\u09c0\0\u09f4\0\64\0\u0a28\0\u0a5c\0\u0a90"+
145 |     "\0\u0ac4\0\u0af8\0\u0b2c\0\u0b60\0\u02d8\0\u02d8\0\u0b94\0\u0bc8"+
146 |     "\0\u0bfc\0\u0c30\0\u0c64\0\u0c98\0\u0ccc\0\u0d00\0\u02d8\0\u0d34"+
147 |     "\0\u0d68\0\u0d9c\0\u02d8\0\u02d8\0\u0dd0\0\u0e04\0\u0e38\0\u0e6c"+
148 |     "\0\u02d8\0\u02d8\0\u0ea0\0\u02d8\0\u02d8\0\u0ed4\0\u0f08\0\u0f3c"+
149 |     "\0\u0f70\0\u0fa4\0\u02d8\0\u02d8\0\u02d8\0\u02d8\0\u02d8\0\u02d8";
150 | 
151 |   private static int [] zzUnpackRowMap() {
152 |     int [] result = new int[120];
153 |     int offset = 0;
154 |     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
155 |     return result;
156 |   }
157 | 
158 |   private static int zzUnpackRowMap(String packed, int offset, int [] result) {
159 |     int i = 0;  /* index in packed string  */
160 |     int j = offset;  /* index in unpacked array */
161 |     int l = packed.length();
162 |     while (i < l) {
163 |       int high = packed.charAt(i++) << 16;
164 |       result[j++] = high | packed.charAt(i++);
165 |     }
166 |     return j;
167 |   }
168 | 
169 |   /**
170 |    * The transition table of the DFA
171 |    */
172 |   private static final int [] ZZ_TRANS = zzUnpackTrans();
173 | 
174 |   private static final String ZZ_TRANS_PACKED_0 =
175 |     "\1\2\1\3\1\4\1\0\2\3\1\5\1\6\1\7"+
176 |     "\1\10\1\11\1\12\1\13\1\14\1\15\1\16\1\17"+
177 |     "\1\20\1\21\1\22\1\23\1\24\1\25\1\26\2\27"+
178 |     "\1\30\1\2\1\31\1\27\1\32\1\33\1\34\1\35"+
179 |     "\1\36\2\27\1\37\2\27\1\40\1\27\1\41\1\42"+
180 |     "\1\43\1\44\1\27\1\45\1\46\1\47\1\50\1\51"+
181 |     "\65\0\1\3\2\0\2\3\104\0\1\52\35\0\7\53"+
182 |     "\1\54\23\53\1\55\30\53\11\0\1\56\100\0\1\57"+
183 |     "\63\0\1\60\57\0\1\61\6\0\1\62\7\0\1\62"+
184 |     "\36\0\1\63\4\0\1\64\62\0\1\61\1\0\1\21"+
185 |     "\6\0\1\62\7\0\1\62\50\0\1\65\63\0\1\66"+
186 |     "\63\0\1\67\57\0\1\27\5\0\2\27\3\0\24\27"+
187 |     "\25\0\1\27\5\0\2\27\3\0\14\27\1\70\1\27"+
188 |     "\1\71\5\27\25\0\1\27\5\0\2\27\3\0\12\27"+
189 |     "\1\72\11\27\25\0\1\27\5\0\2\27\3\0\14\27"+
190 |     "\1\73\7\27\25\0\1\27\5\0\2\27\3\0\12\27"+
191 |     "\1\74\11\27\25\0\1\27\5\0\2\27\3\0\1\75"+
192 |     "\13\27\1\76\7\27\25\0\1\27\5\0\2\27\3\0"+
193 |     "\5\27\1\77\5\27\1\100\10\27\25\0\1\27\5\0"+
194 |     "\2\27\3\0\21\27\1\101\2\27\25\0\1\27\5\0"+
195 |     "\2\27\3\0\21\27\1\102\2\27\25\0\1\27\5\0"+
196 |     "\2\27\3\0\4\27\1\103\17\27\25\0\1\27\5\0"+
197 |     "\2\27\3\0\20\27\1\104\3\27\25\0\1\27\5\0"+
198 |     "\2\27\3\0\16\27\1\105\5\27\25\0\1\27\5\0"+
199 |     "\2\27\3\0\14\27\1\106\7\27\25\0\1\27\5\0"+
200 |     "\2\27\3\0\7\27\1\107\14\27\65\0\1\110\1\0"+
201 |     "\7\53\1\111\23\53\1\55\30\53\15\0\1\112\1\0"+
202 |     "\1\112\2\0\1\113\41\0\14\63\1\114\47\63\2\64"+
203 |     "\1\115\2\0\1\116\56\64\22\0\1\27\5\0\2\27"+
204 |     "\3\0\14\27\1\117\7\27\25\0\1\27\5\0\2\27"+
205 |     "\3\0\4\27\1\120\17\27\25\0\1\27\5\0\2\27"+
206 |     "\3\0\1\121\23\27\25\0\1\27\5\0\2\27\3\0"+
207 |     "\21\27\1\122\2\27\25\0\1\27\5\0\2\27\3\0"+
208 |     "\17\27\1\123\4\27\25\0\1\27\5\0\2\27\3\0"+
209 |     "\12\27\1\124\11\27\25\0\1\27\5\0\2\27\3\0"+
210 |     "\16\27\1\125\5\27\25\0\1\27\5\0\2\27\3\0"+
211 |     "\20\27\1\126\3\27\25\0\1\27\5\0\2\27\3\0"+
212 |     "\12\27\1\127\11\27\25\0\1\27\5\0\2\27\3\0"+
213 |     "\1\27\1\130\22\27\25\0\1\27\5\0\2\27\3\0"+
214 |     "\20\27\1\131\3\27\25\0\1\27\5\0\2\27\3\0"+
215 |     "\1\132\15\27\1\133\5\27\25\0\1\27\5\0\2\27"+
216 |     "\3\0\21\27\1\134\2\27\25\0\1\27\5\0\2\27"+
217 |     "\3\0\10\27\1\135\13\27\25\0\1\27\5\0\2\27"+
218 |     "\3\0\10\27\1\136\13\27\25\0\1\113\41\0\14\63"+
219 |     "\1\114\4\63\1\115\42\63\2\0\1\115\103\0\1\27"+
220 |     "\5\0\2\27\3\0\12\27\1\137\11\27\25\0\1\27"+
221 |     "\5\0\2\27\3\0\1\140\23\27\25\0\1\27\5\0"+
222 |     "\2\27\3\0\17\27\1\141\4\27\25\0\1\27\5\0"+
223 |     "\2\27\3\0\1\27\1\142\22\27\25\0\1\27\5\0"+
224 |     "\2\27\3\0\4\27\1\143\17\27\25\0\1\27\5\0"+
225 |     "\2\27\3\0\17\27\1\134\4\27\25\0\1\27\5\0"+
226 |     "\2\27\3\0\12\27\1\144\11\27\25\0\1\27\5\0"+
227 |     "\2\27\3\0\12\27\1\145\11\27\25\0\1\27\5\0"+
228 |     "\2\27\3\0\21\27\1\146\2\27\25\0\1\27\5\0"+
229 |     "\2\27\3\0\20\27\1\147\3\27\25\0\1\27\5\0"+
230 |     "\2\27\3\0\10\27\1\150\13\27\25\0\1\27\5\0"+
231 |     "\2\27\3\0\4\27\1\151\17\27\25\0\1\27\5\0"+
232 |     "\2\27\3\0\3\27\1\152\20\27\25\0\1\27\5\0"+
233 |     "\2\27\3\0\12\27\1\153\11\27\25\0\1\27\5\0"+
234 |     "\2\27\3\0\11\27\1\154\12\27\25\0\1\27\5\0"+
235 |     "\2\27\3\0\17\27\1\155\4\27\25\0\1\27\5\0"+
236 |     "\2\27\3\0\12\27\1\156\11\27\25\0\1\27\5\0"+
237 |     "\2\27\3\0\10\27\1\157\13\27\25\0\1\27\5\0"+
238 |     "\2\27\3\0\16\27\1\160\5\27\25\0\1\27\5\0"+
239 |     "\2\27\3\0\10\27\1\161\13\27\25\0\1\27\5\0"+
240 |     "\2\27\3\0\13\27\1\162\10\27\25\0\1\27\5\0"+
241 |     "\2\27\3\0\4\27\1\163\17\27\25\0\1\27\5\0"+
242 |     "\2\27\3\0\4\27\1\164\17\27\25\0\1\27\5\0"+
243 |     "\2\27\3\0\2\27\1\165\21\27\25\0\1\27\5\0"+
244 |     "\2\27\3\0\13\27\1\166\10\27\25\0\1\27\5\0"+
245 |     "\2\27\3\0\2\27\1\167\21\27\25\0\1\27\5\0"+
246 |     "\2\27\3\0\6\27\1\170\15\27\3\0";
247 | 
248 |   private static int [] zzUnpackTrans() {
249 |     int [] result = new int[4056];
250 |     int offset = 0;
251 |     offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
252 |     return result;
253 |   }
254 | 
255 |   private static int zzUnpackTrans(String packed, int offset, int [] result) {
256 |     int i = 0;       /* index in packed string  */
257 |     int j = offset;  /* index in unpacked array */
258 |     int l = packed.length();
259 |     while (i < l) {
260 |       int count = packed.charAt(i++);
261 |       int value = packed.charAt(i++);
262 |       value--;
263 |       do result[j++] = value; while (--count > 0);
264 |     }
265 |     return j;
266 |   }
267 | 
268 | 
269 |   /** Error code for "Unknown internal scanner error". */
270 |   private static final int ZZ_UNKNOWN_ERROR = 0;
271 |   /** Error code for "could not match input". */
272 |   private static final int ZZ_NO_MATCH = 1;
273 |   /** Error code for "pushback value was too large". */
274 |   private static final int ZZ_PUSHBACK_2BIG = 2;
275 | 
276 |   /**
277 |    * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
278 |    * {@link #ZZ_PUSHBACK_2BIG} respectively.
279 |    */
280 |   private static final String ZZ_ERROR_MSG[] = {
281 |     "Unknown internal scanner error",
282 |     "Error: could not match input",
283 |     "Error: pushback value was too large"
284 |   };
285 | 
286 |   /**
287 |    * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
288 |    */
289 |   private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
290 | 
291 |   private static final String ZZ_ATTRIBUTE_PACKED_0 =
292 |     "\1\0\1\11\1\1\1\11\2\1\1\11\1\1\3\11"+
293 |     "\1\1\1\11\4\1\2\11\4\1\2\11\15\1\1\11"+
294 |     "\1\1\2\11\1\0\1\11\1\0\3\11\1\1\3\0"+
295 |     "\3\11\20\1\1\11\1\1\1\0\1\1\1\0\1\11"+
296 |     "\1\0\52\1";
297 | 
298 |   private static int [] zzUnpackAttribute() {
299 |     int [] result = new int[120];
300 |     int offset = 0;
301 |     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
302 |     return result;
303 |   }
304 | 
305 |   private static int zzUnpackAttribute(String packed, int offset, int [] result) {
306 |     int i = 0;       /* index in packed string  */
307 |     int j = offset;  /* index in unpacked array */
308 |     int l = packed.length();
309 |     while (i < l) {
310 |       int count = packed.charAt(i++);
311 |       int value = packed.charAt(i++);
312 |       do result[j++] = value; while (--count > 0);
313 |     }
314 |     return j;
315 |   }
316 | 
317 |   /** Input device. */
318 |   private java.io.Reader zzReader;
319 | 
320 |   /** Current state of the DFA. */
321 |   private int zzState;
322 | 
323 |   /** Current lexical state. */
324 |   private int zzLexicalState = YYINITIAL;
325 | 
326 |   /**
327 |    * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
328 |    * string.
329 |    */
330 |   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
331 | 
332 |   /** Text position at the last accepting state. */
333 |   private int zzMarkedPos;
334 | 
335 |   /** Current text position in the buffer. */
336 |   private int zzCurrentPos;
337 | 
338 |   /** Marks the beginning of the {@link #yytext()} string in the buffer. */
339 |   private int zzStartRead;
340 | 
341 |   /** Marks the last character in the buffer, that has been read from input. */
342 |   private int zzEndRead;
343 | 
344 |   /**
345 |    * Whether the scanner is at the end of file.
346 |    * @see #yyatEOF
347 |    */
348 |   private boolean zzAtEOF;
349 | 
350 |   /**
351 |    * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
352 |    *
353 |    * <p>When a lead/high surrogate has been read from the input stream into the final
354 |    * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
355 |    */
356 |   private int zzFinalHighSurrogate = 0;
357 | 
358 |   /** Number of newlines encountered up to the start of the matched text. */
359 |   @SuppressWarnings("unused")
360 |   private int yyline;
361 | 
362 |   /** Number of characters from the last newline up to the start of the matched text. */
363 |   @SuppressWarnings("unused")
364 |   private int yycolumn;
365 | 
366 |   /** Number of characters up to the start of the matched text. */
367 |   @SuppressWarnings("unused")
368 |   private long yychar;
369 | 
370 |   /** Whether the scanner is currently at the beginning of a line. */
371 |   @SuppressWarnings("unused")
372 |   private boolean zzAtBOL = true;
373 | 
374 |   /** Whether the user-EOF-code has already been executed. */
375 |   @SuppressWarnings("unused")
376 |   private boolean zzEOFDone;
377 | 
378 | 
379 |   /**
380 |    * Creates a new scanner
381 |    *
382 |    * @param   in  the java.io.Reader to read input from.
383 |    */
384 |   Yylex(java.io.Reader in) {
385 |     this.zzReader = in;
386 |   }
387 | 
388 |   /**
389 |    * Translates raw input code points to DFA table row
390 |    */
391 |   private static int zzCMap(int input) {
392 |     int offset = input & 255;
393 |     return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
394 |   }
395 | 
396 |   /**
397 |    * Refills the input buffer.
398 |    *
399 |    * @return {@code false} iff there was new input.
400 |    * @exception java.io.IOException  if any I/O-Error occurs
401 |    */
402 |   private boolean zzRefill() throws java.io.IOException {
403 | 
404 |     /* first: make room (if you can) */
405 |     if (zzStartRead > 0) {
406 |       zzEndRead += zzFinalHighSurrogate;
407 |       zzFinalHighSurrogate = 0;
408 |       System.arraycopy(zzBuffer, zzStartRead,
409 |                        zzBuffer, 0,
410 |                        zzEndRead - zzStartRead);
411 | 
412 |       /* translate stored positions */
413 |       zzEndRead -= zzStartRead;
414 |       zzCurrentPos -= zzStartRead;
415 |       zzMarkedPos -= zzStartRead;
416 |       zzStartRead = 0;
417 |     }
418 | 
419 |     /* is the buffer big enough? */
420 |     if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {
421 |       /* if not: blow it up */
422 |       char newBuffer[] = new char[zzBuffer.length * 2];
423 |       System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
424 |       zzBuffer = newBuffer;
425 |       zzEndRead += zzFinalHighSurrogate;
426 |       zzFinalHighSurrogate = 0;
427 |     }
428 | 
429 |     /* fill the buffer with new input */
430 |     int requested = zzBuffer.length - zzEndRead;
431 |     int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
432 | 
433 |     /* not supposed to occur according to specification of java.io.Reader */
434 |     if (numRead == 0) {
435 |       throw new java.io.IOException(
436 |           "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
437 |     }
438 |     if (numRead > 0) {
439 |       zzEndRead += numRead;
440 |       if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
441 |         if (numRead == requested) { // We requested too few chars to encode a full Unicode character
442 |           --zzEndRead;
443 |           zzFinalHighSurrogate = 1;
444 |         } else {                    // There is room in the buffer for at least one more char
445 |           int c = zzReader.read();  // Expecting to read a paired low surrogate char
446 |           if (c == -1) {
447 |             return true;
448 |           } else {
449 |             zzBuffer[zzEndRead++] = (char)c;
450 |           }
451 |         }
452 |       }
453 |       /* potentially more input available */
454 |       return false;
455 |     }
456 | 
457 |     /* numRead < 0 ==> end of stream */
458 |     return true;
459 |   }
460 | 
461 | 
462 |   /**
463 |    * Closes the input reader.
464 |    *
465 |    * @throws java.io.IOException if the reader could not be closed.
466 |    */
467 |   public final void yyclose() throws java.io.IOException {
468 |     zzAtEOF = true; // indicate end of file
469 |     zzEndRead = zzStartRead; // invalidate buffer
470 | 
471 |     if (zzReader != null) {
472 |       zzReader.close();
473 |     }
474 |   }
475 | 
476 | 
477 |   /**
478 |    * Resets the scanner to read from a new input stream.
479 |    *
480 |    * <p>Does not close the old reader.
481 |    *
482 |    * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
483 |    * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
484 |    *
485 |    * <p>Internal scan buffer is resized down to its initial length, if it has grown.
486 |    *
487 |    * @param reader The new input stream.
488 |    */
489 |   public final void yyreset(java.io.Reader reader) {
490 |     zzReader = reader;
491 |     zzEOFDone = false;
492 |     yyResetPosition();
493 |     zzLexicalState = YYINITIAL;
494 |     if (zzBuffer.length > ZZ_BUFFERSIZE) {
495 |       zzBuffer = new char[ZZ_BUFFERSIZE];
496 |     }
497 |   }
498 | 
499 |   /**
500 |    * Resets the input position.
501 |    */
502 |   private final void yyResetPosition() {
503 |       zzAtBOL  = true;
504 |       zzAtEOF  = false;
505 |       zzCurrentPos = 0;
506 |       zzMarkedPos = 0;
507 |       zzStartRead = 0;
508 |       zzEndRead = 0;
509 |       zzFinalHighSurrogate = 0;
510 |       yyline = 0;
511 |       yycolumn = 0;
512 |       yychar = 0L;
513 |   }
514 | 
515 | 
516 |   /**
517 |    * Returns whether the scanner has reached the end of the reader it reads from.
518 |    *
519 |    * @return whether the scanner has reached EOF.
520 |    */
521 |   public final boolean yyatEOF() {
522 |     return zzAtEOF;
523 |   }
524 | 
525 | 
526 |   /**
527 |    * Returns the current lexical state.
528 |    *
529 |    * @return the current lexical state.
530 |    */
531 |   public final int yystate() {
532 |     return zzLexicalState;
533 |   }
534 | 
535 | 
536 |   /**
537 |    * Enters a new lexical state.
538 |    *
539 |    * @param newState the new lexical state
540 |    */
541 |   public final void yybegin(int newState) {
542 |     zzLexicalState = newState;
543 |   }
544 | 
545 | 
546 |   /**
547 |    * Returns the text matched by the current regular expression.
548 |    *
549 |    * @return the matched text.
550 |    */
551 |   public final String yytext() {
552 |     return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
553 |   }
554 | 
555 | 
556 |   /**
557 |    * Returns the character at the given position from the matched text.
558 |    *
559 |    * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
560 |    *
561 |    * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
562 |    *
563 |    * @return the character at {@code position}.
564 |    */
565 |   public final char yycharat(int position) {
566 |     return zzBuffer[zzStartRead + position];
567 |   }
568 | 
569 | 
570 |   /**
571 |    * How many characters were matched.
572 |    *
573 |    * @return the length of the matched text region.
574 |    */
575 |   public final int yylength() {
576 |     return zzMarkedPos-zzStartRead;
577 |   }
578 | 
579 | 
580 |   /**
581 |    * Reports an error that occurred while scanning.
582 |    *
583 |    * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
584 |    * match-all fallback rule) this method will only be called with things that
585 |    * "Can't Possibly Happen".
586 |    *
587 |    * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
588 |    * scanner etc.).
589 |    *
590 |    * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
591 |    *
592 |    * @param errorCode the code of the error message to display.
593 |    */
594 |   private static void zzScanError(int errorCode) {
595 |     String message;
596 |     try {
597 |       message = ZZ_ERROR_MSG[errorCode];
598 |     } catch (ArrayIndexOutOfBoundsException e) {
599 |       message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
600 |     }
601 | 
602 |     throw new Error(message);
603 |   }
604 | 
605 | 
606 |   /**
607 |    * Pushes the specified amount of characters back into the input stream.
608 |    *
609 |    * <p>They will be read again by then next call of the scanning method.
610 |    *
611 |    * @param number the number of characters to be read again. This number must not be greater than
612 |    *     {@link #yylength()}.
613 |    */
614 |   public void yypushback(int number)  {
615 |     if ( number > yylength() )
616 |       zzScanError(ZZ_PUSHBACK_2BIG);
617 | 
618 |     zzMarkedPos -= number;
619 |   }
620 | 
621 | 
622 | 
623 | 
624 |   /**
625 |    * Resumes scanning until the next regular expression is matched, the end of input is encountered
626 |    * or an I/O-Error occurs.
627 |    *
628 |    * @return the next token.
629 |    * @exception java.io.IOException if any I/O-Error occurs.
630 |    */
631 |   public int yylex() throws java.io.IOException {
632 |     int zzInput;
633 |     int zzAction;
634 | 
635 |     // cached fields:
636 |     int zzCurrentPosL;
637 |     int zzMarkedPosL;
638 |     int zzEndReadL = zzEndRead;
639 |     char[] zzBufferL = zzBuffer;
640 | 
641 |     int [] zzTransL = ZZ_TRANS;
642 |     int [] zzRowMapL = ZZ_ROWMAP;
643 |     int [] zzAttrL = ZZ_ATTRIBUTE;
644 | 
645 |     while (true) {
646 |       zzMarkedPosL = zzMarkedPos;
647 | 
648 |       zzAction = -1;
649 | 
650 |       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
651 | 
652 |       zzState = ZZ_LEXSTATE[zzLexicalState];
653 | 
654 |       // set up zzAction for empty match case:
655 |       int zzAttributes = zzAttrL[zzState];
656 |       if ( (zzAttributes & 1) == 1 ) {
657 |         zzAction = zzState;
658 |       }
659 | 
660 | 
661 |       zzForAction: {
662 |         while (true) {
663 | 
664 |           if (zzCurrentPosL < zzEndReadL) {
665 |             zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
666 |             zzCurrentPosL += Character.charCount(zzInput);
667 |           }
668 |           else if (zzAtEOF) {
669 |             zzInput = YYEOF;
670 |             break zzForAction;
671 |           }
672 |           else {
673 |             // store back cached positions
674 |             zzCurrentPos  = zzCurrentPosL;
675 |             zzMarkedPos   = zzMarkedPosL;
676 |             boolean eof = zzRefill();
677 |             // get translated positions and possibly new buffer
678 |             zzCurrentPosL  = zzCurrentPos;
679 |             zzMarkedPosL   = zzMarkedPos;
680 |             zzBufferL      = zzBuffer;
681 |             zzEndReadL     = zzEndRead;
682 |             if (eof) {
683 |               zzInput = YYEOF;
684 |               break zzForAction;
685 |             }
686 |             else {
687 |               zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
688 |               zzCurrentPosL += Character.charCount(zzInput);
689 |             }
690 |           }
691 |           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
692 |           if (zzNext == -1) break zzForAction;
693 |           zzState = zzNext;
694 | 
695 |           zzAttributes = zzAttrL[zzState];
696 |           if ( (zzAttributes & 1) == 1 ) {
697 |             zzAction = zzState;
698 |             zzMarkedPosL = zzCurrentPosL;
699 |             if ( (zzAttributes & 8) == 8 ) break zzForAction;
700 |           }
701 | 
702 |         }
703 |       }
704 | 
705 |       // store back cached position
706 |       zzMarkedPos = zzMarkedPosL;
707 | 
708 |       if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
709 |         zzAtEOF = true;
710 |         return YYEOF;
711 |       }
712 |       else {
713 |         switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
714 |           case 1:
715 |             { j0.lexErr("unrecognized character");
716 |             }
717 |             // fall through
718 |           case 52: break;
719 |           case 2:
720 |             { j0.whitespace();
721 |             }
722 |             // fall through
723 |           case 53: break;
724 |           case 3:
725 |             { j0.newline();
726 |             }
727 |             // fall through
728 |           case 54: break;
729 |           case 4:
730 |             { return j0.scan(j0.ord("!"));
731 |             }
732 |             // fall through
733 |           case 55: break;
734 |           case 5:
735 |             { return j0.scan(j0.ord("%"));
736 |             }
737 |             // fall through
738 |           case 56: break;
739 |           case 6:
740 |             { return j0.scan(j0.ord("("));
741 |             }
742 |             // fall through
743 |           case 57: break;
744 |           case 7:
745 |             { return j0.scan(j0.ord(")"));
746 |             }
747 |             // fall through
748 |           case 58: break;
749 |           case 8:
750 |             { return j0.scan(j0.ord("*"));
751 |             }
752 |             // fall through
753 |           case 59: break;
754 |           case 9:
755 |             { return j0.scan(j0.ord("+"));
756 |             }
757 |             // fall through
758 |           case 60: break;
759 |           case 10:
760 |             { return j0.scan(j0.ord(","));
761 |             }
762 |             // fall through
763 |           case 61: break;
764 |           case 11:
765 |             { return j0.scan(j0.ord("-"));
766 |             }
767 |             // fall through
768 |           case 62: break;
769 |           case 12:
770 |             { return j0.scan(j0.ord("."));
771 |             }
772 |             // fall through
773 |           case 63: break;
774 |           case 13:
775 |             { return j0.scan(j0.ord("/"));
776 |             }
777 |             // fall through
778 |           case 64: break;
779 |           case 14:
780 |             { return j0.scan(parser.INTLIT);
781 |             }
782 |             // fall through
783 |           case 65: break;
784 |           case 15:
785 |             { return j0.scan(j0.ord(":"));
786 |             }
787 |             // fall through
788 |           case 66: break;
789 |           case 16:
790 |             { return j0.scan(j0.ord(";"));
791 |             }
792 |             // fall through
793 |           case 67: break;
794 |           case 17:
795 |             { return j0.scan(j0.ord("<"));
796 |             }
797 |             // fall through
798 |           case 68: break;
799 |           case 18:
800 |             { return j0.scan(j0.ord("="));
801 |             }
802 |             // fall through
803 |           case 69: break;
804 |           case 19:
805 |             { return j0.scan(j0.ord(">"));
806 |             }
807 |             // fall through
808 |           case 70: break;
809 |           case 20:
810 |             { return j0.scan(parser.IDENTIFIER);
811 |             }
812 |             // fall through
813 |           case 71: break;
814 |           case 21:
815 |             { return j0.scan(j0.ord("["));
816 |             }
817 |             // fall through
818 |           case 72: break;
819 |           case 22:
820 |             { return j0.scan(j0.ord("]"));
821 |             }
822 |             // fall through
823 |           case 73: break;
824 |           case 23:
825 |             { return j0.scan(j0.ord("{"));
826 |             }
827 |             // fall through
828 |           case 74: break;
829 |           case 24:
830 |             { return j0.scan(j0.ord("}"));
831 |             }
832 |             // fall through
833 |           case 75: break;
834 |           case 25:
835 |             { return j0.scan(parser.NOTEQUALTO);
836 |             }
837 |             // fall through
838 |           case 76: break;
839 |           case 26:
840 |             { return j0.scan(parser.STRINGLIT);
841 |             }
842 |             // fall through
843 |           case 77: break;
844 |           case 27:
845 |             { return j0.scan(parser.LOGICALAND);
846 |             }
847 |             // fall through
848 |           case 78: break;
849 |           case 28:
850 |             { return j0.scan(parser.INCREMENT);
851 |             }
852 |             // fall through
853 |           case 79: break;
854 |           case 29:
855 |             { return j0.scan(parser.DECREMENT);
856 |             }
857 |             // fall through
858 |           case 80: break;
859 |           case 30:
860 |             { return j0.scan(parser.DOUBLELIT);
861 |             }
862 |             // fall through
863 |           case 81: break;
864 |           case 31:
865 |             { return j0.scan(parser.LESSTHANOREQUAL);
866 |             }
867 |             // fall through
868 |           case 82: break;
869 |           case 32:
870 |             { return j0.scan(parser.ISEQUALTO);
871 |             }
872 |             // fall through
873 |           case 83: break;
874 |           case 33:
875 |             { return j0.scan(parser.GREATERTHANOREQUAL);
876 |             }
877 |             // fall through
878 |           case 84: break;
879 |           case 34:
880 |             { return j0.scan(parser.IF);
881 |             }
882 |             // fall through
883 |           case 85: break;
884 |           case 35:
885 |             { return j0.scan(parser.LOGICALOR);
886 |             }
887 |             // fall through
888 |           case 86: break;
889 |           case 36:
890 |             { j0.comment();
891 |             }
892 |             // fall through
893 |           case 87: break;
894 |           case 37:
895 |             { return j0.scan(parser.FOR);
896 |             }
897 |             // fall through
898 |           case 88: break;
899 |           case 38:
900 |             { return j0.scan(parser.INT);
901 |             }
902 |             // fall through
903 |           case 89: break;
904 |           case 39:
905 |             { return j0.scan(parser.BOOL);
906 |             }
907 |             // fall through
908 |           case 90: break;
909 |           case 40:
910 |             { return j0.scan(parser.ELSE);
911 |             }
912 |             // fall through
913 |           case 91: break;
914 |           case 41:
915 |             { return j0.scan(parser.NULLVAL);
916 |             }
917 |             // fall through
918 |           case 92: break;
919 |           case 42:
920 |             { return j0.scan(parser.BOOLLIT);
921 |             }
922 |             // fall through
923 |           case 93: break;
924 |           case 43:
925 |             { return j0.scan(parser.VOID);
926 |             }
927 |             // fall through
928 |           case 94: break;
929 |           case 44:
930 |             { return j0.scan(parser.BREAK);
931 |             }
932 |             // fall through
933 |           case 95: break;
934 |           case 45:
935 |             { return j0.scan(parser.CLASS);
936 |             }
937 |             // fall through
938 |           case 96: break;
939 |           case 46:
940 |             { return j0.scan(parser.WHILE);
941 |             }
942 |             // fall through
943 |           case 97: break;
944 |           case 47:
945 |             { return j0.scan(parser.DOUBLE);
946 |             }
947 |             // fall through
948 |           case 98: break;
949 |           case 48:
950 |             { return j0.scan(parser.PUBLIC);
951 |             }
952 |             // fall through
953 |           case 99: break;
954 |           case 49:
955 |             { return j0.scan(parser.RETURN);
956 |             }
957 |             // fall through
958 |           case 100: break;
959 |           case 50:
960 |             { return j0.scan(parser.STATIC);
961 |             }
962 |             // fall through
963 |           case 101: break;
964 |           case 51:
965 |             { return j0.scan(parser.STRING);
966 |             }
967 |             // fall through
968 |           case 102: break;
969 |           default:
970 |             zzScanError(ZZ_NO_MATCH);
971 |         }
972 |       }
973 |     }
974 |   }
975 | 
976 | 
977 | }
978 | 


--------------------------------------------------------------------------------
/ch5/cereal.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |    serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch5/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch5/helloerror.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!")
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch5/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yylval, parser, yyfilename
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    serial := serial()
 5 |    parser := Parser()
 6 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 7 |    yyfilename := argv[1]
 8 |    yylineno := 1
 9 |    if yyparse() = 0 then
10 |       write("no errors")
11 | end
12 | class j0()
13 |    method lexErr(s)
14 |       stop(s, ": ", yytext) 
15 |    end
16 |    method scan(cat)
17 |       yylval := tree("token", cat, token(cat, yytext, yylineno))
18 |       return cat
19 |    end
20 |    method whitespace()
21 |    end
22 |    method newline()
23 |       yylineno +:= 1
24 |    end
25 |    method comment()
26 |       yytext ? {
27 |          while tab(find("\n")+1) do newline()
28 |       }
29 |    end
30 |    method ord(s)
31 |       return proc("ord",0)(s[1])
32 |    end
33 |    method print(root)
34 |       root.print()
35 |       root.print_graph(yyfilename || ".dot")
36 |    end
37 |    method node(s,r,p[])
38 |       return tree ! ([s,r] ||| p)
39 |    end
40 | end
41 | 


--------------------------------------------------------------------------------
/ch5/j0.java:
--------------------------------------------------------------------------------
 1 | package ch5;
 2 | import java.io.FileReader;
 3 | public class j0 {
 4 |    public static Yylex yylexer;
 5 |    public static ch5.parser par;
 6 |    public static void main(String argv[]) throws Exception {
 7 |       init(argv[0]);
 8 |       par = new ch5.parser();
 9 |       //                  par.yydebug=true;
10 |       yylineno = 1;
11 |       int i = par.yyparse();
12 |       if (i == 0)
13 |          System.out.println("no errors");
14 |    }
15 |    public static int yylineno;
16 |    public static String yyfilename;
17 |     //   public static parserVal yylval;
18 |    public static void init(String s) throws Exception {
19 |       yyfilename = s;
20 |       yylexer = new Yylex(new FileReader(s));
21 |    }
22 |    public static int YYEOF() { return Yylex.YYEOF; }
23 |    public static int yylex() {
24 |       int rv = 0;
25 |       try {
26 |         rv = yylexer.yylex();
27 |       } catch(java.io.IOException ioException) {
28 |         rv = -1;
29 |       }
30 |       return rv;
31 |    }
32 |    public static String yytext() {
33 |       return yylexer.yytext();
34 |    }
35 |    public static void lexErr(String s) {
36 |       System.err.println(s);
37 |       System.exit(1);
38 |    }
39 |    public static int scan(int cat) {
40 |        ch5.j0.par.yylval =
41 | 	   new parserVal(new tree("token",0,
42 | 		new token(cat, yytext(), yylineno)));
43 |       return cat;
44 |    }
45 |    public static void newline() {
46 |       yylineno++;
47 |    }
48 |    public static void whitespace() {
49 |    }
50 |    public static void comment() {
51 |    }
52 |    public static short ord(String s) { return (short)(s.charAt(0)); }
53 |    public static void print(parserVal root) {
54 |        ((tree)root.obj).print();
55 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
56 |    }
57 |   public static tree unwrap(Object obj) {
58 |     if (obj instanceof token)
59 |       return new tree("token",0,(token)obj);
60 |     else return (tree)obj;
61 |   }
62 |   public static parserVal node(String s,int r,parserVal...p) {
63 |      tree[] t = new tree[p.length];
64 |      for(int i = 0; i < t.length; i++)
65 | 	 t[i] = (tree)(p[i].obj);
66 |      return new parserVal((Object)new tree(s,r,t));
67 |   }
68 | }
69 | 


--------------------------------------------------------------------------------
/ch5/j0gram.icn:
--------------------------------------------------------------------------------
  1 | ### This file created by IYACC 1.1
  2 | ### Please send bug reports to jeffery@cs.nmt.edu
  3 | #define YYPREFIX "yy"
  4 | $define BREAK 257
  5 | $define DOUBLE 258
  6 | $define ELSE 259
  7 | $define FOR 260
  8 | $define IF 261
  9 | $define INT 262
 10 | $define RETURN 263
 11 | $define VOID 264
 12 | $define WHILE 265
 13 | $define IDENTIFIER 266
 14 | $define CLASSNAME 267
 15 | $define CLASS 268
 16 | $define STRING 269
 17 | $define BOOL 270
 18 | $define INTLIT 271
 19 | $define DOUBLELIT 272
 20 | $define STRINGLIT 273
 21 | $define BOOLLIT 274
 22 | $define NULLVAL 275
 23 | $define LESSTHANOREQUAL 276
 24 | $define GREATERTHANOREQUAL 277
 25 | $define ISEQUALTO 278
 26 | $define NOTEQUALTO 279
 27 | $define LOGICALAND 280
 28 | $define LOGICALOR 281
 29 | $define INCREMENT 282
 30 | $define DECREMENT 283
 31 | $define PUBLIC 284
 32 | $define STATIC 285
 33 | $define YYERRCODE 256
 34 | procedure init() 
 35 |   yylhs := [                                        -1,
 36 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 37 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 38 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 39 |    18,    6,   14,   19,   19,   20,   20,   21,   21,   22,
 40 |    24,   23,   23,   23,   23,   23,   23,   23,   23,   23,
 41 |    23,   25,   33,   33,   28,   29,   30,   30,   37,   37,
 42 |    38,   31,   32,   39,   39,   39,   40,   40,   41,   41,
 43 |    42,   42,   26,   26,   27,   43,   43,   43,   43,   44,
 44 |    44,   44,   44,   44,   46,   46,   45,   47,   47,   35,
 45 |    35,   48,   48,   49,   49,   49,   50,   50,   50,   50,
 46 |    51,   51,   51,   52,   52,   52,   52,   53,   53,   54,
 47 |    54,   54,   55,   55,   56,   56,   36,   36,   34,   57,
 48 |    57,   58,   58,   58,
 49 |   ]
 50 |   yylen := [                            2,
 51 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 52 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 53 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 54 |     2,    2,    3,    1,    0,    1,    2,    1,    1,    2,
 55 |     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 56 |     1,    2,    1,    1,    5,    7,    6,    8,    1,    2,
 57 |     2,    5,    9,    1,    1,    0,    1,    0,    1,    0,
 58 |     1,    3,    2,    3,    3,    1,    1,    1,    3,    1,
 59 |     1,    1,    1,    1,    1,    3,    3,    1,    0,    4,
 60 |     6,    1,    1,    2,    2,    1,    1,    3,    3,    3,
 61 |     1,    3,    3,    1,    1,    1,    1,    1,    3,    1,
 62 |     3,    3,    1,    3,    1,    3,    1,    1,    3,    1,
 63 |     1,    1,    1,    1,
 64 |   ]
 65 |   yydefred := [                         0,
 66 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 67 |    12,    0,    3,    0,    4,    6,    7,    8,    0,    0,
 68 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 69 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 70 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 71 |     0,   80,   81,   83,   82,   84,   43,    0,    0,    0,
 72 |    42,    0,    0,   36,   38,   39,    0,   44,   45,   46,
 73 |    47,   48,   49,   50,   51,    0,   53,    0,    0,   76,
 74 |     0,    0,    0,   26,    0,    0,   25,    0,   21,    0,
 75 |    73,    0,    0,    0,    0,    0,  118,   78,   67,    0,
 76 |     0,   96,   97,    0,    0,    0,    0,    0,    0,    0,
 77 |     0,    0,    0,   33,   37,   40,   52,    0,  123,  124,
 78 |   122,    0,   30,   74,   65,   71,    0,    0,    0,    0,
 79 |    77,   94,   95,   75,    0,    0,    0,    0,    0,  104,
 80 |   105,  106,  107,    0,    0,    0,    0,    0,    0,   79,
 81 |    85,    0,    0,    0,  119,    0,    0,    0,   98,   99,
 82 |   100,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 83 |    90,    0,    0,    0,   72,    0,   62,   86,    0,    0,
 84 |     0,    0,   59,   91,    0,    0,    0,   56,   61,    0,
 85 |    60,    0,    0,   58,   63,    0,    0,   55,
 86 |   ]
 87 |   yydgoto := [                          2,
 88 |     6,   14,   15,   16,   17,   18,   59,   29,  130,   21,
 89 |    30,   42,   22,   61,   23,   37,   38,   39,   62,   63,
 90 |    64,   65,   66,   67,   68,   69,   70,   71,   72,   73,
 91 |    74,   75,   76,   97,   98,   99,  182,  183,  127,  100,
 92 |   185,  128,  101,   80,   81,  152,  153,  102,  103,  104,
 93 |   105,  144,  106,  107,  108,  109,   82,  122,
 94 |   ]
 95 |   yysindex := [                      -218,
 96 |  -200,    0, -181,  -35,  -95,    0,    0,    0,   51,    0,
 97 |     0, -177,    0,  -93,    0,    0,    0,    0, -152,   79,
 98 |     0,   16,   16,  227,  217,    0,    0,    0,  -30,   65,
 99 |  -133,  169,    0,    0,    0, -152,  117,  116,    0,    0,
100 |     0,  -96,    0, -152,   95,    0,  -46,  132,  150,   50,
101 |   153,    0,    0,    0,    0,    0,    0,   50, -152,   52,
102 |     0,   72,  169,    0,    0,    0,  141,    0,    0,    0,
103 |     0,    0,    0,    0,    0,  143,    0,    0,  158,    0,
104 |     0,  -24,   65,    0,  227,   51,    0,   65,    0,  148,
105 |     0,  -39,   50,   50,   50,   52,    0,    0,    0,  151,
106 |   158,    0,    0,  145,  109,   97, -100,  -69,  -68,   50,
107 |   171,  170,   50,    0,    0,    0,    0,  -51,    0,    0,
108 |     0,   50,    0,    0,    0,    0,  157,  173,  177,   52,
109 |     0,    0,    0,    0,   50,   50,   50,   50,   50,    0,
110 |     0,    0,    0,   50,   50,   50,   50,   50,  180,    0,
111 |     0,  182,  188,  197,    0,   50,   -1,   16,    0,    0,
112 |     0,  145,  145,  109,   97,   97, -100,  -69,  268,   50,
113 |     0,   50,  179,   52,    0,  -11,    0,    0,  219,   -1,
114 |  -111,    9,    0,    0,  222,  173,  224,    0,    0, -111,
115 |     0,   16,   50,    0,    0,  234,   16,    0,
116 |   ]
117 |   yyrindex := [                         0,
118 |     0,    0,    0,    0,    0,    0,    0,    0,  -44,    0,
119 |     0,    0,    0,    0,    0,    0,    0,    0,    0,   19,
120 |     0,    0,    0,  235,    0,    0,    0,    0,    0,    6,
121 |     0,  172,    0,    0,    0,    0,    0,  257,    0,    0,
122 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  240,
123 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -58,
124 |     0,    0,  175,    0,    0,    0,    0,    0,    0,    0,
125 |     0,    0,    0,    0,    0,    0,    0,  107,    0,    0,
126 |   -37,    0,  -13,    0,    0,    0,    0,   14,    0,    0,
127 |     0,  246,    0,    0,    0,    1,    0,    0,    0,    0,
128 |    10,    0,    0,   56,   76,   15,   90,   45,   43,    0,
129 |     0,  247,  266,    0,    0,    0,    0,    0,    0,    0,
130 |     0,    0,    0,    0,    0,    0,    0,  250,    0,   34,
131 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
132 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
133 |     0,  276,    0,  -26,    0,  240,    0,    0,    0,    0,
134 |     0,   62,   68,   82,   23,   88,   96,  102,    0,    0,
135 |     0,  266,    0,  -21,    0,  124,    0,    0,    0,  277,
136 |     0,  144,    0,    0,    0,  278,    0,    0,    0,    0,
137 |     0,    0,    0,    0,    0,    0,    0,    0,
138 |   ]
139 |   yygindex := [                         0,
140 |     0,    0,  314,    0,    0,    0,  181,  270,  445,    0,
141 |     5,    0,    0,    4,  289,    0,    0,  245,    0,    0,
142 |   287,    0,  195,  273,    0,    0,    0,  -71,    0,    0,
143 |     0,    0,  -12,  288,  388,  378,    0,  190,    0,  223,
144 |     0,  198,  390,    0,  441,    0,  203,    0,  329,   42,
145 |   244,    0,   53,  253,  255,    0,    0,    0,
146 |   ]
147 | $define YYTABLESIZE 638
148 |   yytable := [                         77,
149 |    58,   15,  120,   77,   77,   77,   77,   77,   77,   77,
150 |    87,   32,   91,   44,   87,   87,   87,   87,   87,   87,
151 |    87,   77,   77,  121,   77,   33,   34,   31,   43,   13,
152 |    31,   26,   87,   87,   87,   87,  121,   93,   58,  120,
153 |    83,   93,   93,   93,   93,   93,   92,   93,   88,   18,
154 |    92,   92,   92,   92,   92,  110,   92,   19,  110,   93,
155 |    93,  120,   93,  111,   18,    1,  111,    3,   92,   92,
156 |    93,   92,   19,  110,   93,   93,   93,   93,   93,  126,
157 |    93,  111,   95,  117,    4,  115,  117,    5,  115,   58,
158 |    24,  113,   93,   93,   94,   93,  101,   31,  101,  101,
159 |   101,  117,  103,  115,  103,  103,  103,   25,  102,  189,
160 |   102,  102,  102,   28,  101,  101,  108,  101,  189,  108,
161 |   103,  103,  109,  103,   31,  109,  102,  102,  112,  102,
162 |   113,  112,   46,  113,  108,  108,  114,  108,   32,  114,
163 |   109,  109,  116,  109,  175,  116,  112,   54,  113,  187,
164 |    54,  139,   78,  138,  114,   45,  142,   84,  143,   85,
165 |   116,  176,    7,   55,    7,   54,    8,  126,    8,   86,
166 |     9,   92,    9,   10,   11,   10,   11,  145,  146,  162,
167 |   163,  137,   55,   57,  188,   19,  135,   89,   12,   93,
168 |    12,  136,  110,  194,   19,  195,  114,  165,  166,  116,
169 |   198,  117,   57,  118,   36,   41,  124,   14,   58,  134,
170 |   147,  150,  148,   44,  154,  156,  157,  158,    7,   90,
171 |   169,   15,    8,  120,  120,  170,   35,   57,  171,   10,
172 |    11,   52,   53,   54,   55,   56,  172,  180,   77,   77,
173 |    77,   77,   77,   77,  121,  121,   55,  181,   55,   87,
174 |    87,   87,   87,   87,   87,   87,   87,  119,  120,  184,
175 |   120,  120,  192,  193,   35,   36,   57,  190,   57,   52,
176 |    53,   54,   55,   56,  197,   28,   93,   93,   93,   93,
177 |    93,   93,  120,  120,   14,   92,   92,   92,   92,   92,
178 |    92,   32,  110,  110,  110,  110,   35,   27,   68,   34,
179 |   111,  111,  111,  111,   66,   41,   89,   58,   64,   93,
180 |    93,   93,   93,   93,   93,   35,   88,   70,   69,   77,
181 |    52,   53,   54,   55,   56,  115,   57,   27,  112,  123,
182 |    87,  101,  101,  101,  101,  101,  101,  103,  103,  103,
183 |   103,  103,  103,  102,  102,  102,  102,  102,  102,  115,
184 |    77,  108,  108,  108,  108,  108,  108,  109,  109,  109,
185 |   109,  109,  109,  177,  125,  112,  112,  112,  112,  113,
186 |   113,  191,  140,  141,  179,  114,  114,  186,  173,   77,
187 |    55,   55,  116,   55,   55,   55,   55,  164,   55,   55,
188 |    32,    0,   55,   55,   55,   55,   55,   55,   55,  167,
189 |    57,   57,  168,   57,   57,   57,   57,    0,   57,   57,
190 |     0,    0,   57,   57,   57,   57,   57,   57,   57,   78,
191 |     0,   79,  132,  133,    0,   47,    7,    0,   48,   49,
192 |     8,   50,    0,   51,   35,  111,    0,   10,   11,   52,
193 |    53,   54,   55,   56,   77,    0,    0,    0,    0,   20,
194 |    78,    0,   79,    0,    0,    0,   77,    0,   20,    0,
195 |     0,    0,    0,  159,  160,  161,    0,   77,   20,   20,
196 |   129,    0,    0,    0,    7,    0,   60,    0,    8,   78,
197 |    40,   79,   35,    0,    7,   10,   11,  149,    8,    0,
198 |   151,    0,   35,    0,   96,   10,   11,    0,    0,  155,
199 |     0,    0,   96,    0,    0,    0,    0,   60,    0,    0,
200 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
201 |     0,    0,    0,    0,   47,    0,    0,   48,   49,   20,
202 |    50,    0,   51,   35,  131,  131,   60,   96,   52,   53,
203 |    54,   55,   56,    0,   78,    0,   79,  178,    0,  151,
204 |     0,    0,    0,    0,   96,    0,   78,   96,   79,    0,
205 |     0,    0,    0,    0,    0,    0,   96,   78,    0,   79,
206 |   196,    0,    0,    0,    0,  131,  131,  131,  131,  131,
207 |     0,    0,    0,    0,  131,  131,  131,  131,  131,    0,
208 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
209 |    96,  174,    0,    0,    0,    0,    0,    0,    0,    0,
210 |     0,    0,    0,  174,   96,    0,   96,    0,    0,    0,
211 |     0,    0,    0,    0,  174,    0,    0,    0,    0,    0,
212 |     0,    0,    0,    0,    0,    0,    0,   96,
213 |   ]
214 |   yycheck := [                         37,
215 |    40,   46,   61,   41,   42,   43,   44,   45,   46,   47,
216 |    37,  123,   59,   44,   41,   42,   43,   44,   45,   46,
217 |    47,   59,   60,   61,   62,   22,   23,   41,   59,  125,
218 |    44,  125,   59,   60,   61,   62,   61,   37,   40,   61,
219 |    36,   41,   42,   43,   44,   45,   37,   47,   44,   44,
220 |    41,   42,   43,   44,   45,   41,   47,   44,   44,   59,
221 |    60,   61,   62,   41,   59,  284,   44,  268,   59,   60,
222 |    37,   62,   59,   59,   41,   42,   43,   44,   45,   92,
223 |    47,   59,   33,   41,  266,   41,   44,  123,   44,   40,
224 |    40,   40,   59,   60,   45,   62,   41,   46,   43,   44,
225 |    45,   59,   41,   59,   43,   44,   45,  285,   41,  181,
226 |    43,   44,   45,  266,   59,   60,   41,   62,  190,   44,
227 |    59,   60,   41,   62,   46,   44,   59,   60,   41,   62,
228 |    41,   44,  266,   44,   59,   60,   41,   62,  123,   44,
229 |    59,   60,   41,   62,  157,   44,   59,   41,   59,  261,
230 |    44,   43,   46,   45,   59,   91,   60,   41,   62,   44,
231 |    59,  158,  258,   40,  258,   59,  262,  180,  262,  266,
232 |   266,   40,  266,  269,  270,  269,  270,  278,  279,  138,
233 |   139,   37,   59,   40,  181,    5,   42,   93,  284,   40,
234 |   284,   47,   40,  190,   14,  192,  125,  145,  146,   59,
235 |   197,   59,   59,   46,   24,   25,   59,  266,   40,   59,
236 |   280,   41,  281,   44,  266,   59,   44,   41,  258,  266,
237 |    41,  266,  262,  282,  283,   44,  266,   59,   41,  269,
238 |   270,  271,  272,  273,  274,  275,   40,   59,  276,  277,
239 |   278,  279,  280,  281,  282,  283,  123,  259,  125,  276,
240 |   277,  278,  279,  280,  281,  282,  283,  282,  283,   41,
241 |   282,  283,   41,   40,  266,   85,  123,  259,  125,  271,
242 |   272,  273,  274,  275,   41,   41,  276,  277,  278,  279,
243 |   280,  281,  282,  283,  266,  276,  277,  278,  279,  280,
244 |   281,  123,  278,  279,  280,  281,  125,   41,   59,  125,
245 |   278,  279,  280,  281,   59,   59,   41,   40,   59,  276,
246 |   277,  278,  279,  280,  281,  266,   41,   41,   41,   32,
247 |   271,  272,  273,  274,  275,  281,   59,   14,   59,   85,
248 |    42,  276,  277,  278,  279,  280,  281,  276,  277,  278,
249 |   279,  280,  281,  276,  277,  278,  279,  280,  281,   63,
250 |    63,  276,  277,  278,  279,  280,  281,  276,  277,  278,
251 |   279,  280,  281,  169,   92,  278,  279,  280,  281,  280,
252 |   281,  182,  276,  277,  172,  280,  281,  180,  156,   92,
253 |   257,  258,  281,  260,  261,  262,  263,  144,  265,  266,
254 |   123,   -1,  269,  270,  271,  272,  273,  274,  275,  147,
255 |   257,  258,  148,  260,  261,  262,  263,   -1,  265,  266,
256 |    -1,   -1,  269,  270,  271,  272,  273,  274,  275,   32,
257 |    -1,   32,   94,   95,   -1,  257,  258,   -1,  260,  261,
258 |   262,  263,   -1,  265,  266,   58,   -1,  269,  270,  271,
259 |   272,  273,  274,  275,  157,   -1,   -1,   -1,   -1,    5,
260 |    63,   -1,   63,   -1,   -1,   -1,  169,   -1,   14,   -1,
261 |    -1,   -1,   -1,  135,  136,  137,   -1,  180,   24,   25,
262 |    93,   -1,   -1,   -1,  258,   -1,   32,   -1,  262,   92,
263 |   264,   92,  266,   -1,  258,  269,  270,  110,  262,   -1,
264 |   113,   -1,  266,   -1,   50,  269,  270,   -1,   -1,  122,
265 |    -1,   -1,   58,   -1,   -1,   -1,   -1,   63,   -1,   -1,
266 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
267 |    -1,   -1,   -1,   -1,  257,   -1,   -1,  260,  261,   85,
268 |   263,   -1,  265,  266,   94,   95,   92,   93,  271,  272,
269 |   273,  274,  275,   -1,  157,   -1,  157,  170,   -1,  172,
270 |    -1,   -1,   -1,   -1,  110,   -1,  169,  113,  169,   -1,
271 |    -1,   -1,   -1,   -1,   -1,   -1,  122,  180,   -1,  180,
272 |   193,   -1,   -1,   -1,   -1,  135,  136,  137,  138,  139,
273 |    -1,   -1,   -1,   -1,  144,  145,  146,  147,  148,   -1,
274 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
275 |   156,  157,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
276 |    -1,   -1,   -1,  169,  170,   -1,  172,   -1,   -1,   -1,
277 |    -1,   -1,   -1,   -1,  180,   -1,   -1,   -1,   -1,   -1,
278 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,  193,
279 |   ]
280 | $define YYFINAL 2
281 | $define YYMAXTOKEN 285
282 |   yyname := [
283 | "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
284 | "'!'",0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,
285 | 0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
286 | 0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
287 | 0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
288 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
289 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
290 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"BREAK","DOUBLE","ELSE","FOR","IF",
291 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
292 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
293 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
294 | "INCREMENT","DECREMENT","PUBLIC","STATIC",
295 |   ]
296 |   yyrule := [
297 | "$accept : ClassDecl",
298 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
299 | "ClassBody : '{' ClassBodyDecls '}'",
300 | "ClassBody : '{' '}'",
301 | "ClassBodyDecls : ClassBodyDecl",
302 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
303 | "ClassBodyDecl : FieldDecl",
304 | "ClassBodyDecl : MethodDecl",
305 | "ClassBodyDecl : ConstructorDecl",
306 | "FieldDecl : Type VarDecls ';'",
307 | "Type : INT",
308 | "Type : DOUBLE",
309 | "Type : BOOL",
310 | "Type : STRING",
311 | "Type : Name",
312 | "Name : IDENTIFIER",
313 | "Name : QualifiedName",
314 | "QualifiedName : Name '.' IDENTIFIER",
315 | "VarDecls : VarDeclarator",
316 | "VarDecls : VarDecls ',' VarDeclarator",
317 | "VarDeclarator : IDENTIFIER",
318 | "VarDeclarator : VarDeclarator '[' ']'",
319 | "MethodReturnVal : Type",
320 | "MethodReturnVal : VOID",
321 | "MethodDecl : MethodHeader Block",
322 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
323 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
324 | "FormalParmListOpt : FormalParmList",
325 | "FormalParmListOpt :",
326 | "FormalParmList : FormalParm",
327 | "FormalParmList : FormalParmList ',' FormalParm",
328 | "FormalParm : Type VarDeclarator",
329 | "ConstructorDecl : MethodDeclarator Block",
330 | "Block : '{' BlockStmtsOpt '}'",
331 | "BlockStmtsOpt : BlockStmts",
332 | "BlockStmtsOpt :",
333 | "BlockStmts : BlockStmt",
334 | "BlockStmts : BlockStmts BlockStmt",
335 | "BlockStmt : LocalVarDeclStmt",
336 | "BlockStmt : Stmt",
337 | "LocalVarDeclStmt : LocalVarDecl ';'",
338 | "LocalVarDecl : Type VarDecls",
339 | "Stmt : Block",
340 | "Stmt : ';'",
341 | "Stmt : ExprStmt",
342 | "Stmt : BreakStmt",
343 | "Stmt : ReturnStmt",
344 | "Stmt : IfThenStmt",
345 | "Stmt : IfThenElseStmt",
346 | "Stmt : IfThenElseIfStmt",
347 | "Stmt : WhileStmt",
348 | "Stmt : ForStmt",
349 | "ExprStmt : StmtExpr ';'",
350 | "StmtExpr : Assignment",
351 | "StmtExpr : MethodCall",
352 | "IfThenStmt : IF '(' Expr ')' Block",
353 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
354 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
355 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
356 | "ElseIfSequence : ElseIfStmt",
357 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
358 | "ElseIfStmt : ELSE IfThenStmt",
359 | "WhileStmt : WHILE '(' Expr ')' Stmt",
360 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
361 | "ForInit : StmtExprList",
362 | "ForInit : LocalVarDecl",
363 | "ForInit :",
364 | "ExprOpt : Expr",
365 | "ExprOpt :",
366 | "ForUpdate : StmtExprList",
367 | "ForUpdate :",
368 | "StmtExprList : StmtExpr",
369 | "StmtExprList : StmtExprList ',' StmtExpr",
370 | "BreakStmt : BREAK ';'",
371 | "BreakStmt : BREAK IDENTIFIER ';'",
372 | "ReturnStmt : RETURN ExprOpt ';'",
373 | "Primary : Literal",
374 | "Primary : FieldAccess",
375 | "Primary : MethodCall",
376 | "Primary : '(' Expr ')'",
377 | "Literal : INTLIT",
378 | "Literal : DOUBLELIT",
379 | "Literal : BOOLLIT",
380 | "Literal : STRINGLIT",
381 | "Literal : NULLVAL",
382 | "ArgList : Expr",
383 | "ArgList : ArgList ',' Expr",
384 | "FieldAccess : Primary '.' IDENTIFIER",
385 | "ArgListOpt : ArgList",
386 | "ArgListOpt :",
387 | "MethodCall : Name '(' ArgListOpt ')'",
388 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
389 | "PostFixExpr : Primary",
390 | "PostFixExpr : Name",
391 | "UnaryExpr : '-' UnaryExpr",
392 | "UnaryExpr : '!' UnaryExpr",
393 | "UnaryExpr : PostFixExpr",
394 | "MulExpr : UnaryExpr",
395 | "MulExpr : MulExpr '*' UnaryExpr",
396 | "MulExpr : MulExpr '/' UnaryExpr",
397 | "MulExpr : MulExpr '%' UnaryExpr",
398 | "AddExpr : MulExpr",
399 | "AddExpr : AddExpr '+' MulExpr",
400 | "AddExpr : AddExpr '-' MulExpr",
401 | "RelOp : LESSTHANOREQUAL",
402 | "RelOp : GREATERTHANOREQUAL",
403 | "RelOp : '<'",
404 | "RelOp : '>'",
405 | "RelExpr : AddExpr",
406 | "RelExpr : RelExpr RelOp AddExpr",
407 | "EqExpr : RelExpr",
408 | "EqExpr : EqExpr ISEQUALTO RelExpr",
409 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
410 | "CondAndExpr : EqExpr",
411 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
412 | "CondOrExpr : CondAndExpr",
413 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
414 | "Expr : CondOrExpr",
415 | "Expr : Assignment",
416 | "Assignment : LeftHandSide AssignOp Expr",
417 | "LeftHandSide : Name",
418 | "LeftHandSide : FieldAccess",
419 | "AssignOp : '='",
420 | "AssignOp : INCREMENT",
421 | "AssignOp : DECREMENT",
422 |   ]
423 | 
424 | end
425 | 
426 | #####################################################################
427 | #####################################################################
428 | invocable all    # need to look up semantic actions by name
429 | 
430 | global yytext    # user variable to return contextual strings
431 | global yyval     # used to return semantic vals from action routines
432 | global yylval    # the 'lval' (result) I got from yylex()
433 | global yydebug   # (boolean) do I want debug output?
434 | global yynerrs   # (integer) number of errors so far
435 | global yyerrflag # (integer) was there an error?
436 | global yychar    # (integer) the current working character
437 | global action    # maps an integer to a semantic action procedure
438 | 
439 | global yylhs
440 | global yylen
441 | global yydefred
442 | global yydgoto
443 | global yysindex
444 | global yyrindex
445 | global yygindex
446 | global yytable
447 | global yycheck
448 | global yyname
449 | global yyrule
450 | 
451 | global statestk         # state stack
452 | global valstk           # value stack
453 | ################################################################
454 | # procedure: init_stacks : allocate and prepare stacks
455 | ################################################################
456 | procedure init_stacks()
457 |   local i
458 |   statestk := []
459 |   valstk := []
460 |   yyval  := 0 
461 |   yylval := 0 
462 |   action := list(1000, action_null)  # remove hard coded 1000 later
463 |   every i := 1 to 1000 do action[i] := proc("action_" || i)
464 | end
465 | 
466 | $define YYACCEPT return 0
467 | $define YYABORT return 1
468 | ################################################################
469 | # procedure: yyparse : parse input and execute indicated items
470 | ################################################################
471 | procedure yyparse()
472 |   local yyn        # next next thing to do
473 |   local yym        #
474 |   local yystate    # current parsing state from state table
475 |   local yys        # current token string
476 |   local doaction   # set to 1 if there need to execute action
477 |   local token      # current token
478 | 
479 |   if /yytable then init() 
480 |   init_stacks() 
481 |   yynerrs   := 0 
482 |   yyerrflag := 0 
483 |   yychar    := -1           # impossible char forces a read
484 |   yystate   := 0            # initial state
485 |   push(statestk, yystate)   # save it
486 | 
487 |   repeat { # until parsing is done, either correctly, or w/error
488 |     doaction := 1 
489 | 
490 |     ##### NEXT ACTION (from reduction table)
491 | 	yyn := yydefred[yystate+1]
492 | 
493 |     while yyn = 0 do {
494 | 
495 |       if yychar < 0 then {   # we want a char?
496 |         yychar := yylex()    # get next token
497 |         ##### ERROR CHECK ####
498 |         if yychar < 0 then { # it it didn't work/error
499 |           yychar := 0        # change it to default string (no -1!)
500 |           if \yydebug = 1 then yylexdebug(yystate, yychar) 
501 |           }
502 |         } # yychar < 0
503 | 	  
504 |       yyn := yysindex[yystate+1]  # get amount to shift by (shift index)
505 | 
506 |       if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
507 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
508 | 		
509 |         ##### NEXT STATE ####
510 |         yystate := yytable[yyn+1] # we are in a new state
511 |         push(statestk, yystate)   # save it
512 |         push(valstk, yylval)      # push our lval as the input for next rule
513 |         yychar := -1              # since we have 'eaten' a token, say we need another
514 |         if yyerrflag > 0 then     # have we recovered an error?
515 |            yyerrflag -:= 1        # give ourselves credit
516 |         doaction := 0             # but don't process yet
517 |         break                     # quit the yyn=0 loop
518 |         }
519 | 
520 |     yyn := yyrindex[yystate+1]    # reduce
521 | 
522 |     if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
523 |        (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
524 |       # e reduced!
525 |       yyn      := yytable[yyn+1] 
526 |       doaction := 1  # get ready to execute
527 |       break          # drop down to actions
528 |       }
529 |     else { #ERROR RECOVERY
530 |       if yyerrflag == 0 then {
531 |         (\yyerror | write)("syntax error") 
532 |         yynerrs +:= 1 
533 |       }
534 |       if yyerrflag < 3 then {     # low error count?
535 |         yyerrflag := 3 
536 |         repeat { #do until break
537 |           if *statestk < 1 then {  # check for under & overflow here
538 |             (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
539 |             return 1 
540 |           }
541 |           yyn := yysindex[statestk[1]] 
542 |           if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
543 |                     yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
544 |             yystate := yytable[yyn+1] 
545 |             push(statestk, yystate) 
546 |             push(valstk, yylval) 
547 |             doaction := 0 
548 |             break 
549 |           }
550 |           else {
551 |             if *statestk = 0 then { # check for under & overflow here
552 |               write("Stack underflow. aborting...") # capital 'S'
553 |               return 1 
554 |             }
555 |             pop(statestk) 
556 |             pop(valstk) 
557 |             }
558 |           }
559 |         }
560 |       else  # discard this token
561 |         {
562 |         if yychar = 0 then return 1  # yyabort
563 |         if \yydebug = 1 then {
564 |           yys := &null 
565 |           if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
566 |           if integer(yys) & yys = 0 then yys := "illegal-symbol" 
567 |           write("state ",  yystate, ", error recovery discards token ",
568 |                 yychar, " (", yys, ")") 
569 |           }
570 |         yychar := -1       # read another
571 |         }
572 |       } # end error recovery
573 |       yyn := yydefred[yystate+1] 
574 |     }# yyn = 0 loop
575 | 
576 |     if doaction = 0 then   # any reason not to proceed?
577 |       next                 # skip action
578 | 
579 |     yym := yylen[yyn+1]    # get count of terminals on rhs
580 |     yyval := valstk[yym]   # get current semantic value
581 |     if arv := action[yyn]() then return arv # execute the semantic action
582 | 
583 |     ##### Now let's reduce... ####
584 |     every 1 to yym do pop(statestk)# we just reduced yylen states
585 |     yystate := statestk[1]        # get new state
586 | 
587 |     every 1 to yym do pop(valstk) # corresponding value drop
588 |     yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
589 |     if yystate = 0 & yym = 0 then {
590 |                                   # done? 'rest' state and at first TERMINAL
591 |       yystate := YYFINAL          # explicitly say we're done
592 |       push(statestk, YYFINAL)     # and save it
593 |       push(valstk, yyval)         # also save the semantic value of parsing
594 |       if yychar < 0 then {        # we want another character?
595 |         yychar := yylex()         # get next character
596 |         if yychar < 0 then yychar := 0   #clean, if necessary
597 |       }
598 |       if yychar = 0 then break    # Good exit (if lex returns 0  -)
599 |                                   # quit the loop--all DONE
600 |     } # if yystate
601 |     else {                        #else not done yet
602 |       # get next state and push, for next yydefred[]
603 |       yyn := yygindex[yym+1]        # find out where to go
604 |       if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
605 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
606 |         yystate := yytable[yyn+1]   # get new state
607 |         }
608 |       else {
609 |         yystate := yydgoto[yym+1]   # else go to new defred
610 | 	     }
611 |       push(statestk, yystate)       # going again, so push state & val...
612 |       push(valstk, yyval)           # for next action
613 |       }
614 |     } # main loop
615 | 
616 |   return 0 # yyaccept!!
617 | end
618 | 
619 | ### end of procedure parse() ######################################
620 | 
621 | ### start semantic actions ########################################
622 | 
623 | procedure action_null()
624 |   #write("null action")
625 | end
626 | 
627 | procedure action_1()
628 | #line 8 "j0gram.y"
629 | 
630 |   yyval:=j0.node("ClassDecl",1000,valstk[2],valstk[1]);
631 |   j0.print(yyval);
632 |  
633 | end
634 | 
635 | procedure action_2()
636 | #line 12 "j0gram.y"
637 |  yyval:=j0.node("ClassBody",1010,valstk[2]); 
638 | end
639 | 
640 | procedure action_3()
641 | #line 13 "j0gram.y"
642 |  yyval:=j0.node("ClassBody",1011); 
643 | end
644 | 
645 | procedure action_5()
646 | #line 15 "j0gram.y"
647 | 
648 |   yyval:=j0.node("ClassBodyDecls",1020,valstk[2],valstk[1]); 
649 | end
650 | 
651 | procedure action_9()
652 | #line 18 "j0gram.y"
653 | 
654 |   yyval:=j0.node("FieldDecl",1030,valstk[3],valstk[2]); 
655 | end
656 | 
657 | procedure action_17()
658 | #line 23 "j0gram.y"
659 | 
660 |   yyval:=j0.node("QualifiedName",1040,valstk[3],valstk[1]);
661 | end
662 | 
663 | procedure action_19()
664 | #line 26 "j0gram.y"
665 | 
666 |   yyval:=j0.node("VarDecls",1050,valstk[3],valstk[1]); 
667 | end
668 | 
669 | procedure action_21()
670 | #line 28 "j0gram.y"
671 | 
672 |   yyval:=j0.node("VarDeclarator",1060,valstk[3]); 
673 | end
674 | 
675 | procedure action_24()
676 | #line 32 "j0gram.y"
677 | 
678 |   yyval:=j0.node("MethodDecl",1380,valstk[2],valstk[1]);
679 |  
680 | end
681 | 
682 | procedure action_25()
683 | #line 35 "j0gram.y"
684 | 
685 |   yyval:=j0.node("MethodHeader",1070,valstk[2],valstk[1]); 
686 | end
687 | 
688 | procedure action_26()
689 | #line 37 "j0gram.y"
690 | 
691 |   yyval:=j0.node("MethodDeclarator",1080,valstk[4],valstk[2]); 
692 | end
693 | 
694 | procedure action_30()
695 | #line 41 "j0gram.y"
696 | 
697 |   yyval:=j0.node("FormalParmList",1090,valstk[3],valstk[1]); 
698 | end
699 | 
700 | procedure action_31()
701 | #line 43 "j0gram.y"
702 | 
703 |   yyval:=j0.node("FormalParm",1100,valstk[2],valstk[1]);
704 |  
705 | end
706 | 
707 | procedure action_32()
708 | #line 47 "j0gram.y"
709 | 
710 |   yyval:=j0.node("ConstructorDecl",1110,valstk[2],valstk[1]); 
711 | end
712 | 
713 | procedure action_33()
714 | #line 50 "j0gram.y"
715 | yyval:=j0.node("Block",1200,valstk[2]);
716 | end
717 | 
718 | procedure action_37()
719 | #line 52 "j0gram.y"
720 | 
721 |   yyval:=j0.node("BlockStmts",1130,valstk[2],valstk[1]); 
722 | end
723 | 
724 | procedure action_41()
725 | #line 57 "j0gram.y"
726 | 
727 |   yyval:=j0.node("LocalVarDecl",1140,valstk[2],valstk[1]); 
728 | end
729 | 
730 | procedure action_55()
731 | #line 68 "j0gram.y"
732 | 
733 |   yyval:=j0.node("IfThenStmt",1150,valstk[3],valstk[1]); 
734 | end
735 | 
736 | procedure action_56()
737 | #line 70 "j0gram.y"
738 | 
739 |   yyval:=j0.node("IfThenElseStmt",1160,valstk[5],valstk[3],valstk[1]); 
740 | end
741 | 
742 | procedure action_57()
743 | #line 72 "j0gram.y"
744 | 
745 |   yyval:=j0.node("IfThenElseIfStmt",1170,valstk[4],valstk[2],valstk[1]); 
746 | end
747 | 
748 | procedure action_58()
749 | #line 74 "j0gram.y"
750 | 
751 |   yyval:=j0.node("IfThenElseIfStmt",1171,valstk[6],valstk[4],valstk[3],valstk[1]); 
752 | end
753 | 
754 | procedure action_60()
755 | #line 77 "j0gram.y"
756 | 
757 |   yyval:=j0.node("ElseIfSequence",1180,valstk[2],valstk[1]); 
758 | end
759 | 
760 | procedure action_61()
761 | #line 79 "j0gram.y"
762 | 
763 |   yyval:=j0.node("ElseIfStmt",1190,valstk[1]); 
764 | end
765 | 
766 | procedure action_62()
767 | #line 81 "j0gram.y"
768 | 
769 |   yyval:=j0.node("WhileStmt",1210,valstk[3],valstk[1]); 
770 | end
771 | 
772 | procedure action_63()
773 | #line 84 "j0gram.y"
774 | 
775 |   yyval:=j0.node("ForStmt",1220,valstk[7],valstk[5],valstk[3],valstk[1]); 
776 | end
777 | 
778 | procedure action_72()
779 | #line 90 "j0gram.y"
780 | 
781 |   yyval:=j0.node("StmtExprList",1230,valstk[3],valstk[1]); 
782 | end
783 | 
784 | procedure action_74()
785 | #line 93 "j0gram.y"
786 | 
787 |   yyval:=j0.node("BreakStmt",1240,valstk[2]); 
788 | end
789 | 
790 | procedure action_75()
791 | #line 95 "j0gram.y"
792 | 
793 |   yyval:=j0.node("ReturnStmt",1250,valstk[2]); 
794 | end
795 | 
796 | procedure action_79()
797 | #line 98 "j0gram.y"
798 | 
799 |   yyval:=valstk[2];
800 | end
801 | 
802 | procedure action_86()
803 | #line 102 "j0gram.y"
804 | 
805 |   yyval:=j0.node("ArgList",1270,valstk[3],valstk[1]); 
806 | end
807 | 
808 | procedure action_87()
809 | #line 104 "j0gram.y"
810 | 
811 |   yyval:=j0.node("FieldAccess",1280,valstk[3],valstk[1]); 
812 | end
813 | 
814 | procedure action_90()
815 | #line 108 "j0gram.y"
816 | 
817 |   yyval:=j0.node("MethodCall",1290,valstk[4],valstk[2]); 
818 | end
819 | 
820 | procedure action_91()
821 | #line 110 "j0gram.y"
822 | 
823 |     yyval:=j0.node("MethodCall",1291,valstk[6],valstk[4],valstk[2]); 
824 | end
825 | 
826 | procedure action_94()
827 | #line 115 "j0gram.y"
828 | 
829 |   yyval:=j0.node("UnaryExpr",1300,valstk[2],valstk[1]); 
830 | end
831 | 
832 | procedure action_95()
833 | #line 117 "j0gram.y"
834 | 
835 |   yyval:=j0.node("UnaryExpr",1301,valstk[2],valstk[1]); 
836 | end
837 | 
838 | procedure action_98()
839 | #line 121 "j0gram.y"
840 | 
841 |       yyval:=j0.node("MulExpr",1310,valstk[3],valstk[1]); 
842 | end
843 | 
844 | procedure action_99()
845 | #line 123 "j0gram.y"
846 | 
847 |       yyval:=j0.node("MulExpr",1311,valstk[3],valstk[1]); 
848 | end
849 | 
850 | procedure action_100()
851 | #line 125 "j0gram.y"
852 | 
853 |       yyval:=j0.node("MulExpr",1312,valstk[3],valstk[1]); 
854 | end
855 | 
856 | procedure action_102()
857 | #line 128 "j0gram.y"
858 | 
859 |       yyval:=j0.node("AddExpr",1320,valstk[3],valstk[1]); 
860 | end
861 | 
862 | procedure action_103()
863 | #line 130 "j0gram.y"
864 | 
865 |       yyval:=j0.node("AddExpr",1321,valstk[3],valstk[1]); 
866 | end
867 | 
868 | procedure action_109()
869 | #line 133 "j0gram.y"
870 | 
871 |   yyval:=j0.node("RelExpr",1330,valstk[3],valstk[2],valstk[1]); 
872 | end
873 | 
874 | procedure action_111()
875 | #line 137 "j0gram.y"
876 | 
877 |   yyval:=j0.node("EqExpr",1340,valstk[3],valstk[1]); 
878 | end
879 | 
880 | procedure action_112()
881 | #line 139 "j0gram.y"
882 | 
883 |   yyval:=j0.node("EqExpr",1341,valstk[3],valstk[1]); 
884 | end
885 | 
886 | procedure action_114()
887 | #line 141 "j0gram.y"
888 | 
889 |   yyval:=j0.node("CondAndExpr", 1350, valstk[3], valstk[1]); 
890 | end
891 | 
892 | procedure action_116()
893 | #line 143 "j0gram.y"
894 | 
895 |   yyval:=j0.node("CondOrExpr", 1360, valstk[3], valstk[1]); 
896 | end
897 | 
898 | procedure action_119()
899 | #line 147 "j0gram.y"
900 | 
901 | yyval:=j0.node("Assignment",1370, valstk[3], valstk[2], valstk[1]); 
902 | end
903 | 
904 | #line 909 "j0gram.icn"
905 | 


--------------------------------------------------------------------------------
/ch5/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.print($);
 11 |  } ;
 12 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 13 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 14 | ClassBodyDecls: ClassBodyDecl
 15 | | ClassBodyDecls ClassBodyDecl {
 16 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 17 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 18 | FieldDecl: Type VarDecls ';' {
 19 |   $=j0.node("FieldDecl",1030,$1,$2); };
 20 | Type: INT | DOUBLE | BOOL | STRING | Name ;
 21 | 
 22 | Name: IDENTIFIER | QualifiedName ;
 23 | QualifiedName: Name '.' IDENTIFIER {
 24 |   $=j0.node("QualifiedName",1040,$1,$3);};
 25 | 
 26 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 27 |   $=j0.node("VarDecls",1050,$1,$3); };
 28 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 29 |   $=j0.node("VarDeclarator",1060,$1); };
 30 | 
 31 | MethodReturnVal : Type | VOID ;
 32 | MethodDecl: MethodHeader Block {
 33 |   $=j0.node("MethodDecl",1380,$1,$2);
 34 |  };
 35 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 36 |   $=j0.node("MethodHeader",1070,$3,$4); };
 37 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 38 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 39 | 
 40 | FormalParmListOpt: FormalParmList | ;
 41 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 42 |   $=j0.node("FormalParmList",1090,$1,$3); };
 43 | FormalParm: Type VarDeclarator {
 44 |   $=j0.node("FormalParm",1100,$1,$2);
 45 |  };
 46 | 
 47 | ConstructorDecl: MethodDeclarator Block {
 48 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 49 | 
 50 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 51 | BlockStmtsOpt: BlockStmts | ;
 52 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 53 |   $=j0.node("BlockStmts",1130,$1,$2); };
 54 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 55 | 
 56 | LocalVarDeclStmt: LocalVarDecl ';' ;
 57 | LocalVarDecl: Type VarDecls {
 58 |   $=j0.node("LocalVarDecl",1140,$1,$2); };
 59 | 
 60 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 61 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 62 |       | WhileStmt | ForStmt ;
 63 | 
 64 | ExprStmt: StmtExpr ';' ;
 65 | 
 66 | StmtExpr: Assignment | MethodCall ;
 67 | 
 68 | IfThenStmt: IF '(' Expr ')' Block {
 69 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 70 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 71 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 72 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 73 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 74 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 75 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 76 | 
 77 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 78 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 79 | ElseIfStmt: ELSE IfThenStmt {
 80 |   $=j0.node("ElseIfStmt",1190,$2); };
 81 | WhileStmt: WHILE '(' Expr ')' Stmt {
 82 |   $=j0.node("WhileStmt",1210,$3,$5); };
 83 | 
 84 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 85 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 86 | ForInit: StmtExprList | LocalVarDecl | ;
 87 | ExprOpt: Expr |  ;
 88 | ForUpdate: StmtExprList | ;
 89 | 
 90 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 91 |   $=j0.node("StmtExprList",1230,$1,$3); };
 92 | 
 93 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
 94 |   $=j0.node("BreakStmt",1240,$2); };
 95 | ReturnStmt: RETURN ExprOpt ';' {
 96 |   $=j0.node("ReturnStmt",1250,$2); };
 97 | 
 98 | Primary:  Literal | FieldAccess | MethodCall | '(' Expr ')' {
 99 |   $=$2;};
100 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
101 | 
102 | ArgList: Expr | ArgList ',' Expr {
103 |   $=j0.node("ArgList",1270,$1,$3); };
104 | FieldAccess: Primary '.' IDENTIFIER {
105 |   $=j0.node("FieldAccess",1280,$1,$3); };
106 | 
107 | ArgListOpt:  ArgList | ;
108 | MethodCall: Name '(' ArgListOpt ')' {
109 |   $=j0.node("MethodCall",1290,$1,$3); }
110 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
111 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
112 | 	;
113 | 
114 | PostFixExpr: Primary | Name ;
115 | UnaryExpr:  '-' UnaryExpr {
116 |   $=j0.node("UnaryExpr",1300,$1,$2); }
117 |     | '!' UnaryExpr {
118 |   $=j0.node("UnaryExpr",1301,$1,$2); }
119 |     | PostFixExpr ;
120 | MulExpr: UnaryExpr
121 |     | MulExpr '*' UnaryExpr {
122 |       $=j0.node("MulExpr",1310,$1,$3); }
123 |     | MulExpr '/' UnaryExpr {
124 |       $=j0.node("MulExpr",1311,$1,$3); }
125 |     | MulExpr '%' UnaryExpr {
126 |       $=j0.node("MulExpr",1312,$1,$3); };
127 | AddExpr: MulExpr
128 |     | AddExpr '+' MulExpr {
129 |       $=j0.node("AddExpr",1320,$1,$3); }
130 |     | AddExpr '-' MulExpr {
131 |       $=j0.node("AddExpr",1321,$1,$3); };
132 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
133 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
134 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
135 | 
136 | EqExpr: RelExpr
137 |     | EqExpr ISEQUALTO RelExpr {
138 |   $=j0.node("EqExpr",1340,$1,$3); }
139 | | EqExpr NOTEQUALTO RelExpr {
140 |   $=j0.node("EqExpr",1341,$1,$3); };
141 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
142 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
143 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
144 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
145 | 
146 | Expr: CondOrExpr | Assignment ;
147 | Assignment: LeftHandSide AssignOp Expr {
148 | $=j0.node("Assignment",1370, $1, $2, $3); };
149 | LeftHandSide: Name | FieldAccess ;
150 | AssignOp: '=' | INCREMENT | DECREMENT ;
151 | 


--------------------------------------------------------------------------------
/ch5/j0gram_tab.icn:
--------------------------------------------------------------------------------
 1 | class Parser(BREAK, DOUBLE, ELSE, FOR, IF, INT, RETURN, VOID, WHILE, IDENTIFIER, CLASSNAME, CLASS, STRING, BOOL, INTLIT, DOUBLELIT, STRINGLIT, BOOLLIT, NULLVAL, LESSTHANOREQUAL, GREATERTHANOREQUAL, ISEQUALTO, NOTEQUALTO, LOGICALAND, LOGICALOR, INCREMENT, DECREMENT, PUBLIC, STATIC)
 2 | initially
 3 |    BREAK := 257
 4 |    DOUBLE := 258
 5 |    ELSE := 259
 6 |    FOR := 260
 7 |    IF := 261
 8 |    INT := 262
 9 |    RETURN := 263
10 |    VOID := 264
11 |    WHILE := 265
12 |    IDENTIFIER := 266
13 |    CLASSNAME := 267
14 |    CLASS := 268
15 |    STRING := 269
16 |    BOOL := 270
17 |    INTLIT := 271
18 |    DOUBLELIT := 272
19 |    STRINGLIT := 273
20 |    BOOLLIT := 274
21 |    NULLVAL := 275
22 |    LESSTHANOREQUAL := 276
23 |    GREATERTHANOREQUAL := 277
24 |    ISEQUALTO := 278
25 |    NOTEQUALTO := 279
26 |    LOGICALAND := 280
27 |    LOGICALOR := 281
28 |    INCREMENT := 282
29 |    DECREMENT := 283
30 |    PUBLIC := 284
31 |    STATIC := 285
32 | end
33 | 


--------------------------------------------------------------------------------
/ch5/javalex.icn:
--------------------------------------------------------------------------------
   1 | #
   2 | # uflex skeleton.
   3 | # do not edit by hand, this file is machine-generated
   4 | #
   5 | 
   6 | record edge(symbol, destinations)
   7 | record anode(label, rulenum, edges, epsilon, dot)
   8 | record automata(start, states, accepting)
   9 | 
  10 | global yychar, yytext, yyin, yyleng
  11 | 
  12 | #
  13 | # matchstrings reads from a specified input file and calls the simulate
  14 | # function repeatedly on smaller and smaller pieces of the input until
  15 | # it finds a match. It reports what parts of the input
  16 | # it could parse and what rule accepted the string.
  17 | #
  18 | 
  19 | global stringseq
  20 | 
  21 | procedure yyulex(aut)
  22 | local rulenum, readfrom, position, less, currstring, getln
  23 | local maxrule, maxleng
  24 | 
  25 | initial {
  26 |    if /yyin then yyin := &input
  27 |    readfrom := yyin
  28 | 
  29 |    stringseq := read(readfrom) || "\n"
  30 | 
  31 |    while getln := read(readfrom) do
  32 |       stringseq ||:= getln || "\n"
  33 | 
  34 |    close(readfrom)
  35 |    }
  36 | 
  37 |    repeat {
  38 |       if stringseq == "" then {
  39 |          yychar := -1
  40 |          fail
  41 |          }
  42 | 
  43 |       leng := 1
  44 |       while i := simulate(aut, stringseq[1:leng+1]) do {
  45 |          if i > 0 then {
  46 |             maxrule := i
  47 |             maxleng := leng
  48 |          }
  49 |          leng +:= 1
  50 |       }
  51 |       if \maxrule then {
  52 |          yytext := stringseq[1 : maxleng+1]; yyleng := maxleng
  53 |          stringseq := stringseq[maxleng+1:0]
  54 |          if yychar := (semantic_action)[maxrule] () then return yychar
  55 |       } else {
  56 |          writes(stringseq[1])
  57 |          stringseq := stringseq[2:0]
  58 |       }
  59 |    }
  60 | end
  61 | 
  62 | #
  63 | # simulate(automata, word) determines whether or not the word
  64 | # would be accepted by the given automata. It gets the possible
  65 | # destinations at each symbol of the string and then adds on wherever it
  66 | # could also get if we use any epsilon transitions out of those states.
  67 | # Then the list of accepting states is compared to the reachable set
  68 | # of states to determine if the word was accepted and by which rule.
  69 | #
  70 | procedure simulate(myaut, word)
  71 | local first, currstates, acceptcheck, currsymbol, build, rv
  72 |    currstates := list(0) # should be set()
  73 |    put(currstates, myaut.start) # insert(currstates, myaut.start)
  74 |    acceptcheck := copy(myaut.accepting)
  75 |    currsymbol := word
  76 |    while *currsymbol > 0 do {
  77 |       currstates := getdestinations(currstates, currsymbol)
  78 |       if *currstates = 0 then
  79 |          fail
  80 |       currsymbol := currsymbol[2:0]
  81 |       }
  82 |    while *acceptcheck > 0 do {
  83 |       value1 := pop(acceptcheck)
  84 |       check2 := copy(currstates)
  85 | 
  86 |       while *check2 > 0 do {
  87 |          value2 := pop(check2)
  88 | 
  89 |          if value1.label = value2.label then {
  90 |             if /rv | rv > value1.rulenum then
  91 |                rv := value1.rulenum
  92 |             }
  93 |          }
  94 |       }
  95 |    if \yydebug>0 then write("simulate() returns ", image(\rv)|0)
  96 |    return \rv | -(currstates[1].label)
  97 | end
  98 | 
  99 | #
 100 | # like |||:= except no duplicates. Destructive of L1 but not L2
 101 | #
 102 | procedure yyunionin(L1, L2)
 103 | t1 := table()
 104 |   every x := !L1 do {
 105 |      t1[x.label] := x
 106 |      }
 107 |   every x := !L2 do {
 108 |      if /t1[x.label] then {
 109 |         t1[x.label] := x
 110 |          put(L1, x)
 111 |          }
 112 |       }
 113 | end
 114 | procedure yyonein(L1, L2)
 115 |   if (!L1).label === L2[1].label then fail
 116 |   put(L1, L2[1])
 117 | end
 118 | 
 119 | #
 120 | # getdestinations uses the current set of states and
 121 | # simulates one step of automata computation on the given
 122 | # string and returns the resulting set of destinations
 123 | #
 124 | procedure getdestinations(currstates, currsymbol)
 125 | local result, current, buildresult, reached
 126 | 
 127 |    result := list(0)
 128 |    if *currstates ~= 0 then {
 129 | 
 130 |       buildresult := copy(currstates)
 131 |       while *buildresult > 0 do {
 132 |           reached := reach(pop(buildresult), currsymbol)
 133 |           if *reached>0 then {
 134 |              yyunionin(result, reached)
 135 |              }
 136 |           }
 137 |        }
 138 |     return result
 139 | end
 140 | 
 141 | #
 142 | # reach returns the list of states that can be reached
 143 | # on character symbol from the state state.
 144 | #
 145 | procedure reach(state, symbol)
 146 | local edgeset, answer, edgesymbol, bound1, bound2, curredge
 147 | 
 148 |    edgeset := copy(state.edges)
 149 |    answer := list(0)
 150 | 
 151 |    while *edgeset > 0 do {
 152 |       curredge := pop(edgeset)
 153 |       edgesymbol := copy(curredge.symbol)
 154 |       if type(edgesymbol) == "cset" then {
 155 |          if any(edgesymbol, symbol[1]) then {
 156 |             yyunionin(answer, curredge.destinations)
 157 |           }
 158 |       }
 159 |       else {
 160 |       if (edgesymbol[1] == symbol[1] ~== "[") |
 161 |          (edgesymbol == symbol[1] == "[") then # sometimes a [ is just a [
 162 |              yyunionin(answer, curredge.destinations)
 163 | 
 164 |       else if edgesymbol[1] == "\\" then {
 165 |          if (edgesymbol[2] == "n") & (symbol[1] == "\n") then
 166 |             yyunionin(answer, curredge.destinations)
 167 |          else if (edgesymbol[2] == "t") & (symbol[1] == "\t") then
 168 |             yyunionin(answer, curredge.destinations)
 169 |          else if (edgesymbol[2] == "r") & (symbol[1] == "\r") then
 170 |             yyunionin(answer, curredge.destinations)
 171 |          else if (edgesymbol[2] == "f") & (symbol[1] == "\f") then
 172 |             yyunionin(answer, curredge.destinations)
 173 |          else if (edgesymbol[2] == "\\") & (symbol[1] == "\\") then
 174 |             yyunionin(answer, curredge.destinations)
 175 |          # should handle all escapes here, and error on bogus ones
 176 |          else if edgesymbol[2] == symbol[1] then
 177 |             yyunionin(answer, curredge.destinations)
 178 |          } # escape
 179 | 
 180 | 
 181 |       }
 182 | 
 183 |       } # while edgeset > 0
 184 |    if *(state.dot)>0 then {
 185 |       yyunionin(answer, state.dot)
 186 |       }
 187 |    return answer
 188 | end
 189 | 
 190 | # "recset" == "regular expression cset"
 191 | procedure csetfromrecset(recset)
 192 | local rv, lastchar, origcset := recset
 193 |    if not (recset[1]=="[" & recset[-1]=="]") then
 194 |       stop("malformed recset ", image(recset))
 195 |    recset := recset[2:-1]
 196 | 
 197 |    if recset[1]=="^" then { # not in this cset, subtract from &cset
 198 |       rv := &cset -- csetfromrecset("["||recset[2:0]||"]")
 199 |       return rv
 200 |       }
 201 |    # positive cset construction
 202 |    rv := ''
 203 |    while *recset>0 do {
 204 | 
 205 |       if recset[1] == "-" & \lastchar & *recset>1 then
 206 |          genrangefrom := lastchar
 207 |       else {
 208 |          # did not trigger a new range. Process one char
 209 | 
 210 |          if recset[1] == "\\" then { # escape
 211 |             recset := recset[2:0]
 212 |             case recset[1] of {
 213 |                "n":  recset[1] := "\n"
 214 |                "t":  recset[1] := "\t"
 215 |                "r":  recset[1] := "\r"
 216 |                "v":  recset[1] := "\v"
 217 |                "-":  recset[1] := "\-"
 218 |                "f":  recset[1] := "\f"
 219 |                "'":  recset[1] := "\'"
 220 |                "\"":  recset[1] := "\""
 221 |                "\\": recset[1] := "\\"
 222 |                "0": {
 223 |                   if any('01234567', recset[2]) then {
 224 |                      if any('01234567', recset[3]) then {
 225 |                         o := char(recset[1]*64+recset[2]*8+recset[3])
 226 |                         recset := o || recset[4:0]
 227 |                      }
 228 |                      else stop("argh2 ", image(recset))
 229 |                      }
 230 |                   else recset[1] := "\0"
 231 |                }
 232 |                # should handle all escapes here, and error on bogus ones
 233 |                default: stop("unrecognized escape ", image(recset[1]))
 234 |                }
 235 |             }
 236 | 
 237 |          rv ++:= recset[1]
 238 | 
 239 |          if \genrangefrom then { #if we have a pending range
 240 |             ord1 := ord(genrangefrom)
 241 |              ord2 := ord(recset[1])
 242 |              while ord1 < ord2 do {
 243 |                rv ++:= char(ord1)
 244 |                ord1 +:= 1
 245 |                }
 246 |             genrangefrom := &null
 247 |             }
 248 |          lastchar := recset[1]
 249 |           }
 250 |        recset := recset[2:0]
 251 |        }
 252 | 
 253 |    return rv
 254 | end
 255 | 
 256 | procedure printautomaton(a)
 257 |    write("Automaton:")
 258 |    write("start: ", image(a.start.label),
 259 |          " for rulenum ", image(a.start.rulenum))
 260 |    write("states:")
 261 |    every printstate(!a.states)
 262 |    writes("accepting: ")
 263 |    every writes((!a.accepting).label, " ")
 264 |    write()
 265 | end
 266 | 
 267 | procedure printstate(state)
 268 |    write("state ", state.label, " is for rule #", state.rulenum)
 269 |    if (*state.edges)>0 then {
 270 |       writes("\tedges: "); every printedge(!state.edges); write()
 271 |       }
 272 |    if *state.epsilon>0 then {
 273 |       writes("\tepsilon: ")
 274 |       every writes((!state.epsilon).label, " "); write()
 275 |       }
 276 |    if (*state.dot)>0 then {
 277 |       writes("\tdot: ")
 278 |       every writes((!state.dot).label, " "); write()
 279 |       }
 280 | end
 281 | 
 282 | procedure printedge(edge)
 283 |    writes(image(edge.symbol), " -> ")
 284 |    every writes((!edge.destinations).label)
 285 |    writes("; ")
 286 | end
 287 | 
 288 | procedure printstates(states)
 289 | local statecopy, current
 290 | 
 291 |    write("printstates size ", *states, " in entity ", image(states))
 292 |    statecopy := copy(states)
 293 | 
 294 |    while *statecopy > 1 do {
 295 |       current := pop(statecopy)
 296 |       write(current.label, ", ")
 297 |       }
 298 | 
 299 |    if *statecopy > 0 then {
 300 |       current := pop(statecopy)
 301 |       write(current.label)
 302 |       }
 303 |     else write("state list is empty")
 304 | end
 305 | global semantic_action
 306 | 
 307 | procedure yylex()
 308 | static myautomata
 309 | local currstate, state2, tempedge
 310 | 
 311 |  initial {
 312 |    myautomata := automata()
 313 | 
 314 |    myautomata.states := []
 315 |    myautomata.accepting := []
 316 |    put(myautomata.states, currstate := anode(1, 0, [], [], []))
 317 |    myautomata.start := currstate
 318 | 
 319 |    put(myautomata.states, currstate := anode(2, 3, [], [], []))
 320 |    put(myautomata.accepting, currstate)
 321 | 
 322 |    put(myautomata.states, currstate := anode(3, 4, [], [], []))
 323 |    put(myautomata.accepting, currstate)
 324 | 
 325 |    put(myautomata.states, currstate := anode(4, 0, [], [], []))
 326 | 
 327 |    put(myautomata.states, currstate := anode(5, 0, [], [], []))
 328 | 
 329 |    put(myautomata.states, currstate := anode(6, 0, [], [], []))
 330 | 
 331 |    put(myautomata.states, currstate := anode(7, 0, [], [], []))
 332 | 
 333 |    put(myautomata.states, currstate := anode(8, 0, [], [], []))
 334 | 
 335 |    put(myautomata.states, currstate := anode(9, 0, [], [], []))
 336 | 
 337 |    put(myautomata.states, currstate := anode(10, 0, [], [], []))
 338 | 
 339 |    put(myautomata.states, currstate := anode(11, 0, [], [], []))
 340 | 
 341 |    put(myautomata.states, currstate := anode(12, 0, [], [], []))
 342 | 
 343 |    put(myautomata.states, currstate := anode(13, 0, [], [], []))
 344 | 
 345 |    put(myautomata.states, currstate := anode(14, 0, [], [], []))
 346 | 
 347 |    put(myautomata.states, currstate := anode(15, 0, [], [], []))
 348 | 
 349 |    put(myautomata.states, currstate := anode(16, 0, [], [], []))
 350 | 
 351 |    put(myautomata.states, currstate := anode(17, 22, [], [], []))
 352 |    put(myautomata.accepting, currstate)
 353 | 
 354 |    put(myautomata.states, currstate := anode(18, 23, [], [], []))
 355 |    put(myautomata.accepting, currstate)
 356 | 
 357 |    put(myautomata.states, currstate := anode(19, 24, [], [], []))
 358 |    put(myautomata.accepting, currstate)
 359 | 
 360 |    put(myautomata.states, currstate := anode(20, 25, [], [], []))
 361 |    put(myautomata.accepting, currstate)
 362 | 
 363 |    put(myautomata.states, currstate := anode(21, 26, [], [], []))
 364 |    put(myautomata.accepting, currstate)
 365 | 
 366 |    put(myautomata.states, currstate := anode(22, 27, [], [], []))
 367 |    put(myautomata.accepting, currstate)
 368 | 
 369 |    put(myautomata.states, currstate := anode(23, 28, [], [], []))
 370 |    put(myautomata.accepting, currstate)
 371 | 
 372 |    put(myautomata.states, currstate := anode(24, 29, [], [], []))
 373 |    put(myautomata.accepting, currstate)
 374 | 
 375 |    put(myautomata.states, currstate := anode(25, 31, [], [], []))
 376 |    put(myautomata.accepting, currstate)
 377 | 
 378 |    put(myautomata.states, currstate := anode(26, 32, [], [], []))
 379 |    put(myautomata.accepting, currstate)
 380 | 
 381 |    put(myautomata.states, currstate := anode(27, 33, [], [], []))
 382 |    put(myautomata.accepting, currstate)
 383 | 
 384 |    put(myautomata.states, currstate := anode(28, 36, [], [], []))
 385 |    put(myautomata.accepting, currstate)
 386 | 
 387 |    put(myautomata.states, currstate := anode(29, 38, [], [], []))
 388 |    put(myautomata.accepting, currstate)
 389 | 
 390 |    put(myautomata.states, currstate := anode(30, 30, [], [], []))
 391 |    put(myautomata.accepting, currstate)
 392 | 
 393 |    put(myautomata.states, currstate := anode(31, 0, [], [], []))
 394 | 
 395 |    put(myautomata.states, currstate := anode(32, 0, [], [], []))
 396 | 
 397 |    put(myautomata.states, currstate := anode(33, 34, [], [], []))
 398 |    put(myautomata.accepting, currstate)
 399 | 
 400 |    put(myautomata.states, currstate := anode(34, 35, [], [], []))
 401 |    put(myautomata.accepting, currstate)
 402 | 
 403 |    put(myautomata.states, currstate := anode(35, 44, [], [], []))
 404 |    put(myautomata.accepting, currstate)
 405 | 
 406 |    put(myautomata.states, currstate := anode(36, 47, [], [], []))
 407 |    put(myautomata.accepting, currstate)
 408 | 
 409 |    put(myautomata.states, currstate := anode(37, 49, [], [], []))
 410 |    put(myautomata.accepting, currstate)
 411 | 
 412 |    put(myautomata.states, currstate := anode(38, 48, [], [], []))
 413 |    put(myautomata.accepting, currstate)
 414 | 
 415 |    put(myautomata.states, currstate := anode(39, 50, [], [], []))
 416 |    put(myautomata.accepting, currstate)
 417 | 
 418 |    put(myautomata.states, currstate := anode(40, 0, [], [], []))
 419 | 
 420 |    put(myautomata.states, currstate := anode(41, 54, [], [], []))
 421 |    put(myautomata.accepting, currstate)
 422 | 
 423 |    put(myautomata.states, currstate := anode(42, 0, [], [], []))
 424 | 
 425 |    put(myautomata.states, currstate := anode(43, 0, [], [], []))
 426 | 
 427 |    put(myautomata.states, currstate := anode(44, 0, [], [], []))
 428 | 
 429 |    put(myautomata.states, currstate := anode(45, 0, [], [], []))
 430 | 
 431 |    put(myautomata.states, currstate := anode(46, 0, [], [], []))
 432 | 
 433 |    put(myautomata.states, currstate := anode(47, 0, [], [], []))
 434 | 
 435 |    put(myautomata.states, currstate := anode(48, 0, [], [], []))
 436 | 
 437 |    put(myautomata.states, currstate := anode(49, 0, [], [], []))
 438 | 
 439 |    put(myautomata.states, currstate := anode(50, 0, [], [], []))
 440 | 
 441 |    put(myautomata.states, currstate := anode(51, 0, [], [], []))
 442 | 
 443 |    put(myautomata.states, currstate := anode(52, 0, [], [], []))
 444 | 
 445 |    put(myautomata.states, currstate := anode(53, 10, [], [], []))
 446 |    put(myautomata.accepting, currstate)
 447 | 
 448 |    put(myautomata.states, currstate := anode(54, 0, [], [], []))
 449 | 
 450 |    put(myautomata.states, currstate := anode(55, 0, [], [], []))
 451 | 
 452 |    put(myautomata.states, currstate := anode(56, 0, [], [], []))
 453 | 
 454 |    put(myautomata.states, currstate := anode(57, 0, [], [], []))
 455 | 
 456 |    put(myautomata.states, currstate := anode(58, 0, [], [], []))
 457 | 
 458 |    put(myautomata.states, currstate := anode(59, 0, [], [], []))
 459 | 
 460 |    put(myautomata.states, currstate := anode(60, 37, [], [], []))
 461 |    put(myautomata.accepting, currstate)
 462 | 
 463 |    put(myautomata.states, currstate := anode(61, 39, [], [], []))
 464 |    put(myautomata.accepting, currstate)
 465 | 
 466 |    put(myautomata.states, currstate := anode(62, 41, [], [], []))
 467 |    put(myautomata.accepting, currstate)
 468 | 
 469 |    put(myautomata.states, currstate := anode(63, 42, [], [], []))
 470 |    put(myautomata.accepting, currstate)
 471 | 
 472 |    put(myautomata.states, currstate := anode(64, 43, [], [], []))
 473 |    put(myautomata.accepting, currstate)
 474 | 
 475 |    put(myautomata.states, currstate := anode(65, 45, [], [], []))
 476 |    put(myautomata.accepting, currstate)
 477 | 
 478 |    put(myautomata.states, currstate := anode(66, 46, [], [], []))
 479 |    put(myautomata.accepting, currstate)
 480 | 
 481 |    put(myautomata.states, currstate := anode(67, 40, [], [], []))
 482 |    put(myautomata.accepting, currstate)
 483 | 
 484 |    put(myautomata.states, currstate := anode(68, 49, [], [], []))
 485 |    put(myautomata.accepting, currstate)
 486 | 
 487 |    put(myautomata.states, currstate := anode(69, 0, [], [], []))
 488 | 
 489 |    put(myautomata.states, currstate := anode(70, 0, [], [], []))
 490 | 
 491 |    put(myautomata.states, currstate := anode(71, 0, [], [], []))
 492 | 
 493 |    put(myautomata.states, currstate := anode(72, 0, [], [], []))
 494 | 
 495 |    put(myautomata.states, currstate := anode(73, 0, [], [], []))
 496 | 
 497 |    put(myautomata.states, currstate := anode(74, 0, [], [], []))
 498 | 
 499 |    put(myautomata.states, currstate := anode(75, 53, [], [], []))
 500 |    put(myautomata.accepting, currstate)
 501 | 
 502 |    put(myautomata.states, currstate := anode(76, 9, [], [], []))
 503 |    put(myautomata.accepting, currstate)
 504 | 
 505 |    put(myautomata.states, currstate := anode(77, 0, [], [], []))
 506 | 
 507 |    put(myautomata.states, currstate := anode(78, 0, [], [], []))
 508 | 
 509 |    put(myautomata.states, currstate := anode(79, 0, [], [], []))
 510 | 
 511 |    put(myautomata.states, currstate := anode(80, 0, [], [], []))
 512 | 
 513 |    put(myautomata.states, currstate := anode(81, 0, [], [], []))
 514 | 
 515 |    put(myautomata.states, currstate := anode(82, 0, [], [], []))
 516 | 
 517 |    put(myautomata.states, currstate := anode(83, 0, [], [], []))
 518 | 
 519 |    put(myautomata.states, currstate := anode(84, 0, [], [], []))
 520 | 
 521 |    put(myautomata.states, currstate := anode(85, 0, [], [], []))
 522 | 
 523 |    put(myautomata.states, currstate := anode(86, 0, [], [], []))
 524 | 
 525 |    put(myautomata.states, currstate := anode(87, 11, [], [], []))
 526 |    put(myautomata.accepting, currstate)
 527 | 
 528 |    put(myautomata.states, currstate := anode(88, 0, [], [], []))
 529 | 
 530 |    put(myautomata.states, currstate := anode(89, 0, [], [], []))
 531 | 
 532 |    put(myautomata.states, currstate := anode(90, 0, [], [], []))
 533 | 
 534 |    put(myautomata.states, currstate := anode(91, 0, [], [], []))
 535 | 
 536 |    put(myautomata.states, currstate := anode(92, 0, [], [], []))
 537 | 
 538 |    put(myautomata.states, currstate := anode(93, 0, [], [], []))
 539 | 
 540 |    put(myautomata.states, currstate := anode(94, 2, [], [], []))
 541 |    put(myautomata.accepting, currstate)
 542 | 
 543 |    put(myautomata.states, currstate := anode(95, 0, [], [], []))
 544 | 
 545 |    put(myautomata.states, currstate := anode(96, 0, [], [], []))
 546 | 
 547 |    put(myautomata.states, currstate := anode(97, 0, [], [], []))
 548 | 
 549 |    put(myautomata.states, currstate := anode(98, 51, [], [], []))
 550 |    put(myautomata.accepting, currstate)
 551 | 
 552 |    put(myautomata.states, currstate := anode(99, 0, [], [], []))
 553 | 
 554 |    put(myautomata.states, currstate := anode(100, 52, [], [], []))
 555 |    put(myautomata.accepting, currstate)
 556 | 
 557 |    put(myautomata.states, currstate := anode(101, 0, [], [], []))
 558 | 
 559 |    put(myautomata.states, currstate := anode(102, 0, [], [], []))
 560 | 
 561 |    put(myautomata.states, currstate := anode(103, 0, [], [], []))
 562 | 
 563 |    put(myautomata.states, currstate := anode(104, 12, [], [], []))
 564 |    put(myautomata.accepting, currstate)
 565 | 
 566 |    put(myautomata.states, currstate := anode(105, 17, [], [], []))
 567 |    put(myautomata.accepting, currstate)
 568 | 
 569 |    put(myautomata.states, currstate := anode(106, 0, [], [], []))
 570 | 
 571 |    put(myautomata.states, currstate := anode(107, 0, [], [], []))
 572 | 
 573 |    put(myautomata.states, currstate := anode(108, 18, [], [], []))
 574 |    put(myautomata.accepting, currstate)
 575 | 
 576 |    put(myautomata.states, currstate := anode(109, 19, [], [], []))
 577 |    put(myautomata.accepting, currstate)
 578 | 
 579 |    put(myautomata.states, currstate := anode(110, 0, [], [], []))
 580 | 
 581 |    put(myautomata.states, currstate := anode(111, 0, [], [], []))
 582 | 
 583 |    put(myautomata.states, currstate := anode(112, 7, [], [], []))
 584 |    put(myautomata.accepting, currstate)
 585 | 
 586 |    put(myautomata.states, currstate := anode(113, 0, [], [], []))
 587 | 
 588 |    put(myautomata.states, currstate := anode(114, 0, [], [], []))
 589 | 
 590 |    put(myautomata.states, currstate := anode(115, 0, [], [], []))
 591 | 
 592 |    put(myautomata.states, currstate := anode(116, 0, [], [], []))
 593 | 
 594 |    put(myautomata.states, currstate := anode(117, 1, [], [], []))
 595 |    put(myautomata.accepting, currstate)
 596 | 
 597 |    put(myautomata.states, currstate := anode(118, 8, [], [], []))
 598 |    put(myautomata.accepting, currstate)
 599 | 
 600 |    put(myautomata.states, currstate := anode(119, 0, [], [], []))
 601 | 
 602 |    put(myautomata.states, currstate := anode(120, 0, [], [], []))
 603 | 
 604 |    put(myautomata.states, currstate := anode(121, 5, [], [], []))
 605 |    put(myautomata.accepting, currstate)
 606 | 
 607 |    put(myautomata.states, currstate := anode(122, 0, [], [], []))
 608 | 
 609 |    put(myautomata.states, currstate := anode(123, 20, [], [], []))
 610 |    put(myautomata.accepting, currstate)
 611 | 
 612 |    put(myautomata.states, currstate := anode(124, 21, [], [], []))
 613 |    put(myautomata.accepting, currstate)
 614 | 
 615 |    put(myautomata.states, currstate := anode(125, 0, [], [], []))
 616 | 
 617 |    put(myautomata.states, currstate := anode(126, 0, [], [], []))
 618 | 
 619 |    put(myautomata.states, currstate := anode(127, 13, [], [], []))
 620 |    put(myautomata.accepting, currstate)
 621 | 
 622 |    put(myautomata.states, currstate := anode(128, 14, [], [], []))
 623 |    put(myautomata.accepting, currstate)
 624 | 
 625 |    put(myautomata.states, currstate := anode(129, 6, [], [], []))
 626 |    put(myautomata.accepting, currstate)
 627 | 
 628 |    put(myautomata.states, currstate := anode(130, 16, [], [], []))
 629 |    put(myautomata.accepting, currstate)
 630 | 
 631 |    put(myautomata.states, currstate := anode(131, 15, [], [], []))
 632 |    put(myautomata.accepting, currstate)
 633 | 
 634 |    currstate := pop(myautomata.states)
 635 |    put(myautomata.states, currstate)
 636 | 
 637 |    while currstate.label ~= 1 do {
 638 |       currstate := pop(myautomata.states)
 639 |       put(myautomata.states, currstate)
 640 |       }
 641 |    state2 := currstate
 642 | 
 643 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
 644 |    currstate := pop(myautomata.states)
 645 |    put(myautomata.states, currstate)
 646 | 
 647 |    while currstate.label ~= 2 do {
 648 |       currstate := pop(myautomata.states)
 649 |       put(myautomata.states, currstate)
 650 |       }
 651 |    put(tempedge.destinations, currstate)
 652 | 
 653 |    put(state2.edges, tempedge)
 654 |    tempedge := edge("\n"
 655 | , [])
 656 |    currstate := pop(myautomata.states)
 657 |    put(myautomata.states, currstate)
 658 | 
 659 |    while currstate.label ~= 3 do {
 660 |       currstate := pop(myautomata.states)
 661 |       put(myautomata.states, currstate)
 662 |       }
 663 |    put(tempedge.destinations, currstate)
 664 | 
 665 |    put(state2.edges, tempedge)
 666 |    tempedge := edge("f", [])
 667 |    currstate := pop(myautomata.states)
 668 |    put(myautomata.states, currstate)
 669 | 
 670 |    while currstate.label ~= 4 do {
 671 |       currstate := pop(myautomata.states)
 672 |       put(myautomata.states, currstate)
 673 |       }
 674 |    put(tempedge.destinations, currstate)
 675 | 
 676 |    put(state2.edges, tempedge)
 677 |    tempedge := edge("p", [])
 678 |    currstate := pop(myautomata.states)
 679 |    put(myautomata.states, currstate)
 680 | 
 681 |    while currstate.label ~= 5 do {
 682 |       currstate := pop(myautomata.states)
 683 |       put(myautomata.states, currstate)
 684 |       }
 685 |    put(tempedge.destinations, currstate)
 686 | 
 687 |    put(state2.edges, tempedge)
 688 |    tempedge := edge("n", [])
 689 |    currstate := pop(myautomata.states)
 690 |    put(myautomata.states, currstate)
 691 | 
 692 |    while currstate.label ~= 6 do {
 693 |       currstate := pop(myautomata.states)
 694 |       put(myautomata.states, currstate)
 695 |       }
 696 |    put(tempedge.destinations, currstate)
 697 | 
 698 |    put(state2.edges, tempedge)
 699 |    tempedge := edge("t", [])
 700 |    currstate := pop(myautomata.states)
 701 |    put(myautomata.states, currstate)
 702 | 
 703 |    while currstate.label ~= 7 do {
 704 |       currstate := pop(myautomata.states)
 705 |       put(myautomata.states, currstate)
 706 |       }
 707 |    put(tempedge.destinations, currstate)
 708 | 
 709 |    put(state2.edges, tempedge)
 710 |    tempedge := edge("r", [])
 711 |    currstate := pop(myautomata.states)
 712 |    put(myautomata.states, currstate)
 713 | 
 714 |    while currstate.label ~= 8 do {
 715 |       currstate := pop(myautomata.states)
 716 |       put(myautomata.states, currstate)
 717 |       }
 718 |    put(tempedge.destinations, currstate)
 719 | 
 720 |    put(state2.edges, tempedge)
 721 |    tempedge := edge("b", [])
 722 |    currstate := pop(myautomata.states)
 723 |    put(myautomata.states, currstate)
 724 | 
 725 |    while currstate.label ~= 9 do {
 726 |       currstate := pop(myautomata.states)
 727 |       put(myautomata.states, currstate)
 728 |       }
 729 |    put(tempedge.destinations, currstate)
 730 | 
 731 |    put(state2.edges, tempedge)
 732 |    tempedge := edge("v", [])
 733 |    currstate := pop(myautomata.states)
 734 |    put(myautomata.states, currstate)
 735 | 
 736 |    while currstate.label ~= 10 do {
 737 |       currstate := pop(myautomata.states)
 738 |       put(myautomata.states, currstate)
 739 |       }
 740 |    put(tempedge.destinations, currstate)
 741 | 
 742 |    put(state2.edges, tempedge)
 743 |    tempedge := edge("d", [])
 744 |    currstate := pop(myautomata.states)
 745 |    put(myautomata.states, currstate)
 746 | 
 747 |    while currstate.label ~= 11 do {
 748 |       currstate := pop(myautomata.states)
 749 |       put(myautomata.states, currstate)
 750 |       }
 751 |    put(tempedge.destinations, currstate)
 752 | 
 753 |    put(state2.edges, tempedge)
 754 |    tempedge := edge("w", [])
 755 |    currstate := pop(myautomata.states)
 756 |    put(myautomata.states, currstate)
 757 | 
 758 |    while currstate.label ~= 12 do {
 759 |       currstate := pop(myautomata.states)
 760 |       put(myautomata.states, currstate)
 761 |       }
 762 |    put(tempedge.destinations, currstate)
 763 | 
 764 |    put(state2.edges, tempedge)
 765 |    tempedge := edge("i", [])
 766 |    currstate := pop(myautomata.states)
 767 |    put(myautomata.states, currstate)
 768 | 
 769 |    while currstate.label ~= 13 do {
 770 |       currstate := pop(myautomata.states)
 771 |       put(myautomata.states, currstate)
 772 |       }
 773 |    put(tempedge.destinations, currstate)
 774 | 
 775 |    put(state2.edges, tempedge)
 776 |    tempedge := edge("e", [])
 777 |    currstate := pop(myautomata.states)
 778 |    put(myautomata.states, currstate)
 779 | 
 780 |    while currstate.label ~= 14 do {
 781 |       currstate := pop(myautomata.states)
 782 |       put(myautomata.states, currstate)
 783 |       }
 784 |    put(tempedge.destinations, currstate)
 785 | 
 786 |    put(state2.edges, tempedge)
 787 |    tempedge := edge("c", [])
 788 |    currstate := pop(myautomata.states)
 789 |    put(myautomata.states, currstate)
 790 | 
 791 |    while currstate.label ~= 15 do {
 792 |       currstate := pop(myautomata.states)
 793 |       put(myautomata.states, currstate)
 794 |       }
 795 |    put(tempedge.destinations, currstate)
 796 | 
 797 |    put(state2.edges, tempedge)
 798 |    tempedge := edge("s", [])
 799 |    currstate := pop(myautomata.states)
 800 |    put(myautomata.states, currstate)
 801 | 
 802 |    while currstate.label ~= 16 do {
 803 |       currstate := pop(myautomata.states)
 804 |       put(myautomata.states, currstate)
 805 |       }
 806 |    put(tempedge.destinations, currstate)
 807 | 
 808 |    put(state2.edges, tempedge)
 809 |    tempedge := edge("(", [])
 810 |    currstate := pop(myautomata.states)
 811 |    put(myautomata.states, currstate)
 812 | 
 813 |    while currstate.label ~= 17 do {
 814 |       currstate := pop(myautomata.states)
 815 |       put(myautomata.states, currstate)
 816 |       }
 817 |    put(tempedge.destinations, currstate)
 818 | 
 819 |    put(state2.edges, tempedge)
 820 |    tempedge := edge(")", [])
 821 |    currstate := pop(myautomata.states)
 822 |    put(myautomata.states, currstate)
 823 | 
 824 |    while currstate.label ~= 18 do {
 825 |       currstate := pop(myautomata.states)
 826 |       put(myautomata.states, currstate)
 827 |       }
 828 |    put(tempedge.destinations, currstate)
 829 | 
 830 |    put(state2.edges, tempedge)
 831 |    tempedge := edge("[", [])
 832 |    currstate := pop(myautomata.states)
 833 |    put(myautomata.states, currstate)
 834 | 
 835 |    while currstate.label ~= 19 do {
 836 |       currstate := pop(myautomata.states)
 837 |       put(myautomata.states, currstate)
 838 |       }
 839 |    put(tempedge.destinations, currstate)
 840 | 
 841 |    put(state2.edges, tempedge)
 842 |    tempedge := edge("]", [])
 843 |    currstate := pop(myautomata.states)
 844 |    put(myautomata.states, currstate)
 845 | 
 846 |    while currstate.label ~= 20 do {
 847 |       currstate := pop(myautomata.states)
 848 |       put(myautomata.states, currstate)
 849 |       }
 850 |    put(tempedge.destinations, currstate)
 851 | 
 852 |    put(state2.edges, tempedge)
 853 |    tempedge := edge("{", [])
 854 |    currstate := pop(myautomata.states)
 855 |    put(myautomata.states, currstate)
 856 | 
 857 |    while currstate.label ~= 21 do {
 858 |       currstate := pop(myautomata.states)
 859 |       put(myautomata.states, currstate)
 860 |       }
 861 |    put(tempedge.destinations, currstate)
 862 | 
 863 |    put(state2.edges, tempedge)
 864 |    tempedge := edge("}", [])
 865 |    currstate := pop(myautomata.states)
 866 |    put(myautomata.states, currstate)
 867 | 
 868 |    while currstate.label ~= 22 do {
 869 |       currstate := pop(myautomata.states)
 870 |       put(myautomata.states, currstate)
 871 |       }
 872 |    put(tempedge.destinations, currstate)
 873 | 
 874 |    put(state2.edges, tempedge)
 875 |    tempedge := edge(";", [])
 876 |    currstate := pop(myautomata.states)
 877 |    put(myautomata.states, currstate)
 878 | 
 879 |    while currstate.label ~= 23 do {
 880 |       currstate := pop(myautomata.states)
 881 |       put(myautomata.states, currstate)
 882 |       }
 883 |    put(tempedge.destinations, currstate)
 884 | 
 885 |    put(state2.edges, tempedge)
 886 |    tempedge := edge(":", [])
 887 |    currstate := pop(myautomata.states)
 888 |    put(myautomata.states, currstate)
 889 | 
 890 |    while currstate.label ~= 24 do {
 891 |       currstate := pop(myautomata.states)
 892 |       put(myautomata.states, currstate)
 893 |       }
 894 |    put(tempedge.destinations, currstate)
 895 | 
 896 |    put(state2.edges, tempedge)
 897 |    tempedge := edge("*", [])
 898 |    currstate := pop(myautomata.states)
 899 |    put(myautomata.states, currstate)
 900 | 
 901 |    while currstate.label ~= 25 do {
 902 |       currstate := pop(myautomata.states)
 903 |       put(myautomata.states, currstate)
 904 |       }
 905 |    put(tempedge.destinations, currstate)
 906 | 
 907 |    put(state2.edges, tempedge)
 908 |    tempedge := edge("/", [])
 909 |    currstate := pop(myautomata.states)
 910 |    put(myautomata.states, currstate)
 911 | 
 912 |    while currstate.label ~= 26 do {
 913 |       currstate := pop(myautomata.states)
 914 |       put(myautomata.states, currstate)
 915 |       }
 916 |    put(tempedge.destinations, currstate)
 917 | 
 918 |    put(state2.edges, tempedge)
 919 |    tempedge := edge("%", [])
 920 |    currstate := pop(myautomata.states)
 921 |    put(myautomata.states, currstate)
 922 | 
 923 |    while currstate.label ~= 27 do {
 924 |       currstate := pop(myautomata.states)
 925 |       put(myautomata.states, currstate)
 926 |       }
 927 |    put(tempedge.destinations, currstate)
 928 | 
 929 |    put(state2.edges, tempedge)
 930 |    tempedge := edge("<", [])
 931 |    currstate := pop(myautomata.states)
 932 |    put(myautomata.states, currstate)
 933 | 
 934 |    while currstate.label ~= 28 do {
 935 |       currstate := pop(myautomata.states)
 936 |       put(myautomata.states, currstate)
 937 |       }
 938 |    put(tempedge.destinations, currstate)
 939 | 
 940 |    put(state2.edges, tempedge)
 941 |    tempedge := edge(">", [])
 942 |    currstate := pop(myautomata.states)
 943 |    put(myautomata.states, currstate)
 944 | 
 945 |    while currstate.label ~= 29 do {
 946 |       currstate := pop(myautomata.states)
 947 |       put(myautomata.states, currstate)
 948 |       }
 949 |    put(tempedge.destinations, currstate)
 950 | 
 951 |    put(state2.edges, tempedge)
 952 |    tempedge := edge("!", [])
 953 |    currstate := pop(myautomata.states)
 954 |    put(myautomata.states, currstate)
 955 | 
 956 |    while currstate.label ~= 30 do {
 957 |       currstate := pop(myautomata.states)
 958 |       put(myautomata.states, currstate)
 959 |       }
 960 |    put(tempedge.destinations, currstate)
 961 | 
 962 |    put(state2.edges, tempedge)
 963 |    tempedge := edge("&", [])
 964 |    currstate := pop(myautomata.states)
 965 |    put(myautomata.states, currstate)
 966 | 
 967 |    while currstate.label ~= 31 do {
 968 |       currstate := pop(myautomata.states)
 969 |       put(myautomata.states, currstate)
 970 |       }
 971 |    put(tempedge.destinations, currstate)
 972 | 
 973 |    put(state2.edges, tempedge)
 974 |    tempedge := edge("|", [])
 975 |    currstate := pop(myautomata.states)
 976 |    put(myautomata.states, currstate)
 977 | 
 978 |    while currstate.label ~= 32 do {
 979 |       currstate := pop(myautomata.states)
 980 |       put(myautomata.states, currstate)
 981 |       }
 982 |    put(tempedge.destinations, currstate)
 983 | 
 984 |    put(state2.edges, tempedge)
 985 |    tempedge := edge("+", [])
 986 |    currstate := pop(myautomata.states)
 987 |    put(myautomata.states, currstate)
 988 | 
 989 |    while currstate.label ~= 33 do {
 990 |       currstate := pop(myautomata.states)
 991 |       put(myautomata.states, currstate)
 992 |       }
 993 |    put(tempedge.destinations, currstate)
 994 | 
 995 |    put(state2.edges, tempedge)
 996 |    tempedge := edge("-", [])
 997 |    currstate := pop(myautomata.states)
 998 |    put(myautomata.states, currstate)
 999 | 
1000 |    while currstate.label ~= 34 do {
1001 |       currstate := pop(myautomata.states)
1002 |       put(myautomata.states, currstate)
1003 |       }
1004 |    put(tempedge.destinations, currstate)
1005 | 
1006 |    put(state2.edges, tempedge)
1007 |    tempedge := edge("=", [])
1008 |    currstate := pop(myautomata.states)
1009 |    put(myautomata.states, currstate)
1010 | 
1011 |    while currstate.label ~= 35 do {
1012 |       currstate := pop(myautomata.states)
1013 |       put(myautomata.states, currstate)
1014 |       }
1015 |    put(tempedge.destinations, currstate)
1016 | 
1017 |    put(state2.edges, tempedge)
1018 |    tempedge := edge(",", [])
1019 |    currstate := pop(myautomata.states)
1020 |    put(myautomata.states, currstate)
1021 | 
1022 |    while currstate.label ~= 36 do {
1023 |       currstate := pop(myautomata.states)
1024 |       put(myautomata.states, currstate)
1025 |       }
1026 |    put(tempedge.destinations, currstate)
1027 | 
1028 |    put(state2.edges, tempedge)
1029 |    tempedge := edge(csetfromrecset("[\a-zA-Z_]"), [])
1030 |    currstate := pop(myautomata.states)
1031 |    put(myautomata.states, currstate)
1032 | 
1033 |    while currstate.label ~= 37 do {
1034 |       currstate := pop(myautomata.states)
1035 |       put(myautomata.states, currstate)
1036 |       }
1037 |    put(tempedge.destinations, currstate)
1038 | 
1039 |    put(state2.edges, tempedge)
1040 |    tempedge := edge(".", [])
1041 |    currstate := pop(myautomata.states)
1042 |    put(myautomata.states, currstate)
1043 | 
1044 |    while currstate.label ~= 38 do {
1045 |       currstate := pop(myautomata.states)
1046 |       put(myautomata.states, currstate)
1047 |       }
1048 |    put(tempedge.destinations, currstate)
1049 | 
1050 |    put(state2.edges, tempedge)
1051 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1052 |    currstate := pop(myautomata.states)
1053 |    put(myautomata.states, currstate)
1054 | 
1055 |    while currstate.label ~= 39 do {
1056 |       currstate := pop(myautomata.states)
1057 |       put(myautomata.states, currstate)
1058 |       }
1059 |    put(tempedge.destinations, currstate)
1060 | 
1061 |    put(state2.edges, tempedge)
1062 |    tempedge := edge("\"", [])
1063 |    currstate := pop(myautomata.states)
1064 |    put(myautomata.states, currstate)
1065 | 
1066 |    while currstate.label ~= 40 do {
1067 |       currstate := pop(myautomata.states)
1068 |       put(myautomata.states, currstate)
1069 |       }
1070 |    put(tempedge.destinations, currstate)
1071 | 
1072 |    put(state2.edges, tempedge)
1073 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
1074 |    currstate := pop(myautomata.states)
1075 |    put(myautomata.states, currstate)
1076 | 
1077 |    while currstate.label ~= 41 do {
1078 |       currstate := pop(myautomata.states)
1079 |       put(myautomata.states, currstate)
1080 |       }
1081 |    put(tempedge.destinations, currstate)
1082 | 
1083 |    put(state2.edges, tempedge)
1084 |    currstate := pop(myautomata.states)
1085 |    put(myautomata.states, currstate)
1086 | 
1087 |    while currstate.label ~= 2 do {
1088 |       currstate := pop(myautomata.states)
1089 |       put(myautomata.states, currstate)
1090 |       }
1091 |    state2 := currstate
1092 | 
1093 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
1094 |    currstate := pop(myautomata.states)
1095 |    put(myautomata.states, currstate)
1096 | 
1097 |    while currstate.label ~= 2 do {
1098 |       currstate := pop(myautomata.states)
1099 |       put(myautomata.states, currstate)
1100 |       }
1101 |    put(tempedge.destinations, currstate)
1102 | 
1103 |    put(state2.edges, tempedge)
1104 |    currstate := pop(myautomata.states)
1105 |    put(myautomata.states, currstate)
1106 | 
1107 |    while currstate.label ~= 3 do {
1108 |       currstate := pop(myautomata.states)
1109 |       put(myautomata.states, currstate)
1110 |       }
1111 |    state2 := currstate
1112 | 
1113 |    currstate := pop(myautomata.states)
1114 |    put(myautomata.states, currstate)
1115 | 
1116 |    while currstate.label ~= 4 do {
1117 |       currstate := pop(myautomata.states)
1118 |       put(myautomata.states, currstate)
1119 |       }
1120 |    state2 := currstate
1121 | 
1122 |    tempedge := edge("o", [])
1123 |    currstate := pop(myautomata.states)
1124 |    put(myautomata.states, currstate)
1125 | 
1126 |    while currstate.label ~= 42 do {
1127 |       currstate := pop(myautomata.states)
1128 |       put(myautomata.states, currstate)
1129 |       }
1130 |    put(tempedge.destinations, currstate)
1131 | 
1132 |    put(state2.edges, tempedge)
1133 |    tempedge := edge("\a", [])
1134 |    currstate := pop(myautomata.states)
1135 |    put(myautomata.states, currstate)
1136 | 
1137 |    while currstate.label ~= 43 do {
1138 |       currstate := pop(myautomata.states)
1139 |       put(myautomata.states, currstate)
1140 |       }
1141 |    put(tempedge.destinations, currstate)
1142 | 
1143 |    put(state2.edges, tempedge)
1144 |    currstate := pop(myautomata.states)
1145 |    put(myautomata.states, currstate)
1146 | 
1147 |    while currstate.label ~= 5 do {
1148 |       currstate := pop(myautomata.states)
1149 |       put(myautomata.states, currstate)
1150 |       }
1151 |    state2 := currstate
1152 | 
1153 |    tempedge := edge("u", [])
1154 |    currstate := pop(myautomata.states)
1155 |    put(myautomata.states, currstate)
1156 | 
1157 |    while currstate.label ~= 44 do {
1158 |       currstate := pop(myautomata.states)
1159 |       put(myautomata.states, currstate)
1160 |       }
1161 |    put(tempedge.destinations, currstate)
1162 | 
1163 |    put(state2.edges, tempedge)
1164 |    currstate := pop(myautomata.states)
1165 |    put(myautomata.states, currstate)
1166 | 
1167 |    while currstate.label ~= 6 do {
1168 |       currstate := pop(myautomata.states)
1169 |       put(myautomata.states, currstate)
1170 |       }
1171 |    state2 := currstate
1172 | 
1173 |    tempedge := edge("u", [])
1174 |    currstate := pop(myautomata.states)
1175 |    put(myautomata.states, currstate)
1176 | 
1177 |    while currstate.label ~= 45 do {
1178 |       currstate := pop(myautomata.states)
1179 |       put(myautomata.states, currstate)
1180 |       }
1181 |    put(tempedge.destinations, currstate)
1182 | 
1183 |    put(state2.edges, tempedge)
1184 |    currstate := pop(myautomata.states)
1185 |    put(myautomata.states, currstate)
1186 | 
1187 |    while currstate.label ~= 7 do {
1188 |       currstate := pop(myautomata.states)
1189 |       put(myautomata.states, currstate)
1190 |       }
1191 |    state2 := currstate
1192 | 
1193 |    tempedge := edge("r", [])
1194 |    currstate := pop(myautomata.states)
1195 |    put(myautomata.states, currstate)
1196 | 
1197 |    while currstate.label ~= 46 do {
1198 |       currstate := pop(myautomata.states)
1199 |       put(myautomata.states, currstate)
1200 |       }
1201 |    put(tempedge.destinations, currstate)
1202 | 
1203 |    put(state2.edges, tempedge)
1204 |    currstate := pop(myautomata.states)
1205 |    put(myautomata.states, currstate)
1206 | 
1207 |    while currstate.label ~= 8 do {
1208 |       currstate := pop(myautomata.states)
1209 |       put(myautomata.states, currstate)
1210 |       }
1211 |    state2 := currstate
1212 | 
1213 |    tempedge := edge("e", [])
1214 |    currstate := pop(myautomata.states)
1215 |    put(myautomata.states, currstate)
1216 | 
1217 |    while currstate.label ~= 47 do {
1218 |       currstate := pop(myautomata.states)
1219 |       put(myautomata.states, currstate)
1220 |       }
1221 |    put(tempedge.destinations, currstate)
1222 | 
1223 |    put(state2.edges, tempedge)
1224 |    currstate := pop(myautomata.states)
1225 |    put(myautomata.states, currstate)
1226 | 
1227 |    while currstate.label ~= 9 do {
1228 |       currstate := pop(myautomata.states)
1229 |       put(myautomata.states, currstate)
1230 |       }
1231 |    state2 := currstate
1232 | 
1233 |    tempedge := edge("r", [])
1234 |    currstate := pop(myautomata.states)
1235 |    put(myautomata.states, currstate)
1236 | 
1237 |    while currstate.label ~= 48 do {
1238 |       currstate := pop(myautomata.states)
1239 |       put(myautomata.states, currstate)
1240 |       }
1241 |    put(tempedge.destinations, currstate)
1242 | 
1243 |    put(state2.edges, tempedge)
1244 |    tempedge := edge("o", [])
1245 |    currstate := pop(myautomata.states)
1246 |    put(myautomata.states, currstate)
1247 | 
1248 |    while currstate.label ~= 49 do {
1249 |       currstate := pop(myautomata.states)
1250 |       put(myautomata.states, currstate)
1251 |       }
1252 |    put(tempedge.destinations, currstate)
1253 | 
1254 |    put(state2.edges, tempedge)
1255 |    currstate := pop(myautomata.states)
1256 |    put(myautomata.states, currstate)
1257 | 
1258 |    while currstate.label ~= 10 do {
1259 |       currstate := pop(myautomata.states)
1260 |       put(myautomata.states, currstate)
1261 |       }
1262 |    state2 := currstate
1263 | 
1264 |    tempedge := edge("o", [])
1265 |    currstate := pop(myautomata.states)
1266 |    put(myautomata.states, currstate)
1267 | 
1268 |    while currstate.label ~= 50 do {
1269 |       currstate := pop(myautomata.states)
1270 |       put(myautomata.states, currstate)
1271 |       }
1272 |    put(tempedge.destinations, currstate)
1273 | 
1274 |    put(state2.edges, tempedge)
1275 |    currstate := pop(myautomata.states)
1276 |    put(myautomata.states, currstate)
1277 | 
1278 |    while currstate.label ~= 11 do {
1279 |       currstate := pop(myautomata.states)
1280 |       put(myautomata.states, currstate)
1281 |       }
1282 |    state2 := currstate
1283 | 
1284 |    tempedge := edge("o", [])
1285 |    currstate := pop(myautomata.states)
1286 |    put(myautomata.states, currstate)
1287 | 
1288 |    while currstate.label ~= 51 do {
1289 |       currstate := pop(myautomata.states)
1290 |       put(myautomata.states, currstate)
1291 |       }
1292 |    put(tempedge.destinations, currstate)
1293 | 
1294 |    put(state2.edges, tempedge)
1295 |    currstate := pop(myautomata.states)
1296 |    put(myautomata.states, currstate)
1297 | 
1298 |    while currstate.label ~= 12 do {
1299 |       currstate := pop(myautomata.states)
1300 |       put(myautomata.states, currstate)
1301 |       }
1302 |    state2 := currstate
1303 | 
1304 |    tempedge := edge("h", [])
1305 |    currstate := pop(myautomata.states)
1306 |    put(myautomata.states, currstate)
1307 | 
1308 |    while currstate.label ~= 52 do {
1309 |       currstate := pop(myautomata.states)
1310 |       put(myautomata.states, currstate)
1311 |       }
1312 |    put(tempedge.destinations, currstate)
1313 | 
1314 |    put(state2.edges, tempedge)
1315 |    currstate := pop(myautomata.states)
1316 |    put(myautomata.states, currstate)
1317 | 
1318 |    while currstate.label ~= 13 do {
1319 |       currstate := pop(myautomata.states)
1320 |       put(myautomata.states, currstate)
1321 |       }
1322 |    state2 := currstate
1323 | 
1324 |    tempedge := edge("f", [])
1325 |    currstate := pop(myautomata.states)
1326 |    put(myautomata.states, currstate)
1327 | 
1328 |    while currstate.label ~= 53 do {
1329 |       currstate := pop(myautomata.states)
1330 |       put(myautomata.states, currstate)
1331 |       }
1332 |    put(tempedge.destinations, currstate)
1333 | 
1334 |    put(state2.edges, tempedge)
1335 |    tempedge := edge("n", [])
1336 |    currstate := pop(myautomata.states)
1337 |    put(myautomata.states, currstate)
1338 | 
1339 |    while currstate.label ~= 54 do {
1340 |       currstate := pop(myautomata.states)
1341 |       put(myautomata.states, currstate)
1342 |       }
1343 |    put(tempedge.destinations, currstate)
1344 | 
1345 |    put(state2.edges, tempedge)
1346 |    currstate := pop(myautomata.states)
1347 |    put(myautomata.states, currstate)
1348 | 
1349 |    while currstate.label ~= 14 do {
1350 |       currstate := pop(myautomata.states)
1351 |       put(myautomata.states, currstate)
1352 |       }
1353 |    state2 := currstate
1354 | 
1355 |    tempedge := edge("l", [])
1356 |    currstate := pop(myautomata.states)
1357 |    put(myautomata.states, currstate)
1358 | 
1359 |    while currstate.label ~= 55 do {
1360 |       currstate := pop(myautomata.states)
1361 |       put(myautomata.states, currstate)
1362 |       }
1363 |    put(tempedge.destinations, currstate)
1364 | 
1365 |    put(state2.edges, tempedge)
1366 |    currstate := pop(myautomata.states)
1367 |    put(myautomata.states, currstate)
1368 | 
1369 |    while currstate.label ~= 15 do {
1370 |       currstate := pop(myautomata.states)
1371 |       put(myautomata.states, currstate)
1372 |       }
1373 |    state2 := currstate
1374 | 
1375 |    tempedge := edge("l", [])
1376 |    currstate := pop(myautomata.states)
1377 |    put(myautomata.states, currstate)
1378 | 
1379 |    while currstate.label ~= 56 do {
1380 |       currstate := pop(myautomata.states)
1381 |       put(myautomata.states, currstate)
1382 |       }
1383 |    put(tempedge.destinations, currstate)
1384 | 
1385 |    put(state2.edges, tempedge)
1386 |    currstate := pop(myautomata.states)
1387 |    put(myautomata.states, currstate)
1388 | 
1389 |    while currstate.label ~= 16 do {
1390 |       currstate := pop(myautomata.states)
1391 |       put(myautomata.states, currstate)
1392 |       }
1393 |    state2 := currstate
1394 | 
1395 |    tempedge := edge("t", [])
1396 |    currstate := pop(myautomata.states)
1397 |    put(myautomata.states, currstate)
1398 | 
1399 |    while currstate.label ~= 57 do {
1400 |       currstate := pop(myautomata.states)
1401 |       put(myautomata.states, currstate)
1402 |       }
1403 |    put(tempedge.destinations, currstate)
1404 | 
1405 |    put(state2.edges, tempedge)
1406 |    currstate := pop(myautomata.states)
1407 |    put(myautomata.states, currstate)
1408 | 
1409 |    while currstate.label ~= 17 do {
1410 |       currstate := pop(myautomata.states)
1411 |       put(myautomata.states, currstate)
1412 |       }
1413 |    state2 := currstate
1414 | 
1415 |    currstate := pop(myautomata.states)
1416 |    put(myautomata.states, currstate)
1417 | 
1418 |    while currstate.label ~= 18 do {
1419 |       currstate := pop(myautomata.states)
1420 |       put(myautomata.states, currstate)
1421 |       }
1422 |    state2 := currstate
1423 | 
1424 |    currstate := pop(myautomata.states)
1425 |    put(myautomata.states, currstate)
1426 | 
1427 |    while currstate.label ~= 19 do {
1428 |       currstate := pop(myautomata.states)
1429 |       put(myautomata.states, currstate)
1430 |       }
1431 |    state2 := currstate
1432 | 
1433 |    currstate := pop(myautomata.states)
1434 |    put(myautomata.states, currstate)
1435 | 
1436 |    while currstate.label ~= 20 do {
1437 |       currstate := pop(myautomata.states)
1438 |       put(myautomata.states, currstate)
1439 |       }
1440 |    state2 := currstate
1441 | 
1442 |    currstate := pop(myautomata.states)
1443 |    put(myautomata.states, currstate)
1444 | 
1445 |    while currstate.label ~= 21 do {
1446 |       currstate := pop(myautomata.states)
1447 |       put(myautomata.states, currstate)
1448 |       }
1449 |    state2 := currstate
1450 | 
1451 |    currstate := pop(myautomata.states)
1452 |    put(myautomata.states, currstate)
1453 | 
1454 |    while currstate.label ~= 22 do {
1455 |       currstate := pop(myautomata.states)
1456 |       put(myautomata.states, currstate)
1457 |       }
1458 |    state2 := currstate
1459 | 
1460 |    currstate := pop(myautomata.states)
1461 |    put(myautomata.states, currstate)
1462 | 
1463 |    while currstate.label ~= 23 do {
1464 |       currstate := pop(myautomata.states)
1465 |       put(myautomata.states, currstate)
1466 |       }
1467 |    state2 := currstate
1468 | 
1469 |    currstate := pop(myautomata.states)
1470 |    put(myautomata.states, currstate)
1471 | 
1472 |    while currstate.label ~= 24 do {
1473 |       currstate := pop(myautomata.states)
1474 |       put(myautomata.states, currstate)
1475 |       }
1476 |    state2 := currstate
1477 | 
1478 |    currstate := pop(myautomata.states)
1479 |    put(myautomata.states, currstate)
1480 | 
1481 |    while currstate.label ~= 25 do {
1482 |       currstate := pop(myautomata.states)
1483 |       put(myautomata.states, currstate)
1484 |       }
1485 |    state2 := currstate
1486 | 
1487 |    currstate := pop(myautomata.states)
1488 |    put(myautomata.states, currstate)
1489 | 
1490 |    while currstate.label ~= 26 do {
1491 |       currstate := pop(myautomata.states)
1492 |       put(myautomata.states, currstate)
1493 |       }
1494 |    state2 := currstate
1495 | 
1496 |    tempedge := edge("*", [])
1497 |    currstate := pop(myautomata.states)
1498 |    put(myautomata.states, currstate)
1499 | 
1500 |    while currstate.label ~= 58 do {
1501 |       currstate := pop(myautomata.states)
1502 |       put(myautomata.states, currstate)
1503 |       }
1504 |    put(tempedge.destinations, currstate)
1505 | 
1506 |    put(state2.edges, tempedge)
1507 |    tempedge := edge("/", [])
1508 |    currstate := pop(myautomata.states)
1509 |    put(myautomata.states, currstate)
1510 | 
1511 |    while currstate.label ~= 59 do {
1512 |       currstate := pop(myautomata.states)
1513 |       put(myautomata.states, currstate)
1514 |       }
1515 |    put(tempedge.destinations, currstate)
1516 | 
1517 |    put(state2.edges, tempedge)
1518 |    currstate := pop(myautomata.states)
1519 |    put(myautomata.states, currstate)
1520 | 
1521 |    while currstate.label ~= 27 do {
1522 |       currstate := pop(myautomata.states)
1523 |       put(myautomata.states, currstate)
1524 |       }
1525 |    state2 := currstate
1526 | 
1527 |    currstate := pop(myautomata.states)
1528 |    put(myautomata.states, currstate)
1529 | 
1530 |    while currstate.label ~= 28 do {
1531 |       currstate := pop(myautomata.states)
1532 |       put(myautomata.states, currstate)
1533 |       }
1534 |    state2 := currstate
1535 | 
1536 |    tempedge := edge("=", [])
1537 |    currstate := pop(myautomata.states)
1538 |    put(myautomata.states, currstate)
1539 | 
1540 |    while currstate.label ~= 60 do {
1541 |       currstate := pop(myautomata.states)
1542 |       put(myautomata.states, currstate)
1543 |       }
1544 |    put(tempedge.destinations, currstate)
1545 | 
1546 |    put(state2.edges, tempedge)
1547 |    currstate := pop(myautomata.states)
1548 |    put(myautomata.states, currstate)
1549 | 
1550 |    while currstate.label ~= 29 do {
1551 |       currstate := pop(myautomata.states)
1552 |       put(myautomata.states, currstate)
1553 |       }
1554 |    state2 := currstate
1555 | 
1556 |    tempedge := edge("=", [])
1557 |    currstate := pop(myautomata.states)
1558 |    put(myautomata.states, currstate)
1559 | 
1560 |    while currstate.label ~= 61 do {
1561 |       currstate := pop(myautomata.states)
1562 |       put(myautomata.states, currstate)
1563 |       }
1564 |    put(tempedge.destinations, currstate)
1565 | 
1566 |    put(state2.edges, tempedge)
1567 |    currstate := pop(myautomata.states)
1568 |    put(myautomata.states, currstate)
1569 | 
1570 |    while currstate.label ~= 30 do {
1571 |       currstate := pop(myautomata.states)
1572 |       put(myautomata.states, currstate)
1573 |       }
1574 |    state2 := currstate
1575 | 
1576 |    tempedge := edge("=", [])
1577 |    currstate := pop(myautomata.states)
1578 |    put(myautomata.states, currstate)
1579 | 
1580 |    while currstate.label ~= 62 do {
1581 |       currstate := pop(myautomata.states)
1582 |       put(myautomata.states, currstate)
1583 |       }
1584 |    put(tempedge.destinations, currstate)
1585 | 
1586 |    put(state2.edges, tempedge)
1587 |    currstate := pop(myautomata.states)
1588 |    put(myautomata.states, currstate)
1589 | 
1590 |    while currstate.label ~= 31 do {
1591 |       currstate := pop(myautomata.states)
1592 |       put(myautomata.states, currstate)
1593 |       }
1594 |    state2 := currstate
1595 | 
1596 |    tempedge := edge("&", [])
1597 |    currstate := pop(myautomata.states)
1598 |    put(myautomata.states, currstate)
1599 | 
1600 |    while currstate.label ~= 63 do {
1601 |       currstate := pop(myautomata.states)
1602 |       put(myautomata.states, currstate)
1603 |       }
1604 |    put(tempedge.destinations, currstate)
1605 | 
1606 |    put(state2.edges, tempedge)
1607 |    currstate := pop(myautomata.states)
1608 |    put(myautomata.states, currstate)
1609 | 
1610 |    while currstate.label ~= 32 do {
1611 |       currstate := pop(myautomata.states)
1612 |       put(myautomata.states, currstate)
1613 |       }
1614 |    state2 := currstate
1615 | 
1616 |    tempedge := edge("|", [])
1617 |    currstate := pop(myautomata.states)
1618 |    put(myautomata.states, currstate)
1619 | 
1620 |    while currstate.label ~= 64 do {
1621 |       currstate := pop(myautomata.states)
1622 |       put(myautomata.states, currstate)
1623 |       }
1624 |    put(tempedge.destinations, currstate)
1625 | 
1626 |    put(state2.edges, tempedge)
1627 |    currstate := pop(myautomata.states)
1628 |    put(myautomata.states, currstate)
1629 | 
1630 |    while currstate.label ~= 33 do {
1631 |       currstate := pop(myautomata.states)
1632 |       put(myautomata.states, currstate)
1633 |       }
1634 |    state2 := currstate
1635 | 
1636 |    tempedge := edge("=", [])
1637 |    currstate := pop(myautomata.states)
1638 |    put(myautomata.states, currstate)
1639 | 
1640 |    while currstate.label ~= 65 do {
1641 |       currstate := pop(myautomata.states)
1642 |       put(myautomata.states, currstate)
1643 |       }
1644 |    put(tempedge.destinations, currstate)
1645 | 
1646 |    put(state2.edges, tempedge)
1647 |    currstate := pop(myautomata.states)
1648 |    put(myautomata.states, currstate)
1649 | 
1650 |    while currstate.label ~= 34 do {
1651 |       currstate := pop(myautomata.states)
1652 |       put(myautomata.states, currstate)
1653 |       }
1654 |    state2 := currstate
1655 | 
1656 |    tempedge := edge("=", [])
1657 |    currstate := pop(myautomata.states)
1658 |    put(myautomata.states, currstate)
1659 | 
1660 |    while currstate.label ~= 66 do {
1661 |       currstate := pop(myautomata.states)
1662 |       put(myautomata.states, currstate)
1663 |       }
1664 |    put(tempedge.destinations, currstate)
1665 | 
1666 |    put(state2.edges, tempedge)
1667 |    currstate := pop(myautomata.states)
1668 |    put(myautomata.states, currstate)
1669 | 
1670 |    while currstate.label ~= 35 do {
1671 |       currstate := pop(myautomata.states)
1672 |       put(myautomata.states, currstate)
1673 |       }
1674 |    state2 := currstate
1675 | 
1676 |    tempedge := edge("=", [])
1677 |    currstate := pop(myautomata.states)
1678 |    put(myautomata.states, currstate)
1679 | 
1680 |    while currstate.label ~= 67 do {
1681 |       currstate := pop(myautomata.states)
1682 |       put(myautomata.states, currstate)
1683 |       }
1684 |    put(tempedge.destinations, currstate)
1685 | 
1686 |    put(state2.edges, tempedge)
1687 |    currstate := pop(myautomata.states)
1688 |    put(myautomata.states, currstate)
1689 | 
1690 |    while currstate.label ~= 36 do {
1691 |       currstate := pop(myautomata.states)
1692 |       put(myautomata.states, currstate)
1693 |       }
1694 |    state2 := currstate
1695 | 
1696 |    currstate := pop(myautomata.states)
1697 |    put(myautomata.states, currstate)
1698 | 
1699 |    while currstate.label ~= 37 do {
1700 |       currstate := pop(myautomata.states)
1701 |       put(myautomata.states, currstate)
1702 |       }
1703 |    state2 := currstate
1704 | 
1705 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
1706 |    currstate := pop(myautomata.states)
1707 |    put(myautomata.states, currstate)
1708 | 
1709 |    while currstate.label ~= 68 do {
1710 |       currstate := pop(myautomata.states)
1711 |       put(myautomata.states, currstate)
1712 |       }
1713 |    put(tempedge.destinations, currstate)
1714 | 
1715 |    put(state2.edges, tempedge)
1716 |    currstate := pop(myautomata.states)
1717 |    put(myautomata.states, currstate)
1718 | 
1719 |    while currstate.label ~= 38 do {
1720 |       currstate := pop(myautomata.states)
1721 |       put(myautomata.states, currstate)
1722 |       }
1723 |    state2 := currstate
1724 | 
1725 |    tempedge := edge(csetfromrecset("[eE]"), [])
1726 |    currstate := pop(myautomata.states)
1727 |    put(myautomata.states, currstate)
1728 | 
1729 |    while currstate.label ~= 69 do {
1730 |       currstate := pop(myautomata.states)
1731 |       put(myautomata.states, currstate)
1732 |       }
1733 |    put(tempedge.destinations, currstate)
1734 | 
1735 |    put(state2.edges, tempedge)
1736 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1737 |    currstate := pop(myautomata.states)
1738 |    put(myautomata.states, currstate)
1739 | 
1740 |    while currstate.label ~= 70 do {
1741 |       currstate := pop(myautomata.states)
1742 |       put(myautomata.states, currstate)
1743 |       }
1744 |    put(tempedge.destinations, currstate)
1745 | 
1746 |    put(state2.edges, tempedge)
1747 |    currstate := pop(myautomata.states)
1748 |    put(myautomata.states, currstate)
1749 | 
1750 |    while currstate.label ~= 39 do {
1751 |       currstate := pop(myautomata.states)
1752 |       put(myautomata.states, currstate)
1753 |       }
1754 |    state2 := currstate
1755 | 
1756 |    tempedge := edge(".", [])
1757 |    currstate := pop(myautomata.states)
1758 |    put(myautomata.states, currstate)
1759 | 
1760 |    while currstate.label ~= 71 do {
1761 |       currstate := pop(myautomata.states)
1762 |       put(myautomata.states, currstate)
1763 |       }
1764 |    put(tempedge.destinations, currstate)
1765 | 
1766 |    put(state2.edges, tempedge)
1767 |    tempedge := edge(csetfromrecset("[eE]"), [])
1768 |    currstate := pop(myautomata.states)
1769 |    put(myautomata.states, currstate)
1770 | 
1771 |    while currstate.label ~= 72 do {
1772 |       currstate := pop(myautomata.states)
1773 |       put(myautomata.states, currstate)
1774 |       }
1775 |    put(tempedge.destinations, currstate)
1776 | 
1777 |    put(state2.edges, tempedge)
1778 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1779 |    currstate := pop(myautomata.states)
1780 |    put(myautomata.states, currstate)
1781 | 
1782 |    while currstate.label ~= 39 do {
1783 |       currstate := pop(myautomata.states)
1784 |       put(myautomata.states, currstate)
1785 |       }
1786 |    put(tempedge.destinations, currstate)
1787 | 
1788 |    put(state2.edges, tempedge)
1789 |    currstate := pop(myautomata.states)
1790 |    put(myautomata.states, currstate)
1791 | 
1792 |    while currstate.label ~= 40 do {
1793 |       currstate := pop(myautomata.states)
1794 |       put(myautomata.states, currstate)
1795 |       }
1796 |    state2 := currstate
1797 | 
1798 |    tempedge := edge(csetfromrecset("[^\"]"), [])
1799 |    currstate := pop(myautomata.states)
1800 |    put(myautomata.states, currstate)
1801 | 
1802 |    while currstate.label ~= 73 do {
1803 |       currstate := pop(myautomata.states)
1804 |       put(myautomata.states, currstate)
1805 |       }
1806 |    put(tempedge.destinations, currstate)
1807 | 
1808 |    put(state2.edges, tempedge)
1809 |    tempedge := edge("\\", [])
1810 |    currstate := pop(myautomata.states)
1811 |    put(myautomata.states, currstate)
1812 | 
1813 |    while currstate.label ~= 74 do {
1814 |       currstate := pop(myautomata.states)
1815 |       put(myautomata.states, currstate)
1816 |       }
1817 |    put(tempedge.destinations, currstate)
1818 | 
1819 |    put(state2.edges, tempedge)
1820 |    tempedge := edge("\"", [])
1821 |    currstate := pop(myautomata.states)
1822 |    put(myautomata.states, currstate)
1823 | 
1824 |    while currstate.label ~= 75 do {
1825 |       currstate := pop(myautomata.states)
1826 |       put(myautomata.states, currstate)
1827 |       }
1828 |    put(tempedge.destinations, currstate)
1829 | 
1830 |    put(state2.edges, tempedge)
1831 |    currstate := pop(myautomata.states)
1832 |    put(myautomata.states, currstate)
1833 | 
1834 |    while currstate.label ~= 41 do {
1835 |       currstate := pop(myautomata.states)
1836 |       put(myautomata.states, currstate)
1837 |       }
1838 |    state2 := currstate
1839 | 
1840 |    currstate := pop(myautomata.states)
1841 |    put(myautomata.states, currstate)
1842 | 
1843 |    while currstate.label ~= 42 do {
1844 |       currstate := pop(myautomata.states)
1845 |       put(myautomata.states, currstate)
1846 |       }
1847 |    state2 := currstate
1848 | 
1849 |    tempedge := edge("r", [])
1850 |    currstate := pop(myautomata.states)
1851 |    put(myautomata.states, currstate)
1852 | 
1853 |    while currstate.label ~= 76 do {
1854 |       currstate := pop(myautomata.states)
1855 |       put(myautomata.states, currstate)
1856 |       }
1857 |    put(tempedge.destinations, currstate)
1858 | 
1859 |    put(state2.edges, tempedge)
1860 |    currstate := pop(myautomata.states)
1861 |    put(myautomata.states, currstate)
1862 | 
1863 |    while currstate.label ~= 43 do {
1864 |       currstate := pop(myautomata.states)
1865 |       put(myautomata.states, currstate)
1866 |       }
1867 |    state2 := currstate
1868 | 
1869 |    tempedge := edge("l", [])
1870 |    currstate := pop(myautomata.states)
1871 |    put(myautomata.states, currstate)
1872 | 
1873 |    while currstate.label ~= 77 do {
1874 |       currstate := pop(myautomata.states)
1875 |       put(myautomata.states, currstate)
1876 |       }
1877 |    put(tempedge.destinations, currstate)
1878 | 
1879 |    put(state2.edges, tempedge)
1880 |    currstate := pop(myautomata.states)
1881 |    put(myautomata.states, currstate)
1882 | 
1883 |    while currstate.label ~= 44 do {
1884 |       currstate := pop(myautomata.states)
1885 |       put(myautomata.states, currstate)
1886 |       }
1887 |    state2 := currstate
1888 | 
1889 |    tempedge := edge("b", [])
1890 |    currstate := pop(myautomata.states)
1891 |    put(myautomata.states, currstate)
1892 | 
1893 |    while currstate.label ~= 78 do {
1894 |       currstate := pop(myautomata.states)
1895 |       put(myautomata.states, currstate)
1896 |       }
1897 |    put(tempedge.destinations, currstate)
1898 | 
1899 |    put(state2.edges, tempedge)
1900 |    currstate := pop(myautomata.states)
1901 |    put(myautomata.states, currstate)
1902 | 
1903 |    while currstate.label ~= 45 do {
1904 |       currstate := pop(myautomata.states)
1905 |       put(myautomata.states, currstate)
1906 |       }
1907 |    state2 := currstate
1908 | 
1909 |    tempedge := edge("l", [])
1910 |    currstate := pop(myautomata.states)
1911 |    put(myautomata.states, currstate)
1912 | 
1913 |    while currstate.label ~= 79 do {
1914 |       currstate := pop(myautomata.states)
1915 |       put(myautomata.states, currstate)
1916 |       }
1917 |    put(tempedge.destinations, currstate)
1918 | 
1919 |    put(state2.edges, tempedge)
1920 |    currstate := pop(myautomata.states)
1921 |    put(myautomata.states, currstate)
1922 | 
1923 |    while currstate.label ~= 46 do {
1924 |       currstate := pop(myautomata.states)
1925 |       put(myautomata.states, currstate)
1926 |       }
1927 |    state2 := currstate
1928 | 
1929 |    tempedge := edge("u", [])
1930 |    currstate := pop(myautomata.states)
1931 |    put(myautomata.states, currstate)
1932 | 
1933 |    while currstate.label ~= 80 do {
1934 |       currstate := pop(myautomata.states)
1935 |       put(myautomata.states, currstate)
1936 |       }
1937 |    put(tempedge.destinations, currstate)
1938 | 
1939 |    put(state2.edges, tempedge)
1940 |    currstate := pop(myautomata.states)
1941 |    put(myautomata.states, currstate)
1942 | 
1943 |    while currstate.label ~= 47 do {
1944 |       currstate := pop(myautomata.states)
1945 |       put(myautomata.states, currstate)
1946 |       }
1947 |    state2 := currstate
1948 | 
1949 |    tempedge := edge("t", [])
1950 |    currstate := pop(myautomata.states)
1951 |    put(myautomata.states, currstate)
1952 | 
1953 |    while currstate.label ~= 81 do {
1954 |       currstate := pop(myautomata.states)
1955 |       put(myautomata.states, currstate)
1956 |       }
1957 |    put(tempedge.destinations, currstate)
1958 | 
1959 |    put(state2.edges, tempedge)
1960 |    currstate := pop(myautomata.states)
1961 |    put(myautomata.states, currstate)
1962 | 
1963 |    while currstate.label ~= 48 do {
1964 |       currstate := pop(myautomata.states)
1965 |       put(myautomata.states, currstate)
1966 |       }
1967 |    state2 := currstate
1968 | 
1969 |    tempedge := edge("e", [])
1970 |    currstate := pop(myautomata.states)
1971 |    put(myautomata.states, currstate)
1972 | 
1973 |    while currstate.label ~= 82 do {
1974 |       currstate := pop(myautomata.states)
1975 |       put(myautomata.states, currstate)
1976 |       }
1977 |    put(tempedge.destinations, currstate)
1978 | 
1979 |    put(state2.edges, tempedge)
1980 |    currstate := pop(myautomata.states)
1981 |    put(myautomata.states, currstate)
1982 | 
1983 |    while currstate.label ~= 49 do {
1984 |       currstate := pop(myautomata.states)
1985 |       put(myautomata.states, currstate)
1986 |       }
1987 |    state2 := currstate
1988 | 
1989 |    tempedge := edge("o", [])
1990 |    currstate := pop(myautomata.states)
1991 |    put(myautomata.states, currstate)
1992 | 
1993 |    while currstate.label ~= 83 do {
1994 |       currstate := pop(myautomata.states)
1995 |       put(myautomata.states, currstate)
1996 |       }
1997 |    put(tempedge.destinations, currstate)
1998 | 
1999 |    put(state2.edges, tempedge)
2000 |    currstate := pop(myautomata.states)
2001 |    put(myautomata.states, currstate)
2002 | 
2003 |    while currstate.label ~= 50 do {
2004 |       currstate := pop(myautomata.states)
2005 |       put(myautomata.states, currstate)
2006 |       }
2007 |    state2 := currstate
2008 | 
2009 |    tempedge := edge("i", [])
2010 |    currstate := pop(myautomata.states)
2011 |    put(myautomata.states, currstate)
2012 | 
2013 |    while currstate.label ~= 84 do {
2014 |       currstate := pop(myautomata.states)
2015 |       put(myautomata.states, currstate)
2016 |       }
2017 |    put(tempedge.destinations, currstate)
2018 | 
2019 |    put(state2.edges, tempedge)
2020 |    currstate := pop(myautomata.states)
2021 |    put(myautomata.states, currstate)
2022 | 
2023 |    while currstate.label ~= 51 do {
2024 |       currstate := pop(myautomata.states)
2025 |       put(myautomata.states, currstate)
2026 |       }
2027 |    state2 := currstate
2028 | 
2029 |    tempedge := edge("u", [])
2030 |    currstate := pop(myautomata.states)
2031 |    put(myautomata.states, currstate)
2032 | 
2033 |    while currstate.label ~= 85 do {
2034 |       currstate := pop(myautomata.states)
2035 |       put(myautomata.states, currstate)
2036 |       }
2037 |    put(tempedge.destinations, currstate)
2038 | 
2039 |    put(state2.edges, tempedge)
2040 |    currstate := pop(myautomata.states)
2041 |    put(myautomata.states, currstate)
2042 | 
2043 |    while currstate.label ~= 52 do {
2044 |       currstate := pop(myautomata.states)
2045 |       put(myautomata.states, currstate)
2046 |       }
2047 |    state2 := currstate
2048 | 
2049 |    tempedge := edge("i", [])
2050 |    currstate := pop(myautomata.states)
2051 |    put(myautomata.states, currstate)
2052 | 
2053 |    while currstate.label ~= 86 do {
2054 |       currstate := pop(myautomata.states)
2055 |       put(myautomata.states, currstate)
2056 |       }
2057 |    put(tempedge.destinations, currstate)
2058 | 
2059 |    put(state2.edges, tempedge)
2060 |    currstate := pop(myautomata.states)
2061 |    put(myautomata.states, currstate)
2062 | 
2063 |    while currstate.label ~= 53 do {
2064 |       currstate := pop(myautomata.states)
2065 |       put(myautomata.states, currstate)
2066 |       }
2067 |    state2 := currstate
2068 | 
2069 |    currstate := pop(myautomata.states)
2070 |    put(myautomata.states, currstate)
2071 | 
2072 |    while currstate.label ~= 54 do {
2073 |       currstate := pop(myautomata.states)
2074 |       put(myautomata.states, currstate)
2075 |       }
2076 |    state2 := currstate
2077 | 
2078 |    tempedge := edge("t", [])
2079 |    currstate := pop(myautomata.states)
2080 |    put(myautomata.states, currstate)
2081 | 
2082 |    while currstate.label ~= 87 do {
2083 |       currstate := pop(myautomata.states)
2084 |       put(myautomata.states, currstate)
2085 |       }
2086 |    put(tempedge.destinations, currstate)
2087 | 
2088 |    put(state2.edges, tempedge)
2089 |    currstate := pop(myautomata.states)
2090 |    put(myautomata.states, currstate)
2091 | 
2092 |    while currstate.label ~= 55 do {
2093 |       currstate := pop(myautomata.states)
2094 |       put(myautomata.states, currstate)
2095 |       }
2096 |    state2 := currstate
2097 | 
2098 |    tempedge := edge("s", [])
2099 |    currstate := pop(myautomata.states)
2100 |    put(myautomata.states, currstate)
2101 | 
2102 |    while currstate.label ~= 88 do {
2103 |       currstate := pop(myautomata.states)
2104 |       put(myautomata.states, currstate)
2105 |       }
2106 |    put(tempedge.destinations, currstate)
2107 | 
2108 |    put(state2.edges, tempedge)
2109 |    currstate := pop(myautomata.states)
2110 |    put(myautomata.states, currstate)
2111 | 
2112 |    while currstate.label ~= 56 do {
2113 |       currstate := pop(myautomata.states)
2114 |       put(myautomata.states, currstate)
2115 |       }
2116 |    state2 := currstate
2117 | 
2118 |    tempedge := edge("\a", [])
2119 |    currstate := pop(myautomata.states)
2120 |    put(myautomata.states, currstate)
2121 | 
2122 |    while currstate.label ~= 89 do {
2123 |       currstate := pop(myautomata.states)
2124 |       put(myautomata.states, currstate)
2125 |       }
2126 |    put(tempedge.destinations, currstate)
2127 | 
2128 |    put(state2.edges, tempedge)
2129 |    currstate := pop(myautomata.states)
2130 |    put(myautomata.states, currstate)
2131 | 
2132 |    while currstate.label ~= 57 do {
2133 |       currstate := pop(myautomata.states)
2134 |       put(myautomata.states, currstate)
2135 |       }
2136 |    state2 := currstate
2137 | 
2138 |    tempedge := edge("r", [])
2139 |    currstate := pop(myautomata.states)
2140 |    put(myautomata.states, currstate)
2141 | 
2142 |    while currstate.label ~= 90 do {
2143 |       currstate := pop(myautomata.states)
2144 |       put(myautomata.states, currstate)
2145 |       }
2146 |    put(tempedge.destinations, currstate)
2147 | 
2148 |    put(state2.edges, tempedge)
2149 |    tempedge := edge("\a", [])
2150 |    currstate := pop(myautomata.states)
2151 |    put(myautomata.states, currstate)
2152 | 
2153 |    while currstate.label ~= 91 do {
2154 |       currstate := pop(myautomata.states)
2155 |       put(myautomata.states, currstate)
2156 |       }
2157 |    put(tempedge.destinations, currstate)
2158 | 
2159 |    put(state2.edges, tempedge)
2160 |    currstate := pop(myautomata.states)
2161 |    put(myautomata.states, currstate)
2162 | 
2163 |    while currstate.label ~= 58 do {
2164 |       currstate := pop(myautomata.states)
2165 |       put(myautomata.states, currstate)
2166 |       }
2167 |    state2 := currstate
2168 | 
2169 |    tempedge := edge(csetfromrecset("[^*]"), [])
2170 |    currstate := pop(myautomata.states)
2171 |    put(myautomata.states, currstate)
2172 | 
2173 |    while currstate.label ~= 92 do {
2174 |       currstate := pop(myautomata.states)
2175 |       put(myautomata.states, currstate)
2176 |       }
2177 |    put(tempedge.destinations, currstate)
2178 | 
2179 |    put(state2.edges, tempedge)
2180 |    tempedge := edge("*", [])
2181 |    currstate := pop(myautomata.states)
2182 |    put(myautomata.states, currstate)
2183 | 
2184 |    while currstate.label ~= 93 do {
2185 |       currstate := pop(myautomata.states)
2186 |       put(myautomata.states, currstate)
2187 |       }
2188 |    put(tempedge.destinations, currstate)
2189 | 
2190 |    put(state2.edges, tempedge)
2191 |    currstate := pop(myautomata.states)
2192 |    put(myautomata.states, currstate)
2193 | 
2194 |    while currstate.label ~= 59 do {
2195 |       currstate := pop(myautomata.states)
2196 |       put(myautomata.states, currstate)
2197 |       }
2198 |    state2 := currstate
2199 | 
2200 |    tempedge := edge("\n"
2201 | , [])
2202 |    currstate := pop(myautomata.states)
2203 |    put(myautomata.states, currstate)
2204 | 
2205 |    while currstate.label ~= 94 do {
2206 |       currstate := pop(myautomata.states)
2207 |       put(myautomata.states, currstate)
2208 |       }
2209 |    put(tempedge.destinations, currstate)
2210 | 
2211 |    put(state2.edges, tempedge)
2212 |    tempedge := edge("r", [])
2213 |    currstate := pop(myautomata.states)
2214 |    put(myautomata.states, currstate)
2215 | 
2216 |    while currstate.label ~= 95 do {
2217 |       currstate := pop(myautomata.states)
2218 |       put(myautomata.states, currstate)
2219 |       }
2220 |    put(tempedge.destinations, currstate)
2221 | 
2222 |    put(state2.edges, tempedge)
2223 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2224 |    currstate := pop(myautomata.states)
2225 |    put(myautomata.states, currstate)
2226 | 
2227 |    while currstate.label ~= 96 do {
2228 |       currstate := pop(myautomata.states)
2229 |       put(myautomata.states, currstate)
2230 |       }
2231 |    put(tempedge.destinations, currstate)
2232 | 
2233 |    put(state2.edges, tempedge)
2234 |    currstate := pop(myautomata.states)
2235 |    put(myautomata.states, currstate)
2236 | 
2237 |    while currstate.label ~= 60 do {
2238 |       currstate := pop(myautomata.states)
2239 |       put(myautomata.states, currstate)
2240 |       }
2241 |    state2 := currstate
2242 | 
2243 |    currstate := pop(myautomata.states)
2244 |    put(myautomata.states, currstate)
2245 | 
2246 |    while currstate.label ~= 61 do {
2247 |       currstate := pop(myautomata.states)
2248 |       put(myautomata.states, currstate)
2249 |       }
2250 |    state2 := currstate
2251 | 
2252 |    currstate := pop(myautomata.states)
2253 |    put(myautomata.states, currstate)
2254 | 
2255 |    while currstate.label ~= 62 do {
2256 |       currstate := pop(myautomata.states)
2257 |       put(myautomata.states, currstate)
2258 |       }
2259 |    state2 := currstate
2260 | 
2261 |    currstate := pop(myautomata.states)
2262 |    put(myautomata.states, currstate)
2263 | 
2264 |    while currstate.label ~= 63 do {
2265 |       currstate := pop(myautomata.states)
2266 |       put(myautomata.states, currstate)
2267 |       }
2268 |    state2 := currstate
2269 | 
2270 |    currstate := pop(myautomata.states)
2271 |    put(myautomata.states, currstate)
2272 | 
2273 |    while currstate.label ~= 64 do {
2274 |       currstate := pop(myautomata.states)
2275 |       put(myautomata.states, currstate)
2276 |       }
2277 |    state2 := currstate
2278 | 
2279 |    currstate := pop(myautomata.states)
2280 |    put(myautomata.states, currstate)
2281 | 
2282 |    while currstate.label ~= 65 do {
2283 |       currstate := pop(myautomata.states)
2284 |       put(myautomata.states, currstate)
2285 |       }
2286 |    state2 := currstate
2287 | 
2288 |    currstate := pop(myautomata.states)
2289 |    put(myautomata.states, currstate)
2290 | 
2291 |    while currstate.label ~= 66 do {
2292 |       currstate := pop(myautomata.states)
2293 |       put(myautomata.states, currstate)
2294 |       }
2295 |    state2 := currstate
2296 | 
2297 |    currstate := pop(myautomata.states)
2298 |    put(myautomata.states, currstate)
2299 | 
2300 |    while currstate.label ~= 67 do {
2301 |       currstate := pop(myautomata.states)
2302 |       put(myautomata.states, currstate)
2303 |       }
2304 |    state2 := currstate
2305 | 
2306 |    currstate := pop(myautomata.states)
2307 |    put(myautomata.states, currstate)
2308 | 
2309 |    while currstate.label ~= 68 do {
2310 |       currstate := pop(myautomata.states)
2311 |       put(myautomata.states, currstate)
2312 |       }
2313 |    state2 := currstate
2314 | 
2315 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
2316 |    currstate := pop(myautomata.states)
2317 |    put(myautomata.states, currstate)
2318 | 
2319 |    while currstate.label ~= 68 do {
2320 |       currstate := pop(myautomata.states)
2321 |       put(myautomata.states, currstate)
2322 |       }
2323 |    put(tempedge.destinations, currstate)
2324 | 
2325 |    put(state2.edges, tempedge)
2326 |    currstate := pop(myautomata.states)
2327 |    put(myautomata.states, currstate)
2328 | 
2329 |    while currstate.label ~= 69 do {
2330 |       currstate := pop(myautomata.states)
2331 |       put(myautomata.states, currstate)
2332 |       }
2333 |    state2 := currstate
2334 | 
2335 |    tempedge := edge(csetfromrecset("[+-]"), [])
2336 |    currstate := pop(myautomata.states)
2337 |    put(myautomata.states, currstate)
2338 | 
2339 |    while currstate.label ~= 97 do {
2340 |       currstate := pop(myautomata.states)
2341 |       put(myautomata.states, currstate)
2342 |       }
2343 |    put(tempedge.destinations, currstate)
2344 | 
2345 |    put(state2.edges, tempedge)
2346 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2347 |    currstate := pop(myautomata.states)
2348 |    put(myautomata.states, currstate)
2349 | 
2350 |    while currstate.label ~= 98 do {
2351 |       currstate := pop(myautomata.states)
2352 |       put(myautomata.states, currstate)
2353 |       }
2354 |    put(tempedge.destinations, currstate)
2355 | 
2356 |    put(state2.edges, tempedge)
2357 |    currstate := pop(myautomata.states)
2358 |    put(myautomata.states, currstate)
2359 | 
2360 |    while currstate.label ~= 70 do {
2361 |       currstate := pop(myautomata.states)
2362 |       put(myautomata.states, currstate)
2363 |       }
2364 |    state2 := currstate
2365 | 
2366 |    tempedge := edge(csetfromrecset("[eE]"), [])
2367 |    currstate := pop(myautomata.states)
2368 |    put(myautomata.states, currstate)
2369 | 
2370 |    while currstate.label ~= 69 do {
2371 |       currstate := pop(myautomata.states)
2372 |       put(myautomata.states, currstate)
2373 |       }
2374 |    put(tempedge.destinations, currstate)
2375 | 
2376 |    put(state2.edges, tempedge)
2377 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2378 |    currstate := pop(myautomata.states)
2379 |    put(myautomata.states, currstate)
2380 | 
2381 |    while currstate.label ~= 70 do {
2382 |       currstate := pop(myautomata.states)
2383 |       put(myautomata.states, currstate)
2384 |       }
2385 |    put(tempedge.destinations, currstate)
2386 | 
2387 |    put(state2.edges, tempedge)
2388 |    currstate := pop(myautomata.states)
2389 |    put(myautomata.states, currstate)
2390 | 
2391 |    while currstate.label ~= 71 do {
2392 |       currstate := pop(myautomata.states)
2393 |       put(myautomata.states, currstate)
2394 |       }
2395 |    state2 := currstate
2396 | 
2397 |    tempedge := edge(csetfromrecset("[eE]"), [])
2398 |    currstate := pop(myautomata.states)
2399 |    put(myautomata.states, currstate)
2400 | 
2401 |    while currstate.label ~= 69 do {
2402 |       currstate := pop(myautomata.states)
2403 |       put(myautomata.states, currstate)
2404 |       }
2405 |    put(tempedge.destinations, currstate)
2406 | 
2407 |    put(state2.edges, tempedge)
2408 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2409 |    currstate := pop(myautomata.states)
2410 |    put(myautomata.states, currstate)
2411 | 
2412 |    while currstate.label ~= 70 do {
2413 |       currstate := pop(myautomata.states)
2414 |       put(myautomata.states, currstate)
2415 |       }
2416 |    put(tempedge.destinations, currstate)
2417 | 
2418 |    put(state2.edges, tempedge)
2419 |    currstate := pop(myautomata.states)
2420 |    put(myautomata.states, currstate)
2421 | 
2422 |    while currstate.label ~= 72 do {
2423 |       currstate := pop(myautomata.states)
2424 |       put(myautomata.states, currstate)
2425 |       }
2426 |    state2 := currstate
2427 | 
2428 |    tempedge := edge(csetfromrecset("[+-]"), [])
2429 |    currstate := pop(myautomata.states)
2430 |    put(myautomata.states, currstate)
2431 | 
2432 |    while currstate.label ~= 99 do {
2433 |       currstate := pop(myautomata.states)
2434 |       put(myautomata.states, currstate)
2435 |       }
2436 |    put(tempedge.destinations, currstate)
2437 | 
2438 |    put(state2.edges, tempedge)
2439 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2440 |    currstate := pop(myautomata.states)
2441 |    put(myautomata.states, currstate)
2442 | 
2443 |    while currstate.label ~= 100 do {
2444 |       currstate := pop(myautomata.states)
2445 |       put(myautomata.states, currstate)
2446 |       }
2447 |    put(tempedge.destinations, currstate)
2448 | 
2449 |    put(state2.edges, tempedge)
2450 |    currstate := pop(myautomata.states)
2451 |    put(myautomata.states, currstate)
2452 | 
2453 |    while currstate.label ~= 73 do {
2454 |       currstate := pop(myautomata.states)
2455 |       put(myautomata.states, currstate)
2456 |       }
2457 |    state2 := currstate
2458 | 
2459 |    tempedge := edge(csetfromrecset("[^\"]"), [])
2460 |    currstate := pop(myautomata.states)
2461 |    put(myautomata.states, currstate)
2462 | 
2463 |    while currstate.label ~= 73 do {
2464 |       currstate := pop(myautomata.states)
2465 |       put(myautomata.states, currstate)
2466 |       }
2467 |    put(tempedge.destinations, currstate)
2468 | 
2469 |    put(state2.edges, tempedge)
2470 |    tempedge := edge("\\", [])
2471 |    currstate := pop(myautomata.states)
2472 |    put(myautomata.states, currstate)
2473 | 
2474 |    while currstate.label ~= 74 do {
2475 |       currstate := pop(myautomata.states)
2476 |       put(myautomata.states, currstate)
2477 |       }
2478 |    put(tempedge.destinations, currstate)
2479 | 
2480 |    put(state2.edges, tempedge)
2481 |    tempedge := edge("\"", [])
2482 |    currstate := pop(myautomata.states)
2483 |    put(myautomata.states, currstate)
2484 | 
2485 |    while currstate.label ~= 75 do {
2486 |       currstate := pop(myautomata.states)
2487 |       put(myautomata.states, currstate)
2488 |       }
2489 |    put(tempedge.destinations, currstate)
2490 | 
2491 |    put(state2.edges, tempedge)
2492 |    currstate := pop(myautomata.states)
2493 |    put(myautomata.states, currstate)
2494 | 
2495 |    while currstate.label ~= 74 do {
2496 |       currstate := pop(myautomata.states)
2497 |       put(myautomata.states, currstate)
2498 |       }
2499 |    state2 := currstate
2500 | 
2501 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2502 |    currstate := pop(myautomata.states)
2503 |    put(myautomata.states, currstate)
2504 | 
2505 |    while currstate.label ~= 101 do {
2506 |       currstate := pop(myautomata.states)
2507 |       put(myautomata.states, currstate)
2508 |       }
2509 |    put(tempedge.destinations, currstate)
2510 | 
2511 |    put(state2.edges, tempedge)
2512 |    currstate := pop(myautomata.states)
2513 |    put(myautomata.states, currstate)
2514 | 
2515 |    while currstate.label ~= 75 do {
2516 |       currstate := pop(myautomata.states)
2517 |       put(myautomata.states, currstate)
2518 |       }
2519 |    state2 := currstate
2520 | 
2521 |    currstate := pop(myautomata.states)
2522 |    put(myautomata.states, currstate)
2523 | 
2524 |    while currstate.label ~= 76 do {
2525 |       currstate := pop(myautomata.states)
2526 |       put(myautomata.states, currstate)
2527 |       }
2528 |    state2 := currstate
2529 | 
2530 |    currstate := pop(myautomata.states)
2531 |    put(myautomata.states, currstate)
2532 | 
2533 |    while currstate.label ~= 77 do {
2534 |       currstate := pop(myautomata.states)
2535 |       put(myautomata.states, currstate)
2536 |       }
2537 |    state2 := currstate
2538 | 
2539 |    tempedge := edge("s", [])
2540 |    currstate := pop(myautomata.states)
2541 |    put(myautomata.states, currstate)
2542 | 
2543 |    while currstate.label ~= 102 do {
2544 |       currstate := pop(myautomata.states)
2545 |       put(myautomata.states, currstate)
2546 |       }
2547 |    put(tempedge.destinations, currstate)
2548 | 
2549 |    put(state2.edges, tempedge)
2550 |    currstate := pop(myautomata.states)
2551 |    put(myautomata.states, currstate)
2552 | 
2553 |    while currstate.label ~= 78 do {
2554 |       currstate := pop(myautomata.states)
2555 |       put(myautomata.states, currstate)
2556 |       }
2557 |    state2 := currstate
2558 | 
2559 |    tempedge := edge("l", [])
2560 |    currstate := pop(myautomata.states)
2561 |    put(myautomata.states, currstate)
2562 | 
2563 |    while currstate.label ~= 103 do {
2564 |       currstate := pop(myautomata.states)
2565 |       put(myautomata.states, currstate)
2566 |       }
2567 |    put(tempedge.destinations, currstate)
2568 | 
2569 |    put(state2.edges, tempedge)
2570 |    currstate := pop(myautomata.states)
2571 |    put(myautomata.states, currstate)
2572 | 
2573 |    while currstate.label ~= 79 do {
2574 |       currstate := pop(myautomata.states)
2575 |       put(myautomata.states, currstate)
2576 |       }
2577 |    state2 := currstate
2578 | 
2579 |    tempedge := edge("l", [])
2580 |    currstate := pop(myautomata.states)
2581 |    put(myautomata.states, currstate)
2582 | 
2583 |    while currstate.label ~= 104 do {
2584 |       currstate := pop(myautomata.states)
2585 |       put(myautomata.states, currstate)
2586 |       }
2587 |    put(tempedge.destinations, currstate)
2588 | 
2589 |    put(state2.edges, tempedge)
2590 |    currstate := pop(myautomata.states)
2591 |    put(myautomata.states, currstate)
2592 | 
2593 |    while currstate.label ~= 80 do {
2594 |       currstate := pop(myautomata.states)
2595 |       put(myautomata.states, currstate)
2596 |       }
2597 |    state2 := currstate
2598 | 
2599 |    tempedge := edge("e", [])
2600 |    currstate := pop(myautomata.states)
2601 |    put(myautomata.states, currstate)
2602 | 
2603 |    while currstate.label ~= 105 do {
2604 |       currstate := pop(myautomata.states)
2605 |       put(myautomata.states, currstate)
2606 |       }
2607 |    put(tempedge.destinations, currstate)
2608 | 
2609 |    put(state2.edges, tempedge)
2610 |    currstate := pop(myautomata.states)
2611 |    put(myautomata.states, currstate)
2612 | 
2613 |    while currstate.label ~= 81 do {
2614 |       currstate := pop(myautomata.states)
2615 |       put(myautomata.states, currstate)
2616 |       }
2617 |    state2 := currstate
2618 | 
2619 |    tempedge := edge("u", [])
2620 |    currstate := pop(myautomata.states)
2621 |    put(myautomata.states, currstate)
2622 | 
2623 |    while currstate.label ~= 106 do {
2624 |       currstate := pop(myautomata.states)
2625 |       put(myautomata.states, currstate)
2626 |       }
2627 |    put(tempedge.destinations, currstate)
2628 | 
2629 |    put(state2.edges, tempedge)
2630 |    currstate := pop(myautomata.states)
2631 |    put(myautomata.states, currstate)
2632 | 
2633 |    while currstate.label ~= 82 do {
2634 |       currstate := pop(myautomata.states)
2635 |       put(myautomata.states, currstate)
2636 |       }
2637 |    state2 := currstate
2638 | 
2639 |    tempedge := edge("\a", [])
2640 |    currstate := pop(myautomata.states)
2641 |    put(myautomata.states, currstate)
2642 | 
2643 |    while currstate.label ~= 107 do {
2644 |       currstate := pop(myautomata.states)
2645 |       put(myautomata.states, currstate)
2646 |       }
2647 |    put(tempedge.destinations, currstate)
2648 | 
2649 |    put(state2.edges, tempedge)
2650 |    currstate := pop(myautomata.states)
2651 |    put(myautomata.states, currstate)
2652 | 
2653 |    while currstate.label ~= 83 do {
2654 |       currstate := pop(myautomata.states)
2655 |       put(myautomata.states, currstate)
2656 |       }
2657 |    state2 := currstate
2658 | 
2659 |    tempedge := edge("l", [])
2660 |    currstate := pop(myautomata.states)
2661 |    put(myautomata.states, currstate)
2662 | 
2663 |    while currstate.label ~= 108 do {
2664 |       currstate := pop(myautomata.states)
2665 |       put(myautomata.states, currstate)
2666 |       }
2667 |    put(tempedge.destinations, currstate)
2668 | 
2669 |    put(state2.edges, tempedge)
2670 |    currstate := pop(myautomata.states)
2671 |    put(myautomata.states, currstate)
2672 | 
2673 |    while currstate.label ~= 84 do {
2674 |       currstate := pop(myautomata.states)
2675 |       put(myautomata.states, currstate)
2676 |       }
2677 |    state2 := currstate
2678 | 
2679 |    tempedge := edge("d", [])
2680 |    currstate := pop(myautomata.states)
2681 |    put(myautomata.states, currstate)
2682 | 
2683 |    while currstate.label ~= 109 do {
2684 |       currstate := pop(myautomata.states)
2685 |       put(myautomata.states, currstate)
2686 |       }
2687 |    put(tempedge.destinations, currstate)
2688 | 
2689 |    put(state2.edges, tempedge)
2690 |    currstate := pop(myautomata.states)
2691 |    put(myautomata.states, currstate)
2692 | 
2693 |    while currstate.label ~= 85 do {
2694 |       currstate := pop(myautomata.states)
2695 |       put(myautomata.states, currstate)
2696 |       }
2697 |    state2 := currstate
2698 | 
2699 |    tempedge := edge("b", [])
2700 |    currstate := pop(myautomata.states)
2701 |    put(myautomata.states, currstate)
2702 | 
2703 |    while currstate.label ~= 110 do {
2704 |       currstate := pop(myautomata.states)
2705 |       put(myautomata.states, currstate)
2706 |       }
2707 |    put(tempedge.destinations, currstate)
2708 | 
2709 |    put(state2.edges, tempedge)
2710 |    currstate := pop(myautomata.states)
2711 |    put(myautomata.states, currstate)
2712 | 
2713 |    while currstate.label ~= 86 do {
2714 |       currstate := pop(myautomata.states)
2715 |       put(myautomata.states, currstate)
2716 |       }
2717 |    state2 := currstate
2718 | 
2719 |    tempedge := edge("l", [])
2720 |    currstate := pop(myautomata.states)
2721 |    put(myautomata.states, currstate)
2722 | 
2723 |    while currstate.label ~= 111 do {
2724 |       currstate := pop(myautomata.states)
2725 |       put(myautomata.states, currstate)
2726 |       }
2727 |    put(tempedge.destinations, currstate)
2728 | 
2729 |    put(state2.edges, tempedge)
2730 |    currstate := pop(myautomata.states)
2731 |    put(myautomata.states, currstate)
2732 | 
2733 |    while currstate.label ~= 87 do {
2734 |       currstate := pop(myautomata.states)
2735 |       put(myautomata.states, currstate)
2736 |       }
2737 |    state2 := currstate
2738 | 
2739 |    currstate := pop(myautomata.states)
2740 |    put(myautomata.states, currstate)
2741 | 
2742 |    while currstate.label ~= 88 do {
2743 |       currstate := pop(myautomata.states)
2744 |       put(myautomata.states, currstate)
2745 |       }
2746 |    state2 := currstate
2747 | 
2748 |    tempedge := edge("e", [])
2749 |    currstate := pop(myautomata.states)
2750 |    put(myautomata.states, currstate)
2751 | 
2752 |    while currstate.label ~= 112 do {
2753 |       currstate := pop(myautomata.states)
2754 |       put(myautomata.states, currstate)
2755 |       }
2756 |    put(tempedge.destinations, currstate)
2757 | 
2758 |    put(state2.edges, tempedge)
2759 |    currstate := pop(myautomata.states)
2760 |    put(myautomata.states, currstate)
2761 | 
2762 |    while currstate.label ~= 89 do {
2763 |       currstate := pop(myautomata.states)
2764 |       put(myautomata.states, currstate)
2765 |       }
2766 |    state2 := currstate
2767 | 
2768 |    tempedge := edge("s", [])
2769 |    currstate := pop(myautomata.states)
2770 |    put(myautomata.states, currstate)
2771 | 
2772 |    while currstate.label ~= 113 do {
2773 |       currstate := pop(myautomata.states)
2774 |       put(myautomata.states, currstate)
2775 |       }
2776 |    put(tempedge.destinations, currstate)
2777 | 
2778 |    put(state2.edges, tempedge)
2779 |    currstate := pop(myautomata.states)
2780 |    put(myautomata.states, currstate)
2781 | 
2782 |    while currstate.label ~= 90 do {
2783 |       currstate := pop(myautomata.states)
2784 |       put(myautomata.states, currstate)
2785 |       }
2786 |    state2 := currstate
2787 | 
2788 |    tempedge := edge("i", [])
2789 |    currstate := pop(myautomata.states)
2790 |    put(myautomata.states, currstate)
2791 | 
2792 |    while currstate.label ~= 114 do {
2793 |       currstate := pop(myautomata.states)
2794 |       put(myautomata.states, currstate)
2795 |       }
2796 |    put(tempedge.destinations, currstate)
2797 | 
2798 |    put(state2.edges, tempedge)
2799 |    currstate := pop(myautomata.states)
2800 |    put(myautomata.states, currstate)
2801 | 
2802 |    while currstate.label ~= 91 do {
2803 |       currstate := pop(myautomata.states)
2804 |       put(myautomata.states, currstate)
2805 |       }
2806 |    state2 := currstate
2807 | 
2808 |    tempedge := edge("t", [])
2809 |    currstate := pop(myautomata.states)
2810 |    put(myautomata.states, currstate)
2811 | 
2812 |    while currstate.label ~= 115 do {
2813 |       currstate := pop(myautomata.states)
2814 |       put(myautomata.states, currstate)
2815 |       }
2816 |    put(tempedge.destinations, currstate)
2817 | 
2818 |    put(state2.edges, tempedge)
2819 |    currstate := pop(myautomata.states)
2820 |    put(myautomata.states, currstate)
2821 | 
2822 |    while currstate.label ~= 92 do {
2823 |       currstate := pop(myautomata.states)
2824 |       put(myautomata.states, currstate)
2825 |       }
2826 |    state2 := currstate
2827 | 
2828 |    tempedge := edge(csetfromrecset("[^*]"), [])
2829 |    currstate := pop(myautomata.states)
2830 |    put(myautomata.states, currstate)
2831 | 
2832 |    while currstate.label ~= 92 do {
2833 |       currstate := pop(myautomata.states)
2834 |       put(myautomata.states, currstate)
2835 |       }
2836 |    put(tempedge.destinations, currstate)
2837 | 
2838 |    put(state2.edges, tempedge)
2839 |    tempedge := edge("*", [])
2840 |    currstate := pop(myautomata.states)
2841 |    put(myautomata.states, currstate)
2842 | 
2843 |    while currstate.label ~= 93 do {
2844 |       currstate := pop(myautomata.states)
2845 |       put(myautomata.states, currstate)
2846 |       }
2847 |    put(tempedge.destinations, currstate)
2848 | 
2849 |    put(state2.edges, tempedge)
2850 |    currstate := pop(myautomata.states)
2851 |    put(myautomata.states, currstate)
2852 | 
2853 |    while currstate.label ~= 93 do {
2854 |       currstate := pop(myautomata.states)
2855 |       put(myautomata.states, currstate)
2856 |       }
2857 |    state2 := currstate
2858 | 
2859 |    tempedge := edge(csetfromrecset("[^/*]"), [])
2860 |    currstate := pop(myautomata.states)
2861 |    put(myautomata.states, currstate)
2862 | 
2863 |    while currstate.label ~= 116 do {
2864 |       currstate := pop(myautomata.states)
2865 |       put(myautomata.states, currstate)
2866 |       }
2867 |    put(tempedge.destinations, currstate)
2868 | 
2869 |    put(state2.edges, tempedge)
2870 |    tempedge := edge("*", [])
2871 |    currstate := pop(myautomata.states)
2872 |    put(myautomata.states, currstate)
2873 | 
2874 |    while currstate.label ~= 93 do {
2875 |       currstate := pop(myautomata.states)
2876 |       put(myautomata.states, currstate)
2877 |       }
2878 |    put(tempedge.destinations, currstate)
2879 | 
2880 |    put(state2.edges, tempedge)
2881 |    tempedge := edge("/", [])
2882 |    currstate := pop(myautomata.states)
2883 |    put(myautomata.states, currstate)
2884 | 
2885 |    while currstate.label ~= 117 do {
2886 |       currstate := pop(myautomata.states)
2887 |       put(myautomata.states, currstate)
2888 |       }
2889 |    put(tempedge.destinations, currstate)
2890 | 
2891 |    put(state2.edges, tempedge)
2892 |    currstate := pop(myautomata.states)
2893 |    put(myautomata.states, currstate)
2894 | 
2895 |    while currstate.label ~= 94 do {
2896 |       currstate := pop(myautomata.states)
2897 |       put(myautomata.states, currstate)
2898 |       }
2899 |    state2 := currstate
2900 | 
2901 |    currstate := pop(myautomata.states)
2902 |    put(myautomata.states, currstate)
2903 | 
2904 |    while currstate.label ~= 95 do {
2905 |       currstate := pop(myautomata.states)
2906 |       put(myautomata.states, currstate)
2907 |       }
2908 |    state2 := currstate
2909 | 
2910 |    tempedge := edge("\n"
2911 | , [])
2912 |    currstate := pop(myautomata.states)
2913 |    put(myautomata.states, currstate)
2914 | 
2915 |    while currstate.label ~= 94 do {
2916 |       currstate := pop(myautomata.states)
2917 |       put(myautomata.states, currstate)
2918 |       }
2919 |    put(tempedge.destinations, currstate)
2920 | 
2921 |    put(state2.edges, tempedge)
2922 |    currstate := pop(myautomata.states)
2923 |    put(myautomata.states, currstate)
2924 | 
2925 |    while currstate.label ~= 96 do {
2926 |       currstate := pop(myautomata.states)
2927 |       put(myautomata.states, currstate)
2928 |       }
2929 |    state2 := currstate
2930 | 
2931 |    tempedge := edge("\n"
2932 | , [])
2933 |    currstate := pop(myautomata.states)
2934 |    put(myautomata.states, currstate)
2935 | 
2936 |    while currstate.label ~= 94 do {
2937 |       currstate := pop(myautomata.states)
2938 |       put(myautomata.states, currstate)
2939 |       }
2940 |    put(tempedge.destinations, currstate)
2941 | 
2942 |    put(state2.edges, tempedge)
2943 |    tempedge := edge("r", [])
2944 |    currstate := pop(myautomata.states)
2945 |    put(myautomata.states, currstate)
2946 | 
2947 |    while currstate.label ~= 95 do {
2948 |       currstate := pop(myautomata.states)
2949 |       put(myautomata.states, currstate)
2950 |       }
2951 |    put(tempedge.destinations, currstate)
2952 | 
2953 |    put(state2.edges, tempedge)
2954 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2955 |    currstate := pop(myautomata.states)
2956 |    put(myautomata.states, currstate)
2957 | 
2958 |    while currstate.label ~= 96 do {
2959 |       currstate := pop(myautomata.states)
2960 |       put(myautomata.states, currstate)
2961 |       }
2962 |    put(tempedge.destinations, currstate)
2963 | 
2964 |    put(state2.edges, tempedge)
2965 |    currstate := pop(myautomata.states)
2966 |    put(myautomata.states, currstate)
2967 | 
2968 |    while currstate.label ~= 97 do {
2969 |       currstate := pop(myautomata.states)
2970 |       put(myautomata.states, currstate)
2971 |       }
2972 |    state2 := currstate
2973 | 
2974 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2975 |    currstate := pop(myautomata.states)
2976 |    put(myautomata.states, currstate)
2977 | 
2978 |    while currstate.label ~= 98 do {
2979 |       currstate := pop(myautomata.states)
2980 |       put(myautomata.states, currstate)
2981 |       }
2982 |    put(tempedge.destinations, currstate)
2983 | 
2984 |    put(state2.edges, tempedge)
2985 |    currstate := pop(myautomata.states)
2986 |    put(myautomata.states, currstate)
2987 | 
2988 |    while currstate.label ~= 98 do {
2989 |       currstate := pop(myautomata.states)
2990 |       put(myautomata.states, currstate)
2991 |       }
2992 |    state2 := currstate
2993 | 
2994 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2995 |    currstate := pop(myautomata.states)
2996 |    put(myautomata.states, currstate)
2997 | 
2998 |    while currstate.label ~= 98 do {
2999 |       currstate := pop(myautomata.states)
3000 |       put(myautomata.states, currstate)
3001 |       }
3002 |    put(tempedge.destinations, currstate)
3003 | 
3004 |    put(state2.edges, tempedge)
3005 |    currstate := pop(myautomata.states)
3006 |    put(myautomata.states, currstate)
3007 | 
3008 |    while currstate.label ~= 99 do {
3009 |       currstate := pop(myautomata.states)
3010 |       put(myautomata.states, currstate)
3011 |       }
3012 |    state2 := currstate
3013 | 
3014 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3015 |    currstate := pop(myautomata.states)
3016 |    put(myautomata.states, currstate)
3017 | 
3018 |    while currstate.label ~= 100 do {
3019 |       currstate := pop(myautomata.states)
3020 |       put(myautomata.states, currstate)
3021 |       }
3022 |    put(tempedge.destinations, currstate)
3023 | 
3024 |    put(state2.edges, tempedge)
3025 |    currstate := pop(myautomata.states)
3026 |    put(myautomata.states, currstate)
3027 | 
3028 |    while currstate.label ~= 100 do {
3029 |       currstate := pop(myautomata.states)
3030 |       put(myautomata.states, currstate)
3031 |       }
3032 |    state2 := currstate
3033 | 
3034 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3035 |    currstate := pop(myautomata.states)
3036 |    put(myautomata.states, currstate)
3037 | 
3038 |    while currstate.label ~= 100 do {
3039 |       currstate := pop(myautomata.states)
3040 |       put(myautomata.states, currstate)
3041 |       }
3042 |    put(tempedge.destinations, currstate)
3043 | 
3044 |    put(state2.edges, tempedge)
3045 |    currstate := pop(myautomata.states)
3046 |    put(myautomata.states, currstate)
3047 | 
3048 |    while currstate.label ~= 101 do {
3049 |       currstate := pop(myautomata.states)
3050 |       put(myautomata.states, currstate)
3051 |       }
3052 |    state2 := currstate
3053 | 
3054 |    tempedge := edge(csetfromrecset("[^\"]"), [])
3055 |    currstate := pop(myautomata.states)
3056 |    put(myautomata.states, currstate)
3057 | 
3058 |    while currstate.label ~= 73 do {
3059 |       currstate := pop(myautomata.states)
3060 |       put(myautomata.states, currstate)
3061 |       }
3062 |    put(tempedge.destinations, currstate)
3063 | 
3064 |    put(state2.edges, tempedge)
3065 |    tempedge := edge("\\", [])
3066 |    currstate := pop(myautomata.states)
3067 |    put(myautomata.states, currstate)
3068 | 
3069 |    while currstate.label ~= 74 do {
3070 |       currstate := pop(myautomata.states)
3071 |       put(myautomata.states, currstate)
3072 |       }
3073 |    put(tempedge.destinations, currstate)
3074 | 
3075 |    put(state2.edges, tempedge)
3076 |    tempedge := edge("\"", [])
3077 |    currstate := pop(myautomata.states)
3078 |    put(myautomata.states, currstate)
3079 | 
3080 |    while currstate.label ~= 75 do {
3081 |       currstate := pop(myautomata.states)
3082 |       put(myautomata.states, currstate)
3083 |       }
3084 |    put(tempedge.destinations, currstate)
3085 | 
3086 |    put(state2.edges, tempedge)
3087 |    currstate := pop(myautomata.states)
3088 |    put(myautomata.states, currstate)
3089 | 
3090 |    while currstate.label ~= 102 do {
3091 |       currstate := pop(myautomata.states)
3092 |       put(myautomata.states, currstate)
3093 |       }
3094 |    state2 := currstate
3095 | 
3096 |    tempedge := edge("e", [])
3097 |    currstate := pop(myautomata.states)
3098 |    put(myautomata.states, currstate)
3099 | 
3100 |    while currstate.label ~= 118 do {
3101 |       currstate := pop(myautomata.states)
3102 |       put(myautomata.states, currstate)
3103 |       }
3104 |    put(tempedge.destinations, currstate)
3105 | 
3106 |    put(state2.edges, tempedge)
3107 |    currstate := pop(myautomata.states)
3108 |    put(myautomata.states, currstate)
3109 | 
3110 |    while currstate.label ~= 103 do {
3111 |       currstate := pop(myautomata.states)
3112 |       put(myautomata.states, currstate)
3113 |       }
3114 |    state2 := currstate
3115 | 
3116 |    tempedge := edge("i", [])
3117 |    currstate := pop(myautomata.states)
3118 |    put(myautomata.states, currstate)
3119 | 
3120 |    while currstate.label ~= 119 do {
3121 |       currstate := pop(myautomata.states)
3122 |       put(myautomata.states, currstate)
3123 |       }
3124 |    put(tempedge.destinations, currstate)
3125 | 
3126 |    put(state2.edges, tempedge)
3127 |    currstate := pop(myautomata.states)
3128 |    put(myautomata.states, currstate)
3129 | 
3130 |    while currstate.label ~= 104 do {
3131 |       currstate := pop(myautomata.states)
3132 |       put(myautomata.states, currstate)
3133 |       }
3134 |    state2 := currstate
3135 | 
3136 |    currstate := pop(myautomata.states)
3137 |    put(myautomata.states, currstate)
3138 | 
3139 |    while currstate.label ~= 105 do {
3140 |       currstate := pop(myautomata.states)
3141 |       put(myautomata.states, currstate)
3142 |       }
3143 |    state2 := currstate
3144 | 
3145 |    currstate := pop(myautomata.states)
3146 |    put(myautomata.states, currstate)
3147 | 
3148 |    while currstate.label ~= 106 do {
3149 |       currstate := pop(myautomata.states)
3150 |       put(myautomata.states, currstate)
3151 |       }
3152 |    state2 := currstate
3153 | 
3154 |    tempedge := edge("r", [])
3155 |    currstate := pop(myautomata.states)
3156 |    put(myautomata.states, currstate)
3157 | 
3158 |    while currstate.label ~= 120 do {
3159 |       currstate := pop(myautomata.states)
3160 |       put(myautomata.states, currstate)
3161 |       }
3162 |    put(tempedge.destinations, currstate)
3163 | 
3164 |    put(state2.edges, tempedge)
3165 |    currstate := pop(myautomata.states)
3166 |    put(myautomata.states, currstate)
3167 | 
3168 |    while currstate.label ~= 107 do {
3169 |       currstate := pop(myautomata.states)
3170 |       put(myautomata.states, currstate)
3171 |       }
3172 |    state2 := currstate
3173 | 
3174 |    tempedge := edge("k", [])
3175 |    currstate := pop(myautomata.states)
3176 |    put(myautomata.states, currstate)
3177 | 
3178 |    while currstate.label ~= 121 do {
3179 |       currstate := pop(myautomata.states)
3180 |       put(myautomata.states, currstate)
3181 |       }
3182 |    put(tempedge.destinations, currstate)
3183 | 
3184 |    put(state2.edges, tempedge)
3185 |    currstate := pop(myautomata.states)
3186 |    put(myautomata.states, currstate)
3187 | 
3188 |    while currstate.label ~= 108 do {
3189 |       currstate := pop(myautomata.states)
3190 |       put(myautomata.states, currstate)
3191 |       }
3192 |    state2 := currstate
3193 | 
3194 |    currstate := pop(myautomata.states)
3195 |    put(myautomata.states, currstate)
3196 | 
3197 |    while currstate.label ~= 109 do {
3198 |       currstate := pop(myautomata.states)
3199 |       put(myautomata.states, currstate)
3200 |       }
3201 |    state2 := currstate
3202 | 
3203 |    currstate := pop(myautomata.states)
3204 |    put(myautomata.states, currstate)
3205 | 
3206 |    while currstate.label ~= 110 do {
3207 |       currstate := pop(myautomata.states)
3208 |       put(myautomata.states, currstate)
3209 |       }
3210 |    state2 := currstate
3211 | 
3212 |    tempedge := edge("l", [])
3213 |    currstate := pop(myautomata.states)
3214 |    put(myautomata.states, currstate)
3215 | 
3216 |    while currstate.label ~= 122 do {
3217 |       currstate := pop(myautomata.states)
3218 |       put(myautomata.states, currstate)
3219 |       }
3220 |    put(tempedge.destinations, currstate)
3221 | 
3222 |    put(state2.edges, tempedge)
3223 |    currstate := pop(myautomata.states)
3224 |    put(myautomata.states, currstate)
3225 | 
3226 |    while currstate.label ~= 111 do {
3227 |       currstate := pop(myautomata.states)
3228 |       put(myautomata.states, currstate)
3229 |       }
3230 |    state2 := currstate
3231 | 
3232 |    tempedge := edge("e", [])
3233 |    currstate := pop(myautomata.states)
3234 |    put(myautomata.states, currstate)
3235 | 
3236 |    while currstate.label ~= 123 do {
3237 |       currstate := pop(myautomata.states)
3238 |       put(myautomata.states, currstate)
3239 |       }
3240 |    put(tempedge.destinations, currstate)
3241 | 
3242 |    put(state2.edges, tempedge)
3243 |    currstate := pop(myautomata.states)
3244 |    put(myautomata.states, currstate)
3245 | 
3246 |    while currstate.label ~= 112 do {
3247 |       currstate := pop(myautomata.states)
3248 |       put(myautomata.states, currstate)
3249 |       }
3250 |    state2 := currstate
3251 | 
3252 |    currstate := pop(myautomata.states)
3253 |    put(myautomata.states, currstate)
3254 | 
3255 |    while currstate.label ~= 113 do {
3256 |       currstate := pop(myautomata.states)
3257 |       put(myautomata.states, currstate)
3258 |       }
3259 |    state2 := currstate
3260 | 
3261 |    tempedge := edge("s", [])
3262 |    currstate := pop(myautomata.states)
3263 |    put(myautomata.states, currstate)
3264 | 
3265 |    while currstate.label ~= 124 do {
3266 |       currstate := pop(myautomata.states)
3267 |       put(myautomata.states, currstate)
3268 |       }
3269 |    put(tempedge.destinations, currstate)
3270 | 
3271 |    put(state2.edges, tempedge)
3272 |    currstate := pop(myautomata.states)
3273 |    put(myautomata.states, currstate)
3274 | 
3275 |    while currstate.label ~= 114 do {
3276 |       currstate := pop(myautomata.states)
3277 |       put(myautomata.states, currstate)
3278 |       }
3279 |    state2 := currstate
3280 | 
3281 |    tempedge := edge("n", [])
3282 |    currstate := pop(myautomata.states)
3283 |    put(myautomata.states, currstate)
3284 | 
3285 |    while currstate.label ~= 125 do {
3286 |       currstate := pop(myautomata.states)
3287 |       put(myautomata.states, currstate)
3288 |       }
3289 |    put(tempedge.destinations, currstate)
3290 | 
3291 |    put(state2.edges, tempedge)
3292 |    currstate := pop(myautomata.states)
3293 |    put(myautomata.states, currstate)
3294 | 
3295 |    while currstate.label ~= 115 do {
3296 |       currstate := pop(myautomata.states)
3297 |       put(myautomata.states, currstate)
3298 |       }
3299 |    state2 := currstate
3300 | 
3301 |    tempedge := edge("i", [])
3302 |    currstate := pop(myautomata.states)
3303 |    put(myautomata.states, currstate)
3304 | 
3305 |    while currstate.label ~= 126 do {
3306 |       currstate := pop(myautomata.states)
3307 |       put(myautomata.states, currstate)
3308 |       }
3309 |    put(tempedge.destinations, currstate)
3310 | 
3311 |    put(state2.edges, tempedge)
3312 |    currstate := pop(myautomata.states)
3313 |    put(myautomata.states, currstate)
3314 | 
3315 |    while currstate.label ~= 116 do {
3316 |       currstate := pop(myautomata.states)
3317 |       put(myautomata.states, currstate)
3318 |       }
3319 |    state2 := currstate
3320 | 
3321 |    tempedge := edge(csetfromrecset("[^*]"), [])
3322 |    currstate := pop(myautomata.states)
3323 |    put(myautomata.states, currstate)
3324 | 
3325 |    while currstate.label ~= 92 do {
3326 |       currstate := pop(myautomata.states)
3327 |       put(myautomata.states, currstate)
3328 |       }
3329 |    put(tempedge.destinations, currstate)
3330 | 
3331 |    put(state2.edges, tempedge)
3332 |    tempedge := edge("*", [])
3333 |    currstate := pop(myautomata.states)
3334 |    put(myautomata.states, currstate)
3335 | 
3336 |    while currstate.label ~= 93 do {
3337 |       currstate := pop(myautomata.states)
3338 |       put(myautomata.states, currstate)
3339 |       }
3340 |    put(tempedge.destinations, currstate)
3341 | 
3342 |    put(state2.edges, tempedge)
3343 |    currstate := pop(myautomata.states)
3344 |    put(myautomata.states, currstate)
3345 | 
3346 |    while currstate.label ~= 117 do {
3347 |       currstate := pop(myautomata.states)
3348 |       put(myautomata.states, currstate)
3349 |       }
3350 |    state2 := currstate
3351 | 
3352 |    currstate := pop(myautomata.states)
3353 |    put(myautomata.states, currstate)
3354 | 
3355 |    while currstate.label ~= 118 do {
3356 |       currstate := pop(myautomata.states)
3357 |       put(myautomata.states, currstate)
3358 |       }
3359 |    state2 := currstate
3360 | 
3361 |    currstate := pop(myautomata.states)
3362 |    put(myautomata.states, currstate)
3363 | 
3364 |    while currstate.label ~= 119 do {
3365 |       currstate := pop(myautomata.states)
3366 |       put(myautomata.states, currstate)
3367 |       }
3368 |    state2 := currstate
3369 | 
3370 |    tempedge := edge("c", [])
3371 |    currstate := pop(myautomata.states)
3372 |    put(myautomata.states, currstate)
3373 | 
3374 |    while currstate.label ~= 127 do {
3375 |       currstate := pop(myautomata.states)
3376 |       put(myautomata.states, currstate)
3377 |       }
3378 |    put(tempedge.destinations, currstate)
3379 | 
3380 |    put(state2.edges, tempedge)
3381 |    currstate := pop(myautomata.states)
3382 |    put(myautomata.states, currstate)
3383 | 
3384 |    while currstate.label ~= 120 do {
3385 |       currstate := pop(myautomata.states)
3386 |       put(myautomata.states, currstate)
3387 |       }
3388 |    state2 := currstate
3389 | 
3390 |    tempedge := edge("n", [])
3391 |    currstate := pop(myautomata.states)
3392 |    put(myautomata.states, currstate)
3393 | 
3394 |    while currstate.label ~= 128 do {
3395 |       currstate := pop(myautomata.states)
3396 |       put(myautomata.states, currstate)
3397 |       }
3398 |    put(tempedge.destinations, currstate)
3399 | 
3400 |    put(state2.edges, tempedge)
3401 |    currstate := pop(myautomata.states)
3402 |    put(myautomata.states, currstate)
3403 | 
3404 |    while currstate.label ~= 121 do {
3405 |       currstate := pop(myautomata.states)
3406 |       put(myautomata.states, currstate)
3407 |       }
3408 |    state2 := currstate
3409 | 
3410 |    currstate := pop(myautomata.states)
3411 |    put(myautomata.states, currstate)
3412 | 
3413 |    while currstate.label ~= 122 do {
3414 |       currstate := pop(myautomata.states)
3415 |       put(myautomata.states, currstate)
3416 |       }
3417 |    state2 := currstate
3418 | 
3419 |    tempedge := edge("e", [])
3420 |    currstate := pop(myautomata.states)
3421 |    put(myautomata.states, currstate)
3422 | 
3423 |    while currstate.label ~= 129 do {
3424 |       currstate := pop(myautomata.states)
3425 |       put(myautomata.states, currstate)
3426 |       }
3427 |    put(tempedge.destinations, currstate)
3428 | 
3429 |    put(state2.edges, tempedge)
3430 |    currstate := pop(myautomata.states)
3431 |    put(myautomata.states, currstate)
3432 | 
3433 |    while currstate.label ~= 123 do {
3434 |       currstate := pop(myautomata.states)
3435 |       put(myautomata.states, currstate)
3436 |       }
3437 |    state2 := currstate
3438 | 
3439 |    currstate := pop(myautomata.states)
3440 |    put(myautomata.states, currstate)
3441 | 
3442 |    while currstate.label ~= 124 do {
3443 |       currstate := pop(myautomata.states)
3444 |       put(myautomata.states, currstate)
3445 |       }
3446 |    state2 := currstate
3447 | 
3448 |    currstate := pop(myautomata.states)
3449 |    put(myautomata.states, currstate)
3450 | 
3451 |    while currstate.label ~= 125 do {
3452 |       currstate := pop(myautomata.states)
3453 |       put(myautomata.states, currstate)
3454 |       }
3455 |    state2 := currstate
3456 | 
3457 |    tempedge := edge("g", [])
3458 |    currstate := pop(myautomata.states)
3459 |    put(myautomata.states, currstate)
3460 | 
3461 |    while currstate.label ~= 130 do {
3462 |       currstate := pop(myautomata.states)
3463 |       put(myautomata.states, currstate)
3464 |       }
3465 |    put(tempedge.destinations, currstate)
3466 | 
3467 |    put(state2.edges, tempedge)
3468 |    currstate := pop(myautomata.states)
3469 |    put(myautomata.states, currstate)
3470 | 
3471 |    while currstate.label ~= 126 do {
3472 |       currstate := pop(myautomata.states)
3473 |       put(myautomata.states, currstate)
3474 |       }
3475 |    state2 := currstate
3476 | 
3477 |    tempedge := edge("c", [])
3478 |    currstate := pop(myautomata.states)
3479 |    put(myautomata.states, currstate)
3480 | 
3481 |    while currstate.label ~= 131 do {
3482 |       currstate := pop(myautomata.states)
3483 |       put(myautomata.states, currstate)
3484 |       }
3485 |    put(tempedge.destinations, currstate)
3486 | 
3487 |    put(state2.edges, tempedge)
3488 |    currstate := pop(myautomata.states)
3489 |    put(myautomata.states, currstate)
3490 | 
3491 |    while currstate.label ~= 127 do {
3492 |       currstate := pop(myautomata.states)
3493 |       put(myautomata.states, currstate)
3494 |       }
3495 |    state2 := currstate
3496 | 
3497 |    currstate := pop(myautomata.states)
3498 |    put(myautomata.states, currstate)
3499 | 
3500 |    while currstate.label ~= 128 do {
3501 |       currstate := pop(myautomata.states)
3502 |       put(myautomata.states, currstate)
3503 |       }
3504 |    state2 := currstate
3505 | 
3506 |    currstate := pop(myautomata.states)
3507 |    put(myautomata.states, currstate)
3508 | 
3509 |    while currstate.label ~= 129 do {
3510 |       currstate := pop(myautomata.states)
3511 |       put(myautomata.states, currstate)
3512 |       }
3513 |    state2 := currstate
3514 | 
3515 |    currstate := pop(myautomata.states)
3516 |    put(myautomata.states, currstate)
3517 | 
3518 |    while currstate.label ~= 130 do {
3519 |       currstate := pop(myautomata.states)
3520 |       put(myautomata.states, currstate)
3521 |       }
3522 |    state2 := currstate
3523 | 
3524 |    currstate := pop(myautomata.states)
3525 |    put(myautomata.states, currstate)
3526 | 
3527 |    while currstate.label ~= 131 do {
3528 |       currstate := pop(myautomata.states)
3529 |       put(myautomata.states, currstate)
3530 |       }
3531 |    state2 := currstate
3532 | 
3533 |    init_semantic_actions()
3534 |    }
3535 | 
3536 |    return yyulex(myautomata)
3537 | 
3538 | end
3539 | 
3540 | procedure init_semantic_actions()
3541 | 
3542 |    semantic_action := table()
3543 |    semantic_action[1] := semantic_action_1
3544 |    semantic_action[2] := semantic_action_2
3545 |    semantic_action[3] := semantic_action_3
3546 |    semantic_action[4] := semantic_action_4
3547 |    semantic_action[5] := semantic_action_5
3548 |    semantic_action[6] := semantic_action_6
3549 |    semantic_action[7] := semantic_action_7
3550 |    semantic_action[8] := semantic_action_8
3551 |    semantic_action[9] := semantic_action_9
3552 |    semantic_action[10] := semantic_action_10
3553 |    semantic_action[11] := semantic_action_11
3554 |    semantic_action[12] := semantic_action_12
3555 |    semantic_action[13] := semantic_action_13
3556 |    semantic_action[14] := semantic_action_14
3557 |    semantic_action[15] := semantic_action_15
3558 |    semantic_action[16] := semantic_action_16
3559 |    semantic_action[17] := semantic_action_17
3560 |    semantic_action[18] := semantic_action_18
3561 |    semantic_action[19] := semantic_action_19
3562 |    semantic_action[20] := semantic_action_20
3563 |    semantic_action[21] := semantic_action_21
3564 |    semantic_action[22] := semantic_action_22
3565 |    semantic_action[23] := semantic_action_23
3566 |    semantic_action[24] := semantic_action_24
3567 |    semantic_action[25] := semantic_action_25
3568 |    semantic_action[26] := semantic_action_26
3569 |    semantic_action[27] := semantic_action_27
3570 |    semantic_action[28] := semantic_action_28
3571 |    semantic_action[29] := semantic_action_29
3572 |    semantic_action[30] := semantic_action_30
3573 |    semantic_action[31] := semantic_action_31
3574 |    semantic_action[32] := semantic_action_32
3575 |    semantic_action[33] := semantic_action_33
3576 |    semantic_action[34] := semantic_action_34
3577 |    semantic_action[35] := semantic_action_35
3578 |    semantic_action[36] := semantic_action_36
3579 |    semantic_action[37] := semantic_action_37
3580 |    semantic_action[38] := semantic_action_38
3581 |    semantic_action[39] := semantic_action_39
3582 |    semantic_action[40] := semantic_action_40
3583 |    semantic_action[41] := semantic_action_41
3584 |    semantic_action[42] := semantic_action_42
3585 |    semantic_action[43] := semantic_action_43
3586 |    semantic_action[44] := semantic_action_44
3587 |    semantic_action[45] := semantic_action_45
3588 |    semantic_action[46] := semantic_action_46
3589 |    semantic_action[47] := semantic_action_47
3590 |    semantic_action[48] := semantic_action_48
3591 |    semantic_action[49] := semantic_action_49
3592 |    semantic_action[50] := semantic_action_50
3593 |    semantic_action[51] := semantic_action_51
3594 |    semantic_action[52] := semantic_action_52
3595 |    semantic_action[53] := semantic_action_53
3596 |    semantic_action[54] := semantic_action_54
3597 | 
3598 | end
3599 | 
3600 | procedure semantic_action_3()
3601 |    { j0.whitespace(); }
3602 | end
3603 | 
3604 | procedure semantic_action_4()
3605 |    { j0.newline(); }
3606 | end
3607 | 
3608 | procedure semantic_action_22()
3609 |    { return j0.scan(j0.ord("("));}
3610 | end
3611 | 
3612 | procedure semantic_action_23()
3613 |    { return j0.scan(j0.ord(")"));}
3614 | end
3615 | 
3616 | procedure semantic_action_24()
3617 |    { return j0.scan(j0.ord("["));}
3618 | end
3619 | 
3620 | procedure semantic_action_25()
3621 |    { return j0.scan(j0.ord("]"));}
3622 | end
3623 | 
3624 | procedure semantic_action_26()
3625 |    { return j0.scan(j0.ord("{"));}
3626 | end
3627 | 
3628 | procedure semantic_action_27()
3629 |    { return j0.scan(j0.ord("}"));}
3630 | end
3631 | 
3632 | procedure semantic_action_28()
3633 |    { return j0.scan(j0.ord(";"));}
3634 | end
3635 | 
3636 | procedure semantic_action_29()
3637 |    { return j0.scan(j0.ord(":"));}
3638 | end
3639 | 
3640 | procedure semantic_action_31()
3641 |    { return j0.scan(j0.ord("*"));}
3642 | end
3643 | 
3644 | procedure semantic_action_32()
3645 |    { return j0.scan(j0.ord("/"));}
3646 | end
3647 | 
3648 | procedure semantic_action_33()
3649 |    { return j0.scan(j0.ord("%"));}
3650 | end
3651 | 
3652 | procedure semantic_action_36()
3653 |    { return j0.scan(j0.ord("<"));}
3654 | end
3655 | 
3656 | procedure semantic_action_38()
3657 |    { return j0.scan(j0.ord(">"));}
3658 | end
3659 | 
3660 | procedure semantic_action_30()
3661 |    { return j0.scan(j0.ord("!"));}
3662 | end
3663 | 
3664 | procedure semantic_action_34()
3665 |    { return j0.scan(j0.ord("+"));}
3666 | end
3667 | 
3668 | procedure semantic_action_35()
3669 |    { return j0.scan(j0.ord("-"));}
3670 | end
3671 | 
3672 | procedure semantic_action_44()
3673 |    { return j0.scan(j0.ord("=")); }
3674 | end
3675 | 
3676 | procedure semantic_action_47()
3677 |    { return j0.scan(j0.ord(",")); }
3678 | end
3679 | 
3680 | procedure semantic_action_49()
3681 |    { return j0.scan(parser.IDENTIFIER); }
3682 | end
3683 | 
3684 | procedure semantic_action_48()
3685 |    { return j0.scan(j0.ord(".")); }
3686 | end
3687 | 
3688 | procedure semantic_action_50()
3689 |    { return j0.scan(parser.INTLIT); }
3690 | end
3691 | 
3692 | procedure semantic_action_54()
3693 |    { j0.lexErr("unrecognized character"); }
3694 | end
3695 | 
3696 | procedure semantic_action_10()
3697 |    { return j0.scan(parser.IF); }
3698 | end
3699 | 
3700 | procedure semantic_action_37()
3701 |    { return j0.scan(parser.LESSTHANOREQUAL);}
3702 | end
3703 | 
3704 | procedure semantic_action_39()
3705 |    { return j0.scan(parser.GREATERTHANOREQUAL);}
3706 | end
3707 | 
3708 | procedure semantic_action_41()
3709 |    { return j0.scan(parser.NOTEQUALTO);}
3710 | end
3711 | 
3712 | procedure semantic_action_42()
3713 |    { return j0.scan(parser.LOGICALAND);}
3714 | end
3715 | 
3716 | procedure semantic_action_43()
3717 |    { return j0.scan(parser.LOGICALOR);}
3718 | end
3719 | 
3720 | procedure semantic_action_45()
3721 |    { return j0.scan(parser.INCREMENT); }
3722 | end
3723 | 
3724 | procedure semantic_action_46()
3725 |    { return j0.scan(parser.DECREMENT); }
3726 | end
3727 | 
3728 | procedure semantic_action_40()
3729 |    { return j0.scan(parser.ISEQUALTO);}
3730 | end
3731 | 
3732 | procedure semantic_action_53()
3733 |    { return j0.scan(parser.STRINGLIT); }
3734 | end
3735 | 
3736 | procedure semantic_action_9()
3737 |    { return j0.scan(parser.FOR); }
3738 | end
3739 | 
3740 | procedure semantic_action_11()
3741 |    { return j0.scan(parser.INT); }
3742 | end
3743 | 
3744 | procedure semantic_action_2()
3745 |    { j0.comment(); }
3746 | end
3747 | 
3748 | procedure semantic_action_51()
3749 |    { return j0.scan(parser.DOUBLELIT); }
3750 | end
3751 | 
3752 | procedure semantic_action_52()
3753 |    { return j0.scan(parser.DOUBLELIT); }
3754 | end
3755 | 
3756 | procedure semantic_action_12()
3757 |    { return j0.scan(parser.NULLVAL); }
3758 | end
3759 | 
3760 | procedure semantic_action_17()
3761 |    { return j0.scan(parser.BOOLLIT); }
3762 | end
3763 | 
3764 | procedure semantic_action_18()
3765 |    { return j0.scan(parser.BOOL); }
3766 | end
3767 | 
3768 | procedure semantic_action_19()
3769 |    { return j0.scan(parser.VOID); }
3770 | end
3771 | 
3772 | procedure semantic_action_7()
3773 |    { return j0.scan(parser.ELSE); }
3774 | end
3775 | 
3776 | procedure semantic_action_1()
3777 |    { j0.comment(); }
3778 | end
3779 | 
3780 | procedure semantic_action_8()
3781 |    { return j0.scan(parser.BOOLLIT); }
3782 | end
3783 | 
3784 | procedure semantic_action_5()
3785 |    { return j0.scan(parser.BREAK); }
3786 | end
3787 | 
3788 | procedure semantic_action_20()
3789 |    { return j0.scan(parser.WHILE); }
3790 | end
3791 | 
3792 | procedure semantic_action_21()
3793 |    { return j0.scan(parser.CLASS); }
3794 | end
3795 | 
3796 | procedure semantic_action_13()
3797 |    { return j0.scan(parser.PUBLIC); }
3798 | end
3799 | 
3800 | procedure semantic_action_14()
3801 |    { return j0.scan(parser.RETURN); }
3802 | end
3803 | 
3804 | procedure semantic_action_6()
3805 |    { return j0.scan(parser.DOUBLE); }
3806 | end
3807 | 
3808 | procedure semantic_action_16()
3809 |    { return j0.scan(parser.STRING); }
3810 | end
3811 | 
3812 | procedure semantic_action_15()
3813 |    { return j0.scan(parser.STATIC); }
3814 | end
3815 | 
3816 | 


--------------------------------------------------------------------------------
/ch5/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch5;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "null"                 { return j0.scan(parser.NULLVAL); }
18 | "public"               { return j0.scan(parser.PUBLIC); }
19 | "return"               { return j0.scan(parser.RETURN); }
20 | "static"               { return j0.scan(parser.STATIC); }
21 | "string"               { return j0.scan(parser.STRING); }
22 | "true"                 { return j0.scan(parser.BOOLLIT); }
23 | "bool"                 { return j0.scan(parser.BOOL); }
24 | "void"                 { return j0.scan(parser.VOID); }
25 | "while"                { return j0.scan(parser.WHILE); }
26 | "class"                { return j0.scan(parser.CLASS); }
27 | "("                    { return j0.scan(j0.ord("("));}
28 | ")"                    { return j0.scan(j0.ord(")"));}
29 | "["                    { return j0.scan(j0.ord("["));}
30 | "]"                    { return j0.scan(j0.ord("]"));}
31 | "{"                    { return j0.scan(j0.ord("{"));}
32 | "}"                    { return j0.scan(j0.ord("}"));}
33 | ";"                    { return j0.scan(j0.ord(";"));}
34 | ":"                    { return j0.scan(j0.ord(":"));}
35 | "!"                    { return j0.scan(j0.ord("!"));}
36 | "*"                    { return j0.scan(j0.ord("*"));}
37 | "/"                    { return j0.scan(j0.ord("/"));}
38 | "%"                    { return j0.scan(j0.ord("%"));}
39 | "+"                    { return j0.scan(j0.ord("+"));}
40 | "-"                    { return j0.scan(j0.ord("-"));}
41 | "<"                    { return j0.scan(j0.ord("<"));}
42 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
43 | ">"                    { return j0.scan(j0.ord(">"));}
44 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
45 | "=="                   { return j0.scan(parser.ISEQUALTO);}
46 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
47 | "&&"                   { return j0.scan(parser.LOGICALAND);}
48 | "||"                   { return j0.scan(parser.LOGICALOR);}
49 | "="                    { return j0.scan(j0.ord("=")); }
50 | "+="                   { return j0.scan(parser.INCREMENT); }
51 | "-="                   { return j0.scan(parser.DECREMENT); }
52 | ","                    { return j0.scan(j0.ord(",")); }
53 | "."                    { return j0.scan(j0.ord(".")); }
54 | {id}                   { return j0.scan(parser.IDENTIFIER); }
55 | [0-9]+                 { return j0.scan(parser.INTLIT); }
56 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
57 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
58 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
59 | .                      { j0.lexErr("unrecognized character"); }
60 | 


--------------------------------------------------------------------------------
/ch5/makefile:
--------------------------------------------------------------------------------
 1 | all: java unicon
 2 | 
 3 | LYU=javalex.u j0gram.u j0gram_tab.u
 4 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU)
 5 | unicon: j0
 6 | %.u : %.icn
 7 | 	unicon -c 
lt;
 8 | j0: $(U)
 9 | 	unicon $(U)
10 | javalex.icn: javalex.l
11 | 	uflex javalex.l
12 | j0gram.icn j0gram_tab.icn: j0gram.y
13 | 	iyacc -dd j0gram.y
14 | 
15 | 
16 | # A typical run might use
17 | # set CLASSPATH=".;c:\users\username\byopl"
18 | # in order to run from c:\users\username\byopl\ch5
19 | BYSRC=parser.java parserVal.java
20 | JSRC=j0.java Yylex.java token.java yyerror.java tree.java serial.java $(BYSRC)
21 | BYJOPTS= -Jclass=parser -Jpackage=ch5
22 | BYJIMPS= -Jyylex=ch5.j0.yylex -Jyyerror=ch5.yyerror.yyerror
23 | java: j0.class
24 | 
25 | j: java
26 | 	java ch5.j0 hello.java
27 | 	dot -Tpng hello.java.dot >hello.png
28 | 
29 | j0.class: $(JSRC)
30 | 	javac $(JSRC)
31 | parser.java parserVal.java: j0gram.y
32 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
33 | Yylex.java: javalex.l
34 | 	jflex javalex.l
35 | 
36 | 


--------------------------------------------------------------------------------
/ch5/parser.java:
--------------------------------------------------------------------------------
   1 | //### This file created by BYACC 1.8(/Java extension  1.15)
   2 | //### Java capabilities added 7 Jan 97, Bob Jamison
   3 | //### Updated : 27 Nov 97  -- Bob Jamison, Joe Nieten
   4 | //###           01 Jan 98  -- Bob Jamison -- fixed generic semantic constructor
   5 | //###           01 Jun 99  -- Bob Jamison -- added Runnable support
   6 | //###           06 Aug 00  -- Bob Jamison -- made state variables class-global
   7 | //###           03 Jan 01  -- Bob Jamison -- improved flags, tracing
   8 | //###           16 May 01  -- Bob Jamison -- added custom stack sizing
   9 | //###           04 Mar 02  -- Yuval Oren  -- improved java performance, added options
  10 | //###           14 Mar 02  -- Tomas Hurka -- -d support, static initializer workaround
  11 | //### Please send bug reports to tom@hukatronic.cz
  12 | //### static char yysccsid[] = "@(#)yaccpar	1.8 (Berkeley) 01/20/90";
  13 | 
  14 | 
  15 | 
  16 | package ch5;
  17 | import static ch5.j0.yylex;
  18 | import static ch5.yyerror.yyerror;
  19 | 
  20 | 
  21 | 
  22 | 
  23 | 
  24 | 
  25 | 
  26 | public class parser
  27 | {
  28 | 
  29 | boolean yydebug;        //do I want debug output?
  30 | int yynerrs;            //number of errors so far
  31 | int yyerrflag;          //was there an error?
  32 | int yychar;             //the current working character
  33 | 
  34 | //########## MESSAGES ##########
  35 | //###############################################################
  36 | // method: debug
  37 | //###############################################################
  38 | void debug(String msg)
  39 | {
  40 |   if (yydebug)
  41 |     System.out.println(msg);
  42 | }
  43 | 
  44 | //########## STATE STACK ##########
  45 | final static int YYSTACKSIZE = 500;  //maximum stack size
  46 | int statestk[] = new int[YYSTACKSIZE]; //state stack
  47 | int stateptr;
  48 | int stateptrmax;                     //highest index of stackptr
  49 | int statemax;                        //state when highest index reached
  50 | //###############################################################
  51 | // methods: state stack push,pop,drop,peek
  52 | //###############################################################
  53 | final void state_push(int state)
  54 | {
  55 |   try {
  56 | 		stateptr++;
  57 | 		statestk[stateptr]=state;
  58 | 	 }
  59 | 	 catch (ArrayIndexOutOfBoundsException e) {
  60 |      int oldsize = statestk.length;
  61 |      int newsize = oldsize * 2;
  62 |      int[] newstack = new int[newsize];
  63 |      System.arraycopy(statestk,0,newstack,0,oldsize);
  64 |      statestk = newstack;
  65 |      statestk[stateptr]=state;
  66 |   }
  67 | }
  68 | final int state_pop()
  69 | {
  70 |   return statestk[stateptr--];
  71 | }
  72 | final void state_drop(int cnt)
  73 | {
  74 |   stateptr -= cnt; 
  75 | }
  76 | final int state_peek(int relative)
  77 | {
  78 |   return statestk[stateptr-relative];
  79 | }
  80 | //###############################################################
  81 | // method: init_stacks : allocate and prepare stacks
  82 | //###############################################################
  83 | final boolean init_stacks()
  84 | {
  85 |   stateptr = -1;
  86 |   val_init();
  87 |   return true;
  88 | }
  89 | //###############################################################
  90 | // method: dump_stacks : show n levels of the stacks
  91 | //###############################################################
  92 | void dump_stacks(int count)
  93 | {
  94 | int i;
  95 |   System.out.println("=index==state====value=     s:"+stateptr+"  v:"+valptr);
  96 |   for (i=0;i<count;i++)
  97 |     System.out.println(" "+i+"    "+statestk[i]+"      "+valstk[i]);
  98 |   System.out.println("======================");
  99 | }
 100 | 
 101 | 
 102 | //########## SEMANTIC VALUES ##########
 103 | //public class parserVal is defined in parserVal.java
 104 | 
 105 | 
 106 | String   yytext;//user variable to return contextual strings
 107 | parserVal yyval; //used to return semantic vals from action routines
 108 | parserVal yylval;//the 'lval' (result) I got from yylex()
 109 | parserVal valstk[];
 110 | int valptr;
 111 | //###############################################################
 112 | // methods: value stack push,pop,drop,peek.
 113 | //###############################################################
 114 | void val_init()
 115 | {
 116 |   valstk=new parserVal[YYSTACKSIZE];
 117 |   yyval=new parserVal();
 118 |   yylval=new parserVal();
 119 |   valptr=-1;
 120 | }
 121 | void val_push(parserVal val)
 122 | {
 123 |   if (valptr>=YYSTACKSIZE)
 124 |     return;
 125 |   valstk[++valptr]=val;
 126 | }
 127 | parserVal val_pop()
 128 | {
 129 |   if (valptr<0)
 130 |     return new parserVal();
 131 |   return valstk[valptr--];
 132 | }
 133 | void val_drop(int cnt)
 134 | {
 135 | int ptr;
 136 |   ptr=valptr-cnt;
 137 |   if (ptr<0)
 138 |     return;
 139 |   valptr = ptr;
 140 | }
 141 | parserVal val_peek(int relative)
 142 | {
 143 | int ptr;
 144 |   ptr=valptr-relative;
 145 |   if (ptr<0)
 146 |     return new parserVal();
 147 |   return valstk[ptr];
 148 | }
 149 | final parserVal dup_yyval(parserVal val)
 150 | {
 151 |   parserVal dup = new parserVal();
 152 |   dup.ival = val.ival;
 153 |   dup.dval = val.dval;
 154 |   dup.sval = val.sval;
 155 |   dup.obj = val.obj;
 156 |   return dup;
 157 | }
 158 | //#### end semantic value section ####
 159 | public final static short BREAK=257;
 160 | public final static short DOUBLE=258;
 161 | public final static short ELSE=259;
 162 | public final static short FOR=260;
 163 | public final static short IF=261;
 164 | public final static short INT=262;
 165 | public final static short RETURN=263;
 166 | public final static short VOID=264;
 167 | public final static short WHILE=265;
 168 | public final static short IDENTIFIER=266;
 169 | public final static short CLASSNAME=267;
 170 | public final static short CLASS=268;
 171 | public final static short STRING=269;
 172 | public final static short BOOL=270;
 173 | public final static short INTLIT=271;
 174 | public final static short DOUBLELIT=272;
 175 | public final static short STRINGLIT=273;
 176 | public final static short BOOLLIT=274;
 177 | public final static short NULLVAL=275;
 178 | public final static short LESSTHANOREQUAL=276;
 179 | public final static short GREATERTHANOREQUAL=277;
 180 | public final static short ISEQUALTO=278;
 181 | public final static short NOTEQUALTO=279;
 182 | public final static short LOGICALAND=280;
 183 | public final static short LOGICALOR=281;
 184 | public final static short INCREMENT=282;
 185 | public final static short DECREMENT=283;
 186 | public final static short PUBLIC=284;
 187 | public final static short STATIC=285;
 188 | public final static short YYERRCODE=256;
 189 | final static short yylhs[] = {                           -1,
 190 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 191 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 192 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 193 |    18,    6,   14,   19,   19,   20,   20,   21,   21,   22,
 194 |    24,   23,   23,   23,   23,   23,   23,   23,   23,   23,
 195 |    23,   25,   33,   33,   28,   29,   30,   30,   37,   37,
 196 |    38,   31,   32,   39,   39,   39,   40,   40,   41,   41,
 197 |    42,   42,   26,   26,   27,   43,   43,   43,   43,   44,
 198 |    44,   44,   44,   44,   46,   46,   45,   47,   47,   35,
 199 |    35,   48,   48,   49,   49,   49,   50,   50,   50,   50,
 200 |    51,   51,   51,   52,   52,   52,   52,   53,   53,   54,
 201 |    54,   54,   55,   55,   56,   56,   36,   36,   34,   57,
 202 |    57,   58,   58,   58,
 203 | };
 204 | final static short yylen[] = {                            2,
 205 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 206 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 207 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 208 |     2,    2,    3,    1,    0,    1,    2,    1,    1,    2,
 209 |     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 210 |     1,    2,    1,    1,    5,    7,    6,    8,    1,    2,
 211 |     2,    5,    9,    1,    1,    0,    1,    0,    1,    0,
 212 |     1,    3,    2,    3,    3,    1,    1,    1,    3,    1,
 213 |     1,    1,    1,    1,    1,    3,    3,    1,    0,    4,
 214 |     6,    1,    1,    2,    2,    1,    1,    3,    3,    3,
 215 |     1,    3,    3,    1,    1,    1,    1,    1,    3,    1,
 216 |     3,    3,    1,    3,    1,    3,    1,    1,    3,    1,
 217 |     1,    1,    1,    1,
 218 | };
 219 | final static short yydefred[] = {                         0,
 220 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 221 |    12,    0,    3,    0,    4,    6,    7,    8,    0,    0,
 222 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 223 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 224 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 225 |     0,   80,   81,   83,   82,   84,   43,    0,    0,    0,
 226 |    42,    0,    0,   36,   38,   39,    0,   44,   45,   46,
 227 |    47,   48,   49,   50,   51,    0,   53,    0,    0,   76,
 228 |     0,    0,    0,   26,    0,    0,   25,    0,   21,    0,
 229 |    73,    0,    0,    0,    0,    0,  118,   78,   67,    0,
 230 |     0,   96,   97,    0,    0,    0,    0,    0,    0,    0,
 231 |     0,    0,    0,   33,   37,   40,   52,    0,  123,  124,
 232 |   122,    0,   30,   74,   65,   71,    0,    0,    0,    0,
 233 |    77,   94,   95,   75,    0,    0,    0,    0,    0,  104,
 234 |   105,  106,  107,    0,    0,    0,    0,    0,    0,   79,
 235 |    85,    0,    0,    0,  119,    0,    0,    0,   98,   99,
 236 |   100,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 237 |    90,    0,    0,    0,   72,    0,   62,   86,    0,    0,
 238 |     0,    0,   59,   91,    0,    0,    0,   56,   61,    0,
 239 |    60,    0,    0,   58,   63,    0,    0,   55,
 240 | };
 241 | final static short yydgoto[] = {                          2,
 242 |     6,   14,   15,   16,   17,   18,   59,   29,  130,   21,
 243 |    30,   42,   22,   61,   23,   37,   38,   39,   62,   63,
 244 |    64,   65,   66,   67,   68,   69,   70,   71,   72,   73,
 245 |    74,   75,   76,   97,   98,   99,  182,  183,  127,  100,
 246 |   185,  128,  101,   80,   81,  152,  153,  102,  103,  104,
 247 |   105,  144,  106,  107,  108,  109,   82,  122,
 248 | };
 249 | final static short yysindex[] = {                      -218,
 250 |  -200,    0, -181,  -35,  -95,    0,    0,    0,   51,    0,
 251 |     0, -177,    0,  -93,    0,    0,    0,    0, -152,   79,
 252 |     0,   16,   16,  227,  217,    0,    0,    0,  -30,   65,
 253 |  -133,  169,    0,    0,    0, -152,  117,  116,    0,    0,
 254 |     0,  -96,    0, -152,   95,    0,  -46,  132,  150,   50,
 255 |   153,    0,    0,    0,    0,    0,    0,   50, -152,   52,
 256 |     0,   72,  169,    0,    0,    0,  141,    0,    0,    0,
 257 |     0,    0,    0,    0,    0,  143,    0,    0,  158,    0,
 258 |     0,  -24,   65,    0,  227,   51,    0,   65,    0,  148,
 259 |     0,  -39,   50,   50,   50,   52,    0,    0,    0,  151,
 260 |   158,    0,    0,  145,  109,   97, -100,  -69,  -68,   50,
 261 |   171,  170,   50,    0,    0,    0,    0,  -51,    0,    0,
 262 |     0,   50,    0,    0,    0,    0,  157,  173,  177,   52,
 263 |     0,    0,    0,    0,   50,   50,   50,   50,   50,    0,
 264 |     0,    0,    0,   50,   50,   50,   50,   50,  180,    0,
 265 |     0,  182,  188,  197,    0,   50,   -1,   16,    0,    0,
 266 |     0,  145,  145,  109,   97,   97, -100,  -69,  268,   50,
 267 |     0,   50,  179,   52,    0,  -11,    0,    0,  219,   -1,
 268 |  -111,    9,    0,    0,  222,  173,  224,    0,    0, -111,
 269 |     0,   16,   50,    0,    0,  234,   16,    0,
 270 | };
 271 | final static short yyrindex[] = {                         0,
 272 |     0,    0,    0,    0,    0,    0,    0,    0,  -44,    0,
 273 |     0,    0,    0,    0,    0,    0,    0,    0,    0,   19,
 274 |     0,    0,    0,  235,    0,    0,    0,    0,    0,    6,
 275 |     0,  172,    0,    0,    0,    0,    0,  257,    0,    0,
 276 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  240,
 277 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -58,
 278 |     0,    0,  175,    0,    0,    0,    0,    0,    0,    0,
 279 |     0,    0,    0,    0,    0,    0,    0,  107,    0,    0,
 280 |   -37,    0,  -13,    0,    0,    0,    0,   14,    0,    0,
 281 |     0,  246,    0,    0,    0,    1,    0,    0,    0,    0,
 282 |    10,    0,    0,   56,   76,   15,   90,   45,   43,    0,
 283 |     0,  247,  266,    0,    0,    0,    0,    0,    0,    0,
 284 |     0,    0,    0,    0,    0,    0,    0,  250,    0,   34,
 285 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 286 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 287 |     0,  276,    0,  -26,    0,  240,    0,    0,    0,    0,
 288 |     0,   62,   68,   82,   23,   88,   96,  102,    0,    0,
 289 |     0,  266,    0,  -21,    0,  124,    0,    0,    0,  277,
 290 |     0,  144,    0,    0,    0,  278,    0,    0,    0,    0,
 291 |     0,    0,    0,    0,    0,    0,    0,    0,
 292 | };
 293 | final static short yygindex[] = {                         0,
 294 |     0,    0,  314,    0,    0,    0,  181,  270,  445,    0,
 295 |     5,    0,    0,    4,  289,    0,    0,  245,    0,    0,
 296 |   287,    0,  195,  273,    0,    0,    0,  -71,    0,    0,
 297 |     0,    0,  -12,  288,  388,  378,    0,  190,    0,  223,
 298 |     0,  198,  390,    0,  441,    0,  203,    0,  329,   42,
 299 |   244,    0,   53,  253,  255,    0,    0,    0,
 300 | };
 301 | final static int YYTABLESIZE=638;
 302 | static short yytable[];
 303 | static { yytable();}
 304 | static void yytable(){
 305 | yytable = new short[]{                         77,
 306 |    58,   15,  120,   77,   77,   77,   77,   77,   77,   77,
 307 |    87,   32,   91,   44,   87,   87,   87,   87,   87,   87,
 308 |    87,   77,   77,  121,   77,   33,   34,   31,   43,   13,
 309 |    31,   26,   87,   87,   87,   87,  121,   93,   58,  120,
 310 |    83,   93,   93,   93,   93,   93,   92,   93,   88,   18,
 311 |    92,   92,   92,   92,   92,  110,   92,   19,  110,   93,
 312 |    93,  120,   93,  111,   18,    1,  111,    3,   92,   92,
 313 |    93,   92,   19,  110,   93,   93,   93,   93,   93,  126,
 314 |    93,  111,   95,  117,    4,  115,  117,    5,  115,   58,
 315 |    24,  113,   93,   93,   94,   93,  101,   31,  101,  101,
 316 |   101,  117,  103,  115,  103,  103,  103,   25,  102,  189,
 317 |   102,  102,  102,   28,  101,  101,  108,  101,  189,  108,
 318 |   103,  103,  109,  103,   31,  109,  102,  102,  112,  102,
 319 |   113,  112,   46,  113,  108,  108,  114,  108,   32,  114,
 320 |   109,  109,  116,  109,  175,  116,  112,   54,  113,  187,
 321 |    54,  139,   78,  138,  114,   45,  142,   84,  143,   85,
 322 |   116,  176,    7,   55,    7,   54,    8,  126,    8,   86,
 323 |     9,   92,    9,   10,   11,   10,   11,  145,  146,  162,
 324 |   163,  137,   55,   57,  188,   19,  135,   89,   12,   93,
 325 |    12,  136,  110,  194,   19,  195,  114,  165,  166,  116,
 326 |   198,  117,   57,  118,   36,   41,  124,   14,   58,  134,
 327 |   147,  150,  148,   44,  154,  156,  157,  158,    7,   90,
 328 |   169,   15,    8,  120,  120,  170,   35,   57,  171,   10,
 329 |    11,   52,   53,   54,   55,   56,  172,  180,   77,   77,
 330 |    77,   77,   77,   77,  121,  121,   55,  181,   55,   87,
 331 |    87,   87,   87,   87,   87,   87,   87,  119,  120,  184,
 332 |   120,  120,  192,  193,   35,   36,   57,  190,   57,   52,
 333 |    53,   54,   55,   56,  197,   28,   93,   93,   93,   93,
 334 |    93,   93,  120,  120,   14,   92,   92,   92,   92,   92,
 335 |    92,   32,  110,  110,  110,  110,   35,   27,   68,   34,
 336 |   111,  111,  111,  111,   66,   41,   89,   58,   64,   93,
 337 |    93,   93,   93,   93,   93,   35,   88,   70,   69,   77,
 338 |    52,   53,   54,   55,   56,  115,   57,   27,  112,  123,
 339 |    87,  101,  101,  101,  101,  101,  101,  103,  103,  103,
 340 |   103,  103,  103,  102,  102,  102,  102,  102,  102,  115,
 341 |    77,  108,  108,  108,  108,  108,  108,  109,  109,  109,
 342 |   109,  109,  109,  177,  125,  112,  112,  112,  112,  113,
 343 |   113,  191,  140,  141,  179,  114,  114,  186,  173,   77,
 344 |    55,   55,  116,   55,   55,   55,   55,  164,   55,   55,
 345 |    32,    0,   55,   55,   55,   55,   55,   55,   55,  167,
 346 |    57,   57,  168,   57,   57,   57,   57,    0,   57,   57,
 347 |     0,    0,   57,   57,   57,   57,   57,   57,   57,   78,
 348 |     0,   79,  132,  133,    0,   47,    7,    0,   48,   49,
 349 |     8,   50,    0,   51,   35,  111,    0,   10,   11,   52,
 350 |    53,   54,   55,   56,   77,    0,    0,    0,    0,   20,
 351 |    78,    0,   79,    0,    0,    0,   77,    0,   20,    0,
 352 |     0,    0,    0,  159,  160,  161,    0,   77,   20,   20,
 353 |   129,    0,    0,    0,    7,    0,   60,    0,    8,   78,
 354 |    40,   79,   35,    0,    7,   10,   11,  149,    8,    0,
 355 |   151,    0,   35,    0,   96,   10,   11,    0,    0,  155,
 356 |     0,    0,   96,    0,    0,    0,    0,   60,    0,    0,
 357 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 358 |     0,    0,    0,    0,   47,    0,    0,   48,   49,   20,
 359 |    50,    0,   51,   35,  131,  131,   60,   96,   52,   53,
 360 |    54,   55,   56,    0,   78,    0,   79,  178,    0,  151,
 361 |     0,    0,    0,    0,   96,    0,   78,   96,   79,    0,
 362 |     0,    0,    0,    0,    0,    0,   96,   78,    0,   79,
 363 |   196,    0,    0,    0,    0,  131,  131,  131,  131,  131,
 364 |     0,    0,    0,    0,  131,  131,  131,  131,  131,    0,
 365 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 366 |    96,  174,    0,    0,    0,    0,    0,    0,    0,    0,
 367 |     0,    0,    0,  174,   96,    0,   96,    0,    0,    0,
 368 |     0,    0,    0,    0,  174,    0,    0,    0,    0,    0,
 369 |     0,    0,    0,    0,    0,    0,    0,   96,
 370 | };
 371 | }
 372 | static short yycheck[];
 373 | static { yycheck(); }
 374 | static void yycheck() {
 375 | yycheck = new short[] {                         37,
 376 |    40,   46,   61,   41,   42,   43,   44,   45,   46,   47,
 377 |    37,  123,   59,   44,   41,   42,   43,   44,   45,   46,
 378 |    47,   59,   60,   61,   62,   22,   23,   41,   59,  125,
 379 |    44,  125,   59,   60,   61,   62,   61,   37,   40,   61,
 380 |    36,   41,   42,   43,   44,   45,   37,   47,   44,   44,
 381 |    41,   42,   43,   44,   45,   41,   47,   44,   44,   59,
 382 |    60,   61,   62,   41,   59,  284,   44,  268,   59,   60,
 383 |    37,   62,   59,   59,   41,   42,   43,   44,   45,   92,
 384 |    47,   59,   33,   41,  266,   41,   44,  123,   44,   40,
 385 |    40,   40,   59,   60,   45,   62,   41,   46,   43,   44,
 386 |    45,   59,   41,   59,   43,   44,   45,  285,   41,  181,
 387 |    43,   44,   45,  266,   59,   60,   41,   62,  190,   44,
 388 |    59,   60,   41,   62,   46,   44,   59,   60,   41,   62,
 389 |    41,   44,  266,   44,   59,   60,   41,   62,  123,   44,
 390 |    59,   60,   41,   62,  157,   44,   59,   41,   59,  261,
 391 |    44,   43,   46,   45,   59,   91,   60,   41,   62,   44,
 392 |    59,  158,  258,   40,  258,   59,  262,  180,  262,  266,
 393 |   266,   40,  266,  269,  270,  269,  270,  278,  279,  138,
 394 |   139,   37,   59,   40,  181,    5,   42,   93,  284,   40,
 395 |   284,   47,   40,  190,   14,  192,  125,  145,  146,   59,
 396 |   197,   59,   59,   46,   24,   25,   59,  266,   40,   59,
 397 |   280,   41,  281,   44,  266,   59,   44,   41,  258,  266,
 398 |    41,  266,  262,  282,  283,   44,  266,   59,   41,  269,
 399 |   270,  271,  272,  273,  274,  275,   40,   59,  276,  277,
 400 |   278,  279,  280,  281,  282,  283,  123,  259,  125,  276,
 401 |   277,  278,  279,  280,  281,  282,  283,  282,  283,   41,
 402 |   282,  283,   41,   40,  266,   85,  123,  259,  125,  271,
 403 |   272,  273,  274,  275,   41,   41,  276,  277,  278,  279,
 404 |   280,  281,  282,  283,  266,  276,  277,  278,  279,  280,
 405 |   281,  123,  278,  279,  280,  281,  125,   41,   59,  125,
 406 |   278,  279,  280,  281,   59,   59,   41,   40,   59,  276,
 407 |   277,  278,  279,  280,  281,  266,   41,   41,   41,   32,
 408 |   271,  272,  273,  274,  275,  281,   59,   14,   59,   85,
 409 |    42,  276,  277,  278,  279,  280,  281,  276,  277,  278,
 410 |   279,  280,  281,  276,  277,  278,  279,  280,  281,   63,
 411 |    63,  276,  277,  278,  279,  280,  281,  276,  277,  278,
 412 |   279,  280,  281,  169,   92,  278,  279,  280,  281,  280,
 413 |   281,  182,  276,  277,  172,  280,  281,  180,  156,   92,
 414 |   257,  258,  281,  260,  261,  262,  263,  144,  265,  266,
 415 |   123,   -1,  269,  270,  271,  272,  273,  274,  275,  147,
 416 |   257,  258,  148,  260,  261,  262,  263,   -1,  265,  266,
 417 |    -1,   -1,  269,  270,  271,  272,  273,  274,  275,   32,
 418 |    -1,   32,   94,   95,   -1,  257,  258,   -1,  260,  261,
 419 |   262,  263,   -1,  265,  266,   58,   -1,  269,  270,  271,
 420 |   272,  273,  274,  275,  157,   -1,   -1,   -1,   -1,    5,
 421 |    63,   -1,   63,   -1,   -1,   -1,  169,   -1,   14,   -1,
 422 |    -1,   -1,   -1,  135,  136,  137,   -1,  180,   24,   25,
 423 |    93,   -1,   -1,   -1,  258,   -1,   32,   -1,  262,   92,
 424 |   264,   92,  266,   -1,  258,  269,  270,  110,  262,   -1,
 425 |   113,   -1,  266,   -1,   50,  269,  270,   -1,   -1,  122,
 426 |    -1,   -1,   58,   -1,   -1,   -1,   -1,   63,   -1,   -1,
 427 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 428 |    -1,   -1,   -1,   -1,  257,   -1,   -1,  260,  261,   85,
 429 |   263,   -1,  265,  266,   94,   95,   92,   93,  271,  272,
 430 |   273,  274,  275,   -1,  157,   -1,  157,  170,   -1,  172,
 431 |    -1,   -1,   -1,   -1,  110,   -1,  169,  113,  169,   -1,
 432 |    -1,   -1,   -1,   -1,   -1,   -1,  122,  180,   -1,  180,
 433 |   193,   -1,   -1,   -1,   -1,  135,  136,  137,  138,  139,
 434 |    -1,   -1,   -1,   -1,  144,  145,  146,  147,  148,   -1,
 435 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 436 |   156,  157,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 437 |    -1,   -1,   -1,  169,  170,   -1,  172,   -1,   -1,   -1,
 438 |    -1,   -1,   -1,   -1,  180,   -1,   -1,   -1,   -1,   -1,
 439 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,  193,
 440 | };
 441 | }
 442 | final static short YYFINAL=2;
 443 | final static short YYMAXTOKEN=285;
 444 | final static String yyname[] = {
 445 | "end-of-file",null,null,null,null,null,null,null,null,null,null,null,null,null,
 446 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 447 | null,null,null,"'!'",null,null,null,"'%'",null,null,"'('","')'","'*'","'+'",
 448 | "','","'-'","'.'","'/'",null,null,null,null,null,null,null,null,null,null,null,
 449 | "';'","'<'","'='","'>'",null,null,null,null,null,null,null,null,null,null,null,
 450 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 451 | null,"'['",null,"']'",null,null,null,null,null,null,null,null,null,null,null,
 452 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 453 | null,null,"'{'",null,"'}'",null,null,null,null,null,null,null,null,null,null,
 454 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 455 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 456 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 457 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 458 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 459 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 460 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 461 | null,null,null,null,null,null,null,null,null,"BREAK","DOUBLE","ELSE","FOR","IF",
 462 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
 463 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
 464 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
 465 | "INCREMENT","DECREMENT","PUBLIC","STATIC",
 466 | };
 467 | final static String yyrule[] = {
 468 | "$accept : ClassDecl",
 469 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
 470 | "ClassBody : '{' ClassBodyDecls '}'",
 471 | "ClassBody : '{' '}'",
 472 | "ClassBodyDecls : ClassBodyDecl",
 473 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
 474 | "ClassBodyDecl : FieldDecl",
 475 | "ClassBodyDecl : MethodDecl",
 476 | "ClassBodyDecl : ConstructorDecl",
 477 | "FieldDecl : Type VarDecls ';'",
 478 | "Type : INT",
 479 | "Type : DOUBLE",
 480 | "Type : BOOL",
 481 | "Type : STRING",
 482 | "Type : Name",
 483 | "Name : IDENTIFIER",
 484 | "Name : QualifiedName",
 485 | "QualifiedName : Name '.' IDENTIFIER",
 486 | "VarDecls : VarDeclarator",
 487 | "VarDecls : VarDecls ',' VarDeclarator",
 488 | "VarDeclarator : IDENTIFIER",
 489 | "VarDeclarator : VarDeclarator '[' ']'",
 490 | "MethodReturnVal : Type",
 491 | "MethodReturnVal : VOID",
 492 | "MethodDecl : MethodHeader Block",
 493 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
 494 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
 495 | "FormalParmListOpt : FormalParmList",
 496 | "FormalParmListOpt :",
 497 | "FormalParmList : FormalParm",
 498 | "FormalParmList : FormalParmList ',' FormalParm",
 499 | "FormalParm : Type VarDeclarator",
 500 | "ConstructorDecl : MethodDeclarator Block",
 501 | "Block : '{' BlockStmtsOpt '}'",
 502 | "BlockStmtsOpt : BlockStmts",
 503 | "BlockStmtsOpt :",
 504 | "BlockStmts : BlockStmt",
 505 | "BlockStmts : BlockStmts BlockStmt",
 506 | "BlockStmt : LocalVarDeclStmt",
 507 | "BlockStmt : Stmt",
 508 | "LocalVarDeclStmt : LocalVarDecl ';'",
 509 | "LocalVarDecl : Type VarDecls",
 510 | "Stmt : Block",
 511 | "Stmt : ';'",
 512 | "Stmt : ExprStmt",
 513 | "Stmt : BreakStmt",
 514 | "Stmt : ReturnStmt",
 515 | "Stmt : IfThenStmt",
 516 | "Stmt : IfThenElseStmt",
 517 | "Stmt : IfThenElseIfStmt",
 518 | "Stmt : WhileStmt",
 519 | "Stmt : ForStmt",
 520 | "ExprStmt : StmtExpr ';'",
 521 | "StmtExpr : Assignment",
 522 | "StmtExpr : MethodCall",
 523 | "IfThenStmt : IF '(' Expr ')' Block",
 524 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
 525 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
 526 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
 527 | "ElseIfSequence : ElseIfStmt",
 528 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
 529 | "ElseIfStmt : ELSE IfThenStmt",
 530 | "WhileStmt : WHILE '(' Expr ')' Stmt",
 531 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
 532 | "ForInit : StmtExprList",
 533 | "ForInit : LocalVarDecl",
 534 | "ForInit :",
 535 | "ExprOpt : Expr",
 536 | "ExprOpt :",
 537 | "ForUpdate : StmtExprList",
 538 | "ForUpdate :",
 539 | "StmtExprList : StmtExpr",
 540 | "StmtExprList : StmtExprList ',' StmtExpr",
 541 | "BreakStmt : BREAK ';'",
 542 | "BreakStmt : BREAK IDENTIFIER ';'",
 543 | "ReturnStmt : RETURN ExprOpt ';'",
 544 | "Primary : Literal",
 545 | "Primary : FieldAccess",
 546 | "Primary : MethodCall",
 547 | "Primary : '(' Expr ')'",
 548 | "Literal : INTLIT",
 549 | "Literal : DOUBLELIT",
 550 | "Literal : BOOLLIT",
 551 | "Literal : STRINGLIT",
 552 | "Literal : NULLVAL",
 553 | "ArgList : Expr",
 554 | "ArgList : ArgList ',' Expr",
 555 | "FieldAccess : Primary '.' IDENTIFIER",
 556 | "ArgListOpt : ArgList",
 557 | "ArgListOpt :",
 558 | "MethodCall : Name '(' ArgListOpt ')'",
 559 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
 560 | "PostFixExpr : Primary",
 561 | "PostFixExpr : Name",
 562 | "UnaryExpr : '-' UnaryExpr",
 563 | "UnaryExpr : '!' UnaryExpr",
 564 | "UnaryExpr : PostFixExpr",
 565 | "MulExpr : UnaryExpr",
 566 | "MulExpr : MulExpr '*' UnaryExpr",
 567 | "MulExpr : MulExpr '/' UnaryExpr",
 568 | "MulExpr : MulExpr '%' UnaryExpr",
 569 | "AddExpr : MulExpr",
 570 | "AddExpr : AddExpr '+' MulExpr",
 571 | "AddExpr : AddExpr '-' MulExpr",
 572 | "RelOp : LESSTHANOREQUAL",
 573 | "RelOp : GREATERTHANOREQUAL",
 574 | "RelOp : '<'",
 575 | "RelOp : '>'",
 576 | "RelExpr : AddExpr",
 577 | "RelExpr : RelExpr RelOp AddExpr",
 578 | "EqExpr : RelExpr",
 579 | "EqExpr : EqExpr ISEQUALTO RelExpr",
 580 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
 581 | "CondAndExpr : EqExpr",
 582 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
 583 | "CondOrExpr : CondAndExpr",
 584 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
 585 | "Expr : CondOrExpr",
 586 | "Expr : Assignment",
 587 | "Assignment : LeftHandSide AssignOp Expr",
 588 | "LeftHandSide : Name",
 589 | "LeftHandSide : FieldAccess",
 590 | "AssignOp : '='",
 591 | "AssignOp : INCREMENT",
 592 | "AssignOp : DECREMENT",
 593 | };
 594 | 
 595 | //###############################################################
 596 | // method: yylexdebug : check lexer state
 597 | //###############################################################
 598 | void yylexdebug(int state,int ch)
 599 | {
 600 | String s=null;
 601 |   if (ch < 0) ch=0;
 602 |   if (ch <= YYMAXTOKEN) //check index bounds
 603 |      s = yyname[ch];    //now get it
 604 |   if (s==null)
 605 |     s = "illegal-symbol";
 606 |   debug("state "+state+", reading "+ch+" ("+s+")");
 607 | }
 608 | 
 609 | 
 610 | 
 611 | 
 612 | 
 613 | //The following are now global, to aid in error reporting
 614 | int yyn;       //next next thing to do
 615 | int yym;       //
 616 | int yystate;   //current parsing state from state table
 617 | String yys;    //current token string
 618 | 
 619 | 
 620 | //###############################################################
 621 | // method: yyparse : parse input and execute indicated items
 622 | //###############################################################
 623 | int yyparse()
 624 | {
 625 | boolean doaction;
 626 |   init_stacks();
 627 |   yynerrs = 0;
 628 |   yyerrflag = 0;
 629 |   yychar = -1;          //impossible char forces a read
 630 |   yystate=0;            //initial state
 631 |   state_push(yystate);  //save it
 632 |   val_push(yylval);     //save empty value
 633 |   while (true) //until parsing is done, either correctly, or w/error
 634 |     {
 635 |     doaction=true;
 636 |     if (yydebug) debug("loop"); 
 637 |     //#### NEXT ACTION (from reduction table)
 638 |     for (yyn=yydefred[yystate];yyn==0;yyn=yydefred[yystate])
 639 |       {
 640 |       if (yydebug) debug("yyn:"+yyn+"  state:"+yystate+"  yychar:"+yychar);
 641 |       if (yychar < 0)      //we want a char?
 642 |         {
 643 |         yychar = yylex();  //get next token
 644 |         if (yydebug) debug(" next yychar:"+yychar);
 645 |         //#### ERROR CHECK ####
 646 |         if (yychar < 0)    //it it didn't work/error
 647 |           {
 648 |           yychar = 0;      //change it to default string (no -1!)
 649 |           if (yydebug)
 650 |             yylexdebug(yystate,yychar);
 651 |           }
 652 |         }//yychar<0
 653 |       yyn = yysindex[yystate];  //get amount to shift by (shift index)
 654 |       if ((yyn != 0) && (yyn += yychar) >= 0 &&
 655 |           yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
 656 |         {
 657 |         if (yydebug)
 658 |           debug("state "+yystate+", shifting to state "+yytable[yyn]);
 659 |         //#### NEXT STATE ####
 660 |         yystate = yytable[yyn];//we are in a new state
 661 |         state_push(yystate);   //save it
 662 |         val_push(yylval);      //push our lval as the input for next rule
 663 |         yychar = -1;           //since we have 'eaten' a token, say we need another
 664 |         if (yyerrflag > 0)     //have we recovered an error?
 665 |            --yyerrflag;        //give ourselves credit
 666 |         doaction=false;        //but don't process yet
 667 |         break;   //quit the yyn=0 loop
 668 |         }
 669 | 
 670 |     yyn = yyrindex[yystate];  //reduce
 671 |     if ((yyn !=0 ) && (yyn += yychar) >= 0 &&
 672 |             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
 673 |       {   //we reduced!
 674 |       if (yydebug) debug("reduce");
 675 |       yyn = yytable[yyn];
 676 |       doaction=true; //get ready to execute
 677 |       break;         //drop down to actions
 678 |       }
 679 |     else //ERROR RECOVERY
 680 |       {
 681 |       if (yyerrflag==0)
 682 |         {
 683 |         yyerror("syntax error");
 684 |         yynerrs++;
 685 |         }
 686 |       if (yyerrflag < 3) //low error count?
 687 |         {
 688 |         yyerrflag = 3;
 689 |         while (true)   //do until break
 690 |           {
 691 |           if (stateptr<0)   //check for under & overflow here
 692 |             {
 693 |             yyerror("stack underflow. aborting...");  //note lower case 's'
 694 |             return 1;
 695 |             }
 696 |           yyn = yysindex[state_peek(0)];
 697 |           if ((yyn != 0) && (yyn += YYERRCODE) >= 0 &&
 698 |                     yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
 699 |             {
 700 |             if (yydebug)
 701 |               debug("state "+state_peek(0)+", error recovery shifting to state "+yytable[yyn]+" ");
 702 |             yystate = yytable[yyn];
 703 |             state_push(yystate);
 704 |             val_push(yylval);
 705 |             doaction=false;
 706 |             break;
 707 |             }
 708 |           else
 709 |             {
 710 |             if (yydebug)
 711 |               debug("error recovery discarding state "+state_peek(0)+" ");
 712 |             if (stateptr<0)   //check for under & overflow here
 713 |               {
 714 |               yyerror("Stack underflow. aborting...");  //capital 'S'
 715 |               return 1;
 716 |               }
 717 |             state_pop();
 718 |             val_pop();
 719 |             }
 720 |           }
 721 |         }
 722 |       else            //discard this token
 723 |         {
 724 |         if (yychar == 0)
 725 |           return 1; //yyabort
 726 |         if (yydebug)
 727 |           {
 728 |           yys = null;
 729 |           if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
 730 |           if (yys == null) yys = "illegal-symbol";
 731 |           debug("state "+yystate+", error recovery discards token "+yychar+" ("+yys+")");
 732 |           }
 733 |         yychar = -1;  //read another
 734 |         }
 735 |       }//end error recovery
 736 |     }//yyn=0 loop
 737 |     if (!doaction)   //any reason not to proceed?
 738 |       continue;      //skip action
 739 |     yym = yylen[yyn];          //get count of terminals on rhs
 740 |     if (yydebug)
 741 |       debug("state "+yystate+", reducing "+yym+" by rule "+yyn+" ("+yyrule[yyn]+")");
 742 |     if (yym>0)                 //if count of rhs not 'nil'
 743 |       yyval = val_peek(yym-1); //get current semantic value
 744 |     yyval = dup_yyval(yyval); //duplicate yyval if ParserVal is used as semantic value
 745 |     switch(yyn)
 746 |       {
 747 | //########## USER-SUPPLIED ACTIONS ##########
 748 | case 1:
 749 | //#line 8 "j0gram.y"
 750 | {
 751 |   yyval=j0.node("ClassDecl",1000,val_peek(1),val_peek(0));
 752 |   j0.print(yyval);
 753 |  }
 754 | break;
 755 | case 2:
 756 | //#line 12 "j0gram.y"
 757 | { yyval=j0.node("ClassBody",1010,val_peek(1)); }
 758 | break;
 759 | case 3:
 760 | //#line 13 "j0gram.y"
 761 | { yyval=j0.node("ClassBody",1011); }
 762 | break;
 763 | case 5:
 764 | //#line 15 "j0gram.y"
 765 | {
 766 |   yyval=j0.node("ClassBodyDecls",1020,val_peek(1),val_peek(0)); }
 767 | break;
 768 | case 9:
 769 | //#line 18 "j0gram.y"
 770 | {
 771 |   yyval=j0.node("FieldDecl",1030,val_peek(2),val_peek(1)); }
 772 | break;
 773 | case 17:
 774 | //#line 23 "j0gram.y"
 775 | {
 776 |   yyval=j0.node("QualifiedName",1040,val_peek(2),val_peek(0));}
 777 | break;
 778 | case 19:
 779 | //#line 26 "j0gram.y"
 780 | {
 781 |   yyval=j0.node("VarDecls",1050,val_peek(2),val_peek(0)); }
 782 | break;
 783 | case 21:
 784 | //#line 28 "j0gram.y"
 785 | {
 786 |   yyval=j0.node("VarDeclarator",1060,val_peek(2)); }
 787 | break;
 788 | case 24:
 789 | //#line 32 "j0gram.y"
 790 | {
 791 |   yyval=j0.node("MethodDecl",1380,val_peek(1),val_peek(0));
 792 |  }
 793 | break;
 794 | case 25:
 795 | //#line 35 "j0gram.y"
 796 | {
 797 |   yyval=j0.node("MethodHeader",1070,val_peek(1),val_peek(0)); }
 798 | break;
 799 | case 26:
 800 | //#line 37 "j0gram.y"
 801 | {
 802 |   yyval=j0.node("MethodDeclarator",1080,val_peek(3),val_peek(1)); }
 803 | break;
 804 | case 30:
 805 | //#line 41 "j0gram.y"
 806 | {
 807 |   yyval=j0.node("FormalParmList",1090,val_peek(2),val_peek(0)); }
 808 | break;
 809 | case 31:
 810 | //#line 43 "j0gram.y"
 811 | {
 812 |   yyval=j0.node("FormalParm",1100,val_peek(1),val_peek(0));
 813 |  }
 814 | break;
 815 | case 32:
 816 | //#line 47 "j0gram.y"
 817 | {
 818 |   yyval=j0.node("ConstructorDecl",1110,val_peek(1),val_peek(0)); }
 819 | break;
 820 | case 33:
 821 | //#line 50 "j0gram.y"
 822 | {yyval=j0.node("Block",1200,val_peek(1));}
 823 | break;
 824 | case 37:
 825 | //#line 52 "j0gram.y"
 826 | {
 827 |   yyval=j0.node("BlockStmts",1130,val_peek(1),val_peek(0)); }
 828 | break;
 829 | case 41:
 830 | //#line 57 "j0gram.y"
 831 | {
 832 |   yyval=j0.node("LocalVarDecl",1140,val_peek(1),val_peek(0)); }
 833 | break;
 834 | case 55:
 835 | //#line 68 "j0gram.y"
 836 | {
 837 |   yyval=j0.node("IfThenStmt",1150,val_peek(2),val_peek(0)); }
 838 | break;
 839 | case 56:
 840 | //#line 70 "j0gram.y"
 841 | {
 842 |   yyval=j0.node("IfThenElseStmt",1160,val_peek(4),val_peek(2),val_peek(0)); }
 843 | break;
 844 | case 57:
 845 | //#line 72 "j0gram.y"
 846 | {
 847 |   yyval=j0.node("IfThenElseIfStmt",1170,val_peek(3),val_peek(1),val_peek(0)); }
 848 | break;
 849 | case 58:
 850 | //#line 74 "j0gram.y"
 851 | {
 852 |   yyval=j0.node("IfThenElseIfStmt",1171,val_peek(5),val_peek(3),val_peek(2),val_peek(0)); }
 853 | break;
 854 | case 60:
 855 | //#line 77 "j0gram.y"
 856 | {
 857 |   yyval=j0.node("ElseIfSequence",1180,val_peek(1),val_peek(0)); }
 858 | break;
 859 | case 61:
 860 | //#line 79 "j0gram.y"
 861 | {
 862 |   yyval=j0.node("ElseIfStmt",1190,val_peek(0)); }
 863 | break;
 864 | case 62:
 865 | //#line 81 "j0gram.y"
 866 | {
 867 |   yyval=j0.node("WhileStmt",1210,val_peek(2),val_peek(0)); }
 868 | break;
 869 | case 63:
 870 | //#line 84 "j0gram.y"
 871 | {
 872 |   yyval=j0.node("ForStmt",1220,val_peek(6),val_peek(4),val_peek(2),val_peek(0)); }
 873 | break;
 874 | case 72:
 875 | //#line 90 "j0gram.y"
 876 | {
 877 |   yyval=j0.node("StmtExprList",1230,val_peek(2),val_peek(0)); }
 878 | break;
 879 | case 74:
 880 | //#line 93 "j0gram.y"
 881 | {
 882 |   yyval=j0.node("BreakStmt",1240,val_peek(1)); }
 883 | break;
 884 | case 75:
 885 | //#line 95 "j0gram.y"
 886 | {
 887 |   yyval=j0.node("ReturnStmt",1250,val_peek(1)); }
 888 | break;
 889 | case 79:
 890 | //#line 98 "j0gram.y"
 891 | {
 892 |   yyval=val_peek(1);}
 893 | break;
 894 | case 86:
 895 | //#line 102 "j0gram.y"
 896 | {
 897 |   yyval=j0.node("ArgList",1270,val_peek(2),val_peek(0)); }
 898 | break;
 899 | case 87:
 900 | //#line 104 "j0gram.y"
 901 | {
 902 |   yyval=j0.node("FieldAccess",1280,val_peek(2),val_peek(0)); }
 903 | break;
 904 | case 90:
 905 | //#line 108 "j0gram.y"
 906 | {
 907 |   yyval=j0.node("MethodCall",1290,val_peek(3),val_peek(1)); }
 908 | break;
 909 | case 91:
 910 | //#line 110 "j0gram.y"
 911 | {
 912 |     yyval=j0.node("MethodCall",1291,val_peek(5),val_peek(3),val_peek(1)); }
 913 | break;
 914 | case 94:
 915 | //#line 115 "j0gram.y"
 916 | {
 917 |   yyval=j0.node("UnaryExpr",1300,val_peek(1),val_peek(0)); }
 918 | break;
 919 | case 95:
 920 | //#line 117 "j0gram.y"
 921 | {
 922 |   yyval=j0.node("UnaryExpr",1301,val_peek(1),val_peek(0)); }
 923 | break;
 924 | case 98:
 925 | //#line 121 "j0gram.y"
 926 | {
 927 |       yyval=j0.node("MulExpr",1310,val_peek(2),val_peek(0)); }
 928 | break;
 929 | case 99:
 930 | //#line 123 "j0gram.y"
 931 | {
 932 |       yyval=j0.node("MulExpr",1311,val_peek(2),val_peek(0)); }
 933 | break;
 934 | case 100:
 935 | //#line 125 "j0gram.y"
 936 | {
 937 |       yyval=j0.node("MulExpr",1312,val_peek(2),val_peek(0)); }
 938 | break;
 939 | case 102:
 940 | //#line 128 "j0gram.y"
 941 | {
 942 |       yyval=j0.node("AddExpr",1320,val_peek(2),val_peek(0)); }
 943 | break;
 944 | case 103:
 945 | //#line 130 "j0gram.y"
 946 | {
 947 |       yyval=j0.node("AddExpr",1321,val_peek(2),val_peek(0)); }
 948 | break;
 949 | case 109:
 950 | //#line 133 "j0gram.y"
 951 | {
 952 |   yyval=j0.node("RelExpr",1330,val_peek(2),val_peek(1),val_peek(0)); }
 953 | break;
 954 | case 111:
 955 | //#line 137 "j0gram.y"
 956 | {
 957 |   yyval=j0.node("EqExpr",1340,val_peek(2),val_peek(0)); }
 958 | break;
 959 | case 112:
 960 | //#line 139 "j0gram.y"
 961 | {
 962 |   yyval=j0.node("EqExpr",1341,val_peek(2),val_peek(0)); }
 963 | break;
 964 | case 114:
 965 | //#line 141 "j0gram.y"
 966 | {
 967 |   yyval=j0.node("CondAndExpr", 1350, val_peek(2), val_peek(0)); }
 968 | break;
 969 | case 116:
 970 | //#line 143 "j0gram.y"
 971 | {
 972 |   yyval=j0.node("CondOrExpr", 1360, val_peek(2), val_peek(0)); }
 973 | break;
 974 | case 119:
 975 | //#line 147 "j0gram.y"
 976 | {
 977 | yyval=j0.node("Assignment",1370, val_peek(2), val_peek(1), val_peek(0)); }
 978 | break;
 979 | //#line 900 "parser.java"
 980 | //########## END OF USER-SUPPLIED ACTIONS ##########
 981 |     }//switch
 982 |     //#### Now let's reduce... ####
 983 |     if (yydebug) debug("reduce");
 984 |     state_drop(yym);             //we just reduced yylen states
 985 |     yystate = state_peek(0);     //get new state
 986 |     val_drop(yym);               //corresponding value drop
 987 |     yym = yylhs[yyn];            //select next TERMINAL(on lhs)
 988 |     if (yystate == 0 && yym == 0)//done? 'rest' state and at first TERMINAL
 989 |       {
 990 |       if (yydebug) debug("After reduction, shifting from state 0 to state "+YYFINAL+"");
 991 |       yystate = YYFINAL;         //explicitly say we're done
 992 |       state_push(YYFINAL);       //and save it
 993 |       val_push(yyval);           //also save the semantic value of parsing
 994 |       if (yychar < 0)            //we want another character?
 995 |         {
 996 |         yychar = yylex();        //get next character
 997 |         if (yychar<0) yychar=0;  //clean, if necessary
 998 |         if (yydebug)
 999 |           yylexdebug(yystate,yychar);
1000 |         }
1001 |       if (yychar == 0)          //Good exit (if lex returns 0 ;-)
1002 |          break;                 //quit the loop--all DONE
1003 |       }//if yystate
1004 |     else                        //else not done yet
1005 |       {                         //get next state and push, for next yydefred[]
1006 |       yyn = yygindex[yym];      //find out where to go
1007 |       if ((yyn != 0) && (yyn += yystate) >= 0 &&
1008 |             yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
1009 |         yystate = yytable[yyn]; //get new state
1010 |       else
1011 |         yystate = yydgoto[yym]; //else go to new defred
1012 |       if (yydebug) debug("after reduction, shifting from state "+state_peek(0)+" to state "+yystate+"");
1013 |       state_push(yystate);     //going again, so push state & val...
1014 |       val_push(yyval);         //for next action
1015 |       }
1016 |     }//main loop
1017 |   return 0;//yyaccept!!
1018 | }
1019 | //## end of method parse() ######################################
1020 | 
1021 | 
1022 | 
1023 | //## run() --- for Thread #######################################
1024 | /**
1025 |  * A default run method, used for operating this parser
1026 |  * object in the background.  It is intended for extending Thread
1027 |  * or implementing Runnable.  Turn off with -Jnorun .
1028 |  */
1029 | public void run()
1030 | {
1031 |   yyparse();
1032 | }
1033 | //## end of method run() ########################################
1034 | 
1035 | 
1036 | 
1037 | //## Constructors ###############################################
1038 | /**
1039 |  * Default constructor.  Turn off with -Jnoconstruct .
1040 | 
1041 |  */
1042 | public parser()
1043 | {
1044 |   //nothing to do
1045 | }
1046 | 
1047 | 
1048 | /**
1049 |  * Create a parser, setting the debug to true or false.
1050 |  * @param debugMe true for debugging, false for no debug.
1051 |  */
1052 | public parser(boolean debugMe)
1053 | {
1054 |   yydebug=debugMe;
1055 | }
1056 | //###############################################################
1057 | 
1058 | 
1059 | 
1060 | }
1061 | //################### END OF CLASS ##############################
1062 | 


--------------------------------------------------------------------------------
/ch5/parserVal.java:
--------------------------------------------------------------------------------
 1 | //#############################################
 2 | //## file: parser.java
 3 | //## Generated by Byacc/j
 4 | //#############################################
 5 | package ch5;
 6 | 
 7 | /**
 8 |  * BYACC/J Semantic Value for parser: parser
 9 |  * This class provides some of the functionality
10 |  * of the yacc/C 'union' directive
11 |  */
12 | public class parserVal
13 | {
14 | /**
15 |  * integer value of this 'union'
16 |  */
17 | public int ival;
18 | 
19 | /**
20 |  * double value of this 'union'
21 |  */
22 | public double dval;
23 | 
24 | /**
25 |  * string value of this 'union'
26 |  */
27 | public String sval;
28 | 
29 | /**
30 |  * object value of this 'union'
31 |  */
32 | public Object obj;
33 | 
34 | //#############################################
35 | //## C O N S T R U C T O R S
36 | //#############################################
37 | /**
38 |  * Initialize me without a value
39 |  */
40 | public parserVal()
41 | {
42 | }
43 | /**
44 |  * Initialize me as an int
45 |  */
46 | public parserVal(int val)
47 | {
48 |   ival=val;
49 | }
50 | 
51 | /**
52 |  * Initialize me as a double
53 |  */
54 | public parserVal(double val)
55 | {
56 |   dval=val;
57 | }
58 | 
59 | /**
60 |  * Initialize me as a string
61 |  */
62 | public parserVal(String val)
63 | {
64 |   sval=val;
65 | }
66 | 
67 | /**
68 |  * Initialize me as an Object
69 |  */
70 | public parserVal(Object val)
71 | {
72 |   obj=val;
73 | }
74 | }//end class
75 | 
76 | //#############################################
77 | //## E N D    O F    F I L E
78 | //#############################################
79 | 


--------------------------------------------------------------------------------
/ch5/prodrule.java:
--------------------------------------------------------------------------------
1 | public class prodrule {
2 | }
3 | 


--------------------------------------------------------------------------------
/ch5/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch5/serial.java:
--------------------------------------------------------------------------------
1 | package ch5;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch5/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | initially
21 |    case cat of {
22 |      parser.INTLIT:    { ival := integer(text) }
23 |      parser.DOUBLELIT: { dval := real(text) }
24 |      parser.STRINGLIT: { sval := deEscape(text) }
25 |    }
26 | end
27 | 


--------------------------------------------------------------------------------
/ch5/token.java:
--------------------------------------------------------------------------------
 1 | package ch5;
 2 | public class token {
 3 |    public int id;
 4 |    public int cat;
 5 |    public String text;
 6 |    public int lineno;
 7 |    public token(int c, String s, int l) {
 8 |       cat = c; text = s; lineno = l;
 9 |       id = serial.getid();
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch5/tree.icn:
--------------------------------------------------------------------------------
 1 | class tree (id,sym,rule,nkids,tok,kids)
 2 |   method print(level:0)
 3 |     writes(repl(" ",level))
 4 |     if \tok then {
 5 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
 6 |       }
 7 |     else {
 8 |        write(id, "   ", sym, " (", rule, "): ", nkids)
 9 |        every (!kids).print(level+1)
10 |        }
11 |   end
12 |   method print_graph(fw)
13 |     if type(fw) == "string" then {
14 |       fw := open(fw,  "w") |
15 |         stop("can't open ", image(fw), " for writing")
16 |       write(fw, "digraph {")
17 |       print_graph(fw)
18 |       write(fw, "}")
19 |       close(fw)
20 |     }
21 |     else if \tok then print_leaf(fw)
22 |     else { 
23 |       print_branch(fw)
24 |       every i := 1 to nkids do
25 |         if \kids[i] then {
26 |           write(fw, "N",id," -> N",kids[i].id,";")
27 |           kids[i].print_graph(fw)
28 |         } else {
29 |           write(fw, "N",id," -> N",id,"_",j,";")
30 |           write(fw, "N", id, "_", j,
31 |                     " [label=\"Empty rule\"];")
32 |           j +:= 1
33 |         }
34 |     }
35 |   end
36 |   method print_leaf(pw)
37 |     local s := yyname[tok.cat]
38 |     print_branch(pw)
39 |     write(pw,"N",id,
40 |           " [shape=box style=dotted label=\" ",s," \\n ")
41 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
42 |              tok.lineno," \\l\"];\n")
43 |   end
44 |   method print_branch(pw)
45 |     write(pw, "N",id," [shape=box label=\"",
46 |           pretty_print_name(),"\"];\n");
47 |   end
48 |   method escape(s)
49 |     if s[1] == "\"" then
50 |       return "\\" || s[1:-1] || "\\\""
51 |     else return s
52 |   end
53 |   method pretty_print_name()
54 |     if /tok then return sym || "#" || (rule%10)
55 |     else return escape(tok.text) || ":" || tok.cat
56 |   end
57 | 
58 | initially (s,r,x[])
59 |    id := serial.getid(); sym := s; rule := r
60 |    if type(x[1]) == "token__state" then {
61 |       nkids := 0; tok := x[1]
62 |    } else {
63 |       nkids := *x;
64 |       kids := x
65 |    }
66 | end
67 | 


--------------------------------------------------------------------------------
/ch5/tree.java:
--------------------------------------------------------------------------------
  1 | package ch5;
  2 | import java.io.PrintWriter;
  3 | import java.io.BufferedWriter;
  4 | import java.io.FileWriter;
  5 | class tree {
  6 |   int id;
  7 |   String sym;
  8 |   int rule;
  9 |   int nkids;
 10 |   token tok;
 11 |   tree kids[];
 12 | 
 13 |   public String escape(String s) {
 14 |       if (s.charAt(0) == '\"')
 15 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 16 |       else return s;
 17 |   }
 18 | 
 19 |   public String pretty_print_name() {
 20 |     if (tok == null) return sym +"#"+(rule%10);
 21 |     else {
 22 | 	return escape(tok.text)+":"+tok.cat;
 23 | 	}
 24 |     }
 25 | 
 26 |   void print_graph(String filename){
 27 |     try {
 28 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 29 |       pw.printf("digraph {\n");
 30 |       j = 0;
 31 |       print_graph(pw);
 32 |       pw.printf("}\n");
 33 |       pw.close();
 34 |       }
 35 |     catch (java.io.IOException ioException) {
 36 |       System.err.println("printgraph exception");
 37 |       System.exit(1);
 38 |       }
 39 |     }
 40 | 
 41 |   int j;
 42 |   void print_graph(PrintWriter pw) {
 43 |   int i;
 44 |     if (tok != null) {
 45 | 	print_leaf(pw);
 46 |         return;
 47 |     }
 48 |     // from here on out, we know we are not a leaf
 49 |     print_branch(pw);
 50 |     
 51 |     for(i=0; i<nkids; i++) {
 52 |         if (kids[i] != null) {
 53 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 54 | 	    kids[i].print_graph(pw);
 55 |         } else {
 56 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 57 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 58 | 	    j++;
 59 |         }
 60 |     }
 61 |   }
 62 | 
 63 |   void print_leaf(PrintWriter pw) {
 64 |     String s = parser.yyname[tok.cat];
 65 |     print_branch(pw);
 66 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 67 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 68 | 	      escape(tok.text), tok.lineno);
 69 |   }
 70 | 
 71 |   void print_branch(PrintWriter pw) {
 72 |     pw.printf("N%d ",id);
 73 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 74 |     if (tok != null)
 75 | 	pw.printf("struct token* leaf %d", tok.id);
 76 |     pw.printf("\"];\n");
 77 |   }
 78 | 
 79 |   public void print(int level) {
 80 |     int i;
 81 |     for(i=0;i<level;i++) System.out.print(" ");
 82 |     if (tok != null) {
 83 |       System.out.println(id + "   " + tok.text +
 84 |                          " (" + tok.cat + "): "+tok.lineno);
 85 |     }
 86 |     else {
 87 |       System.out.println(id + "   " + sym +
 88 | 			 " (" + rule + "): "+nkids);
 89 |     }
 90 |     for(i=0; i<nkids; i++)
 91 |       kids[i].print(level+1);
 92 |   }
 93 |     public void print() {
 94 | 	print(0);
 95 |     }
 96 |     public tree(String s, int r, token t) {
 97 | 	id = serial.getid();
 98 |         sym = s; rule = r; tok = t; }
 99 | 
100 |     public tree(String s, int r, tree[] t) {
101 | 	id = serial.getid();
102 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
103 | 	sym = s; rule = r; nkids = t.length;
104 | 	kids = t;
105 |     }
106 | }
107 | 


--------------------------------------------------------------------------------
/ch5/xy5.java:
--------------------------------------------------------------------------------
1 | public class xy5 {
2 |    static double y = 5.0;
3 |    public static void main(String argv[]) {
4 |        int x;
5 |        x = (int)y + 5;
6 |       System.out.println("y + 5 = " + x);
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch5/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     stop(s)
3 | end
4 | 


--------------------------------------------------------------------------------
/ch5/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch5;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch6/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!");
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch6/helloerror.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!")
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch6/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yycolno, yylval, parser, global_st
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    serial := serial()
 5 |    parser := Parser()
 6 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 7 |    yylineno := yycolno := 1
 8 |    if yyparse() = 0 then
 9 |       write("no errors")
10 | end
11 | class j0()
12 |    method lexErr(s)
13 |       stop(s, ": ", yytext) 
14 |    end
15 |    method scan(cat)
16 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
17 |       yycolno +:= *yytext
18 |       return cat
19 |    end
20 |    method whitespace()
21 |       yycolno +:= *yytext
22 |    end
23 |    method newline()
24 |       yylineno +:= 1; yycolno := 1
25 |    end
26 |    method comment()
27 |       yytext ? {
28 |          while tab(find("\n")+1) do newline()
29 |          yycolno +:= *tab(0)
30 |       }
31 |    end
32 |    method ord(s)
33 |       return proc("ord",0)(s[1])
34 |    end
35 |    method print(root)
36 |       root.print()
37 |    end
38 |    method node(s,r,p[])
39 |       return tree ! ([s,r] ||| p)
40 |    end
41 |    method semantic(root)
42 |    local out_st, System_st
43 |      global_st := symtab("global")
44 |      System_st := symtab("class")
45 |      out_st := symtab("class")
46 |      out_st.insert("println", false)
47 |      System_st.insert("out", false, out_st)
48 |      global_st.insert("System", false, System_st)
49 |      root.mkSymTables(global_st)
50 |      root.populateSymTables()
51 |      root.checkSymTables()
52 |      global_st.print()
53 |    end
54 |    method semerror(s)
55 |      stop("semantic error: ", s)
56 |    end
57 | 
58 | end
59 | 


--------------------------------------------------------------------------------
/ch6/j0.java:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | import java.io.FileReader;
 3 | public class j0 {
 4 |    public static Yylex yylexer;
 5 |    public static ch6.parser par;
 6 |    public static ch6.symtab global_st;
 7 |    public static void main(String argv[]) throws Exception {
 8 |       init(argv[0]);
 9 |       par = new ch6.parser();
10 |       //                  par.yydebug=true;
11 |       yylineno = 1;
12 |       int i = par.yyparse();
13 |       if (i == 0)
14 |          System.out.println("no errors");
15 |    }
16 |    public static int yylineno;
17 |    public static String yyfilename;
18 |     //   public static parserVal yylval;
19 |    public static void init(String s) throws Exception {
20 |       yyfilename = s;
21 |       System.out.println("yyfilename "+yyfilename);
22 |       yylexer = new Yylex(new FileReader(s));
23 |    }
24 |    public static int YYEOF() { return Yylex.YYEOF; }
25 |    public static int yylex() {
26 |       int rv = 0;
27 |       try {
28 |         rv = yylexer.yylex();
29 |       } catch(java.io.IOException ioException) {
30 |         rv = -1;
31 |       }
32 |       return rv;
33 |    }
34 |    public static String yytext() {
35 |       return yylexer.yytext();
36 |    }
37 |    public static void lexErr(String s) {
38 |       System.err.println(s);
39 |       System.exit(1);
40 |    }
41 |    public static int scan(int cat) {
42 |        ch6.j0.par.yylval =
43 | 	   new parserVal(new tree("token",0,
44 | 		new token(cat, yytext(), yylineno)));
45 |       return cat;
46 |    }
47 |    public static void newline() {
48 |       yylineno++;
49 |    }
50 |    public static void whitespace() {
51 |    }
52 |    public static void comment() {
53 |    }
54 |    public static short ord(String s) { return (short)(s.charAt(0)); }
55 |    public static void print(parserVal root) {
56 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
57 |    }
58 |   public static tree unwrap(Object obj) {
59 |     if (obj instanceof token)
60 |       return new tree("token",0,(token)obj);
61 |     else return (tree)obj;
62 |   }
63 |   public static parserVal node(String s,int r,parserVal...p) {
64 |      tree[] t = new tree[p.length];
65 |      for(int i = 0; i < t.length; i++)
66 | 	 t[i] = (tree)(p[i].obj);
67 |      return new parserVal((Object)new tree(s,r,t));
68 |   }
69 |   public static void semantic(parserVal r) {
70 |     tree root = (tree)(r.obj);
71 |     ch6.symtab out_st, System_st;
72 |     global_st = new ch6.symtab("global");
73 |     System_st = new ch6.symtab("class");
74 |     out_st = new ch6.symtab("class");
75 |     out_st.insert("println", false);
76 |     System_st.insert("out", false, out_st);
77 |     global_st.insert("System", false, System_st);
78 |    root.mkSymTables(global_st);
79 |    root.populateSymTables();
80 |    root.checkSymTables();
81 |    global_st.print();
82 |   }
83 |   public static void semerror(String s) {
84 |    System.out.println("semantic error: " + s);
85 |    System.exit(1);
86 |   }
87 | }
88 | 


--------------------------------------------------------------------------------
/ch6/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |  } ;
 12 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 13 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 14 | ClassBodyDecls: ClassBodyDecl
 15 | | ClassBodyDecls ClassBodyDecl {
 16 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 17 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 18 | FieldDecl: Type VarDecls ';' {
 19 |   $=j0.node("FieldDecl",1030,$1,$2); };
 20 | Type: INT | DOUBLE | BOOL | STRING | Name ;
 21 | 
 22 | Name: IDENTIFIER | QualifiedName ;
 23 | QualifiedName: Name '.' IDENTIFIER {
 24 |   $=j0.node("QualifiedName",1040,$1,$3);};
 25 | 
 26 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 27 |   $=j0.node("VarDecls",1050,$1,$3); };
 28 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 29 |   $=j0.node("VarDeclarator",1060,$1); };
 30 | 
 31 | MethodReturnVal : Type | VOID ;
 32 | MethodDecl: MethodHeader Block {
 33 |   $=j0.node("MethodDecl",1380,$1,$2);
 34 |  };
 35 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 36 |   $=j0.node("MethodHeader",1070,$3,$4);
 37 |   };
 38 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 39 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 40 | 
 41 | FormalParmListOpt: FormalParmList | ;
 42 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 43 |   $=j0.node("FormalParmList",1090,$1,$3); };
 44 | FormalParm: Type VarDeclarator {
 45 |   $=j0.node("FormalParm",1100,$1,$2);
 46 |  };
 47 | 
 48 | ConstructorDecl: MethodDeclarator Block {
 49 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 50 | 
 51 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 52 | BlockStmtsOpt: BlockStmts | ;
 53 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 54 |   $=j0.node("BlockStmts",1130,$1,$2); };
 55 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 56 | 
 57 | LocalVarDeclStmt: LocalVarDecl ';' ;
 58 | LocalVarDecl: Type VarDecls {
 59 |   $=j0.node("LocalVarDecl",1140,$1,$2); };
 60 | 
 61 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 62 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 63 |       | WhileStmt | ForStmt ;
 64 | 
 65 | ExprStmt: StmtExpr ';' ;
 66 | 
 67 | StmtExpr: Assignment | MethodCall ;
 68 | 
 69 | IfThenStmt: IF '(' Expr ')' Block {
 70 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 71 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 72 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 73 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 74 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 75 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 76 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 77 | 
 78 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 79 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 80 | ElseIfStmt: ELSE IfThenStmt {
 81 |   $=j0.node("ElseIfStmt",1190,$2); };
 82 | WhileStmt: WHILE '(' Expr ')' Stmt {
 83 |   $=j0.node("WhileStmt",1210,$3,$5); };
 84 | 
 85 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 86 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 87 | ForInit: StmtExprList | LocalVarDecl | ;
 88 | ExprOpt: Expr |  ;
 89 | ForUpdate: StmtExprList | ;
 90 | 
 91 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 92 |   $=j0.node("StmtExprList",1230,$1,$3); };
 93 | 
 94 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
 95 |   $=j0.node("BreakStmt",1240,$2); };
 96 | ReturnStmt: RETURN ExprOpt ';' {
 97 |   $=j0.node("ReturnStmt",1250,$2); };
 98 | 
 99 | Primary:  Literal | FieldAccess | MethodCall | '(' Expr ')' {
100 |   $=$2;};
101 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
102 | 
103 | ArgList: Expr | ArgList ',' Expr {
104 |   $=j0.node("ArgList",1270,$1,$3); };
105 | FieldAccess: Primary '.' IDENTIFIER {
106 |   $=j0.node("FieldAccess",1280,$1,$3); };
107 | 
108 | ArgListOpt:  ArgList | ;
109 | MethodCall: Name '(' ArgListOpt ')' {
110 |   $=j0.node("MethodCall",1290,$1,$3); }
111 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
112 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
113 | 	;
114 | 
115 | PostFixExpr: Primary | Name ;
116 | UnaryExpr:  '-' UnaryExpr {
117 |   $=j0.node("UnaryExpr",1300,$1,$2); }
118 |     | '!' UnaryExpr {
119 |   $=j0.node("UnaryExpr",1301,$1,$2); }
120 |     | PostFixExpr ;
121 | MulExpr: UnaryExpr
122 |     | MulExpr '*' UnaryExpr {
123 |       $=j0.node("MulExpr",1310,$1,$3); }
124 |     | MulExpr '/' UnaryExpr {
125 |       $=j0.node("MulExpr",1311,$1,$3); }
126 |     | MulExpr '%' UnaryExpr {
127 |       $=j0.node("MulExpr",1312,$1,$3); };
128 | AddExpr: MulExpr
129 |     | AddExpr '+' MulExpr {
130 |       $=j0.node("AddExpr",1320,$1,$3); }
131 |     | AddExpr '-' MulExpr {
132 |       $=j0.node("AddExpr",1321,$1,$3); };
133 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
134 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
135 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
136 | 
137 | EqExpr: RelExpr
138 |     | EqExpr ISEQUALTO RelExpr {
139 |   $=j0.node("EqExpr",1340,$1,$3); }
140 | | EqExpr NOTEQUALTO RelExpr {
141 |   $=j0.node("EqExpr",1341,$1,$3); };
142 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
143 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
144 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
145 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
146 | 
147 | Expr: CondOrExpr | Assignment ;
148 | Assignment: LeftHandSide AssignOp Expr {
149 | $=j0.node("Assignment",1370, $1, $2, $3); };
150 | LeftHandSide: Name | FieldAccess ;
151 | AssignOp: '=' | INCREMENT | DECREMENT ;
152 | 


--------------------------------------------------------------------------------
/ch6/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "null"                 { return j0.scan(parser.NULLVAL); }
18 | "public"               { return j0.scan(parser.PUBLIC); }
19 | "return"               { return j0.scan(parser.RETURN); }
20 | "static"               { return j0.scan(parser.STATIC); }
21 | "string"               { return j0.scan(parser.STRING); }
22 | "true"                 { return j0.scan(parser.BOOLLIT); }
23 | "bool"                 { return j0.scan(parser.BOOL); }
24 | "void"                 { return j0.scan(parser.VOID); }
25 | "while"                { return j0.scan(parser.WHILE); }
26 | "class"                { return j0.scan(parser.CLASS); }
27 | "("                    { return j0.scan(j0.ord("("));}
28 | ")"                    { return j0.scan(j0.ord(")"));}
29 | "["                    { return j0.scan(j0.ord("["));}
30 | "]"                    { return j0.scan(j0.ord("]"));}
31 | "{"                    { return j0.scan(j0.ord("{"));}
32 | "}"                    { return j0.scan(j0.ord("}"));}
33 | ";"                    { return j0.scan(j0.ord(";"));}
34 | ":"                    { return j0.scan(j0.ord(":"));}
35 | "!"                    { return j0.scan(j0.ord("!"));}
36 | "*"                    { return j0.scan(j0.ord("*"));}
37 | "/"                    { return j0.scan(j0.ord("/"));}
38 | "%"                    { return j0.scan(j0.ord("%"));}
39 | "+"                    { return j0.scan(j0.ord("+"));}
40 | "-"                    { return j0.scan(j0.ord("-"));}
41 | "<"                    { return j0.scan(j0.ord("<"));}
42 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
43 | ">"                    { return j0.scan(j0.ord(">"));}
44 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
45 | "=="                   { return j0.scan(parser.ISEQUALTO);}
46 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
47 | "&&"                   { return j0.scan(parser.LOGICALAND);}
48 | "||"                   { return j0.scan(parser.LOGICALOR);}
49 | "="                    { return j0.scan(j0.ord("=")); }
50 | "+="                   { return j0.scan(parser.INCREMENT); }
51 | "-="                   { return j0.scan(parser.DECREMENT); }
52 | ","                    { return j0.scan(j0.ord(",")); }
53 | "."                    { return j0.scan(j0.ord(".")); }
54 | {id}                   { return j0.scan(parser.IDENTIFIER); }
55 | [0-9]+                 { return j0.scan(parser.INTLIT); }
56 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
57 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
58 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
59 | .                      { j0.lexErr("unrecognized character"); }
60 | 


--------------------------------------------------------------------------------
/ch6/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u
 6 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU)
 7 | unicon: j0
 8 | %.u : %.icn
 9 | 	unicon -c 
lt;
10 | j0: $(U)
11 | 	unicon $(U)
12 | javalex.icn: javalex.l
13 | 	uflex javalex.l
14 | j0gram.icn j0gram_tab.icn: j0gram.y
15 | 	iyacc -dd j0gram.y
16 | 
17 | # A typical run might use
18 | # set CLASSPATH=".;c:\users\username\byopl"
19 | # in order to run from c:\users\username\byopl\ch5
20 | LYSRC=Yylex.java parser.java parserVal.java
21 | STJ=symtab.java symtab_entry.java
22 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ)
23 | BYJOPTS= -Jclass=parser -Jpackage=ch6
24 | BYJIMPS= -Jyylex=ch6.j0.yylex -Jyyerror=ch6.yyerror.yyerror
25 | java: j0.class
26 | 
27 | j: java
28 | 	java ch6.j0 hello.java
29 | 	dot -Tpng hello.java.dot >hello.png
30 | 
31 | j0.class: $(JSRC)
32 | 	javac $(JSRC)
33 | parser.java parserVal.java: j0gram.y
34 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
35 | Yylex.java: javalex.l
36 | 	jflex javalex.l
37 | 
38 | 


--------------------------------------------------------------------------------
/ch6/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch6/serial.java:
--------------------------------------------------------------------------------
1 | package ch6;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch6/symtab.icn:
--------------------------------------------------------------------------------
 1 | class symtab(scope, parent, t)
 2 |   method lookup(s)
 3 |     return \ (t[s])
 4 |   end
 5 |   method insert(s, isConst, sub)
 6 |       if \ (t[s]) then j0.semerror("redeclaration of " || s)
 7 |       else t[s] := symtab_entry(s, self, sub, isConst)
 8 |   end
 9 |   method print(level:0)
10 |     writes(repl(" ",level))
11 |     write(scope, " - ", *t, " symbols")
12 |     every (!t).print(level+1);
13 |   end
14 | 
15 | initially
16 |   t := table()
17 | end
18 | 


--------------------------------------------------------------------------------
/ch6/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | import java.util.HashMap;
 3 | public class symtab {
 4 |    String scope;
 5 |    symtab parent;
 6 |    HashMap<String,symtab_entry> t;
 7 |    symtab(String sc) {
 8 |       scope = sc;
 9 |       t = new HashMap<String,symtab_entry>();
10 |    }
11 |     symtab(String sc, symtab p) {
12 |       scope = sc; parent = p;
13 |       t = new HashMap<String,symtab_entry>();
14 |    }
15 |    symtab_entry lookup(String s) {
16 |       return t.get(s);
17 |    }
18 |    void insert(String s, Boolean iC, symtab sub) {
19 |       if (t.containsKey(s)) {
20 |          j0.semerror("redeclaration of " + s);
21 |       } else {
22 |          sub.parent = this;
23 |          t.put(s, new symtab_entry(s, this, iC, sub));
24 |       }
25 |    }
26 |    void insert(String s, Boolean iC) {
27 |       if (t.containsKey(s)) {
28 |          j0.semerror("redeclaration of " + s);
29 |       } else {
30 |          t.put(s, new symtab_entry(s, this, iC));
31 |       }
32 |    }
33 |    void print() { print(0); }
34 |    void print(int level) {
35 |       for(int i=0; i<level; i++)
36 |         System.out.print(" ");
37 |       System.out.println(scope + " - " + t.size() + " symbols");
38 |       for(symtab_entry se : t.values()) se.print(level+1);
39 |    }
40 | }
41 | 


--------------------------------------------------------------------------------
/ch6/symtab_entry.icn:
--------------------------------------------------------------------------------
1 | class symtab_entry(sym,parent_st,st,isConst)
2 |   method print(level:0)
3 |     writes(repl(" ",level), sym)
4 |     if \isconst then writes(" (const)")
5 |     write()
6 |     (\st).print(level+1);
7 |   end
8 | end
9 | 


--------------------------------------------------------------------------------
/ch6/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    void print(int level) {
 7 |       for(int i=0; i<level; i++) System.out.print(" ");
 8 |       System.out.print(sym);
 9 |       if (isConst) System.out.print(" (const)");
10 |       System.out.println("");
11 |       if (st != null) st.print(level+1);
12 |    }
13 |    symtab_entry(String s, symtab p, boolean iC) {
14 |        sym = s; parent_st = p; isConst = iC; }
15 |    symtab_entry(String s, symtab p, boolean iC, symtab t) {
16 |      sym = s; parent_st = p; isConst = iC; st = t;
17 |  }
18 | }
19 | 


--------------------------------------------------------------------------------
/ch6/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | initially
21 |    case cat of {
22 |      parser.INTLIT:    { ival := integer(text) }
23 |      parser.DOUBLELIT: { dval := real(text) }
24 |      parser.STRINGLIT: { sval := deEscape(text) }
25 |    }
26 | end
27 | 


--------------------------------------------------------------------------------
/ch6/token.java:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | public class token {
 3 |    public int id;
 4 |    public int cat;
 5 |    public String text;
 6 |    public int lineno;
 7 |    public token(int c, String s, int l) {
 8 |       cat = c; text = s; lineno = l;
 9 |       id = serial.getid();
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch6/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab)
  2 |   method print(level:0)
  3 |     writes(repl(" ",level))
  4 |     if \tok then {
  5 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  6 |       }
  7 |     else {
  8 |        write(id, "   ", sym, " (", rule, "): ", nkids)
  9 |        every (!kids).print(level+1)
 10 |        }
 11 |   end
 12 |   method print_graph(fw)
 13 |     if type(filename) == "string" then {
 14 |       fw := open(filename,  "w") |
 15 |         stop("can't open ", image(filename), " for writing")
 16 |       write(fw, "digraph {")
 17 |       print_graph(fw)
 18 |       write(fw, "}")
 19 |       close(fw)
 20 |     }
 21 |     else if \tok then print_leaf(fw)
 22 |     else { 
 23 |       print_branch(fw)
 24 |       every i := 1 to nkids do
 25 |         if \kids[i] then {
 26 |           write(fw, "N",id," -> N",kids[i].id,";")
 27 |           kids[i].print_graph(fw)
 28 |         } else {
 29 |           write(fw, "N",id," -> N",id,"_",j,";")
 30 |           write(fw, "N", id, "_", j,
 31 |                     " [label=\"Empty rule\"];")
 32 |           j +:= 1
 33 |         }
 34 |     }
 35 |   end
 36 |   method print_leaf(pw)
 37 |     local s := parser.yyname[tok.cat]
 38 |     print_branch(pw)
 39 |     write(pw,"N",id,
 40 |           " [shape=box style=dotted label=\" ",s," \\n ")
 41 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 42 |              tok.lineno," \\l\"];\n")
 43 |   end
 44 |   method print_branch(pw)
 45 |     write(pw, "N",id," [shape=box label=\"",
 46 |           pretty_print_name(),"\"];\n");
 47 |   end
 48 |   method escape(s)
 49 |     if s[1] == "\"" then
 50 |       return "\\" || s[1:-1] || "\\\""
 51 |     else return s
 52 |   end
 53 |   method pretty_print_name()
 54 |     if /tok then return sym || "#" || (rule%10)
 55 |     else return escape(tok.text) || ":" || tok.cat
 56 |   end
 57 |   method mkSymTables(curr)
 58 |     stab := curr
 59 |     case sym of {
 60 |       "ClassDecl": { curr := symtab("class",curr) }
 61 |       "MethodDecl": { curr := symtab("method",curr) }
 62 |     }
 63 |     every (!\kids).mkSymTables(curr)
 64 |   end
 65 |   method populateSymTables()
 66 |   case sym of {
 67 |     "ClassDecl": {
 68 |        stab.insert(kids[1].tok.text, , kids[1].stab)
 69 |        }
 70 |     "FieldDecl" | "LocalVarDecl" : {
 71 |        k := kids[2]
 72 |        while \k & k.label=="VarDecls" do {
 73 |          insert_vardeclarator(k.kids[2])
 74 |          k := k.kids[1]
 75 |          }
 76 |        insert_vardeclarator(k); return
 77 |        }
 78 |     "MethodDecl": {
 79 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab)
 80 |       }
 81 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 82 |     }
 83 |     every (!\kids).populateSymTables()
 84 |   end
 85 |   method insert_vardeclarator(vd)
 86 |    if \vd.tok then stab.insert(vd.tok.text)
 87 |    else insert_vardeclarator(vd.kids[1])
 88 |   end
 89 |   method calc_isConst()
 90 |    case sym of {
 91 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 92 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 93 |       "UnaryExpr": isConst := \kid[2].isConst
 94 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 95 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
 96 |       "MULEXPR"|
 97 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
 98 |       default: isConst := &null
 99 |    }
100 |    every (!\kids).calc_isConst()
101 |   end
102 |   method checkSymTables()
103 |     check_codeblocks()
104 |     
105 |   end
106 |   method check_codeblocks()
107 |    if sym == "MethodDecl" then { kids[2].check_block() }
108 |    else every k := !kids do
109 |          if k.nkids>0 then k.check_codeblocks()
110 |   end
111 |   method check_block()
112 |    case sym of {
113 |    "IDENTIFIER": {
114 |      if not (stab.lookup(tok.text)) then
115 |         j0.semerror("undeclared variable "||tok.text)
116 |      }
117 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
118 |    "MethodCall": {
119 |       kids[1].check_block()
120 |       if rule = 1290 then
121 |          kids[2].check_block()
122 |       else kids[3].check_block()
123 |      }
124 |    "LocalVarDecl": { } # skip
125 |    default:  {
126 |       every k := !\kids do {
127 |             k.check_block()
128 |          }
129 |       }
130 |    }
131 |   end
132 | 
133 | initially (s,r,x[])
134 |    id := serial.getid(); sym := s; rule := r
135 |    if type(x[1]) == "token__state" then {
136 |       nkids := 0; tok := x[1]
137 |    } else {
138 |       nkids := *x;
139 |       kids := x
140 |    }
141 | end
142 | 


--------------------------------------------------------------------------------
/ch6/tree.java:
--------------------------------------------------------------------------------
  1 | package ch6;
  2 | import java.io.PrintWriter;
  3 | import java.io.BufferedWriter;
  4 | import java.io.FileWriter;
  5 | class tree {
  6 |   int id, rule, nkids;
  7 |   String sym;
  8 |   token tok;
  9 |   tree kids[];
 10 |   Boolean isConst;
 11 |   symtab stab;
 12 | 
 13 |   public String escape(String s) {
 14 |       if (s.charAt(0) == '\"')
 15 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 16 |       else return s;
 17 |   }
 18 | 
 19 |   public String pretty_print_name() {
 20 |     if (tok == null) return sym +"#"+(rule%10);
 21 |     else {
 22 | 	return escape(tok.text)+":"+tok.cat;
 23 | 	}
 24 |     }
 25 | 
 26 |   void print_graph(String filename){
 27 |     try {
 28 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 29 |       pw.printf("digraph {\n");
 30 |       j = 0;
 31 |       print_graph(pw);
 32 |       pw.printf("}\n");
 33 |       pw.close();
 34 |       }
 35 |     catch (java.io.IOException ioException) {
 36 |       System.err.println("printgraph exception");
 37 |       System.exit(1);
 38 |       }
 39 |     }
 40 | 
 41 |   int j;
 42 |   void print_graph(PrintWriter pw) {
 43 |   int i;
 44 |     if (tok != null) {
 45 | 	print_leaf(pw);
 46 |         return;
 47 |     }
 48 |     // from here on out, we know we are not a leaf
 49 |     print_branch(pw);
 50 |     
 51 |     for(i=0; i<nkids; i++) {
 52 |         if (kids[i] != null) {
 53 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 54 | 	    kids[i].print_graph(pw);
 55 |         } else {
 56 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 57 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 58 | 	    j++;
 59 |         }
 60 |     }
 61 |   }
 62 | 
 63 |   void print_leaf(PrintWriter pw) {
 64 |     String s = parser.yyname[tok.cat];
 65 |     print_branch(pw);
 66 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 67 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 68 | 	      escape(tok.text), tok.lineno);
 69 |   }
 70 | 
 71 |   void print_branch(PrintWriter pw) {
 72 |     pw.printf("N%d ",id);
 73 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 74 |     if (tok != null)
 75 | 	pw.printf("struct token* leaf %d", tok.id);
 76 |     pw.printf("\"];\n");
 77 |   }
 78 | 
 79 |   public void print(int level) {
 80 |     int i;
 81 |     for(i=0;i<level;i++) System.out.print(" ");
 82 |     if (tok != null) {
 83 |       System.out.println(id + "   " + tok.text +
 84 |                          " (" + tok.cat + "): "+tok.lineno);
 85 |     }
 86 |     else {
 87 |       System.out.println(id + "   " + sym +
 88 | 			 " (" + rule + "): "+nkids);
 89 |     }
 90 |     for(i=0; i<nkids; i++)
 91 |       kids[i].print(level+1);
 92 |   }
 93 |   public void print() {
 94 |     print(0);
 95 |   }
 96 | 
 97 |   void mkSymTables(symtab curr) {
 98 |    stab = curr;
 99 |    switch (sym) {
100 |    case "ClassDecl": curr = new symtab("class", curr); break;
101 |    case "MethodDecl": curr = new symtab("method", curr); break;
102 |    }
103 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
104 |   }
105 | 
106 |   void populateSymTables() {
107 |     switch(sym) {
108 |     case "ClassDecl": {
109 |        stab.insert(kids[0].tok.text, false, kids[0].stab);
110 |        break;
111 |     }
112 |     case "FieldDecl": case "LocalVarDecl": {
113 |        tree k = kids[1];
114 |        while ((k != null) && k.sym.equals("VarDecls")) {
115 |          insert_vardeclarator(k.kids[1]);
116 |          k = k.kids[0];
117 |          }
118 |        insert_vardeclarator(k); return;
119 |        }
120 |     case "MethodDecl": {
121 |        stab.insert(kids[0].kids[1].kids[0].tok.text, false, kids[0].stab); }
122 |     case "FormalParm": {
123 |       insert_vardeclarator(kids[1]); return; }
124 |     }
125 |    for(int i = 0; i < nkids; i++) {
126 |       tree k = kids[i];
127 |       k.populateSymTables();
128 |    }
129 |   }
130 | 
131 |   void insert_vardeclarator(tree vd) {
132 |     if (vd.tok != null) stab.insert(vd.tok.text, false);
133 |     else insert_vardeclarator(vd.kids[0]);
134 |   }
135 | 
136 |   void calc_isConst() {
137 |    switch(sym) {
138 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
139 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
140 |    case "UnaryExpr": isConst = kids[1].isConst; break;
141 |    case "RelExpr":
142 |       isConst = kids[0].isConst && kids[2].isConst; break;
143 |    case "CondOrExpr": case "CondAndExpr":
144 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
145 |       isConst = kids[0].isConst && kids[1].isConst; break;
146 |    default: isConst = false;
147 |    }
148 |    for(int i=0; i <nkids; i++)
149 |       kids[i].calc_isConst();
150 |   }
151 | 
152 |   void checkSymTables() { check_codeblocks(); }
153 |   void check_codeblocks() {
154 |   tree k;
155 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
156 |    else {
157 |       for(int i = 0; i<nkids; i++){
158 |          k = kids[i];
159 |          if (k.nkids>0) k.check_codeblocks();
160 |       }
161 |    }
162 |   }
163 | void check_block() {
164 |    switch (sym) {
165 |    case "IDENTIFIER": {
166 |      if (stab.lookup(tok.text) == null)
167 |         j0.semerror("undeclared variable " + tok.text);
168 |      break;
169 |      }
170 |    case "FieldAccess": case "QualifiedName":
171 |      kids[0].check_block();
172 |      break;
173 |   case "MethodCall": {
174 |       kids[0].check_block();
175 |       if (rule == 1290)
176 |          kids[1].check_block();
177 |       else kids[2].check_block();
178 |       break;
179 |      }
180 |    case "LocalVarDecl": break;
181 |    default:
182 |       for(int i=0;i<nkids;i++)
183 |             kids[i].check_block();
184 |    }
185 |   }
186 | 
187 |     public tree(String s, int r, token t) {
188 | 	id = serial.getid();
189 |         sym = s; rule = r; tok = t; }
190 | 
191 |     public tree(String s, int r, tree[] t) {
192 | 	id = serial.getid();
193 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
194 | 	sym = s; rule = r; nkids = t.length;
195 | 	kids = t;
196 |     }
197 | }
198 | 


--------------------------------------------------------------------------------
/ch6/xy5.java:
--------------------------------------------------------------------------------
1 | public class xy5 {
2 |    static double y = 5.0;
3 |    public static void main(String argv[]) {
4 |        int x;
5 |        x = (int)y + 5;
6 |       System.out.println("y + 5 = " + x);
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch6/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     stop(s)
3 | end
4 | 


--------------------------------------------------------------------------------
/ch6/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch6;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch7/Yylex.java:
--------------------------------------------------------------------------------
  1 | // DO NOT EDIT
  2 | // Generated by JFlex 1.8.2 http://jflex.de/
  3 | // source: javalex.l
  4 | 
  5 | package ch7;
  6 | 
  7 | // See https://github.com/jflex-de/jflex/issues/222
  8 | @SuppressWarnings("FallThrough")
  9 | class Yylex {
 10 | 
 11 |   /** This character denotes the end of file. */
 12 |   public static final int YYEOF = -1;
 13 | 
 14 |   /** Initial size of the lookahead buffer. */
 15 |   private static final int ZZ_BUFFERSIZE = 16384;
 16 | 
 17 |   // Lexical states.
 18 |   public static final int YYINITIAL = 0;
 19 | 
 20 |   /**
 21 |    * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
 22 |    * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
 23 |    *                  at the beginning of a line
 24 |    * l is of the form l = 2*k, k a non negative integer
 25 |    */
 26 |   private static final int ZZ_LEXSTATE[] = {
 27 |      0, 0
 28 |   };
 29 | 
 30 |   /**
 31 |    * Top-level table for translating characters to character classes
 32 |    */
 33 |   private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
 34 | 
 35 |   private static final String ZZ_CMAP_TOP_PACKED_0 =
 36 |     "\1\0\37\u0100\1\u0200\267\u0100\10\u0300\u1020\u0100";
 37 | 
 38 |   private static int [] zzUnpackcmap_top() {
 39 |     int [] result = new int[4352];
 40 |     int offset = 0;
 41 |     offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
 42 |     return result;
 43 |   }
 44 | 
 45 |   private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
 46 |     int i = 0;       /* index in packed string  */
 47 |     int j = offset;  /* index in unpacked array */
 48 |     int l = packed.length();
 49 |     while (i < l) {
 50 |       int count = packed.charAt(i++);
 51 |       int value = packed.charAt(i++);
 52 |       do result[j++] = value; while (--count > 0);
 53 |     }
 54 |     return j;
 55 |   }
 56 | 
 57 | 
 58 |   /**
 59 |    * Second-level tables for translating characters to character classes
 60 |    */
 61 |   private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
 62 | 
 63 |   private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
 64 |     "\11\0\1\1\1\2\1\3\1\4\1\5\22\0\1\1"+
 65 |     "\1\6\1\7\2\0\1\10\1\11\1\0\1\12\1\13"+
 66 |     "\1\14\1\15\1\16\1\17\1\20\1\21\12\22\1\23"+
 67 |     "\1\24\1\25\1\26\1\27\2\0\4\30\1\31\25\30"+
 68 |     "\1\32\1\33\1\34\1\0\1\30\1\0\1\35\1\36"+
 69 |     "\1\37\1\40\1\41\1\42\1\43\1\44\1\45\1\30"+
 70 |     "\1\46\1\47\1\30\1\50\1\51\1\52\1\30\1\53"+
 71 |     "\1\54\1\55\1\56\1\57\1\60\3\30\1\61\1\62"+
 72 |     "\1\63\7\0\1\3\u01a2\0\2\3\326\0\u0100\3";
 73 | 
 74 |   private static int [] zzUnpackcmap_blocks() {
 75 |     int [] result = new int[1024];
 76 |     int offset = 0;
 77 |     offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
 78 |     return result;
 79 |   }
 80 | 
 81 |   private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
 82 |     int i = 0;       /* index in packed string  */
 83 |     int j = offset;  /* index in unpacked array */
 84 |     int l = packed.length();
 85 |     while (i < l) {
 86 |       int count = packed.charAt(i++);
 87 |       int value = packed.charAt(i++);
 88 |       do result[j++] = value; while (--count > 0);
 89 |     }
 90 |     return j;
 91 |   }
 92 | 
 93 |   /**
 94 |    * Translates DFA states to action switch labels.
 95 |    */
 96 |   private static final int [] ZZ_ACTION = zzUnpackAction();
 97 | 
 98 |   private static final String ZZ_ACTION_PACKED_0 =
 99 |     "\1\0\1\1\1\2\1\3\1\4\1\1\1\5\1\1"+
100 |     "\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1\15"+
101 |     "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
102 |     "\1\26\15\24\1\27\1\1\1\30\1\31\1\0\1\32"+
103 |     "\1\0\1\33\1\34\1\35\1\36\3\0\1\37\1\40"+
104 |     "\1\41\7\24\1\42\10\24\1\43\1\32\1\0\1\36"+
105 |     "\1\0\1\44\1\0\6\24\1\45\1\46\10\24\1\47"+
106 |     "\3\24\1\50\1\51\4\24\1\52\1\53\1\24\1\54"+
107 |     "\1\55\5\24\1\56\1\57\1\60\1\61\1\62\1\63";
108 | 
109 |   private static int [] zzUnpackAction() {
110 |     int [] result = new int[120];
111 |     int offset = 0;
112 |     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
113 |     return result;
114 |   }
115 | 
116 |   private static int zzUnpackAction(String packed, int offset, int [] result) {
117 |     int i = 0;       /* index in packed string  */
118 |     int j = offset;  /* index in unpacked array */
119 |     int l = packed.length();
120 |     while (i < l) {
121 |       int count = packed.charAt(i++);
122 |       int value = packed.charAt(i++);
123 |       do result[j++] = value; while (--count > 0);
124 |     }
125 |     return j;
126 |   }
127 | 
128 | 
129 |   /**
130 |    * Translates a state to a row index in the transition table
131 |    */
132 |   private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
133 | 
134 |   private static final String ZZ_ROWMAP_PACKED_0 =
135 |     "\0\0\0\64\0\150\0\64\0\234\0\320\0\64\0\u0104"+
136 |     "\0\64\0\64\0\64\0\u0138\0\64\0\u016c\0\u01a0\0\u01d4"+
137 |     "\0\u0208\0\64\0\64\0\u023c\0\u0270\0\u02a4\0\u02d8\0\64"+
138 |     "\0\64\0\u030c\0\u0340\0\u0374\0\u03a8\0\u03dc\0\u0410\0\u0444"+
139 |     "\0\u0478\0\u04ac\0\u04e0\0\u0514\0\u0548\0\u057c\0\64\0\u05b0"+
140 |     "\0\64\0\64\0\320\0\64\0\u05e4\0\64\0\64\0\64"+
141 |     "\0\u01a0\0\u0618\0\u064c\0\u0680\0\64\0\64\0\64\0\u06b4"+
142 |     "\0\u06e8\0\u071c\0\u0750\0\u0784\0\u07b8\0\u07ec\0\u02d8\0\u0820"+
143 |     "\0\u0854\0\u0888\0\u08bc\0\u08f0\0\u0924\0\u0958\0\u098c\0\64"+
144 |     "\0\320\0\u09c0\0\u09c0\0\u09f4\0\64\0\u0a28\0\u0a5c\0\u0a90"+
145 |     "\0\u0ac4\0\u0af8\0\u0b2c\0\u0b60\0\u02d8\0\u02d8\0\u0b94\0\u0bc8"+
146 |     "\0\u0bfc\0\u0c30\0\u0c64\0\u0c98\0\u0ccc\0\u0d00\0\u02d8\0\u0d34"+
147 |     "\0\u0d68\0\u0d9c\0\u02d8\0\u02d8\0\u0dd0\0\u0e04\0\u0e38\0\u0e6c"+
148 |     "\0\u02d8\0\u02d8\0\u0ea0\0\u02d8\0\u02d8\0\u0ed4\0\u0f08\0\u0f3c"+
149 |     "\0\u0f70\0\u0fa4\0\u02d8\0\u02d8\0\u02d8\0\u02d8\0\u02d8\0\u02d8";
150 | 
151 |   private static int [] zzUnpackRowMap() {
152 |     int [] result = new int[120];
153 |     int offset = 0;
154 |     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
155 |     return result;
156 |   }
157 | 
158 |   private static int zzUnpackRowMap(String packed, int offset, int [] result) {
159 |     int i = 0;  /* index in packed string  */
160 |     int j = offset;  /* index in unpacked array */
161 |     int l = packed.length();
162 |     while (i < l) {
163 |       int high = packed.charAt(i++) << 16;
164 |       result[j++] = high | packed.charAt(i++);
165 |     }
166 |     return j;
167 |   }
168 | 
169 |   /**
170 |    * The transition table of the DFA
171 |    */
172 |   private static final int [] ZZ_TRANS = zzUnpackTrans();
173 | 
174 |   private static final String ZZ_TRANS_PACKED_0 =
175 |     "\1\2\1\3\1\4\1\0\2\3\1\5\1\6\1\7"+
176 |     "\1\10\1\11\1\12\1\13\1\14\1\15\1\16\1\17"+
177 |     "\1\20\1\21\1\22\1\23\1\24\1\25\1\26\2\27"+
178 |     "\1\30\1\2\1\31\1\27\1\32\1\33\1\34\1\35"+
179 |     "\1\36\2\27\1\37\2\27\1\40\1\27\1\41\1\42"+
180 |     "\1\43\1\44\1\27\1\45\1\46\1\47\1\50\1\51"+
181 |     "\65\0\1\3\2\0\2\3\104\0\1\52\35\0\7\53"+
182 |     "\1\54\23\53\1\55\30\53\11\0\1\56\100\0\1\57"+
183 |     "\63\0\1\60\57\0\1\61\6\0\1\62\7\0\1\62"+
184 |     "\36\0\1\63\4\0\1\64\62\0\1\61\1\0\1\21"+
185 |     "\6\0\1\62\7\0\1\62\50\0\1\65\63\0\1\66"+
186 |     "\63\0\1\67\57\0\1\27\5\0\2\27\3\0\24\27"+
187 |     "\25\0\1\27\5\0\2\27\3\0\14\27\1\70\1\27"+
188 |     "\1\71\5\27\25\0\1\27\5\0\2\27\3\0\12\27"+
189 |     "\1\72\11\27\25\0\1\27\5\0\2\27\3\0\14\27"+
190 |     "\1\73\7\27\25\0\1\27\5\0\2\27\3\0\12\27"+
191 |     "\1\74\11\27\25\0\1\27\5\0\2\27\3\0\1\75"+
192 |     "\13\27\1\76\7\27\25\0\1\27\5\0\2\27\3\0"+
193 |     "\5\27\1\77\5\27\1\100\10\27\25\0\1\27\5\0"+
194 |     "\2\27\3\0\21\27\1\101\2\27\25\0\1\27\5\0"+
195 |     "\2\27\3\0\21\27\1\102\2\27\25\0\1\27\5\0"+
196 |     "\2\27\3\0\4\27\1\103\17\27\25\0\1\27\5\0"+
197 |     "\2\27\3\0\20\27\1\104\3\27\25\0\1\27\5\0"+
198 |     "\2\27\3\0\16\27\1\105\5\27\25\0\1\27\5\0"+
199 |     "\2\27\3\0\14\27\1\106\7\27\25\0\1\27\5\0"+
200 |     "\2\27\3\0\7\27\1\107\14\27\65\0\1\110\1\0"+
201 |     "\7\53\1\111\23\53\1\55\30\53\15\0\1\112\1\0"+
202 |     "\1\112\2\0\1\113\41\0\14\63\1\114\47\63\2\64"+
203 |     "\1\115\2\0\1\116\56\64\22\0\1\27\5\0\2\27"+
204 |     "\3\0\14\27\1\117\7\27\25\0\1\27\5\0\2\27"+
205 |     "\3\0\4\27\1\120\17\27\25\0\1\27\5\0\2\27"+
206 |     "\3\0\1\121\23\27\25\0\1\27\5\0\2\27\3\0"+
207 |     "\21\27\1\122\2\27\25\0\1\27\5\0\2\27\3\0"+
208 |     "\17\27\1\123\4\27\25\0\1\27\5\0\2\27\3\0"+
209 |     "\12\27\1\124\11\27\25\0\1\27\5\0\2\27\3\0"+
210 |     "\16\27\1\125\5\27\25\0\1\27\5\0\2\27\3\0"+
211 |     "\20\27\1\126\3\27\25\0\1\27\5\0\2\27\3\0"+
212 |     "\12\27\1\127\11\27\25\0\1\27\5\0\2\27\3\0"+
213 |     "\1\27\1\130\22\27\25\0\1\27\5\0\2\27\3\0"+
214 |     "\20\27\1\131\3\27\25\0\1\27\5\0\2\27\3\0"+
215 |     "\1\132\15\27\1\133\5\27\25\0\1\27\5\0\2\27"+
216 |     "\3\0\21\27\1\134\2\27\25\0\1\27\5\0\2\27"+
217 |     "\3\0\10\27\1\135\13\27\25\0\1\27\5\0\2\27"+
218 |     "\3\0\10\27\1\136\13\27\25\0\1\113\41\0\14\63"+
219 |     "\1\114\4\63\1\115\42\63\2\0\1\115\103\0\1\27"+
220 |     "\5\0\2\27\3\0\12\27\1\137\11\27\25\0\1\27"+
221 |     "\5\0\2\27\3\0\1\140\23\27\25\0\1\27\5\0"+
222 |     "\2\27\3\0\17\27\1\141\4\27\25\0\1\27\5\0"+
223 |     "\2\27\3\0\1\27\1\142\22\27\25\0\1\27\5\0"+
224 |     "\2\27\3\0\4\27\1\143\17\27\25\0\1\27\5\0"+
225 |     "\2\27\3\0\17\27\1\134\4\27\25\0\1\27\5\0"+
226 |     "\2\27\3\0\12\27\1\144\11\27\25\0\1\27\5\0"+
227 |     "\2\27\3\0\12\27\1\145\11\27\25\0\1\27\5\0"+
228 |     "\2\27\3\0\21\27\1\146\2\27\25\0\1\27\5\0"+
229 |     "\2\27\3\0\20\27\1\147\3\27\25\0\1\27\5\0"+
230 |     "\2\27\3\0\10\27\1\150\13\27\25\0\1\27\5\0"+
231 |     "\2\27\3\0\4\27\1\151\17\27\25\0\1\27\5\0"+
232 |     "\2\27\3\0\3\27\1\152\20\27\25\0\1\27\5\0"+
233 |     "\2\27\3\0\12\27\1\153\11\27\25\0\1\27\5\0"+
234 |     "\2\27\3\0\11\27\1\154\12\27\25\0\1\27\5\0"+
235 |     "\2\27\3\0\17\27\1\155\4\27\25\0\1\27\5\0"+
236 |     "\2\27\3\0\12\27\1\156\11\27\25\0\1\27\5\0"+
237 |     "\2\27\3\0\10\27\1\157\13\27\25\0\1\27\5\0"+
238 |     "\2\27\3\0\16\27\1\160\5\27\25\0\1\27\5\0"+
239 |     "\2\27\3\0\10\27\1\161\13\27\25\0\1\27\5\0"+
240 |     "\2\27\3\0\13\27\1\162\10\27\25\0\1\27\5\0"+
241 |     "\2\27\3\0\4\27\1\163\17\27\25\0\1\27\5\0"+
242 |     "\2\27\3\0\4\27\1\164\17\27\25\0\1\27\5\0"+
243 |     "\2\27\3\0\2\27\1\165\21\27\25\0\1\27\5\0"+
244 |     "\2\27\3\0\13\27\1\166\10\27\25\0\1\27\5\0"+
245 |     "\2\27\3\0\2\27\1\167\21\27\25\0\1\27\5\0"+
246 |     "\2\27\3\0\6\27\1\170\15\27\3\0";
247 | 
248 |   private static int [] zzUnpackTrans() {
249 |     int [] result = new int[4056];
250 |     int offset = 0;
251 |     offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
252 |     return result;
253 |   }
254 | 
255 |   private static int zzUnpackTrans(String packed, int offset, int [] result) {
256 |     int i = 0;       /* index in packed string  */
257 |     int j = offset;  /* index in unpacked array */
258 |     int l = packed.length();
259 |     while (i < l) {
260 |       int count = packed.charAt(i++);
261 |       int value = packed.charAt(i++);
262 |       value--;
263 |       do result[j++] = value; while (--count > 0);
264 |     }
265 |     return j;
266 |   }
267 | 
268 | 
269 |   /** Error code for "Unknown internal scanner error". */
270 |   private static final int ZZ_UNKNOWN_ERROR = 0;
271 |   /** Error code for "could not match input". */
272 |   private static final int ZZ_NO_MATCH = 1;
273 |   /** Error code for "pushback value was too large". */
274 |   private static final int ZZ_PUSHBACK_2BIG = 2;
275 | 
276 |   /**
277 |    * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
278 |    * {@link #ZZ_PUSHBACK_2BIG} respectively.
279 |    */
280 |   private static final String ZZ_ERROR_MSG[] = {
281 |     "Unknown internal scanner error",
282 |     "Error: could not match input",
283 |     "Error: pushback value was too large"
284 |   };
285 | 
286 |   /**
287 |    * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
288 |    */
289 |   private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
290 | 
291 |   private static final String ZZ_ATTRIBUTE_PACKED_0 =
292 |     "\1\0\1\11\1\1\1\11\2\1\1\11\1\1\3\11"+
293 |     "\1\1\1\11\4\1\2\11\4\1\2\11\15\1\1\11"+
294 |     "\1\1\2\11\1\0\1\11\1\0\3\11\1\1\3\0"+
295 |     "\3\11\20\1\1\11\1\1\1\0\1\1\1\0\1\11"+
296 |     "\1\0\52\1";
297 | 
298 |   private static int [] zzUnpackAttribute() {
299 |     int [] result = new int[120];
300 |     int offset = 0;
301 |     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
302 |     return result;
303 |   }
304 | 
305 |   private static int zzUnpackAttribute(String packed, int offset, int [] result) {
306 |     int i = 0;       /* index in packed string  */
307 |     int j = offset;  /* index in unpacked array */
308 |     int l = packed.length();
309 |     while (i < l) {
310 |       int count = packed.charAt(i++);
311 |       int value = packed.charAt(i++);
312 |       do result[j++] = value; while (--count > 0);
313 |     }
314 |     return j;
315 |   }
316 | 
317 |   /** Input device. */
318 |   private java.io.Reader zzReader;
319 | 
320 |   /** Current state of the DFA. */
321 |   private int zzState;
322 | 
323 |   /** Current lexical state. */
324 |   private int zzLexicalState = YYINITIAL;
325 | 
326 |   /**
327 |    * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
328 |    * string.
329 |    */
330 |   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
331 | 
332 |   /** Text position at the last accepting state. */
333 |   private int zzMarkedPos;
334 | 
335 |   /** Current text position in the buffer. */
336 |   private int zzCurrentPos;
337 | 
338 |   /** Marks the beginning of the {@link #yytext()} string in the buffer. */
339 |   private int zzStartRead;
340 | 
341 |   /** Marks the last character in the buffer, that has been read from input. */
342 |   private int zzEndRead;
343 | 
344 |   /**
345 |    * Whether the scanner is at the end of file.
346 |    * @see #yyatEOF
347 |    */
348 |   private boolean zzAtEOF;
349 | 
350 |   /**
351 |    * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
352 |    *
353 |    * <p>When a lead/high surrogate has been read from the input stream into the final
354 |    * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
355 |    */
356 |   private int zzFinalHighSurrogate = 0;
357 | 
358 |   /** Number of newlines encountered up to the start of the matched text. */
359 |   @SuppressWarnings("unused")
360 |   private int yyline;
361 | 
362 |   /** Number of characters from the last newline up to the start of the matched text. */
363 |   @SuppressWarnings("unused")
364 |   private int yycolumn;
365 | 
366 |   /** Number of characters up to the start of the matched text. */
367 |   @SuppressWarnings("unused")
368 |   private long yychar;
369 | 
370 |   /** Whether the scanner is currently at the beginning of a line. */
371 |   @SuppressWarnings("unused")
372 |   private boolean zzAtBOL = true;
373 | 
374 |   /** Whether the user-EOF-code has already been executed. */
375 |   @SuppressWarnings("unused")
376 |   private boolean zzEOFDone;
377 | 
378 | 
379 |   /**
380 |    * Creates a new scanner
381 |    *
382 |    * @param   in  the java.io.Reader to read input from.
383 |    */
384 |   Yylex(java.io.Reader in) {
385 |     this.zzReader = in;
386 |   }
387 | 
388 |   /**
389 |    * Translates raw input code points to DFA table row
390 |    */
391 |   private static int zzCMap(int input) {
392 |     int offset = input & 255;
393 |     return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
394 |   }
395 | 
396 |   /**
397 |    * Refills the input buffer.
398 |    *
399 |    * @return {@code false} iff there was new input.
400 |    * @exception java.io.IOException  if any I/O-Error occurs
401 |    */
402 |   private boolean zzRefill() throws java.io.IOException {
403 | 
404 |     /* first: make room (if you can) */
405 |     if (zzStartRead > 0) {
406 |       zzEndRead += zzFinalHighSurrogate;
407 |       zzFinalHighSurrogate = 0;
408 |       System.arraycopy(zzBuffer, zzStartRead,
409 |                        zzBuffer, 0,
410 |                        zzEndRead - zzStartRead);
411 | 
412 |       /* translate stored positions */
413 |       zzEndRead -= zzStartRead;
414 |       zzCurrentPos -= zzStartRead;
415 |       zzMarkedPos -= zzStartRead;
416 |       zzStartRead = 0;
417 |     }
418 | 
419 |     /* is the buffer big enough? */
420 |     if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {
421 |       /* if not: blow it up */
422 |       char newBuffer[] = new char[zzBuffer.length * 2];
423 |       System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
424 |       zzBuffer = newBuffer;
425 |       zzEndRead += zzFinalHighSurrogate;
426 |       zzFinalHighSurrogate = 0;
427 |     }
428 | 
429 |     /* fill the buffer with new input */
430 |     int requested = zzBuffer.length - zzEndRead;
431 |     int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
432 | 
433 |     /* not supposed to occur according to specification of java.io.Reader */
434 |     if (numRead == 0) {
435 |       throw new java.io.IOException(
436 |           "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
437 |     }
438 |     if (numRead > 0) {
439 |       zzEndRead += numRead;
440 |       if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
441 |         if (numRead == requested) { // We requested too few chars to encode a full Unicode character
442 |           --zzEndRead;
443 |           zzFinalHighSurrogate = 1;
444 |         } else {                    // There is room in the buffer for at least one more char
445 |           int c = zzReader.read();  // Expecting to read a paired low surrogate char
446 |           if (c == -1) {
447 |             return true;
448 |           } else {
449 |             zzBuffer[zzEndRead++] = (char)c;
450 |           }
451 |         }
452 |       }
453 |       /* potentially more input available */
454 |       return false;
455 |     }
456 | 
457 |     /* numRead < 0 ==> end of stream */
458 |     return true;
459 |   }
460 | 
461 | 
462 |   /**
463 |    * Closes the input reader.
464 |    *
465 |    * @throws java.io.IOException if the reader could not be closed.
466 |    */
467 |   public final void yyclose() throws java.io.IOException {
468 |     zzAtEOF = true; // indicate end of file
469 |     zzEndRead = zzStartRead; // invalidate buffer
470 | 
471 |     if (zzReader != null) {
472 |       zzReader.close();
473 |     }
474 |   }
475 | 
476 | 
477 |   /**
478 |    * Resets the scanner to read from a new input stream.
479 |    *
480 |    * <p>Does not close the old reader.
481 |    *
482 |    * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
483 |    * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
484 |    *
485 |    * <p>Internal scan buffer is resized down to its initial length, if it has grown.
486 |    *
487 |    * @param reader The new input stream.
488 |    */
489 |   public final void yyreset(java.io.Reader reader) {
490 |     zzReader = reader;
491 |     zzEOFDone = false;
492 |     yyResetPosition();
493 |     zzLexicalState = YYINITIAL;
494 |     if (zzBuffer.length > ZZ_BUFFERSIZE) {
495 |       zzBuffer = new char[ZZ_BUFFERSIZE];
496 |     }
497 |   }
498 | 
499 |   /**
500 |    * Resets the input position.
501 |    */
502 |   private final void yyResetPosition() {
503 |       zzAtBOL  = true;
504 |       zzAtEOF  = false;
505 |       zzCurrentPos = 0;
506 |       zzMarkedPos = 0;
507 |       zzStartRead = 0;
508 |       zzEndRead = 0;
509 |       zzFinalHighSurrogate = 0;
510 |       yyline = 0;
511 |       yycolumn = 0;
512 |       yychar = 0L;
513 |   }
514 | 
515 | 
516 |   /**
517 |    * Returns whether the scanner has reached the end of the reader it reads from.
518 |    *
519 |    * @return whether the scanner has reached EOF.
520 |    */
521 |   public final boolean yyatEOF() {
522 |     return zzAtEOF;
523 |   }
524 | 
525 | 
526 |   /**
527 |    * Returns the current lexical state.
528 |    *
529 |    * @return the current lexical state.
530 |    */
531 |   public final int yystate() {
532 |     return zzLexicalState;
533 |   }
534 | 
535 | 
536 |   /**
537 |    * Enters a new lexical state.
538 |    *
539 |    * @param newState the new lexical state
540 |    */
541 |   public final void yybegin(int newState) {
542 |     zzLexicalState = newState;
543 |   }
544 | 
545 | 
546 |   /**
547 |    * Returns the text matched by the current regular expression.
548 |    *
549 |    * @return the matched text.
550 |    */
551 |   public final String yytext() {
552 |     return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
553 |   }
554 | 
555 | 
556 |   /**
557 |    * Returns the character at the given position from the matched text.
558 |    *
559 |    * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
560 |    *
561 |    * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
562 |    *
563 |    * @return the character at {@code position}.
564 |    */
565 |   public final char yycharat(int position) {
566 |     return zzBuffer[zzStartRead + position];
567 |   }
568 | 
569 | 
570 |   /**
571 |    * How many characters were matched.
572 |    *
573 |    * @return the length of the matched text region.
574 |    */
575 |   public final int yylength() {
576 |     return zzMarkedPos-zzStartRead;
577 |   }
578 | 
579 | 
580 |   /**
581 |    * Reports an error that occurred while scanning.
582 |    *
583 |    * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
584 |    * match-all fallback rule) this method will only be called with things that
585 |    * "Can't Possibly Happen".
586 |    *
587 |    * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
588 |    * scanner etc.).
589 |    *
590 |    * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
591 |    *
592 |    * @param errorCode the code of the error message to display.
593 |    */
594 |   private static void zzScanError(int errorCode) {
595 |     String message;
596 |     try {
597 |       message = ZZ_ERROR_MSG[errorCode];
598 |     } catch (ArrayIndexOutOfBoundsException e) {
599 |       message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
600 |     }
601 | 
602 |     throw new Error(message);
603 |   }
604 | 
605 | 
606 |   /**
607 |    * Pushes the specified amount of characters back into the input stream.
608 |    *
609 |    * <p>They will be read again by then next call of the scanning method.
610 |    *
611 |    * @param number the number of characters to be read again. This number must not be greater than
612 |    *     {@link #yylength()}.
613 |    */
614 |   public void yypushback(int number)  {
615 |     if ( number > yylength() )
616 |       zzScanError(ZZ_PUSHBACK_2BIG);
617 | 
618 |     zzMarkedPos -= number;
619 |   }
620 | 
621 | 
622 | 
623 | 
624 |   /**
625 |    * Resumes scanning until the next regular expression is matched, the end of input is encountered
626 |    * or an I/O-Error occurs.
627 |    *
628 |    * @return the next token.
629 |    * @exception java.io.IOException if any I/O-Error occurs.
630 |    */
631 |   public int yylex() throws java.io.IOException {
632 |     int zzInput;
633 |     int zzAction;
634 | 
635 |     // cached fields:
636 |     int zzCurrentPosL;
637 |     int zzMarkedPosL;
638 |     int zzEndReadL = zzEndRead;
639 |     char[] zzBufferL = zzBuffer;
640 | 
641 |     int [] zzTransL = ZZ_TRANS;
642 |     int [] zzRowMapL = ZZ_ROWMAP;
643 |     int [] zzAttrL = ZZ_ATTRIBUTE;
644 | 
645 |     while (true) {
646 |       zzMarkedPosL = zzMarkedPos;
647 | 
648 |       zzAction = -1;
649 | 
650 |       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
651 | 
652 |       zzState = ZZ_LEXSTATE[zzLexicalState];
653 | 
654 |       // set up zzAction for empty match case:
655 |       int zzAttributes = zzAttrL[zzState];
656 |       if ( (zzAttributes & 1) == 1 ) {
657 |         zzAction = zzState;
658 |       }
659 | 
660 | 
661 |       zzForAction: {
662 |         while (true) {
663 | 
664 |           if (zzCurrentPosL < zzEndReadL) {
665 |             zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
666 |             zzCurrentPosL += Character.charCount(zzInput);
667 |           }
668 |           else if (zzAtEOF) {
669 |             zzInput = YYEOF;
670 |             break zzForAction;
671 |           }
672 |           else {
673 |             // store back cached positions
674 |             zzCurrentPos  = zzCurrentPosL;
675 |             zzMarkedPos   = zzMarkedPosL;
676 |             boolean eof = zzRefill();
677 |             // get translated positions and possibly new buffer
678 |             zzCurrentPosL  = zzCurrentPos;
679 |             zzMarkedPosL   = zzMarkedPos;
680 |             zzBufferL      = zzBuffer;
681 |             zzEndReadL     = zzEndRead;
682 |             if (eof) {
683 |               zzInput = YYEOF;
684 |               break zzForAction;
685 |             }
686 |             else {
687 |               zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
688 |               zzCurrentPosL += Character.charCount(zzInput);
689 |             }
690 |           }
691 |           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
692 |           if (zzNext == -1) break zzForAction;
693 |           zzState = zzNext;
694 | 
695 |           zzAttributes = zzAttrL[zzState];
696 |           if ( (zzAttributes & 1) == 1 ) {
697 |             zzAction = zzState;
698 |             zzMarkedPosL = zzCurrentPosL;
699 |             if ( (zzAttributes & 8) == 8 ) break zzForAction;
700 |           }
701 | 
702 |         }
703 |       }
704 | 
705 |       // store back cached position
706 |       zzMarkedPos = zzMarkedPosL;
707 | 
708 |       if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
709 |         zzAtEOF = true;
710 |         return YYEOF;
711 |       }
712 |       else {
713 |         switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
714 |           case 1:
715 |             { j0.lexErr("unrecognized character");
716 |             }
717 |             // fall through
718 |           case 52: break;
719 |           case 2:
720 |             { j0.whitespace();
721 |             }
722 |             // fall through
723 |           case 53: break;
724 |           case 3:
725 |             { j0.newline();
726 |             }
727 |             // fall through
728 |           case 54: break;
729 |           case 4:
730 |             { return j0.scan(j0.ord("!"));
731 |             }
732 |             // fall through
733 |           case 55: break;
734 |           case 5:
735 |             { return j0.scan(j0.ord("%"));
736 |             }
737 |             // fall through
738 |           case 56: break;
739 |           case 6:
740 |             { return j0.scan(j0.ord("("));
741 |             }
742 |             // fall through
743 |           case 57: break;
744 |           case 7:
745 |             { return j0.scan(j0.ord(")"));
746 |             }
747 |             // fall through
748 |           case 58: break;
749 |           case 8:
750 |             { return j0.scan(j0.ord("*"));
751 |             }
752 |             // fall through
753 |           case 59: break;
754 |           case 9:
755 |             { return j0.scan(j0.ord("+"));
756 |             }
757 |             // fall through
758 |           case 60: break;
759 |           case 10:
760 |             { return j0.scan(j0.ord(","));
761 |             }
762 |             // fall through
763 |           case 61: break;
764 |           case 11:
765 |             { return j0.scan(j0.ord("-"));
766 |             }
767 |             // fall through
768 |           case 62: break;
769 |           case 12:
770 |             { return j0.scan(j0.ord("."));
771 |             }
772 |             // fall through
773 |           case 63: break;
774 |           case 13:
775 |             { return j0.scan(j0.ord("/"));
776 |             }
777 |             // fall through
778 |           case 64: break;
779 |           case 14:
780 |             { return j0.scan(parser.INTLIT);
781 |             }
782 |             // fall through
783 |           case 65: break;
784 |           case 15:
785 |             { return j0.scan(j0.ord(":"));
786 |             }
787 |             // fall through
788 |           case 66: break;
789 |           case 16:
790 |             { return j0.scan(j0.ord(";"));
791 |             }
792 |             // fall through
793 |           case 67: break;
794 |           case 17:
795 |             { return j0.scan(j0.ord("<"));
796 |             }
797 |             // fall through
798 |           case 68: break;
799 |           case 18:
800 |             { return j0.scan(j0.ord("="));
801 |             }
802 |             // fall through
803 |           case 69: break;
804 |           case 19:
805 |             { return j0.scan(j0.ord(">"));
806 |             }
807 |             // fall through
808 |           case 70: break;
809 |           case 20:
810 |             { return j0.scan(parser.IDENTIFIER);
811 |             }
812 |             // fall through
813 |           case 71: break;
814 |           case 21:
815 |             { return j0.scan(j0.ord("["));
816 |             }
817 |             // fall through
818 |           case 72: break;
819 |           case 22:
820 |             { return j0.scan(j0.ord("]"));
821 |             }
822 |             // fall through
823 |           case 73: break;
824 |           case 23:
825 |             { return j0.scan(j0.ord("{"));
826 |             }
827 |             // fall through
828 |           case 74: break;
829 |           case 24:
830 |             { return j0.scan(j0.ord("}"));
831 |             }
832 |             // fall through
833 |           case 75: break;
834 |           case 25:
835 |             { return j0.scan(parser.NOTEQUALTO);
836 |             }
837 |             // fall through
838 |           case 76: break;
839 |           case 26:
840 |             { return j0.scan(parser.STRINGLIT);
841 |             }
842 |             // fall through
843 |           case 77: break;
844 |           case 27:
845 |             { return j0.scan(parser.LOGICALAND);
846 |             }
847 |             // fall through
848 |           case 78: break;
849 |           case 28:
850 |             { return j0.scan(parser.INCREMENT);
851 |             }
852 |             // fall through
853 |           case 79: break;
854 |           case 29:
855 |             { return j0.scan(parser.DECREMENT);
856 |             }
857 |             // fall through
858 |           case 80: break;
859 |           case 30:
860 |             { return j0.scan(parser.DOUBLELIT);
861 |             }
862 |             // fall through
863 |           case 81: break;
864 |           case 31:
865 |             { return j0.scan(parser.LESSTHANOREQUAL);
866 |             }
867 |             // fall through
868 |           case 82: break;
869 |           case 32:
870 |             { return j0.scan(parser.ISEQUALTO);
871 |             }
872 |             // fall through
873 |           case 83: break;
874 |           case 33:
875 |             { return j0.scan(parser.GREATERTHANOREQUAL);
876 |             }
877 |             // fall through
878 |           case 84: break;
879 |           case 34:
880 |             { return j0.scan(parser.IF);
881 |             }
882 |             // fall through
883 |           case 85: break;
884 |           case 35:
885 |             { return j0.scan(parser.LOGICALOR);
886 |             }
887 |             // fall through
888 |           case 86: break;
889 |           case 36:
890 |             { j0.comment();
891 |             }
892 |             // fall through
893 |           case 87: break;
894 |           case 37:
895 |             { return j0.scan(parser.FOR);
896 |             }
897 |             // fall through
898 |           case 88: break;
899 |           case 38:
900 |             { return j0.scan(parser.INT);
901 |             }
902 |             // fall through
903 |           case 89: break;
904 |           case 39:
905 |             { return j0.scan(parser.BOOL);
906 |             }
907 |             // fall through
908 |           case 90: break;
909 |           case 40:
910 |             { return j0.scan(parser.ELSE);
911 |             }
912 |             // fall through
913 |           case 91: break;
914 |           case 41:
915 |             { return j0.scan(parser.NULLVAL);
916 |             }
917 |             // fall through
918 |           case 92: break;
919 |           case 42:
920 |             { return j0.scan(parser.BOOLLIT);
921 |             }
922 |             // fall through
923 |           case 93: break;
924 |           case 43:
925 |             { return j0.scan(parser.VOID);
926 |             }
927 |             // fall through
928 |           case 94: break;
929 |           case 44:
930 |             { return j0.scan(parser.BREAK);
931 |             }
932 |             // fall through
933 |           case 95: break;
934 |           case 45:
935 |             { return j0.scan(parser.CLASS);
936 |             }
937 |             // fall through
938 |           case 96: break;
939 |           case 46:
940 |             { return j0.scan(parser.WHILE);
941 |             }
942 |             // fall through
943 |           case 97: break;
944 |           case 47:
945 |             { return j0.scan(parser.DOUBLE);
946 |             }
947 |             // fall through
948 |           case 98: break;
949 |           case 48:
950 |             { return j0.scan(parser.PUBLIC);
951 |             }
952 |             // fall through
953 |           case 99: break;
954 |           case 49:
955 |             { return j0.scan(parser.RETURN);
956 |             }
957 |             // fall through
958 |           case 100: break;
959 |           case 50:
960 |             { return j0.scan(parser.STATIC);
961 |             }
962 |             // fall through
963 |           case 101: break;
964 |           case 51:
965 |             { return j0.scan(parser.STRING);
966 |             }
967 |             // fall through
968 |           case 102: break;
969 |           default:
970 |             zzScanError(ZZ_NO_MATCH);
971 |         }
972 |       }
973 |     }
974 |   }
975 | 
976 | 
977 | }
978 | 


--------------------------------------------------------------------------------
/ch7/arraytype.java:
--------------------------------------------------------------------------------
1 | package ch7;
2 | public class arraytype extends typeinfo {
3 |    typeinfo element_type;
4 |    public arraytype(typeinfo t) {
5 |       basetype = "array"; element_type = t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch7/classtype.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | public class classtype extends typeinfo {
 3 |    String name;
 4 |    symtab st;
 5 |    parameter [] methods;
 6 |    parameter [] fields;
 7 |    typeinfo [] constrs;
 8 |    public classtype(String s) { name = s; }
 9 |    public classtype(String s, symtab stab) { name = s; st = stab; }
10 | }
11 | 


--------------------------------------------------------------------------------
/ch7/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       int x;
4 |       x = 0;
5 |       x = x + "hello";
6 |       System.out.println("hello, jzero!");
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch7/helloerror.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!")
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch7/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yycolno, yylval, parser, global_st
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    serial := serial()
 5 |    parser := Parser()
 6 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 7 |    yylineno := yycolno := 1
 8 |    if yyparse() = 0 then
 9 |       write("no errors")
10 | end
11 | class j0()
12 |    method lexErr(s)
13 |       stop(s, ": ", yytext) 
14 |    end
15 |    method scan(cat)
16 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
17 |       yycolno +:= *yytext
18 |       return cat
19 |    end
20 |    method whitespace()
21 |       yycolno +:= *yytext
22 |    end
23 |    method newline()
24 |       yylineno +:= 1; yycolno := 1
25 |    end
26 |    method comment()
27 |       yytext ? {
28 |          while tab(find("\n")+1) do newline()
29 |          yycolno +:= *tab(0)
30 |       }
31 |    end
32 |    method ord(s)
33 |       return proc("ord",0)(s[1])
34 |    end
35 |    method print(root)
36 |       root.print()
37 |    end
38 |    method node(s,r,p[])
39 |       rv := tree ! ([s,r] ||| p)
40 |       return rv
41 |    end
42 |    method semantic(root)
43 |    local out_st, System_st
44 |      global_st := symtab("global")
45 |      System_st := symtab("class")
46 |      out_st := symtab("class")
47 |      out_st.insert("println", false, , methodtype())
48 |      System_st.insert("out", false, out_st, classtype("PrintStream",out_st))
49 |      global_st.insert("System", false, System_st, classtype("System",System_st))
50 |      root.mkSymTables(global_st)
51 |      root.populateSymTables()
52 |      root.checkSymTables()
53 | #     global_st.print()
54 |      root.checktype()
55 |    end
56 |    method semerror(s)
57 |      stop("semantic error: ", s)
58 |    end
59 |    method calctype(t)
60 |      t.kids[1].calctype()
61 |      t.kids[2].assigntype(t.kids[1].typ)
62 |    end
63 | end
64 | 


--------------------------------------------------------------------------------
/ch7/j0.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | import java.io.FileReader;
 3 | public class j0 {
 4 |    public static Yylex yylexer;
 5 |    public static ch7.parser par;
 6 |    public static ch7.symtab global_st;
 7 |    public static void main(String argv[]) throws Exception {
 8 |       init(argv[0]);
 9 |       par = new ch7.parser();
10 |       //                  par.yydebug=true;
11 |       yylineno = 1;
12 |       int i = par.yyparse();
13 |       if (i == 0)
14 |          System.out.println("no errors");
15 |    }
16 |    public static int yylineno;
17 |    public static String yyfilename;
18 |     //   public static parserVal yylval;
19 |    public static void init(String s) throws Exception {
20 |       yyfilename = s;
21 |       System.out.println("yyfilename "+yyfilename);
22 |       yylexer = new Yylex(new FileReader(s));
23 |    }
24 |    public static int YYEOF() { return Yylex.YYEOF; }
25 |    public static int yylex() {
26 |       int rv = 0;
27 |       try {
28 |         rv = yylexer.yylex();
29 |       } catch(java.io.IOException ioException) {
30 |         rv = -1;
31 |       }
32 |       return rv;
33 |    }
34 |    public static String yytext() {
35 |       return yylexer.yytext();
36 |    }
37 |    public static void lexErr(String s) {
38 |       System.err.println(s);
39 |       System.exit(1);
40 |    }
41 |    public static int scan(int cat) {
42 |        ch7.j0.par.yylval =
43 | 	   new parserVal(new tree("token",0,
44 | 		new token(cat, yytext(), yylineno)));
45 |       return cat;
46 |    }
47 |    public static void newline() {
48 |       yylineno++;
49 |    }
50 |    public static void whitespace() {
51 |    }
52 |    public static void comment() {
53 |    }
54 |    public static short ord(String s) { return (short)(s.charAt(0)); }
55 |    public static void print(parserVal root) {
56 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
57 |    }
58 |   public static tree unwrap(Object obj) {
59 |     if (obj instanceof token)
60 |       return new tree("token",0,(token)obj);
61 |     else return (tree)obj;
62 |   }
63 |   public static parserVal node(String s,int r,parserVal...p) {
64 |      tree[] t = new tree[p.length];
65 |      for(int i = 0; i < t.length; i++)
66 | 	 t[i] = (tree)(p[i].obj);
67 |      return new parserVal((Object)new tree(s,r,t));
68 |   }
69 |   public static void semantic(parserVal r) {
70 |     tree root = (tree)(r.obj);
71 |     ch7.symtab out_st, System_st;
72 |     global_st = new ch7.symtab("global");
73 |     System_st = new ch7.symtab("class");
74 |     out_st = new ch7.symtab("class");
75 |     out_st.insert("println", false, null, new methodtype(null, null));
76 |     System_st.insert("out", false, out_st,
77 |        new classtype("PrintStream",out_st));
78 |     global_st.insert("System", false, System_st,
79 |        new classtype("System",System_st));
80 |    root.mkSymTables(global_st);
81 |    root.populateSymTables();
82 |    root.checkSymTables();
83 |    //   global_st.print();
84 |    root.checktype(false);
85 |   }
86 |   public static void semerror(String s) {
87 |    System.out.println("semantic error: " + s);
88 |    System.exit(1);
89 |   }
90 |   public static void calctype(parserVal pv){
91 |     tree t = (tree)pv.obj;
92 |     t.kids[0].calctype();
93 |     t.kids[1].assigntype(t.kids[0].typ);
94 |   }
95 | }
96 | 


--------------------------------------------------------------------------------
/ch7/j0gram.icn:
--------------------------------------------------------------------------------
  1 | ### This file created by IYACC 1.1
  2 | ### Please send bug reports to jeffery@cs.nmt.edu
  3 | #define YYPREFIX "yy"
  4 | $define BREAK 257
  5 | $define DOUBLE 258
  6 | $define ELSE 259
  7 | $define FOR 260
  8 | $define IF 261
  9 | $define INT 262
 10 | $define RETURN 263
 11 | $define VOID 264
 12 | $define WHILE 265
 13 | $define IDENTIFIER 266
 14 | $define CLASSNAME 267
 15 | $define CLASS 268
 16 | $define STRING 269
 17 | $define BOOL 270
 18 | $define INTLIT 271
 19 | $define DOUBLELIT 272
 20 | $define STRINGLIT 273
 21 | $define BOOLLIT 274
 22 | $define NULLVAL 275
 23 | $define LESSTHANOREQUAL 276
 24 | $define GREATERTHANOREQUAL 277
 25 | $define ISEQUALTO 278
 26 | $define NOTEQUALTO 279
 27 | $define LOGICALAND 280
 28 | $define LOGICALOR 281
 29 | $define INCREMENT 282
 30 | $define DECREMENT 283
 31 | $define PUBLIC 284
 32 | $define STATIC 285
 33 | $define YYERRCODE 256
 34 | procedure init() 
 35 |   yylhs := [                                        -1,
 36 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 37 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 38 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 39 |    18,    6,   14,   19,   19,   20,   20,   21,   21,   22,
 40 |    24,   23,   23,   23,   23,   23,   23,   23,   23,   23,
 41 |    23,   25,   33,   33,   28,   29,   30,   30,   37,   37,
 42 |    38,   31,   32,   39,   39,   39,   40,   40,   41,   41,
 43 |    42,   42,   26,   26,   27,   43,   43,   43,   43,   44,
 44 |    44,   44,   44,   44,   46,   46,   45,   47,   47,   35,
 45 |    35,   48,   48,   49,   49,   49,   50,   50,   50,   50,
 46 |    51,   51,   51,   52,   52,   52,   52,   53,   53,   54,
 47 |    54,   54,   55,   55,   56,   56,   36,   36,   34,   57,
 48 |    57,   58,   58,   58,
 49 |   ]
 50 |   yylen := [                            2,
 51 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 52 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 53 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 54 |     2,    2,    3,    1,    0,    1,    2,    1,    1,    2,
 55 |     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 56 |     1,    2,    1,    1,    5,    7,    6,    8,    1,    2,
 57 |     2,    5,    9,    1,    1,    0,    1,    0,    1,    0,
 58 |     1,    3,    2,    3,    3,    1,    1,    1,    3,    1,
 59 |     1,    1,    1,    1,    1,    3,    3,    1,    0,    4,
 60 |     6,    1,    1,    2,    2,    1,    1,    3,    3,    3,
 61 |     1,    3,    3,    1,    1,    1,    1,    1,    3,    1,
 62 |     3,    3,    1,    3,    1,    3,    1,    1,    3,    1,
 63 |     1,    1,    1,    1,
 64 |   ]
 65 |   yydefred := [                         0,
 66 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 67 |    12,    0,    3,    0,    4,    6,    7,    8,    0,    0,
 68 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 69 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 70 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 71 |     0,   80,   81,   83,   82,   84,   43,    0,    0,    0,
 72 |    42,    0,    0,   36,   38,   39,    0,   44,   45,   46,
 73 |    47,   48,   49,   50,   51,    0,   53,    0,    0,   76,
 74 |     0,    0,    0,   26,    0,    0,   25,    0,   21,    0,
 75 |    73,    0,    0,    0,    0,    0,  118,   78,   67,    0,
 76 |     0,   96,   97,    0,    0,    0,    0,    0,    0,    0,
 77 |     0,    0,    0,   33,   37,   40,   52,    0,  123,  124,
 78 |   122,    0,   30,   74,   65,   71,    0,    0,    0,    0,
 79 |    77,   94,   95,   75,    0,    0,    0,    0,    0,  104,
 80 |   105,  106,  107,    0,    0,    0,    0,    0,    0,   79,
 81 |    85,    0,    0,    0,  119,    0,    0,    0,   98,   99,
 82 |   100,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 83 |    90,    0,    0,    0,   72,    0,   62,   86,    0,    0,
 84 |     0,    0,   59,   91,    0,    0,    0,   56,   61,    0,
 85 |    60,    0,    0,   58,   63,    0,    0,   55,
 86 |   ]
 87 |   yydgoto := [                          2,
 88 |     6,   14,   15,   16,   17,   18,   59,   29,  130,   21,
 89 |    30,   42,   22,   61,   23,   37,   38,   39,   62,   63,
 90 |    64,   65,   66,   67,   68,   69,   70,   71,   72,   73,
 91 |    74,   75,   76,   97,   98,   99,  182,  183,  127,  100,
 92 |   185,  128,  101,   80,   81,  152,  153,  102,  103,  104,
 93 |   105,  144,  106,  107,  108,  109,   82,  122,
 94 |   ]
 95 |   yysindex := [                      -218,
 96 |  -200,    0, -181,  -35,  -95,    0,    0,    0,   51,    0,
 97 |     0, -177,    0,  -93,    0,    0,    0,    0, -152,   79,
 98 |     0,   16,   16,  227,  217,    0,    0,    0,  -30,   65,
 99 |  -133,  169,    0,    0,    0, -152,  117,  116,    0,    0,
100 |     0,  -96,    0, -152,   95,    0,  -46,  132,  150,   50,
101 |   153,    0,    0,    0,    0,    0,    0,   50, -152,   52,
102 |     0,   72,  169,    0,    0,    0,  141,    0,    0,    0,
103 |     0,    0,    0,    0,    0,  143,    0,    0,  158,    0,
104 |     0,  -24,   65,    0,  227,   51,    0,   65,    0,  148,
105 |     0,  -39,   50,   50,   50,   52,    0,    0,    0,  151,
106 |   158,    0,    0,  145,  109,   97, -100,  -69,  -68,   50,
107 |   171,  170,   50,    0,    0,    0,    0,  -51,    0,    0,
108 |     0,   50,    0,    0,    0,    0,  157,  173,  177,   52,
109 |     0,    0,    0,    0,   50,   50,   50,   50,   50,    0,
110 |     0,    0,    0,   50,   50,   50,   50,   50,  180,    0,
111 |     0,  182,  188,  197,    0,   50,   -1,   16,    0,    0,
112 |     0,  145,  145,  109,   97,   97, -100,  -69,  268,   50,
113 |     0,   50,  179,   52,    0,  -11,    0,    0,  219,   -1,
114 |  -111,    9,    0,    0,  222,  173,  224,    0,    0, -111,
115 |     0,   16,   50,    0,    0,  234,   16,    0,
116 |   ]
117 |   yyrindex := [                         0,
118 |     0,    0,    0,    0,    0,    0,    0,    0,  -44,    0,
119 |     0,    0,    0,    0,    0,    0,    0,    0,    0,   19,
120 |     0,    0,    0,  235,    0,    0,    0,    0,    0,    6,
121 |     0,  172,    0,    0,    0,    0,    0,  257,    0,    0,
122 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  240,
123 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -58,
124 |     0,    0,  175,    0,    0,    0,    0,    0,    0,    0,
125 |     0,    0,    0,    0,    0,    0,    0,  107,    0,    0,
126 |   -37,    0,  -13,    0,    0,    0,    0,   14,    0,    0,
127 |     0,  246,    0,    0,    0,    1,    0,    0,    0,    0,
128 |    10,    0,    0,   56,   76,   15,   90,   45,   43,    0,
129 |     0,  247,  266,    0,    0,    0,    0,    0,    0,    0,
130 |     0,    0,    0,    0,    0,    0,    0,  250,    0,   34,
131 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
132 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
133 |     0,  276,    0,  -26,    0,  240,    0,    0,    0,    0,
134 |     0,   62,   68,   82,   23,   88,   96,  102,    0,    0,
135 |     0,  266,    0,  -21,    0,  124,    0,    0,    0,  277,
136 |     0,  144,    0,    0,    0,  278,    0,    0,    0,    0,
137 |     0,    0,    0,    0,    0,    0,    0,    0,
138 |   ]
139 |   yygindex := [                         0,
140 |     0,    0,  314,    0,    0,    0,  181,  270,  445,    0,
141 |     5,    0,    0,    4,  289,    0,    0,  245,    0,    0,
142 |   287,    0,  195,  273,    0,    0,    0,  -71,    0,    0,
143 |     0,    0,  -12,  288,  388,  378,    0,  190,    0,  223,
144 |     0,  198,  390,    0,  441,    0,  203,    0,  329,   42,
145 |   244,    0,   53,  253,  255,    0,    0,    0,
146 |   ]
147 | $define YYTABLESIZE 638
148 |   yytable := [                         77,
149 |    58,   15,  120,   77,   77,   77,   77,   77,   77,   77,
150 |    87,   32,   91,   44,   87,   87,   87,   87,   87,   87,
151 |    87,   77,   77,  121,   77,   33,   34,   31,   43,   13,
152 |    31,   26,   87,   87,   87,   87,  121,   93,   58,  120,
153 |    83,   93,   93,   93,   93,   93,   92,   93,   88,   18,
154 |    92,   92,   92,   92,   92,  110,   92,   19,  110,   93,
155 |    93,  120,   93,  111,   18,    1,  111,    3,   92,   92,
156 |    93,   92,   19,  110,   93,   93,   93,   93,   93,  126,
157 |    93,  111,   95,  117,    4,  115,  117,    5,  115,   58,
158 |    24,  113,   93,   93,   94,   93,  101,   31,  101,  101,
159 |   101,  117,  103,  115,  103,  103,  103,   25,  102,  189,
160 |   102,  102,  102,   28,  101,  101,  108,  101,  189,  108,
161 |   103,  103,  109,  103,   31,  109,  102,  102,  112,  102,
162 |   113,  112,   46,  113,  108,  108,  114,  108,   32,  114,
163 |   109,  109,  116,  109,  175,  116,  112,   54,  113,  187,
164 |    54,  139,   78,  138,  114,   45,  142,   84,  143,   85,
165 |   116,  176,    7,   55,    7,   54,    8,  126,    8,   86,
166 |     9,   92,    9,   10,   11,   10,   11,  145,  146,  162,
167 |   163,  137,   55,   57,  188,   19,  135,   89,   12,   93,
168 |    12,  136,  110,  194,   19,  195,  114,  165,  166,  116,
169 |   198,  117,   57,  118,   36,   41,  124,   14,   58,  134,
170 |   147,  150,  148,   44,  154,  156,  157,  158,    7,   90,
171 |   169,   15,    8,  120,  120,  170,   35,   57,  171,   10,
172 |    11,   52,   53,   54,   55,   56,  172,  180,   77,   77,
173 |    77,   77,   77,   77,  121,  121,   55,  181,   55,   87,
174 |    87,   87,   87,   87,   87,   87,   87,  119,  120,  184,
175 |   120,  120,  192,  193,   35,   36,   57,  190,   57,   52,
176 |    53,   54,   55,   56,  197,   28,   93,   93,   93,   93,
177 |    93,   93,  120,  120,   14,   92,   92,   92,   92,   92,
178 |    92,   32,  110,  110,  110,  110,   35,   27,   68,   34,
179 |   111,  111,  111,  111,   66,   41,   89,   58,   64,   93,
180 |    93,   93,   93,   93,   93,   35,   88,   70,   69,   77,
181 |    52,   53,   54,   55,   56,  115,   57,   27,  112,  123,
182 |    87,  101,  101,  101,  101,  101,  101,  103,  103,  103,
183 |   103,  103,  103,  102,  102,  102,  102,  102,  102,  115,
184 |    77,  108,  108,  108,  108,  108,  108,  109,  109,  109,
185 |   109,  109,  109,  177,  125,  112,  112,  112,  112,  113,
186 |   113,  191,  140,  141,  179,  114,  114,  186,  173,   77,
187 |    55,   55,  116,   55,   55,   55,   55,  164,   55,   55,
188 |    32,    0,   55,   55,   55,   55,   55,   55,   55,  167,
189 |    57,   57,  168,   57,   57,   57,   57,    0,   57,   57,
190 |     0,    0,   57,   57,   57,   57,   57,   57,   57,   78,
191 |     0,   79,  132,  133,    0,   47,    7,    0,   48,   49,
192 |     8,   50,    0,   51,   35,  111,    0,   10,   11,   52,
193 |    53,   54,   55,   56,   77,    0,    0,    0,    0,   20,
194 |    78,    0,   79,    0,    0,    0,   77,    0,   20,    0,
195 |     0,    0,    0,  159,  160,  161,    0,   77,   20,   20,
196 |   129,    0,    0,    0,    7,    0,   60,    0,    8,   78,
197 |    40,   79,   35,    0,    7,   10,   11,  149,    8,    0,
198 |   151,    0,   35,    0,   96,   10,   11,    0,    0,  155,
199 |     0,    0,   96,    0,    0,    0,    0,   60,    0,    0,
200 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
201 |     0,    0,    0,    0,   47,    0,    0,   48,   49,   20,
202 |    50,    0,   51,   35,  131,  131,   60,   96,   52,   53,
203 |    54,   55,   56,    0,   78,    0,   79,  178,    0,  151,
204 |     0,    0,    0,    0,   96,    0,   78,   96,   79,    0,
205 |     0,    0,    0,    0,    0,    0,   96,   78,    0,   79,
206 |   196,    0,    0,    0,    0,  131,  131,  131,  131,  131,
207 |     0,    0,    0,    0,  131,  131,  131,  131,  131,    0,
208 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
209 |    96,  174,    0,    0,    0,    0,    0,    0,    0,    0,
210 |     0,    0,    0,  174,   96,    0,   96,    0,    0,    0,
211 |     0,    0,    0,    0,  174,    0,    0,    0,    0,    0,
212 |     0,    0,    0,    0,    0,    0,    0,   96,
213 |   ]
214 |   yycheck := [                         37,
215 |    40,   46,   61,   41,   42,   43,   44,   45,   46,   47,
216 |    37,  123,   59,   44,   41,   42,   43,   44,   45,   46,
217 |    47,   59,   60,   61,   62,   22,   23,   41,   59,  125,
218 |    44,  125,   59,   60,   61,   62,   61,   37,   40,   61,
219 |    36,   41,   42,   43,   44,   45,   37,   47,   44,   44,
220 |    41,   42,   43,   44,   45,   41,   47,   44,   44,   59,
221 |    60,   61,   62,   41,   59,  284,   44,  268,   59,   60,
222 |    37,   62,   59,   59,   41,   42,   43,   44,   45,   92,
223 |    47,   59,   33,   41,  266,   41,   44,  123,   44,   40,
224 |    40,   40,   59,   60,   45,   62,   41,   46,   43,   44,
225 |    45,   59,   41,   59,   43,   44,   45,  285,   41,  181,
226 |    43,   44,   45,  266,   59,   60,   41,   62,  190,   44,
227 |    59,   60,   41,   62,   46,   44,   59,   60,   41,   62,
228 |    41,   44,  266,   44,   59,   60,   41,   62,  123,   44,
229 |    59,   60,   41,   62,  157,   44,   59,   41,   59,  261,
230 |    44,   43,   46,   45,   59,   91,   60,   41,   62,   44,
231 |    59,  158,  258,   40,  258,   59,  262,  180,  262,  266,
232 |   266,   40,  266,  269,  270,  269,  270,  278,  279,  138,
233 |   139,   37,   59,   40,  181,    5,   42,   93,  284,   40,
234 |   284,   47,   40,  190,   14,  192,  125,  145,  146,   59,
235 |   197,   59,   59,   46,   24,   25,   59,  266,   40,   59,
236 |   280,   41,  281,   44,  266,   59,   44,   41,  258,  266,
237 |    41,  266,  262,  282,  283,   44,  266,   59,   41,  269,
238 |   270,  271,  272,  273,  274,  275,   40,   59,  276,  277,
239 |   278,  279,  280,  281,  282,  283,  123,  259,  125,  276,
240 |   277,  278,  279,  280,  281,  282,  283,  282,  283,   41,
241 |   282,  283,   41,   40,  266,   85,  123,  259,  125,  271,
242 |   272,  273,  274,  275,   41,   41,  276,  277,  278,  279,
243 |   280,  281,  282,  283,  266,  276,  277,  278,  279,  280,
244 |   281,  123,  278,  279,  280,  281,  125,   41,   59,  125,
245 |   278,  279,  280,  281,   59,   59,   41,   40,   59,  276,
246 |   277,  278,  279,  280,  281,  266,   41,   41,   41,   32,
247 |   271,  272,  273,  274,  275,  281,   59,   14,   59,   85,
248 |    42,  276,  277,  278,  279,  280,  281,  276,  277,  278,
249 |   279,  280,  281,  276,  277,  278,  279,  280,  281,   63,
250 |    63,  276,  277,  278,  279,  280,  281,  276,  277,  278,
251 |   279,  280,  281,  169,   92,  278,  279,  280,  281,  280,
252 |   281,  182,  276,  277,  172,  280,  281,  180,  156,   92,
253 |   257,  258,  281,  260,  261,  262,  263,  144,  265,  266,
254 |   123,   -1,  269,  270,  271,  272,  273,  274,  275,  147,
255 |   257,  258,  148,  260,  261,  262,  263,   -1,  265,  266,
256 |    -1,   -1,  269,  270,  271,  272,  273,  274,  275,   32,
257 |    -1,   32,   94,   95,   -1,  257,  258,   -1,  260,  261,
258 |   262,  263,   -1,  265,  266,   58,   -1,  269,  270,  271,
259 |   272,  273,  274,  275,  157,   -1,   -1,   -1,   -1,    5,
260 |    63,   -1,   63,   -1,   -1,   -1,  169,   -1,   14,   -1,
261 |    -1,   -1,   -1,  135,  136,  137,   -1,  180,   24,   25,
262 |    93,   -1,   -1,   -1,  258,   -1,   32,   -1,  262,   92,
263 |   264,   92,  266,   -1,  258,  269,  270,  110,  262,   -1,
264 |   113,   -1,  266,   -1,   50,  269,  270,   -1,   -1,  122,
265 |    -1,   -1,   58,   -1,   -1,   -1,   -1,   63,   -1,   -1,
266 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
267 |    -1,   -1,   -1,   -1,  257,   -1,   -1,  260,  261,   85,
268 |   263,   -1,  265,  266,   94,   95,   92,   93,  271,  272,
269 |   273,  274,  275,   -1,  157,   -1,  157,  170,   -1,  172,
270 |    -1,   -1,   -1,   -1,  110,   -1,  169,  113,  169,   -1,
271 |    -1,   -1,   -1,   -1,   -1,   -1,  122,  180,   -1,  180,
272 |   193,   -1,   -1,   -1,   -1,  135,  136,  137,  138,  139,
273 |    -1,   -1,   -1,   -1,  144,  145,  146,  147,  148,   -1,
274 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
275 |   156,  157,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
276 |    -1,   -1,   -1,  169,  170,   -1,  172,   -1,   -1,   -1,
277 |    -1,   -1,   -1,   -1,  180,   -1,   -1,   -1,   -1,   -1,
278 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,  193,
279 |   ]
280 | $define YYFINAL 2
281 | $define YYMAXTOKEN 285
282 |   yyname := [
283 | "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
284 | "'!'",0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,
285 | 0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
286 | 0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
287 | 0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
288 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
289 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
290 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"BREAK","DOUBLE","ELSE","FOR","IF",
291 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
292 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
293 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
294 | "INCREMENT","DECREMENT","PUBLIC","STATIC",
295 |   ]
296 |   yyrule := [
297 | "$accept : ClassDecl",
298 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
299 | "ClassBody : '{' ClassBodyDecls '}'",
300 | "ClassBody : '{' '}'",
301 | "ClassBodyDecls : ClassBodyDecl",
302 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
303 | "ClassBodyDecl : FieldDecl",
304 | "ClassBodyDecl : MethodDecl",
305 | "ClassBodyDecl : ConstructorDecl",
306 | "FieldDecl : Type VarDecls ';'",
307 | "Type : INT",
308 | "Type : DOUBLE",
309 | "Type : BOOL",
310 | "Type : STRING",
311 | "Type : Name",
312 | "Name : IDENTIFIER",
313 | "Name : QualifiedName",
314 | "QualifiedName : Name '.' IDENTIFIER",
315 | "VarDecls : VarDeclarator",
316 | "VarDecls : VarDecls ',' VarDeclarator",
317 | "VarDeclarator : IDENTIFIER",
318 | "VarDeclarator : VarDeclarator '[' ']'",
319 | "MethodReturnVal : Type",
320 | "MethodReturnVal : VOID",
321 | "MethodDecl : MethodHeader Block",
322 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
323 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
324 | "FormalParmListOpt : FormalParmList",
325 | "FormalParmListOpt :",
326 | "FormalParmList : FormalParm",
327 | "FormalParmList : FormalParmList ',' FormalParm",
328 | "FormalParm : Type VarDeclarator",
329 | "ConstructorDecl : MethodDeclarator Block",
330 | "Block : '{' BlockStmtsOpt '}'",
331 | "BlockStmtsOpt : BlockStmts",
332 | "BlockStmtsOpt :",
333 | "BlockStmts : BlockStmt",
334 | "BlockStmts : BlockStmts BlockStmt",
335 | "BlockStmt : LocalVarDeclStmt",
336 | "BlockStmt : Stmt",
337 | "LocalVarDeclStmt : LocalVarDecl ';'",
338 | "LocalVarDecl : Type VarDecls",
339 | "Stmt : Block",
340 | "Stmt : ';'",
341 | "Stmt : ExprStmt",
342 | "Stmt : BreakStmt",
343 | "Stmt : ReturnStmt",
344 | "Stmt : IfThenStmt",
345 | "Stmt : IfThenElseStmt",
346 | "Stmt : IfThenElseIfStmt",
347 | "Stmt : WhileStmt",
348 | "Stmt : ForStmt",
349 | "ExprStmt : StmtExpr ';'",
350 | "StmtExpr : Assignment",
351 | "StmtExpr : MethodCall",
352 | "IfThenStmt : IF '(' Expr ')' Block",
353 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
354 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
355 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
356 | "ElseIfSequence : ElseIfStmt",
357 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
358 | "ElseIfStmt : ELSE IfThenStmt",
359 | "WhileStmt : WHILE '(' Expr ')' Stmt",
360 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
361 | "ForInit : StmtExprList",
362 | "ForInit : LocalVarDecl",
363 | "ForInit :",
364 | "ExprOpt : Expr",
365 | "ExprOpt :",
366 | "ForUpdate : StmtExprList",
367 | "ForUpdate :",
368 | "StmtExprList : StmtExpr",
369 | "StmtExprList : StmtExprList ',' StmtExpr",
370 | "BreakStmt : BREAK ';'",
371 | "BreakStmt : BREAK IDENTIFIER ';'",
372 | "ReturnStmt : RETURN ExprOpt ';'",
373 | "Primary : Literal",
374 | "Primary : FieldAccess",
375 | "Primary : MethodCall",
376 | "Primary : '(' Expr ')'",
377 | "Literal : INTLIT",
378 | "Literal : DOUBLELIT",
379 | "Literal : BOOLLIT",
380 | "Literal : STRINGLIT",
381 | "Literal : NULLVAL",
382 | "ArgList : Expr",
383 | "ArgList : ArgList ',' Expr",
384 | "FieldAccess : Primary '.' IDENTIFIER",
385 | "ArgListOpt : ArgList",
386 | "ArgListOpt :",
387 | "MethodCall : Name '(' ArgListOpt ')'",
388 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
389 | "PostFixExpr : Primary",
390 | "PostFixExpr : Name",
391 | "UnaryExpr : '-' UnaryExpr",
392 | "UnaryExpr : '!' UnaryExpr",
393 | "UnaryExpr : PostFixExpr",
394 | "MulExpr : UnaryExpr",
395 | "MulExpr : MulExpr '*' UnaryExpr",
396 | "MulExpr : MulExpr '/' UnaryExpr",
397 | "MulExpr : MulExpr '%' UnaryExpr",
398 | "AddExpr : MulExpr",
399 | "AddExpr : AddExpr '+' MulExpr",
400 | "AddExpr : AddExpr '-' MulExpr",
401 | "RelOp : LESSTHANOREQUAL",
402 | "RelOp : GREATERTHANOREQUAL",
403 | "RelOp : '<'",
404 | "RelOp : '>'",
405 | "RelExpr : AddExpr",
406 | "RelExpr : RelExpr RelOp AddExpr",
407 | "EqExpr : RelExpr",
408 | "EqExpr : EqExpr ISEQUALTO RelExpr",
409 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
410 | "CondAndExpr : EqExpr",
411 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
412 | "CondOrExpr : CondAndExpr",
413 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
414 | "Expr : CondOrExpr",
415 | "Expr : Assignment",
416 | "Assignment : LeftHandSide AssignOp Expr",
417 | "LeftHandSide : Name",
418 | "LeftHandSide : FieldAccess",
419 | "AssignOp : '='",
420 | "AssignOp : INCREMENT",
421 | "AssignOp : DECREMENT",
422 |   ]
423 | 
424 | end
425 | 
426 | #####################################################################
427 | #####################################################################
428 | invocable all    # need to look up semantic actions by name
429 | 
430 | global yytext    # user variable to return contextual strings
431 | global yyval     # used to return semantic vals from action routines
432 | global yylval    # the 'lval' (result) I got from yylex()
433 | global yydebug   # (boolean) do I want debug output?
434 | global yynerrs   # (integer) number of errors so far
435 | global yyerrflag # (integer) was there an error?
436 | global yychar    # (integer) the current working character
437 | global action    # maps an integer to a semantic action procedure
438 | 
439 | global yylhs
440 | global yylen
441 | global yydefred
442 | global yydgoto
443 | global yysindex
444 | global yyrindex
445 | global yygindex
446 | global yytable
447 | global yycheck
448 | global yyname
449 | global yyrule
450 | 
451 | global statestk         # state stack
452 | global valstk           # value stack
453 | ################################################################
454 | # procedure: init_stacks : allocate and prepare stacks
455 | ################################################################
456 | procedure init_stacks()
457 |   local i
458 |   statestk := []
459 |   valstk := []
460 |   yyval  := 0 
461 |   yylval := 0 
462 |   action := list(1000, action_null)  # remove hard coded 1000 later
463 |   every i := 1 to 1000 do action[i] := proc("action_" || i)
464 | end
465 | 
466 | $define YYACCEPT return 0
467 | $define YYABORT return 1
468 | ################################################################
469 | # procedure: yyparse : parse input and execute indicated items
470 | ################################################################
471 | procedure yyparse()
472 |   local yyn        # next next thing to do
473 |   local yym        #
474 |   local yystate    # current parsing state from state table
475 |   local yys        # current token string
476 |   local doaction   # set to 1 if there need to execute action
477 |   local token      # current token
478 | 
479 |   if /yytable then init() 
480 |   init_stacks() 
481 |   yynerrs   := 0 
482 |   yyerrflag := 0 
483 |   yychar    := -1           # impossible char forces a read
484 |   yystate   := 0            # initial state
485 |   push(statestk, yystate)   # save it
486 | 
487 |   repeat { # until parsing is done, either correctly, or w/error
488 |     doaction := 1 
489 | 
490 |     ##### NEXT ACTION (from reduction table)
491 | 	yyn := yydefred[yystate+1]
492 | 
493 |     while yyn = 0 do {
494 | 
495 |       if yychar < 0 then {   # we want a char?
496 |         yychar := yylex()    # get next token
497 |         ##### ERROR CHECK ####
498 |         if yychar < 0 then { # it it didn't work/error
499 |           yychar := 0        # change it to default string (no -1!)
500 |           if \yydebug = 1 then yylexdebug(yystate, yychar) 
501 |           }
502 |         } # yychar < 0
503 | 	  
504 |       yyn := yysindex[yystate+1]  # get amount to shift by (shift index)
505 | 
506 |       if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
507 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
508 | 		
509 |         ##### NEXT STATE ####
510 |         yystate := yytable[yyn+1] # we are in a new state
511 |         push(statestk, yystate)   # save it
512 |         push(valstk, yylval)      # push our lval as the input for next rule
513 |         yychar := -1              # since we have 'eaten' a token, say we need another
514 |         if yyerrflag > 0 then     # have we recovered an error?
515 |            yyerrflag -:= 1        # give ourselves credit
516 |         doaction := 0             # but don't process yet
517 |         break                     # quit the yyn=0 loop
518 |         }
519 | 
520 |     yyn := yyrindex[yystate+1]    # reduce
521 | 
522 |     if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
523 |        (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
524 |       # e reduced!
525 |       yyn      := yytable[yyn+1] 
526 |       doaction := 1  # get ready to execute
527 |       break          # drop down to actions
528 |       }
529 |     else { #ERROR RECOVERY
530 |       if yyerrflag == 0 then {
531 |         (\yyerror | write)("syntax error") 
532 |         yynerrs +:= 1 
533 |       }
534 |       if yyerrflag < 3 then {     # low error count?
535 |         yyerrflag := 3 
536 |         repeat { #do until break
537 |           if *statestk < 1 then {  # check for under & overflow here
538 |             (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
539 |             return 1 
540 |           }
541 |           yyn := yysindex[statestk[1]] 
542 |           if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
543 |                     yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
544 |             yystate := yytable[yyn+1] 
545 |             push(statestk, yystate) 
546 |             push(valstk, yylval) 
547 |             doaction := 0 
548 |             break 
549 |           }
550 |           else {
551 |             if *statestk = 0 then { # check for under & overflow here
552 |               write("Stack underflow. aborting...") # capital 'S'
553 |               return 1 
554 |             }
555 |             pop(statestk) 
556 |             pop(valstk) 
557 |             }
558 |           }
559 |         }
560 |       else  # discard this token
561 |         {
562 |         if yychar = 0 then return 1  # yyabort
563 |         if \yydebug = 1 then {
564 |           yys := &null 
565 |           if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
566 |           if integer(yys) & yys = 0 then yys := "illegal-symbol" 
567 |           write("state ",  yystate, ", error recovery discards token ",
568 |                 yychar, " (", yys, ")") 
569 |           }
570 |         yychar := -1       # read another
571 |         }
572 |       } # end error recovery
573 |       yyn := yydefred[yystate+1] 
574 |     }# yyn = 0 loop
575 | 
576 |     if doaction = 0 then   # any reason not to proceed?
577 |       next                 # skip action
578 | 
579 |     yym := yylen[yyn+1]    # get count of terminals on rhs
580 |     yyval := valstk[yym]   # get current semantic value
581 |     if arv := action[yyn]() then return arv # execute the semantic action
582 | 
583 |     ##### Now let's reduce... ####
584 |     every 1 to yym do pop(statestk)# we just reduced yylen states
585 |     yystate := statestk[1]        # get new state
586 | 
587 |     every 1 to yym do pop(valstk) # corresponding value drop
588 |     yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
589 |     if yystate = 0 & yym = 0 then {
590 |                                   # done? 'rest' state and at first TERMINAL
591 |       yystate := YYFINAL          # explicitly say we're done
592 |       push(statestk, YYFINAL)     # and save it
593 |       push(valstk, yyval)         # also save the semantic value of parsing
594 |       if yychar < 0 then {        # we want another character?
595 |         yychar := yylex()         # get next character
596 |         if yychar < 0 then yychar := 0   #clean, if necessary
597 |       }
598 |       if yychar = 0 then break    # Good exit (if lex returns 0  -)
599 |                                   # quit the loop--all DONE
600 |     } # if yystate
601 |     else {                        #else not done yet
602 |       # get next state and push, for next yydefred[]
603 |       yyn := yygindex[yym+1]        # find out where to go
604 |       if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
605 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
606 |         yystate := yytable[yyn+1]   # get new state
607 |         }
608 |       else {
609 |         yystate := yydgoto[yym+1]   # else go to new defred
610 | 	     }
611 |       push(statestk, yystate)       # going again, so push state & val...
612 |       push(valstk, yyval)           # for next action
613 |       }
614 |     } # main loop
615 | 
616 |   return 0 # yyaccept!!
617 | end
618 | 
619 | ### end of procedure parse() ######################################
620 | 
621 | ### start semantic actions ########################################
622 | 
623 | procedure action_null()
624 |   #write("null action")
625 | end
626 | 
627 | procedure action_1()
628 | #line 8 "j0gram.y"
629 | 
630 |   yyval:=j0.node("ClassDecl",1000,valstk[2],valstk[1]);
631 |   j0.semantic(yyval);
632 |  
633 | end
634 | 
635 | procedure action_2()
636 | #line 12 "j0gram.y"
637 |  yyval:=j0.node("ClassBody",1010,valstk[2]); 
638 | end
639 | 
640 | procedure action_3()
641 | #line 13 "j0gram.y"
642 |  yyval:=j0.node("ClassBody",1011); 
643 | end
644 | 
645 | procedure action_5()
646 | #line 15 "j0gram.y"
647 | 
648 |   yyval:=j0.node("ClassBodyDecls",1020,valstk[2],valstk[1]); 
649 | end
650 | 
651 | procedure action_9()
652 | #line 18 "j0gram.y"
653 | 
654 |   yyval:=j0.node("FieldDecl",1030,valstk[3],valstk[2]);
655 |   j0.calctype(yyval);
656 |   
657 | end
658 | 
659 | procedure action_17()
660 | #line 25 "j0gram.y"
661 | 
662 |   yyval:=j0.node("QualifiedName",1040,valstk[3],valstk[1]);
663 | end
664 | 
665 | procedure action_19()
666 | #line 28 "j0gram.y"
667 | 
668 |   yyval:=j0.node("VarDecls",1050,valstk[3],valstk[1]); 
669 | end
670 | 
671 | procedure action_21()
672 | #line 30 "j0gram.y"
673 | 
674 |   yyval:=j0.node("VarDeclarator",1060,valstk[3]); 
675 | end
676 | 
677 | procedure action_24()
678 | #line 34 "j0gram.y"
679 | 
680 |   yyval:=j0.node("MethodDecl",1380,valstk[2],valstk[1]);
681 |  
682 | end
683 | 
684 | procedure action_25()
685 | #line 37 "j0gram.y"
686 | 
687 |   yyval:=j0.node("MethodHeader",1070,valstk[2],valstk[1]);
688 |   
689 | end
690 | 
691 | procedure action_26()
692 | #line 40 "j0gram.y"
693 | 
694 |   yyval:=j0.node("MethodDeclarator",1080,valstk[4],valstk[2]); 
695 | end
696 | 
697 | procedure action_30()
698 | #line 44 "j0gram.y"
699 | 
700 |   yyval:=j0.node("FormalParmList",1090,valstk[3],valstk[1]); 
701 | end
702 | 
703 | procedure action_31()
704 | #line 46 "j0gram.y"
705 | 
706 |   yyval:=j0.node("FormalParm",1100,valstk[2],valstk[1]);
707 |   j0.calctype(yyval);
708 |  
709 | end
710 | 
711 | procedure action_32()
712 | #line 51 "j0gram.y"
713 | 
714 |   yyval:=j0.node("ConstructorDecl",1110,valstk[2],valstk[1]); 
715 | end
716 | 
717 | procedure action_33()
718 | #line 54 "j0gram.y"
719 | yyval:=j0.node("Block",1200,valstk[2]);
720 | end
721 | 
722 | procedure action_37()
723 | #line 56 "j0gram.y"
724 | 
725 |   yyval:=j0.node("BlockStmts",1130,valstk[2],valstk[1]); 
726 | end
727 | 
728 | procedure action_41()
729 | #line 61 "j0gram.y"
730 | 
731 |   yyval:=j0.node("LocalVarDecl",1140,valstk[2],valstk[1]);
732 |   j0.calctype(yyval);
733 |   
734 | end
735 | 
736 | procedure action_55()
737 | #line 74 "j0gram.y"
738 | 
739 |   yyval:=j0.node("IfThenStmt",1150,valstk[3],valstk[1]); 
740 | end
741 | 
742 | procedure action_56()
743 | #line 76 "j0gram.y"
744 | 
745 |   yyval:=j0.node("IfThenElseStmt",1160,valstk[5],valstk[3],valstk[1]); 
746 | end
747 | 
748 | procedure action_57()
749 | #line 78 "j0gram.y"
750 | 
751 |   yyval:=j0.node("IfThenElseIfStmt",1170,valstk[4],valstk[2],valstk[1]); 
752 | end
753 | 
754 | procedure action_58()
755 | #line 80 "j0gram.y"
756 | 
757 |   yyval:=j0.node("IfThenElseIfStmt",1171,valstk[6],valstk[4],valstk[3],valstk[1]); 
758 | end
759 | 
760 | procedure action_60()
761 | #line 83 "j0gram.y"
762 | 
763 |   yyval:=j0.node("ElseIfSequence",1180,valstk[2],valstk[1]); 
764 | end
765 | 
766 | procedure action_61()
767 | #line 85 "j0gram.y"
768 | 
769 |   yyval:=j0.node("ElseIfStmt",1190,valstk[1]); 
770 | end
771 | 
772 | procedure action_62()
773 | #line 87 "j0gram.y"
774 | 
775 |   yyval:=j0.node("WhileStmt",1210,valstk[3],valstk[1]); 
776 | end
777 | 
778 | procedure action_63()
779 | #line 90 "j0gram.y"
780 | 
781 |   yyval:=j0.node("ForStmt",1220,valstk[7],valstk[5],valstk[3],valstk[1]); 
782 | end
783 | 
784 | procedure action_72()
785 | #line 96 "j0gram.y"
786 | 
787 |   yyval:=j0.node("StmtExprList",1230,valstk[3],valstk[1]); 
788 | end
789 | 
790 | procedure action_74()
791 | #line 99 "j0gram.y"
792 | 
793 |   yyval:=j0.node("BreakStmt",1240,valstk[2]); 
794 | end
795 | 
796 | procedure action_75()
797 | #line 101 "j0gram.y"
798 | 
799 |   yyval:=j0.node("ReturnStmt",1250,valstk[2]); 
800 | end
801 | 
802 | procedure action_79()
803 | #line 104 "j0gram.y"
804 | 
805 |   yyval:=valstk[2];
806 | end
807 | 
808 | procedure action_86()
809 | #line 108 "j0gram.y"
810 | 
811 |   yyval:=j0.node("ArgList",1270,valstk[3],valstk[1]); 
812 | end
813 | 
814 | procedure action_87()
815 | #line 110 "j0gram.y"
816 | 
817 |   yyval:=j0.node("FieldAccess",1280,valstk[3],valstk[1]); 
818 | end
819 | 
820 | procedure action_90()
821 | #line 114 "j0gram.y"
822 | 
823 |   yyval:=j0.node("MethodCall",1290,valstk[4],valstk[2]); 
824 | end
825 | 
826 | procedure action_91()
827 | #line 116 "j0gram.y"
828 | 
829 |     yyval:=j0.node("MethodCall",1291,valstk[6],valstk[4],valstk[2]); 
830 | end
831 | 
832 | procedure action_94()
833 | #line 121 "j0gram.y"
834 | 
835 |   yyval:=j0.node("UnaryExpr",1300,valstk[2],valstk[1]); 
836 | end
837 | 
838 | procedure action_95()
839 | #line 123 "j0gram.y"
840 | 
841 |   yyval:=j0.node("UnaryExpr",1301,valstk[2],valstk[1]); 
842 | end
843 | 
844 | procedure action_98()
845 | #line 127 "j0gram.y"
846 | 
847 |       yyval:=j0.node("MulExpr",1310,valstk[3],valstk[1]); 
848 | end
849 | 
850 | procedure action_99()
851 | #line 129 "j0gram.y"
852 | 
853 |       yyval:=j0.node("MulExpr",1311,valstk[3],valstk[1]); 
854 | end
855 | 
856 | procedure action_100()
857 | #line 131 "j0gram.y"
858 | 
859 |       yyval:=j0.node("MulExpr",1312,valstk[3],valstk[1]); 
860 | end
861 | 
862 | procedure action_102()
863 | #line 134 "j0gram.y"
864 | 
865 |       yyval:=j0.node("AddExpr",1320,valstk[3],valstk[1]); 
866 | end
867 | 
868 | procedure action_103()
869 | #line 136 "j0gram.y"
870 | 
871 |       yyval:=j0.node("AddExpr",1321,valstk[3],valstk[1]); 
872 | end
873 | 
874 | procedure action_109()
875 | #line 139 "j0gram.y"
876 | 
877 |   yyval:=j0.node("RelExpr",1330,valstk[3],valstk[2],valstk[1]); 
878 | end
879 | 
880 | procedure action_111()
881 | #line 143 "j0gram.y"
882 | 
883 |   yyval:=j0.node("EqExpr",1340,valstk[3],valstk[1]); 
884 | end
885 | 
886 | procedure action_112()
887 | #line 145 "j0gram.y"
888 | 
889 |   yyval:=j0.node("EqExpr",1341,valstk[3],valstk[1]); 
890 | end
891 | 
892 | procedure action_114()
893 | #line 147 "j0gram.y"
894 | 
895 |   yyval:=j0.node("CondAndExpr", 1350, valstk[3], valstk[1]); 
896 | end
897 | 
898 | procedure action_116()
899 | #line 149 "j0gram.y"
900 | 
901 |   yyval:=j0.node("CondOrExpr", 1360, valstk[3], valstk[1]); 
902 | end
903 | 
904 | procedure action_119()
905 | #line 153 "j0gram.y"
906 | 
907 | yyval:=j0.node("Assignment",1370, valstk[3], valstk[2], valstk[1]); 
908 | end
909 | 
910 | #line 915 "j0gram.icn"
911 | 


--------------------------------------------------------------------------------
/ch7/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |  } ;
 12 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 13 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 14 | ClassBodyDecls: ClassBodyDecl
 15 | | ClassBodyDecls ClassBodyDecl {
 16 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 17 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 18 | FieldDecl: Type VarDecls ';' {
 19 |   $=j0.node("FieldDecl",1030,$1,$2);
 20 |   j0.calctype($);
 21 |   };
 22 | Type: INT | DOUBLE | BOOL | STRING | Name ;
 23 | 
 24 | Name: IDENTIFIER | QualifiedName ;
 25 | QualifiedName: Name '.' IDENTIFIER {
 26 |   $=j0.node("QualifiedName",1040,$1,$3);};
 27 | 
 28 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 29 |   $=j0.node("VarDecls",1050,$1,$3); };
 30 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 31 |   $=j0.node("VarDeclarator",1060,$1); };
 32 | 
 33 | MethodReturnVal : Type | VOID ;
 34 | MethodDecl: MethodHeader Block {
 35 |   $=j0.node("MethodDecl",1380,$1,$2);
 36 |  };
 37 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 38 |   $=j0.node("MethodHeader",1070,$3,$4);
 39 |   };
 40 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 41 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 42 | 
 43 | FormalParmListOpt: FormalParmList | ;
 44 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 45 |   $=j0.node("FormalParmList",1090,$1,$3); };
 46 | FormalParm: Type VarDeclarator {
 47 |   $=j0.node("FormalParm",1100,$1,$2);
 48 |   j0.calctype($);
 49 |  };
 50 | 
 51 | ConstructorDecl: MethodDeclarator Block {
 52 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 53 | 
 54 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 55 | BlockStmtsOpt: BlockStmts | ;
 56 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 57 |   $=j0.node("BlockStmts",1130,$1,$2); };
 58 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 59 | 
 60 | LocalVarDeclStmt: LocalVarDecl ';' ;
 61 | LocalVarDecl: Type VarDecls {
 62 |   $=j0.node("LocalVarDecl",1140,$1,$2);
 63 |   j0.calctype($);
 64 |   };
 65 | 
 66 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 67 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 68 |       | WhileStmt | ForStmt ;
 69 | 
 70 | ExprStmt: StmtExpr ';' ;
 71 | 
 72 | StmtExpr: Assignment | MethodCall ;
 73 | 
 74 | IfThenStmt: IF '(' Expr ')' Block {
 75 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 76 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 77 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 78 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 79 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 80 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 81 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 82 | 
 83 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 84 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 85 | ElseIfStmt: ELSE IfThenStmt {
 86 |   $=j0.node("ElseIfStmt",1190,$2); };
 87 | WhileStmt: WHILE '(' Expr ')' Stmt {
 88 |   $=j0.node("WhileStmt",1210,$3,$5); };
 89 | 
 90 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 91 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 92 | ForInit: StmtExprList | LocalVarDecl | ;
 93 | ExprOpt: Expr |  ;
 94 | ForUpdate: StmtExprList | ;
 95 | 
 96 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 97 |   $=j0.node("StmtExprList",1230,$1,$3); };
 98 | 
 99 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
100 |   $=j0.node("BreakStmt",1240,$2); };
101 | ReturnStmt: RETURN ExprOpt ';' {
102 |   $=j0.node("ReturnStmt",1250,$2); };
103 | 
104 | Primary:  Literal | FieldAccess | MethodCall | '(' Expr ')' {
105 |   $=$2;};
106 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
107 | 
108 | ArgList: Expr | ArgList ',' Expr {
109 |   $=j0.node("ArgList",1270,$1,$3); };
110 | FieldAccess: Primary '.' IDENTIFIER {
111 |   $=j0.node("FieldAccess",1280,$1,$3); };
112 | 
113 | ArgListOpt:  ArgList | ;
114 | MethodCall: Name '(' ArgListOpt ')' {
115 |   $=j0.node("MethodCall",1290,$1,$3); }
116 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
117 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
118 | 	;
119 | 
120 | PostFixExpr: Primary | Name ;
121 | UnaryExpr:  '-' UnaryExpr {
122 |   $=j0.node("UnaryExpr",1300,$1,$2); }
123 |     | '!' UnaryExpr {
124 |   $=j0.node("UnaryExpr",1301,$1,$2); }
125 |     | PostFixExpr ;
126 | MulExpr: UnaryExpr
127 |     | MulExpr '*' UnaryExpr {
128 |       $=j0.node("MulExpr",1310,$1,$3); }
129 |     | MulExpr '/' UnaryExpr {
130 |       $=j0.node("MulExpr",1311,$1,$3); }
131 |     | MulExpr '%' UnaryExpr {
132 |       $=j0.node("MulExpr",1312,$1,$3); };
133 | AddExpr: MulExpr
134 |     | AddExpr '+' MulExpr {
135 |       $=j0.node("AddExpr",1320,$1,$3); }
136 |     | AddExpr '-' MulExpr {
137 |       $=j0.node("AddExpr",1321,$1,$3); };
138 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
139 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
140 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
141 | 
142 | EqExpr: RelExpr
143 |     | EqExpr ISEQUALTO RelExpr {
144 |   $=j0.node("EqExpr",1340,$1,$3); }
145 | | EqExpr NOTEQUALTO RelExpr {
146 |   $=j0.node("EqExpr",1341,$1,$3); };
147 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
148 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
149 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
150 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
151 | 
152 | Expr: CondOrExpr | Assignment ;
153 | Assignment: LeftHandSide AssignOp Expr {
154 | $=j0.node("Assignment",1370, $1, $2, $3); };
155 | LeftHandSide: Name | FieldAccess ;
156 | AssignOp: '=' | INCREMENT | DECREMENT ;
157 | 


--------------------------------------------------------------------------------
/ch7/j0gram_tab.icn:
--------------------------------------------------------------------------------
 1 | class Parser(BREAK, DOUBLE, ELSE, FOR, IF, INT, RETURN, VOID, WHILE, IDENTIFIER, CLASSNAME, CLASS, STRING, BOOL, INTLIT, DOUBLELIT, STRINGLIT, BOOLLIT, NULLVAL, LESSTHANOREQUAL, GREATERTHANOREQUAL, ISEQUALTO, NOTEQUALTO, LOGICALAND, LOGICALOR, INCREMENT, DECREMENT, PUBLIC, STATIC)
 2 | initially
 3 |    BREAK := 257
 4 |    DOUBLE := 258
 5 |    ELSE := 259
 6 |    FOR := 260
 7 |    IF := 261
 8 |    INT := 262
 9 |    RETURN := 263
10 |    VOID := 264
11 |    WHILE := 265
12 |    IDENTIFIER := 266
13 |    CLASSNAME := 267
14 |    CLASS := 268
15 |    STRING := 269
16 |    BOOL := 270
17 |    INTLIT := 271
18 |    DOUBLELIT := 272
19 |    STRINGLIT := 273
20 |    BOOLLIT := 274
21 |    NULLVAL := 275
22 |    LESSTHANOREQUAL := 276
23 |    GREATERTHANOREQUAL := 277
24 |    ISEQUALTO := 278
25 |    NOTEQUALTO := 279
26 |    LOGICALAND := 280
27 |    LOGICALOR := 281
28 |    INCREMENT := 282
29 |    DECREMENT := 283
30 |    PUBLIC := 284
31 |    STATIC := 285
32 | end
33 | 


--------------------------------------------------------------------------------
/ch7/javalex.icn:
--------------------------------------------------------------------------------
   1 | #
   2 | # uflex skeleton.
   3 | # do not edit by hand, this file is machine-generated
   4 | #
   5 | 
   6 | record edge(symbol, destinations)
   7 | record anode(label, rulenum, edges, epsilon, dot)
   8 | record automata(start, states, accepting)
   9 | 
  10 | global yychar, yytext, yyin, yyleng
  11 | 
  12 | #
  13 | # matchstrings reads from a specified input file and calls the simulate
  14 | # function repeatedly on smaller and smaller pieces of the input until
  15 | # it finds a match. It reports what parts of the input
  16 | # it could parse and what rule accepted the string.
  17 | #
  18 | 
  19 | global stringseq
  20 | 
  21 | procedure yyulex(aut)
  22 | local rulenum, readfrom, position, less, currstring, getln
  23 | local maxrule, maxleng
  24 | 
  25 | initial {
  26 |    if /yyin then yyin := &input
  27 |    readfrom := yyin
  28 | 
  29 |    stringseq := read(readfrom) || "\n"
  30 | 
  31 |    while getln := read(readfrom) do
  32 |       stringseq ||:= getln || "\n"
  33 | 
  34 |    close(readfrom)
  35 |    }
  36 | 
  37 |    repeat {
  38 |       if stringseq == "" then {
  39 |          yychar := -1
  40 |          fail
  41 |          }
  42 | 
  43 |       leng := 1
  44 |       while i := simulate(aut, stringseq[1:leng+1]) do {
  45 |          if i > 0 then {
  46 |             maxrule := i
  47 |             maxleng := leng
  48 |          }
  49 |          leng +:= 1
  50 |       }
  51 |       if \maxrule then {
  52 |          yytext := stringseq[1 : maxleng+1]; yyleng := maxleng
  53 |          stringseq := stringseq[maxleng+1:0]
  54 |          if yychar := (semantic_action)[maxrule] () then return yychar
  55 |       } else {
  56 |          writes(stringseq[1])
  57 |          stringseq := stringseq[2:0]
  58 |       }
  59 |    }
  60 | end
  61 | 
  62 | #
  63 | # simulate(automata, word) determines whether or not the word
  64 | # would be accepted by the given automata. It gets the possible
  65 | # destinations at each symbol of the string and then adds on wherever it
  66 | # could also get if we use any epsilon transitions out of those states.
  67 | # Then the list of accepting states is compared to the reachable set
  68 | # of states to determine if the word was accepted and by which rule.
  69 | #
  70 | procedure simulate(myaut, word)
  71 | local first, currstates, acceptcheck, currsymbol, build, rv
  72 |    currstates := list(0) # should be set()
  73 |    put(currstates, myaut.start) # insert(currstates, myaut.start)
  74 |    acceptcheck := copy(myaut.accepting)
  75 |    currsymbol := word
  76 |    while *currsymbol > 0 do {
  77 |       currstates := getdestinations(currstates, currsymbol)
  78 |       if *currstates = 0 then
  79 |          fail
  80 |       currsymbol := currsymbol[2:0]
  81 |       }
  82 |    while *acceptcheck > 0 do {
  83 |       value1 := pop(acceptcheck)
  84 |       check2 := copy(currstates)
  85 | 
  86 |       while *check2 > 0 do {
  87 |          value2 := pop(check2)
  88 | 
  89 |          if value1.label = value2.label then {
  90 |             if /rv | rv > value1.rulenum then
  91 |                rv := value1.rulenum
  92 |             }
  93 |          }
  94 |       }
  95 |    if \yydebug>0 then write("simulate() returns ", image(\rv)|0)
  96 |    return \rv | -(currstates[1].label)
  97 | end
  98 | 
  99 | #
 100 | # like |||:= except no duplicates. Destructive of L1 but not L2
 101 | #
 102 | procedure yyunionin(L1, L2)
 103 | t1 := table()
 104 |   every x := !L1 do {
 105 |      t1[x.label] := x
 106 |      }
 107 |   every x := !L2 do {
 108 |      if /t1[x.label] then {
 109 |         t1[x.label] := x
 110 |          put(L1, x)
 111 |          }
 112 |       }
 113 | end
 114 | procedure yyonein(L1, L2)
 115 |   if (!L1).label === L2[1].label then fail
 116 |   put(L1, L2[1])
 117 | end
 118 | 
 119 | #
 120 | # getdestinations uses the current set of states and
 121 | # simulates one step of automata computation on the given
 122 | # string and returns the resulting set of destinations
 123 | #
 124 | procedure getdestinations(currstates, currsymbol)
 125 | local result, current, buildresult, reached
 126 | 
 127 |    result := list(0)
 128 |    if *currstates ~= 0 then {
 129 | 
 130 |       buildresult := copy(currstates)
 131 |       while *buildresult > 0 do {
 132 |           reached := reach(pop(buildresult), currsymbol)
 133 |           if *reached>0 then {
 134 |              yyunionin(result, reached)
 135 |              }
 136 |           }
 137 |        }
 138 |     return result
 139 | end
 140 | 
 141 | #
 142 | # reach returns the list of states that can be reached
 143 | # on character symbol from the state state.
 144 | #
 145 | procedure reach(state, symbol)
 146 | local edgeset, answer, edgesymbol, bound1, bound2, curredge
 147 | 
 148 |    edgeset := copy(state.edges)
 149 |    answer := list(0)
 150 | 
 151 |    while *edgeset > 0 do {
 152 |       curredge := pop(edgeset)
 153 |       edgesymbol := copy(curredge.symbol)
 154 |       if type(edgesymbol) == "cset" then {
 155 |          if any(edgesymbol, symbol[1]) then {
 156 |             yyunionin(answer, curredge.destinations)
 157 |           }
 158 |       }
 159 |       else {
 160 |       if (edgesymbol[1] == symbol[1] ~== "[") |
 161 |          (edgesymbol == symbol[1] == "[") then # sometimes a [ is just a [
 162 |              yyunionin(answer, curredge.destinations)
 163 | 
 164 |       else if edgesymbol[1] == "\\" then {
 165 |          if (edgesymbol[2] == "n") & (symbol[1] == "\n") then
 166 |             yyunionin(answer, curredge.destinations)
 167 |          else if (edgesymbol[2] == "t") & (symbol[1] == "\t") then
 168 |             yyunionin(answer, curredge.destinations)
 169 |          else if (edgesymbol[2] == "r") & (symbol[1] == "\r") then
 170 |             yyunionin(answer, curredge.destinations)
 171 |          else if (edgesymbol[2] == "f") & (symbol[1] == "\f") then
 172 |             yyunionin(answer, curredge.destinations)
 173 |          else if (edgesymbol[2] == "\\") & (symbol[1] == "\\") then
 174 |             yyunionin(answer, curredge.destinations)
 175 |          # should handle all escapes here, and error on bogus ones
 176 |          else if edgesymbol[2] == symbol[1] then
 177 |             yyunionin(answer, curredge.destinations)
 178 |          } # escape
 179 | 
 180 | 
 181 |       }
 182 | 
 183 |       } # while edgeset > 0
 184 |    if *(state.dot)>0 then {
 185 |       yyunionin(answer, state.dot)
 186 |       }
 187 |    return answer
 188 | end
 189 | 
 190 | # "recset" == "regular expression cset"
 191 | procedure csetfromrecset(recset)
 192 | local rv, lastchar, origcset := recset
 193 |    if not (recset[1]=="[" & recset[-1]=="]") then
 194 |       stop("malformed recset ", image(recset))
 195 |    recset := recset[2:-1]
 196 | 
 197 |    if recset[1]=="^" then { # not in this cset, subtract from &cset
 198 |       rv := &cset -- csetfromrecset("["||recset[2:0]||"]")
 199 |       return rv
 200 |       }
 201 |    # positive cset construction
 202 |    rv := ''
 203 |    while *recset>0 do {
 204 | 
 205 |       if recset[1] == "-" & \lastchar & *recset>1 then
 206 |          genrangefrom := lastchar
 207 |       else {
 208 |          # did not trigger a new range. Process one char
 209 | 
 210 |          if recset[1] == "\\" then { # escape
 211 |             recset := recset[2:0]
 212 |             case recset[1] of {
 213 |                "n":  recset[1] := "\n"
 214 |                "t":  recset[1] := "\t"
 215 |                "r":  recset[1] := "\r"
 216 |                "v":  recset[1] := "\v"
 217 |                "-":  recset[1] := "\-"
 218 |                "f":  recset[1] := "\f"
 219 |                "'":  recset[1] := "\'"
 220 |                "\"":  recset[1] := "\""
 221 |                "\\": recset[1] := "\\"
 222 |                "0": {
 223 |                   if any('01234567', recset[2]) then {
 224 |                      if any('01234567', recset[3]) then {
 225 |                         o := char(recset[1]*64+recset[2]*8+recset[3])
 226 |                         recset := o || recset[4:0]
 227 |                      }
 228 |                      else stop("argh2 ", image(recset))
 229 |                      }
 230 |                   else recset[1] := "\0"
 231 |                }
 232 |                # should handle all escapes here, and error on bogus ones
 233 |                default: stop("unrecognized escape ", image(recset[1]))
 234 |                }
 235 |             }
 236 | 
 237 |          rv ++:= recset[1]
 238 | 
 239 |          if \genrangefrom then { #if we have a pending range
 240 |             ord1 := ord(genrangefrom)
 241 |              ord2 := ord(recset[1])
 242 |              while ord1 < ord2 do {
 243 |                rv ++:= char(ord1)
 244 |                ord1 +:= 1
 245 |                }
 246 |             genrangefrom := &null
 247 |             }
 248 |          lastchar := recset[1]
 249 |           }
 250 |        recset := recset[2:0]
 251 |        }
 252 | 
 253 |    return rv
 254 | end
 255 | 
 256 | procedure printautomaton(a)
 257 |    write("Automaton:")
 258 |    write("start: ", image(a.start.label),
 259 |          " for rulenum ", image(a.start.rulenum))
 260 |    write("states:")
 261 |    every printstate(!a.states)
 262 |    writes("accepting: ")
 263 |    every writes((!a.accepting).label, " ")
 264 |    write()
 265 | end
 266 | 
 267 | procedure printstate(state)
 268 |    write("state ", state.label, " is for rule #", state.rulenum)
 269 |    if (*state.edges)>0 then {
 270 |       writes("\tedges: "); every printedge(!state.edges); write()
 271 |       }
 272 |    if *state.epsilon>0 then {
 273 |       writes("\tepsilon: ")
 274 |       every writes((!state.epsilon).label, " "); write()
 275 |       }
 276 |    if (*state.dot)>0 then {
 277 |       writes("\tdot: ")
 278 |       every writes((!state.dot).label, " "); write()
 279 |       }
 280 | end
 281 | 
 282 | procedure printedge(edge)
 283 |    writes(image(edge.symbol), " -> ")
 284 |    every writes((!edge.destinations).label)
 285 |    writes("; ")
 286 | end
 287 | 
 288 | procedure printstates(states)
 289 | local statecopy, current
 290 | 
 291 |    write("printstates size ", *states, " in entity ", image(states))
 292 |    statecopy := copy(states)
 293 | 
 294 |    while *statecopy > 1 do {
 295 |       current := pop(statecopy)
 296 |       write(current.label, ", ")
 297 |       }
 298 | 
 299 |    if *statecopy > 0 then {
 300 |       current := pop(statecopy)
 301 |       write(current.label)
 302 |       }
 303 |     else write("state list is empty")
 304 | end
 305 | global semantic_action
 306 | 
 307 | procedure yylex()
 308 | static myautomata
 309 | local currstate, state2, tempedge
 310 | 
 311 |  initial {
 312 |    myautomata := automata()
 313 | 
 314 |    myautomata.states := []
 315 |    myautomata.accepting := []
 316 |    put(myautomata.states, currstate := anode(1, 0, [], [], []))
 317 |    myautomata.start := currstate
 318 | 
 319 |    put(myautomata.states, currstate := anode(2, 3, [], [], []))
 320 |    put(myautomata.accepting, currstate)
 321 | 
 322 |    put(myautomata.states, currstate := anode(3, 4, [], [], []))
 323 |    put(myautomata.accepting, currstate)
 324 | 
 325 |    put(myautomata.states, currstate := anode(4, 0, [], [], []))
 326 | 
 327 |    put(myautomata.states, currstate := anode(5, 0, [], [], []))
 328 | 
 329 |    put(myautomata.states, currstate := anode(6, 0, [], [], []))
 330 | 
 331 |    put(myautomata.states, currstate := anode(7, 0, [], [], []))
 332 | 
 333 |    put(myautomata.states, currstate := anode(8, 0, [], [], []))
 334 | 
 335 |    put(myautomata.states, currstate := anode(9, 0, [], [], []))
 336 | 
 337 |    put(myautomata.states, currstate := anode(10, 0, [], [], []))
 338 | 
 339 |    put(myautomata.states, currstate := anode(11, 0, [], [], []))
 340 | 
 341 |    put(myautomata.states, currstate := anode(12, 0, [], [], []))
 342 | 
 343 |    put(myautomata.states, currstate := anode(13, 0, [], [], []))
 344 | 
 345 |    put(myautomata.states, currstate := anode(14, 0, [], [], []))
 346 | 
 347 |    put(myautomata.states, currstate := anode(15, 0, [], [], []))
 348 | 
 349 |    put(myautomata.states, currstate := anode(16, 0, [], [], []))
 350 | 
 351 |    put(myautomata.states, currstate := anode(17, 22, [], [], []))
 352 |    put(myautomata.accepting, currstate)
 353 | 
 354 |    put(myautomata.states, currstate := anode(18, 23, [], [], []))
 355 |    put(myautomata.accepting, currstate)
 356 | 
 357 |    put(myautomata.states, currstate := anode(19, 24, [], [], []))
 358 |    put(myautomata.accepting, currstate)
 359 | 
 360 |    put(myautomata.states, currstate := anode(20, 25, [], [], []))
 361 |    put(myautomata.accepting, currstate)
 362 | 
 363 |    put(myautomata.states, currstate := anode(21, 26, [], [], []))
 364 |    put(myautomata.accepting, currstate)
 365 | 
 366 |    put(myautomata.states, currstate := anode(22, 27, [], [], []))
 367 |    put(myautomata.accepting, currstate)
 368 | 
 369 |    put(myautomata.states, currstate := anode(23, 28, [], [], []))
 370 |    put(myautomata.accepting, currstate)
 371 | 
 372 |    put(myautomata.states, currstate := anode(24, 29, [], [], []))
 373 |    put(myautomata.accepting, currstate)
 374 | 
 375 |    put(myautomata.states, currstate := anode(25, 31, [], [], []))
 376 |    put(myautomata.accepting, currstate)
 377 | 
 378 |    put(myautomata.states, currstate := anode(26, 32, [], [], []))
 379 |    put(myautomata.accepting, currstate)
 380 | 
 381 |    put(myautomata.states, currstate := anode(27, 33, [], [], []))
 382 |    put(myautomata.accepting, currstate)
 383 | 
 384 |    put(myautomata.states, currstate := anode(28, 36, [], [], []))
 385 |    put(myautomata.accepting, currstate)
 386 | 
 387 |    put(myautomata.states, currstate := anode(29, 38, [], [], []))
 388 |    put(myautomata.accepting, currstate)
 389 | 
 390 |    put(myautomata.states, currstate := anode(30, 30, [], [], []))
 391 |    put(myautomata.accepting, currstate)
 392 | 
 393 |    put(myautomata.states, currstate := anode(31, 0, [], [], []))
 394 | 
 395 |    put(myautomata.states, currstate := anode(32, 0, [], [], []))
 396 | 
 397 |    put(myautomata.states, currstate := anode(33, 34, [], [], []))
 398 |    put(myautomata.accepting, currstate)
 399 | 
 400 |    put(myautomata.states, currstate := anode(34, 35, [], [], []))
 401 |    put(myautomata.accepting, currstate)
 402 | 
 403 |    put(myautomata.states, currstate := anode(35, 44, [], [], []))
 404 |    put(myautomata.accepting, currstate)
 405 | 
 406 |    put(myautomata.states, currstate := anode(36, 47, [], [], []))
 407 |    put(myautomata.accepting, currstate)
 408 | 
 409 |    put(myautomata.states, currstate := anode(37, 49, [], [], []))
 410 |    put(myautomata.accepting, currstate)
 411 | 
 412 |    put(myautomata.states, currstate := anode(38, 48, [], [], []))
 413 |    put(myautomata.accepting, currstate)
 414 | 
 415 |    put(myautomata.states, currstate := anode(39, 50, [], [], []))
 416 |    put(myautomata.accepting, currstate)
 417 | 
 418 |    put(myautomata.states, currstate := anode(40, 0, [], [], []))
 419 | 
 420 |    put(myautomata.states, currstate := anode(41, 54, [], [], []))
 421 |    put(myautomata.accepting, currstate)
 422 | 
 423 |    put(myautomata.states, currstate := anode(42, 0, [], [], []))
 424 | 
 425 |    put(myautomata.states, currstate := anode(43, 0, [], [], []))
 426 | 
 427 |    put(myautomata.states, currstate := anode(44, 0, [], [], []))
 428 | 
 429 |    put(myautomata.states, currstate := anode(45, 0, [], [], []))
 430 | 
 431 |    put(myautomata.states, currstate := anode(46, 0, [], [], []))
 432 | 
 433 |    put(myautomata.states, currstate := anode(47, 0, [], [], []))
 434 | 
 435 |    put(myautomata.states, currstate := anode(48, 0, [], [], []))
 436 | 
 437 |    put(myautomata.states, currstate := anode(49, 0, [], [], []))
 438 | 
 439 |    put(myautomata.states, currstate := anode(50, 0, [], [], []))
 440 | 
 441 |    put(myautomata.states, currstate := anode(51, 0, [], [], []))
 442 | 
 443 |    put(myautomata.states, currstate := anode(52, 0, [], [], []))
 444 | 
 445 |    put(myautomata.states, currstate := anode(53, 10, [], [], []))
 446 |    put(myautomata.accepting, currstate)
 447 | 
 448 |    put(myautomata.states, currstate := anode(54, 0, [], [], []))
 449 | 
 450 |    put(myautomata.states, currstate := anode(55, 0, [], [], []))
 451 | 
 452 |    put(myautomata.states, currstate := anode(56, 0, [], [], []))
 453 | 
 454 |    put(myautomata.states, currstate := anode(57, 0, [], [], []))
 455 | 
 456 |    put(myautomata.states, currstate := anode(58, 0, [], [], []))
 457 | 
 458 |    put(myautomata.states, currstate := anode(59, 0, [], [], []))
 459 | 
 460 |    put(myautomata.states, currstate := anode(60, 37, [], [], []))
 461 |    put(myautomata.accepting, currstate)
 462 | 
 463 |    put(myautomata.states, currstate := anode(61, 39, [], [], []))
 464 |    put(myautomata.accepting, currstate)
 465 | 
 466 |    put(myautomata.states, currstate := anode(62, 41, [], [], []))
 467 |    put(myautomata.accepting, currstate)
 468 | 
 469 |    put(myautomata.states, currstate := anode(63, 42, [], [], []))
 470 |    put(myautomata.accepting, currstate)
 471 | 
 472 |    put(myautomata.states, currstate := anode(64, 43, [], [], []))
 473 |    put(myautomata.accepting, currstate)
 474 | 
 475 |    put(myautomata.states, currstate := anode(65, 45, [], [], []))
 476 |    put(myautomata.accepting, currstate)
 477 | 
 478 |    put(myautomata.states, currstate := anode(66, 46, [], [], []))
 479 |    put(myautomata.accepting, currstate)
 480 | 
 481 |    put(myautomata.states, currstate := anode(67, 40, [], [], []))
 482 |    put(myautomata.accepting, currstate)
 483 | 
 484 |    put(myautomata.states, currstate := anode(68, 49, [], [], []))
 485 |    put(myautomata.accepting, currstate)
 486 | 
 487 |    put(myautomata.states, currstate := anode(69, 0, [], [], []))
 488 | 
 489 |    put(myautomata.states, currstate := anode(70, 0, [], [], []))
 490 | 
 491 |    put(myautomata.states, currstate := anode(71, 0, [], [], []))
 492 | 
 493 |    put(myautomata.states, currstate := anode(72, 0, [], [], []))
 494 | 
 495 |    put(myautomata.states, currstate := anode(73, 0, [], [], []))
 496 | 
 497 |    put(myautomata.states, currstate := anode(74, 0, [], [], []))
 498 | 
 499 |    put(myautomata.states, currstate := anode(75, 53, [], [], []))
 500 |    put(myautomata.accepting, currstate)
 501 | 
 502 |    put(myautomata.states, currstate := anode(76, 9, [], [], []))
 503 |    put(myautomata.accepting, currstate)
 504 | 
 505 |    put(myautomata.states, currstate := anode(77, 0, [], [], []))
 506 | 
 507 |    put(myautomata.states, currstate := anode(78, 0, [], [], []))
 508 | 
 509 |    put(myautomata.states, currstate := anode(79, 0, [], [], []))
 510 | 
 511 |    put(myautomata.states, currstate := anode(80, 0, [], [], []))
 512 | 
 513 |    put(myautomata.states, currstate := anode(81, 0, [], [], []))
 514 | 
 515 |    put(myautomata.states, currstate := anode(82, 0, [], [], []))
 516 | 
 517 |    put(myautomata.states, currstate := anode(83, 0, [], [], []))
 518 | 
 519 |    put(myautomata.states, currstate := anode(84, 0, [], [], []))
 520 | 
 521 |    put(myautomata.states, currstate := anode(85, 0, [], [], []))
 522 | 
 523 |    put(myautomata.states, currstate := anode(86, 0, [], [], []))
 524 | 
 525 |    put(myautomata.states, currstate := anode(87, 11, [], [], []))
 526 |    put(myautomata.accepting, currstate)
 527 | 
 528 |    put(myautomata.states, currstate := anode(88, 0, [], [], []))
 529 | 
 530 |    put(myautomata.states, currstate := anode(89, 0, [], [], []))
 531 | 
 532 |    put(myautomata.states, currstate := anode(90, 0, [], [], []))
 533 | 
 534 |    put(myautomata.states, currstate := anode(91, 0, [], [], []))
 535 | 
 536 |    put(myautomata.states, currstate := anode(92, 0, [], [], []))
 537 | 
 538 |    put(myautomata.states, currstate := anode(93, 0, [], [], []))
 539 | 
 540 |    put(myautomata.states, currstate := anode(94, 2, [], [], []))
 541 |    put(myautomata.accepting, currstate)
 542 | 
 543 |    put(myautomata.states, currstate := anode(95, 0, [], [], []))
 544 | 
 545 |    put(myautomata.states, currstate := anode(96, 0, [], [], []))
 546 | 
 547 |    put(myautomata.states, currstate := anode(97, 0, [], [], []))
 548 | 
 549 |    put(myautomata.states, currstate := anode(98, 51, [], [], []))
 550 |    put(myautomata.accepting, currstate)
 551 | 
 552 |    put(myautomata.states, currstate := anode(99, 0, [], [], []))
 553 | 
 554 |    put(myautomata.states, currstate := anode(100, 52, [], [], []))
 555 |    put(myautomata.accepting, currstate)
 556 | 
 557 |    put(myautomata.states, currstate := anode(101, 0, [], [], []))
 558 | 
 559 |    put(myautomata.states, currstate := anode(102, 0, [], [], []))
 560 | 
 561 |    put(myautomata.states, currstate := anode(103, 0, [], [], []))
 562 | 
 563 |    put(myautomata.states, currstate := anode(104, 12, [], [], []))
 564 |    put(myautomata.accepting, currstate)
 565 | 
 566 |    put(myautomata.states, currstate := anode(105, 17, [], [], []))
 567 |    put(myautomata.accepting, currstate)
 568 | 
 569 |    put(myautomata.states, currstate := anode(106, 0, [], [], []))
 570 | 
 571 |    put(myautomata.states, currstate := anode(107, 0, [], [], []))
 572 | 
 573 |    put(myautomata.states, currstate := anode(108, 18, [], [], []))
 574 |    put(myautomata.accepting, currstate)
 575 | 
 576 |    put(myautomata.states, currstate := anode(109, 19, [], [], []))
 577 |    put(myautomata.accepting, currstate)
 578 | 
 579 |    put(myautomata.states, currstate := anode(110, 0, [], [], []))
 580 | 
 581 |    put(myautomata.states, currstate := anode(111, 0, [], [], []))
 582 | 
 583 |    put(myautomata.states, currstate := anode(112, 7, [], [], []))
 584 |    put(myautomata.accepting, currstate)
 585 | 
 586 |    put(myautomata.states, currstate := anode(113, 0, [], [], []))
 587 | 
 588 |    put(myautomata.states, currstate := anode(114, 0, [], [], []))
 589 | 
 590 |    put(myautomata.states, currstate := anode(115, 0, [], [], []))
 591 | 
 592 |    put(myautomata.states, currstate := anode(116, 0, [], [], []))
 593 | 
 594 |    put(myautomata.states, currstate := anode(117, 1, [], [], []))
 595 |    put(myautomata.accepting, currstate)
 596 | 
 597 |    put(myautomata.states, currstate := anode(118, 8, [], [], []))
 598 |    put(myautomata.accepting, currstate)
 599 | 
 600 |    put(myautomata.states, currstate := anode(119, 0, [], [], []))
 601 | 
 602 |    put(myautomata.states, currstate := anode(120, 0, [], [], []))
 603 | 
 604 |    put(myautomata.states, currstate := anode(121, 5, [], [], []))
 605 |    put(myautomata.accepting, currstate)
 606 | 
 607 |    put(myautomata.states, currstate := anode(122, 0, [], [], []))
 608 | 
 609 |    put(myautomata.states, currstate := anode(123, 20, [], [], []))
 610 |    put(myautomata.accepting, currstate)
 611 | 
 612 |    put(myautomata.states, currstate := anode(124, 21, [], [], []))
 613 |    put(myautomata.accepting, currstate)
 614 | 
 615 |    put(myautomata.states, currstate := anode(125, 0, [], [], []))
 616 | 
 617 |    put(myautomata.states, currstate := anode(126, 0, [], [], []))
 618 | 
 619 |    put(myautomata.states, currstate := anode(127, 13, [], [], []))
 620 |    put(myautomata.accepting, currstate)
 621 | 
 622 |    put(myautomata.states, currstate := anode(128, 14, [], [], []))
 623 |    put(myautomata.accepting, currstate)
 624 | 
 625 |    put(myautomata.states, currstate := anode(129, 6, [], [], []))
 626 |    put(myautomata.accepting, currstate)
 627 | 
 628 |    put(myautomata.states, currstate := anode(130, 16, [], [], []))
 629 |    put(myautomata.accepting, currstate)
 630 | 
 631 |    put(myautomata.states, currstate := anode(131, 15, [], [], []))
 632 |    put(myautomata.accepting, currstate)
 633 | 
 634 |    currstate := pop(myautomata.states)
 635 |    put(myautomata.states, currstate)
 636 | 
 637 |    while currstate.label ~= 1 do {
 638 |       currstate := pop(myautomata.states)
 639 |       put(myautomata.states, currstate)
 640 |       }
 641 |    state2 := currstate
 642 | 
 643 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
 644 |    currstate := pop(myautomata.states)
 645 |    put(myautomata.states, currstate)
 646 | 
 647 |    while currstate.label ~= 2 do {
 648 |       currstate := pop(myautomata.states)
 649 |       put(myautomata.states, currstate)
 650 |       }
 651 |    put(tempedge.destinations, currstate)
 652 | 
 653 |    put(state2.edges, tempedge)
 654 |    tempedge := edge("\n"
 655 | , [])
 656 |    currstate := pop(myautomata.states)
 657 |    put(myautomata.states, currstate)
 658 | 
 659 |    while currstate.label ~= 3 do {
 660 |       currstate := pop(myautomata.states)
 661 |       put(myautomata.states, currstate)
 662 |       }
 663 |    put(tempedge.destinations, currstate)
 664 | 
 665 |    put(state2.edges, tempedge)
 666 |    tempedge := edge("f", [])
 667 |    currstate := pop(myautomata.states)
 668 |    put(myautomata.states, currstate)
 669 | 
 670 |    while currstate.label ~= 4 do {
 671 |       currstate := pop(myautomata.states)
 672 |       put(myautomata.states, currstate)
 673 |       }
 674 |    put(tempedge.destinations, currstate)
 675 | 
 676 |    put(state2.edges, tempedge)
 677 |    tempedge := edge("p", [])
 678 |    currstate := pop(myautomata.states)
 679 |    put(myautomata.states, currstate)
 680 | 
 681 |    while currstate.label ~= 5 do {
 682 |       currstate := pop(myautomata.states)
 683 |       put(myautomata.states, currstate)
 684 |       }
 685 |    put(tempedge.destinations, currstate)
 686 | 
 687 |    put(state2.edges, tempedge)
 688 |    tempedge := edge("n", [])
 689 |    currstate := pop(myautomata.states)
 690 |    put(myautomata.states, currstate)
 691 | 
 692 |    while currstate.label ~= 6 do {
 693 |       currstate := pop(myautomata.states)
 694 |       put(myautomata.states, currstate)
 695 |       }
 696 |    put(tempedge.destinations, currstate)
 697 | 
 698 |    put(state2.edges, tempedge)
 699 |    tempedge := edge("t", [])
 700 |    currstate := pop(myautomata.states)
 701 |    put(myautomata.states, currstate)
 702 | 
 703 |    while currstate.label ~= 7 do {
 704 |       currstate := pop(myautomata.states)
 705 |       put(myautomata.states, currstate)
 706 |       }
 707 |    put(tempedge.destinations, currstate)
 708 | 
 709 |    put(state2.edges, tempedge)
 710 |    tempedge := edge("r", [])
 711 |    currstate := pop(myautomata.states)
 712 |    put(myautomata.states, currstate)
 713 | 
 714 |    while currstate.label ~= 8 do {
 715 |       currstate := pop(myautomata.states)
 716 |       put(myautomata.states, currstate)
 717 |       }
 718 |    put(tempedge.destinations, currstate)
 719 | 
 720 |    put(state2.edges, tempedge)
 721 |    tempedge := edge("b", [])
 722 |    currstate := pop(myautomata.states)
 723 |    put(myautomata.states, currstate)
 724 | 
 725 |    while currstate.label ~= 9 do {
 726 |       currstate := pop(myautomata.states)
 727 |       put(myautomata.states, currstate)
 728 |       }
 729 |    put(tempedge.destinations, currstate)
 730 | 
 731 |    put(state2.edges, tempedge)
 732 |    tempedge := edge("v", [])
 733 |    currstate := pop(myautomata.states)
 734 |    put(myautomata.states, currstate)
 735 | 
 736 |    while currstate.label ~= 10 do {
 737 |       currstate := pop(myautomata.states)
 738 |       put(myautomata.states, currstate)
 739 |       }
 740 |    put(tempedge.destinations, currstate)
 741 | 
 742 |    put(state2.edges, tempedge)
 743 |    tempedge := edge("d", [])
 744 |    currstate := pop(myautomata.states)
 745 |    put(myautomata.states, currstate)
 746 | 
 747 |    while currstate.label ~= 11 do {
 748 |       currstate := pop(myautomata.states)
 749 |       put(myautomata.states, currstate)
 750 |       }
 751 |    put(tempedge.destinations, currstate)
 752 | 
 753 |    put(state2.edges, tempedge)
 754 |    tempedge := edge("w", [])
 755 |    currstate := pop(myautomata.states)
 756 |    put(myautomata.states, currstate)
 757 | 
 758 |    while currstate.label ~= 12 do {
 759 |       currstate := pop(myautomata.states)
 760 |       put(myautomata.states, currstate)
 761 |       }
 762 |    put(tempedge.destinations, currstate)
 763 | 
 764 |    put(state2.edges, tempedge)
 765 |    tempedge := edge("i", [])
 766 |    currstate := pop(myautomata.states)
 767 |    put(myautomata.states, currstate)
 768 | 
 769 |    while currstate.label ~= 13 do {
 770 |       currstate := pop(myautomata.states)
 771 |       put(myautomata.states, currstate)
 772 |       }
 773 |    put(tempedge.destinations, currstate)
 774 | 
 775 |    put(state2.edges, tempedge)
 776 |    tempedge := edge("e", [])
 777 |    currstate := pop(myautomata.states)
 778 |    put(myautomata.states, currstate)
 779 | 
 780 |    while currstate.label ~= 14 do {
 781 |       currstate := pop(myautomata.states)
 782 |       put(myautomata.states, currstate)
 783 |       }
 784 |    put(tempedge.destinations, currstate)
 785 | 
 786 |    put(state2.edges, tempedge)
 787 |    tempedge := edge("c", [])
 788 |    currstate := pop(myautomata.states)
 789 |    put(myautomata.states, currstate)
 790 | 
 791 |    while currstate.label ~= 15 do {
 792 |       currstate := pop(myautomata.states)
 793 |       put(myautomata.states, currstate)
 794 |       }
 795 |    put(tempedge.destinations, currstate)
 796 | 
 797 |    put(state2.edges, tempedge)
 798 |    tempedge := edge("s", [])
 799 |    currstate := pop(myautomata.states)
 800 |    put(myautomata.states, currstate)
 801 | 
 802 |    while currstate.label ~= 16 do {
 803 |       currstate := pop(myautomata.states)
 804 |       put(myautomata.states, currstate)
 805 |       }
 806 |    put(tempedge.destinations, currstate)
 807 | 
 808 |    put(state2.edges, tempedge)
 809 |    tempedge := edge("(", [])
 810 |    currstate := pop(myautomata.states)
 811 |    put(myautomata.states, currstate)
 812 | 
 813 |    while currstate.label ~= 17 do {
 814 |       currstate := pop(myautomata.states)
 815 |       put(myautomata.states, currstate)
 816 |       }
 817 |    put(tempedge.destinations, currstate)
 818 | 
 819 |    put(state2.edges, tempedge)
 820 |    tempedge := edge(")", [])
 821 |    currstate := pop(myautomata.states)
 822 |    put(myautomata.states, currstate)
 823 | 
 824 |    while currstate.label ~= 18 do {
 825 |       currstate := pop(myautomata.states)
 826 |       put(myautomata.states, currstate)
 827 |       }
 828 |    put(tempedge.destinations, currstate)
 829 | 
 830 |    put(state2.edges, tempedge)
 831 |    tempedge := edge("[", [])
 832 |    currstate := pop(myautomata.states)
 833 |    put(myautomata.states, currstate)
 834 | 
 835 |    while currstate.label ~= 19 do {
 836 |       currstate := pop(myautomata.states)
 837 |       put(myautomata.states, currstate)
 838 |       }
 839 |    put(tempedge.destinations, currstate)
 840 | 
 841 |    put(state2.edges, tempedge)
 842 |    tempedge := edge("]", [])
 843 |    currstate := pop(myautomata.states)
 844 |    put(myautomata.states, currstate)
 845 | 
 846 |    while currstate.label ~= 20 do {
 847 |       currstate := pop(myautomata.states)
 848 |       put(myautomata.states, currstate)
 849 |       }
 850 |    put(tempedge.destinations, currstate)
 851 | 
 852 |    put(state2.edges, tempedge)
 853 |    tempedge := edge("{", [])
 854 |    currstate := pop(myautomata.states)
 855 |    put(myautomata.states, currstate)
 856 | 
 857 |    while currstate.label ~= 21 do {
 858 |       currstate := pop(myautomata.states)
 859 |       put(myautomata.states, currstate)
 860 |       }
 861 |    put(tempedge.destinations, currstate)
 862 | 
 863 |    put(state2.edges, tempedge)
 864 |    tempedge := edge("}", [])
 865 |    currstate := pop(myautomata.states)
 866 |    put(myautomata.states, currstate)
 867 | 
 868 |    while currstate.label ~= 22 do {
 869 |       currstate := pop(myautomata.states)
 870 |       put(myautomata.states, currstate)
 871 |       }
 872 |    put(tempedge.destinations, currstate)
 873 | 
 874 |    put(state2.edges, tempedge)
 875 |    tempedge := edge(";", [])
 876 |    currstate := pop(myautomata.states)
 877 |    put(myautomata.states, currstate)
 878 | 
 879 |    while currstate.label ~= 23 do {
 880 |       currstate := pop(myautomata.states)
 881 |       put(myautomata.states, currstate)
 882 |       }
 883 |    put(tempedge.destinations, currstate)
 884 | 
 885 |    put(state2.edges, tempedge)
 886 |    tempedge := edge(":", [])
 887 |    currstate := pop(myautomata.states)
 888 |    put(myautomata.states, currstate)
 889 | 
 890 |    while currstate.label ~= 24 do {
 891 |       currstate := pop(myautomata.states)
 892 |       put(myautomata.states, currstate)
 893 |       }
 894 |    put(tempedge.destinations, currstate)
 895 | 
 896 |    put(state2.edges, tempedge)
 897 |    tempedge := edge("*", [])
 898 |    currstate := pop(myautomata.states)
 899 |    put(myautomata.states, currstate)
 900 | 
 901 |    while currstate.label ~= 25 do {
 902 |       currstate := pop(myautomata.states)
 903 |       put(myautomata.states, currstate)
 904 |       }
 905 |    put(tempedge.destinations, currstate)
 906 | 
 907 |    put(state2.edges, tempedge)
 908 |    tempedge := edge("/", [])
 909 |    currstate := pop(myautomata.states)
 910 |    put(myautomata.states, currstate)
 911 | 
 912 |    while currstate.label ~= 26 do {
 913 |       currstate := pop(myautomata.states)
 914 |       put(myautomata.states, currstate)
 915 |       }
 916 |    put(tempedge.destinations, currstate)
 917 | 
 918 |    put(state2.edges, tempedge)
 919 |    tempedge := edge("%", [])
 920 |    currstate := pop(myautomata.states)
 921 |    put(myautomata.states, currstate)
 922 | 
 923 |    while currstate.label ~= 27 do {
 924 |       currstate := pop(myautomata.states)
 925 |       put(myautomata.states, currstate)
 926 |       }
 927 |    put(tempedge.destinations, currstate)
 928 | 
 929 |    put(state2.edges, tempedge)
 930 |    tempedge := edge("<", [])
 931 |    currstate := pop(myautomata.states)
 932 |    put(myautomata.states, currstate)
 933 | 
 934 |    while currstate.label ~= 28 do {
 935 |       currstate := pop(myautomata.states)
 936 |       put(myautomata.states, currstate)
 937 |       }
 938 |    put(tempedge.destinations, currstate)
 939 | 
 940 |    put(state2.edges, tempedge)
 941 |    tempedge := edge(">", [])
 942 |    currstate := pop(myautomata.states)
 943 |    put(myautomata.states, currstate)
 944 | 
 945 |    while currstate.label ~= 29 do {
 946 |       currstate := pop(myautomata.states)
 947 |       put(myautomata.states, currstate)
 948 |       }
 949 |    put(tempedge.destinations, currstate)
 950 | 
 951 |    put(state2.edges, tempedge)
 952 |    tempedge := edge("!", [])
 953 |    currstate := pop(myautomata.states)
 954 |    put(myautomata.states, currstate)
 955 | 
 956 |    while currstate.label ~= 30 do {
 957 |       currstate := pop(myautomata.states)
 958 |       put(myautomata.states, currstate)
 959 |       }
 960 |    put(tempedge.destinations, currstate)
 961 | 
 962 |    put(state2.edges, tempedge)
 963 |    tempedge := edge("&", [])
 964 |    currstate := pop(myautomata.states)
 965 |    put(myautomata.states, currstate)
 966 | 
 967 |    while currstate.label ~= 31 do {
 968 |       currstate := pop(myautomata.states)
 969 |       put(myautomata.states, currstate)
 970 |       }
 971 |    put(tempedge.destinations, currstate)
 972 | 
 973 |    put(state2.edges, tempedge)
 974 |    tempedge := edge("|", [])
 975 |    currstate := pop(myautomata.states)
 976 |    put(myautomata.states, currstate)
 977 | 
 978 |    while currstate.label ~= 32 do {
 979 |       currstate := pop(myautomata.states)
 980 |       put(myautomata.states, currstate)
 981 |       }
 982 |    put(tempedge.destinations, currstate)
 983 | 
 984 |    put(state2.edges, tempedge)
 985 |    tempedge := edge("+", [])
 986 |    currstate := pop(myautomata.states)
 987 |    put(myautomata.states, currstate)
 988 | 
 989 |    while currstate.label ~= 33 do {
 990 |       currstate := pop(myautomata.states)
 991 |       put(myautomata.states, currstate)
 992 |       }
 993 |    put(tempedge.destinations, currstate)
 994 | 
 995 |    put(state2.edges, tempedge)
 996 |    tempedge := edge("-", [])
 997 |    currstate := pop(myautomata.states)
 998 |    put(myautomata.states, currstate)
 999 | 
1000 |    while currstate.label ~= 34 do {
1001 |       currstate := pop(myautomata.states)
1002 |       put(myautomata.states, currstate)
1003 |       }
1004 |    put(tempedge.destinations, currstate)
1005 | 
1006 |    put(state2.edges, tempedge)
1007 |    tempedge := edge("=", [])
1008 |    currstate := pop(myautomata.states)
1009 |    put(myautomata.states, currstate)
1010 | 
1011 |    while currstate.label ~= 35 do {
1012 |       currstate := pop(myautomata.states)
1013 |       put(myautomata.states, currstate)
1014 |       }
1015 |    put(tempedge.destinations, currstate)
1016 | 
1017 |    put(state2.edges, tempedge)
1018 |    tempedge := edge(",", [])
1019 |    currstate := pop(myautomata.states)
1020 |    put(myautomata.states, currstate)
1021 | 
1022 |    while currstate.label ~= 36 do {
1023 |       currstate := pop(myautomata.states)
1024 |       put(myautomata.states, currstate)
1025 |       }
1026 |    put(tempedge.destinations, currstate)
1027 | 
1028 |    put(state2.edges, tempedge)
1029 |    tempedge := edge(csetfromrecset("[\a-zA-Z_]"), [])
1030 |    currstate := pop(myautomata.states)
1031 |    put(myautomata.states, currstate)
1032 | 
1033 |    while currstate.label ~= 37 do {
1034 |       currstate := pop(myautomata.states)
1035 |       put(myautomata.states, currstate)
1036 |       }
1037 |    put(tempedge.destinations, currstate)
1038 | 
1039 |    put(state2.edges, tempedge)
1040 |    tempedge := edge(".", [])
1041 |    currstate := pop(myautomata.states)
1042 |    put(myautomata.states, currstate)
1043 | 
1044 |    while currstate.label ~= 38 do {
1045 |       currstate := pop(myautomata.states)
1046 |       put(myautomata.states, currstate)
1047 |       }
1048 |    put(tempedge.destinations, currstate)
1049 | 
1050 |    put(state2.edges, tempedge)
1051 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1052 |    currstate := pop(myautomata.states)
1053 |    put(myautomata.states, currstate)
1054 | 
1055 |    while currstate.label ~= 39 do {
1056 |       currstate := pop(myautomata.states)
1057 |       put(myautomata.states, currstate)
1058 |       }
1059 |    put(tempedge.destinations, currstate)
1060 | 
1061 |    put(state2.edges, tempedge)
1062 |    tempedge := edge("\"", [])
1063 |    currstate := pop(myautomata.states)
1064 |    put(myautomata.states, currstate)
1065 | 
1066 |    while currstate.label ~= 40 do {
1067 |       currstate := pop(myautomata.states)
1068 |       put(myautomata.states, currstate)
1069 |       }
1070 |    put(tempedge.destinations, currstate)
1071 | 
1072 |    put(state2.edges, tempedge)
1073 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
1074 |    currstate := pop(myautomata.states)
1075 |    put(myautomata.states, currstate)
1076 | 
1077 |    while currstate.label ~= 41 do {
1078 |       currstate := pop(myautomata.states)
1079 |       put(myautomata.states, currstate)
1080 |       }
1081 |    put(tempedge.destinations, currstate)
1082 | 
1083 |    put(state2.edges, tempedge)
1084 |    currstate := pop(myautomata.states)
1085 |    put(myautomata.states, currstate)
1086 | 
1087 |    while currstate.label ~= 2 do {
1088 |       currstate := pop(myautomata.states)
1089 |       put(myautomata.states, currstate)
1090 |       }
1091 |    state2 := currstate
1092 | 
1093 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
1094 |    currstate := pop(myautomata.states)
1095 |    put(myautomata.states, currstate)
1096 | 
1097 |    while currstate.label ~= 2 do {
1098 |       currstate := pop(myautomata.states)
1099 |       put(myautomata.states, currstate)
1100 |       }
1101 |    put(tempedge.destinations, currstate)
1102 | 
1103 |    put(state2.edges, tempedge)
1104 |    currstate := pop(myautomata.states)
1105 |    put(myautomata.states, currstate)
1106 | 
1107 |    while currstate.label ~= 3 do {
1108 |       currstate := pop(myautomata.states)
1109 |       put(myautomata.states, currstate)
1110 |       }
1111 |    state2 := currstate
1112 | 
1113 |    currstate := pop(myautomata.states)
1114 |    put(myautomata.states, currstate)
1115 | 
1116 |    while currstate.label ~= 4 do {
1117 |       currstate := pop(myautomata.states)
1118 |       put(myautomata.states, currstate)
1119 |       }
1120 |    state2 := currstate
1121 | 
1122 |    tempedge := edge("o", [])
1123 |    currstate := pop(myautomata.states)
1124 |    put(myautomata.states, currstate)
1125 | 
1126 |    while currstate.label ~= 42 do {
1127 |       currstate := pop(myautomata.states)
1128 |       put(myautomata.states, currstate)
1129 |       }
1130 |    put(tempedge.destinations, currstate)
1131 | 
1132 |    put(state2.edges, tempedge)
1133 |    tempedge := edge("\a", [])
1134 |    currstate := pop(myautomata.states)
1135 |    put(myautomata.states, currstate)
1136 | 
1137 |    while currstate.label ~= 43 do {
1138 |       currstate := pop(myautomata.states)
1139 |       put(myautomata.states, currstate)
1140 |       }
1141 |    put(tempedge.destinations, currstate)
1142 | 
1143 |    put(state2.edges, tempedge)
1144 |    currstate := pop(myautomata.states)
1145 |    put(myautomata.states, currstate)
1146 | 
1147 |    while currstate.label ~= 5 do {
1148 |       currstate := pop(myautomata.states)
1149 |       put(myautomata.states, currstate)
1150 |       }
1151 |    state2 := currstate
1152 | 
1153 |    tempedge := edge("u", [])
1154 |    currstate := pop(myautomata.states)
1155 |    put(myautomata.states, currstate)
1156 | 
1157 |    while currstate.label ~= 44 do {
1158 |       currstate := pop(myautomata.states)
1159 |       put(myautomata.states, currstate)
1160 |       }
1161 |    put(tempedge.destinations, currstate)
1162 | 
1163 |    put(state2.edges, tempedge)
1164 |    currstate := pop(myautomata.states)
1165 |    put(myautomata.states, currstate)
1166 | 
1167 |    while currstate.label ~= 6 do {
1168 |       currstate := pop(myautomata.states)
1169 |       put(myautomata.states, currstate)
1170 |       }
1171 |    state2 := currstate
1172 | 
1173 |    tempedge := edge("u", [])
1174 |    currstate := pop(myautomata.states)
1175 |    put(myautomata.states, currstate)
1176 | 
1177 |    while currstate.label ~= 45 do {
1178 |       currstate := pop(myautomata.states)
1179 |       put(myautomata.states, currstate)
1180 |       }
1181 |    put(tempedge.destinations, currstate)
1182 | 
1183 |    put(state2.edges, tempedge)
1184 |    currstate := pop(myautomata.states)
1185 |    put(myautomata.states, currstate)
1186 | 
1187 |    while currstate.label ~= 7 do {
1188 |       currstate := pop(myautomata.states)
1189 |       put(myautomata.states, currstate)
1190 |       }
1191 |    state2 := currstate
1192 | 
1193 |    tempedge := edge("r", [])
1194 |    currstate := pop(myautomata.states)
1195 |    put(myautomata.states, currstate)
1196 | 
1197 |    while currstate.label ~= 46 do {
1198 |       currstate := pop(myautomata.states)
1199 |       put(myautomata.states, currstate)
1200 |       }
1201 |    put(tempedge.destinations, currstate)
1202 | 
1203 |    put(state2.edges, tempedge)
1204 |    currstate := pop(myautomata.states)
1205 |    put(myautomata.states, currstate)
1206 | 
1207 |    while currstate.label ~= 8 do {
1208 |       currstate := pop(myautomata.states)
1209 |       put(myautomata.states, currstate)
1210 |       }
1211 |    state2 := currstate
1212 | 
1213 |    tempedge := edge("e", [])
1214 |    currstate := pop(myautomata.states)
1215 |    put(myautomata.states, currstate)
1216 | 
1217 |    while currstate.label ~= 47 do {
1218 |       currstate := pop(myautomata.states)
1219 |       put(myautomata.states, currstate)
1220 |       }
1221 |    put(tempedge.destinations, currstate)
1222 | 
1223 |    put(state2.edges, tempedge)
1224 |    currstate := pop(myautomata.states)
1225 |    put(myautomata.states, currstate)
1226 | 
1227 |    while currstate.label ~= 9 do {
1228 |       currstate := pop(myautomata.states)
1229 |       put(myautomata.states, currstate)
1230 |       }
1231 |    state2 := currstate
1232 | 
1233 |    tempedge := edge("r", [])
1234 |    currstate := pop(myautomata.states)
1235 |    put(myautomata.states, currstate)
1236 | 
1237 |    while currstate.label ~= 48 do {
1238 |       currstate := pop(myautomata.states)
1239 |       put(myautomata.states, currstate)
1240 |       }
1241 |    put(tempedge.destinations, currstate)
1242 | 
1243 |    put(state2.edges, tempedge)
1244 |    tempedge := edge("o", [])
1245 |    currstate := pop(myautomata.states)
1246 |    put(myautomata.states, currstate)
1247 | 
1248 |    while currstate.label ~= 49 do {
1249 |       currstate := pop(myautomata.states)
1250 |       put(myautomata.states, currstate)
1251 |       }
1252 |    put(tempedge.destinations, currstate)
1253 | 
1254 |    put(state2.edges, tempedge)
1255 |    currstate := pop(myautomata.states)
1256 |    put(myautomata.states, currstate)
1257 | 
1258 |    while currstate.label ~= 10 do {
1259 |       currstate := pop(myautomata.states)
1260 |       put(myautomata.states, currstate)
1261 |       }
1262 |    state2 := currstate
1263 | 
1264 |    tempedge := edge("o", [])
1265 |    currstate := pop(myautomata.states)
1266 |    put(myautomata.states, currstate)
1267 | 
1268 |    while currstate.label ~= 50 do {
1269 |       currstate := pop(myautomata.states)
1270 |       put(myautomata.states, currstate)
1271 |       }
1272 |    put(tempedge.destinations, currstate)
1273 | 
1274 |    put(state2.edges, tempedge)
1275 |    currstate := pop(myautomata.states)
1276 |    put(myautomata.states, currstate)
1277 | 
1278 |    while currstate.label ~= 11 do {
1279 |       currstate := pop(myautomata.states)
1280 |       put(myautomata.states, currstate)
1281 |       }
1282 |    state2 := currstate
1283 | 
1284 |    tempedge := edge("o", [])
1285 |    currstate := pop(myautomata.states)
1286 |    put(myautomata.states, currstate)
1287 | 
1288 |    while currstate.label ~= 51 do {
1289 |       currstate := pop(myautomata.states)
1290 |       put(myautomata.states, currstate)
1291 |       }
1292 |    put(tempedge.destinations, currstate)
1293 | 
1294 |    put(state2.edges, tempedge)
1295 |    currstate := pop(myautomata.states)
1296 |    put(myautomata.states, currstate)
1297 | 
1298 |    while currstate.label ~= 12 do {
1299 |       currstate := pop(myautomata.states)
1300 |       put(myautomata.states, currstate)
1301 |       }
1302 |    state2 := currstate
1303 | 
1304 |    tempedge := edge("h", [])
1305 |    currstate := pop(myautomata.states)
1306 |    put(myautomata.states, currstate)
1307 | 
1308 |    while currstate.label ~= 52 do {
1309 |       currstate := pop(myautomata.states)
1310 |       put(myautomata.states, currstate)
1311 |       }
1312 |    put(tempedge.destinations, currstate)
1313 | 
1314 |    put(state2.edges, tempedge)
1315 |    currstate := pop(myautomata.states)
1316 |    put(myautomata.states, currstate)
1317 | 
1318 |    while currstate.label ~= 13 do {
1319 |       currstate := pop(myautomata.states)
1320 |       put(myautomata.states, currstate)
1321 |       }
1322 |    state2 := currstate
1323 | 
1324 |    tempedge := edge("f", [])
1325 |    currstate := pop(myautomata.states)
1326 |    put(myautomata.states, currstate)
1327 | 
1328 |    while currstate.label ~= 53 do {
1329 |       currstate := pop(myautomata.states)
1330 |       put(myautomata.states, currstate)
1331 |       }
1332 |    put(tempedge.destinations, currstate)
1333 | 
1334 |    put(state2.edges, tempedge)
1335 |    tempedge := edge("n", [])
1336 |    currstate := pop(myautomata.states)
1337 |    put(myautomata.states, currstate)
1338 | 
1339 |    while currstate.label ~= 54 do {
1340 |       currstate := pop(myautomata.states)
1341 |       put(myautomata.states, currstate)
1342 |       }
1343 |    put(tempedge.destinations, currstate)
1344 | 
1345 |    put(state2.edges, tempedge)
1346 |    currstate := pop(myautomata.states)
1347 |    put(myautomata.states, currstate)
1348 | 
1349 |    while currstate.label ~= 14 do {
1350 |       currstate := pop(myautomata.states)
1351 |       put(myautomata.states, currstate)
1352 |       }
1353 |    state2 := currstate
1354 | 
1355 |    tempedge := edge("l", [])
1356 |    currstate := pop(myautomata.states)
1357 |    put(myautomata.states, currstate)
1358 | 
1359 |    while currstate.label ~= 55 do {
1360 |       currstate := pop(myautomata.states)
1361 |       put(myautomata.states, currstate)
1362 |       }
1363 |    put(tempedge.destinations, currstate)
1364 | 
1365 |    put(state2.edges, tempedge)
1366 |    currstate := pop(myautomata.states)
1367 |    put(myautomata.states, currstate)
1368 | 
1369 |    while currstate.label ~= 15 do {
1370 |       currstate := pop(myautomata.states)
1371 |       put(myautomata.states, currstate)
1372 |       }
1373 |    state2 := currstate
1374 | 
1375 |    tempedge := edge("l", [])
1376 |    currstate := pop(myautomata.states)
1377 |    put(myautomata.states, currstate)
1378 | 
1379 |    while currstate.label ~= 56 do {
1380 |       currstate := pop(myautomata.states)
1381 |       put(myautomata.states, currstate)
1382 |       }
1383 |    put(tempedge.destinations, currstate)
1384 | 
1385 |    put(state2.edges, tempedge)
1386 |    currstate := pop(myautomata.states)
1387 |    put(myautomata.states, currstate)
1388 | 
1389 |    while currstate.label ~= 16 do {
1390 |       currstate := pop(myautomata.states)
1391 |       put(myautomata.states, currstate)
1392 |       }
1393 |    state2 := currstate
1394 | 
1395 |    tempedge := edge("t", [])
1396 |    currstate := pop(myautomata.states)
1397 |    put(myautomata.states, currstate)
1398 | 
1399 |    while currstate.label ~= 57 do {
1400 |       currstate := pop(myautomata.states)
1401 |       put(myautomata.states, currstate)
1402 |       }
1403 |    put(tempedge.destinations, currstate)
1404 | 
1405 |    put(state2.edges, tempedge)
1406 |    currstate := pop(myautomata.states)
1407 |    put(myautomata.states, currstate)
1408 | 
1409 |    while currstate.label ~= 17 do {
1410 |       currstate := pop(myautomata.states)
1411 |       put(myautomata.states, currstate)
1412 |       }
1413 |    state2 := currstate
1414 | 
1415 |    currstate := pop(myautomata.states)
1416 |    put(myautomata.states, currstate)
1417 | 
1418 |    while currstate.label ~= 18 do {
1419 |       currstate := pop(myautomata.states)
1420 |       put(myautomata.states, currstate)
1421 |       }
1422 |    state2 := currstate
1423 | 
1424 |    currstate := pop(myautomata.states)
1425 |    put(myautomata.states, currstate)
1426 | 
1427 |    while currstate.label ~= 19 do {
1428 |       currstate := pop(myautomata.states)
1429 |       put(myautomata.states, currstate)
1430 |       }
1431 |    state2 := currstate
1432 | 
1433 |    currstate := pop(myautomata.states)
1434 |    put(myautomata.states, currstate)
1435 | 
1436 |    while currstate.label ~= 20 do {
1437 |       currstate := pop(myautomata.states)
1438 |       put(myautomata.states, currstate)
1439 |       }
1440 |    state2 := currstate
1441 | 
1442 |    currstate := pop(myautomata.states)
1443 |    put(myautomata.states, currstate)
1444 | 
1445 |    while currstate.label ~= 21 do {
1446 |       currstate := pop(myautomata.states)
1447 |       put(myautomata.states, currstate)
1448 |       }
1449 |    state2 := currstate
1450 | 
1451 |    currstate := pop(myautomata.states)
1452 |    put(myautomata.states, currstate)
1453 | 
1454 |    while currstate.label ~= 22 do {
1455 |       currstate := pop(myautomata.states)
1456 |       put(myautomata.states, currstate)
1457 |       }
1458 |    state2 := currstate
1459 | 
1460 |    currstate := pop(myautomata.states)
1461 |    put(myautomata.states, currstate)
1462 | 
1463 |    while currstate.label ~= 23 do {
1464 |       currstate := pop(myautomata.states)
1465 |       put(myautomata.states, currstate)
1466 |       }
1467 |    state2 := currstate
1468 | 
1469 |    currstate := pop(myautomata.states)
1470 |    put(myautomata.states, currstate)
1471 | 
1472 |    while currstate.label ~= 24 do {
1473 |       currstate := pop(myautomata.states)
1474 |       put(myautomata.states, currstate)
1475 |       }
1476 |    state2 := currstate
1477 | 
1478 |    currstate := pop(myautomata.states)
1479 |    put(myautomata.states, currstate)
1480 | 
1481 |    while currstate.label ~= 25 do {
1482 |       currstate := pop(myautomata.states)
1483 |       put(myautomata.states, currstate)
1484 |       }
1485 |    state2 := currstate
1486 | 
1487 |    currstate := pop(myautomata.states)
1488 |    put(myautomata.states, currstate)
1489 | 
1490 |    while currstate.label ~= 26 do {
1491 |       currstate := pop(myautomata.states)
1492 |       put(myautomata.states, currstate)
1493 |       }
1494 |    state2 := currstate
1495 | 
1496 |    tempedge := edge("*", [])
1497 |    currstate := pop(myautomata.states)
1498 |    put(myautomata.states, currstate)
1499 | 
1500 |    while currstate.label ~= 58 do {
1501 |       currstate := pop(myautomata.states)
1502 |       put(myautomata.states, currstate)
1503 |       }
1504 |    put(tempedge.destinations, currstate)
1505 | 
1506 |    put(state2.edges, tempedge)
1507 |    tempedge := edge("/", [])
1508 |    currstate := pop(myautomata.states)
1509 |    put(myautomata.states, currstate)
1510 | 
1511 |    while currstate.label ~= 59 do {
1512 |       currstate := pop(myautomata.states)
1513 |       put(myautomata.states, currstate)
1514 |       }
1515 |    put(tempedge.destinations, currstate)
1516 | 
1517 |    put(state2.edges, tempedge)
1518 |    currstate := pop(myautomata.states)
1519 |    put(myautomata.states, currstate)
1520 | 
1521 |    while currstate.label ~= 27 do {
1522 |       currstate := pop(myautomata.states)
1523 |       put(myautomata.states, currstate)
1524 |       }
1525 |    state2 := currstate
1526 | 
1527 |    currstate := pop(myautomata.states)
1528 |    put(myautomata.states, currstate)
1529 | 
1530 |    while currstate.label ~= 28 do {
1531 |       currstate := pop(myautomata.states)
1532 |       put(myautomata.states, currstate)
1533 |       }
1534 |    state2 := currstate
1535 | 
1536 |    tempedge := edge("=", [])
1537 |    currstate := pop(myautomata.states)
1538 |    put(myautomata.states, currstate)
1539 | 
1540 |    while currstate.label ~= 60 do {
1541 |       currstate := pop(myautomata.states)
1542 |       put(myautomata.states, currstate)
1543 |       }
1544 |    put(tempedge.destinations, currstate)
1545 | 
1546 |    put(state2.edges, tempedge)
1547 |    currstate := pop(myautomata.states)
1548 |    put(myautomata.states, currstate)
1549 | 
1550 |    while currstate.label ~= 29 do {
1551 |       currstate := pop(myautomata.states)
1552 |       put(myautomata.states, currstate)
1553 |       }
1554 |    state2 := currstate
1555 | 
1556 |    tempedge := edge("=", [])
1557 |    currstate := pop(myautomata.states)
1558 |    put(myautomata.states, currstate)
1559 | 
1560 |    while currstate.label ~= 61 do {
1561 |       currstate := pop(myautomata.states)
1562 |       put(myautomata.states, currstate)
1563 |       }
1564 |    put(tempedge.destinations, currstate)
1565 | 
1566 |    put(state2.edges, tempedge)
1567 |    currstate := pop(myautomata.states)
1568 |    put(myautomata.states, currstate)
1569 | 
1570 |    while currstate.label ~= 30 do {
1571 |       currstate := pop(myautomata.states)
1572 |       put(myautomata.states, currstate)
1573 |       }
1574 |    state2 := currstate
1575 | 
1576 |    tempedge := edge("=", [])
1577 |    currstate := pop(myautomata.states)
1578 |    put(myautomata.states, currstate)
1579 | 
1580 |    while currstate.label ~= 62 do {
1581 |       currstate := pop(myautomata.states)
1582 |       put(myautomata.states, currstate)
1583 |       }
1584 |    put(tempedge.destinations, currstate)
1585 | 
1586 |    put(state2.edges, tempedge)
1587 |    currstate := pop(myautomata.states)
1588 |    put(myautomata.states, currstate)
1589 | 
1590 |    while currstate.label ~= 31 do {
1591 |       currstate := pop(myautomata.states)
1592 |       put(myautomata.states, currstate)
1593 |       }
1594 |    state2 := currstate
1595 | 
1596 |    tempedge := edge("&", [])
1597 |    currstate := pop(myautomata.states)
1598 |    put(myautomata.states, currstate)
1599 | 
1600 |    while currstate.label ~= 63 do {
1601 |       currstate := pop(myautomata.states)
1602 |       put(myautomata.states, currstate)
1603 |       }
1604 |    put(tempedge.destinations, currstate)
1605 | 
1606 |    put(state2.edges, tempedge)
1607 |    currstate := pop(myautomata.states)
1608 |    put(myautomata.states, currstate)
1609 | 
1610 |    while currstate.label ~= 32 do {
1611 |       currstate := pop(myautomata.states)
1612 |       put(myautomata.states, currstate)
1613 |       }
1614 |    state2 := currstate
1615 | 
1616 |    tempedge := edge("|", [])
1617 |    currstate := pop(myautomata.states)
1618 |    put(myautomata.states, currstate)
1619 | 
1620 |    while currstate.label ~= 64 do {
1621 |       currstate := pop(myautomata.states)
1622 |       put(myautomata.states, currstate)
1623 |       }
1624 |    put(tempedge.destinations, currstate)
1625 | 
1626 |    put(state2.edges, tempedge)
1627 |    currstate := pop(myautomata.states)
1628 |    put(myautomata.states, currstate)
1629 | 
1630 |    while currstate.label ~= 33 do {
1631 |       currstate := pop(myautomata.states)
1632 |       put(myautomata.states, currstate)
1633 |       }
1634 |    state2 := currstate
1635 | 
1636 |    tempedge := edge("=", [])
1637 |    currstate := pop(myautomata.states)
1638 |    put(myautomata.states, currstate)
1639 | 
1640 |    while currstate.label ~= 65 do {
1641 |       currstate := pop(myautomata.states)
1642 |       put(myautomata.states, currstate)
1643 |       }
1644 |    put(tempedge.destinations, currstate)
1645 | 
1646 |    put(state2.edges, tempedge)
1647 |    currstate := pop(myautomata.states)
1648 |    put(myautomata.states, currstate)
1649 | 
1650 |    while currstate.label ~= 34 do {
1651 |       currstate := pop(myautomata.states)
1652 |       put(myautomata.states, currstate)
1653 |       }
1654 |    state2 := currstate
1655 | 
1656 |    tempedge := edge("=", [])
1657 |    currstate := pop(myautomata.states)
1658 |    put(myautomata.states, currstate)
1659 | 
1660 |    while currstate.label ~= 66 do {
1661 |       currstate := pop(myautomata.states)
1662 |       put(myautomata.states, currstate)
1663 |       }
1664 |    put(tempedge.destinations, currstate)
1665 | 
1666 |    put(state2.edges, tempedge)
1667 |    currstate := pop(myautomata.states)
1668 |    put(myautomata.states, currstate)
1669 | 
1670 |    while currstate.label ~= 35 do {
1671 |       currstate := pop(myautomata.states)
1672 |       put(myautomata.states, currstate)
1673 |       }
1674 |    state2 := currstate
1675 | 
1676 |    tempedge := edge("=", [])
1677 |    currstate := pop(myautomata.states)
1678 |    put(myautomata.states, currstate)
1679 | 
1680 |    while currstate.label ~= 67 do {
1681 |       currstate := pop(myautomata.states)
1682 |       put(myautomata.states, currstate)
1683 |       }
1684 |    put(tempedge.destinations, currstate)
1685 | 
1686 |    put(state2.edges, tempedge)
1687 |    currstate := pop(myautomata.states)
1688 |    put(myautomata.states, currstate)
1689 | 
1690 |    while currstate.label ~= 36 do {
1691 |       currstate := pop(myautomata.states)
1692 |       put(myautomata.states, currstate)
1693 |       }
1694 |    state2 := currstate
1695 | 
1696 |    currstate := pop(myautomata.states)
1697 |    put(myautomata.states, currstate)
1698 | 
1699 |    while currstate.label ~= 37 do {
1700 |       currstate := pop(myautomata.states)
1701 |       put(myautomata.states, currstate)
1702 |       }
1703 |    state2 := currstate
1704 | 
1705 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
1706 |    currstate := pop(myautomata.states)
1707 |    put(myautomata.states, currstate)
1708 | 
1709 |    while currstate.label ~= 68 do {
1710 |       currstate := pop(myautomata.states)
1711 |       put(myautomata.states, currstate)
1712 |       }
1713 |    put(tempedge.destinations, currstate)
1714 | 
1715 |    put(state2.edges, tempedge)
1716 |    currstate := pop(myautomata.states)
1717 |    put(myautomata.states, currstate)
1718 | 
1719 |    while currstate.label ~= 38 do {
1720 |       currstate := pop(myautomata.states)
1721 |       put(myautomata.states, currstate)
1722 |       }
1723 |    state2 := currstate
1724 | 
1725 |    tempedge := edge(csetfromrecset("[eE]"), [])
1726 |    currstate := pop(myautomata.states)
1727 |    put(myautomata.states, currstate)
1728 | 
1729 |    while currstate.label ~= 69 do {
1730 |       currstate := pop(myautomata.states)
1731 |       put(myautomata.states, currstate)
1732 |       }
1733 |    put(tempedge.destinations, currstate)
1734 | 
1735 |    put(state2.edges, tempedge)
1736 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1737 |    currstate := pop(myautomata.states)
1738 |    put(myautomata.states, currstate)
1739 | 
1740 |    while currstate.label ~= 70 do {
1741 |       currstate := pop(myautomata.states)
1742 |       put(myautomata.states, currstate)
1743 |       }
1744 |    put(tempedge.destinations, currstate)
1745 | 
1746 |    put(state2.edges, tempedge)
1747 |    currstate := pop(myautomata.states)
1748 |    put(myautomata.states, currstate)
1749 | 
1750 |    while currstate.label ~= 39 do {
1751 |       currstate := pop(myautomata.states)
1752 |       put(myautomata.states, currstate)
1753 |       }
1754 |    state2 := currstate
1755 | 
1756 |    tempedge := edge(".", [])
1757 |    currstate := pop(myautomata.states)
1758 |    put(myautomata.states, currstate)
1759 | 
1760 |    while currstate.label ~= 71 do {
1761 |       currstate := pop(myautomata.states)
1762 |       put(myautomata.states, currstate)
1763 |       }
1764 |    put(tempedge.destinations, currstate)
1765 | 
1766 |    put(state2.edges, tempedge)
1767 |    tempedge := edge(csetfromrecset("[eE]"), [])
1768 |    currstate := pop(myautomata.states)
1769 |    put(myautomata.states, currstate)
1770 | 
1771 |    while currstate.label ~= 72 do {
1772 |       currstate := pop(myautomata.states)
1773 |       put(myautomata.states, currstate)
1774 |       }
1775 |    put(tempedge.destinations, currstate)
1776 | 
1777 |    put(state2.edges, tempedge)
1778 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1779 |    currstate := pop(myautomata.states)
1780 |    put(myautomata.states, currstate)
1781 | 
1782 |    while currstate.label ~= 39 do {
1783 |       currstate := pop(myautomata.states)
1784 |       put(myautomata.states, currstate)
1785 |       }
1786 |    put(tempedge.destinations, currstate)
1787 | 
1788 |    put(state2.edges, tempedge)
1789 |    currstate := pop(myautomata.states)
1790 |    put(myautomata.states, currstate)
1791 | 
1792 |    while currstate.label ~= 40 do {
1793 |       currstate := pop(myautomata.states)
1794 |       put(myautomata.states, currstate)
1795 |       }
1796 |    state2 := currstate
1797 | 
1798 |    tempedge := edge(csetfromrecset("[^\"]"), [])
1799 |    currstate := pop(myautomata.states)
1800 |    put(myautomata.states, currstate)
1801 | 
1802 |    while currstate.label ~= 73 do {
1803 |       currstate := pop(myautomata.states)
1804 |       put(myautomata.states, currstate)
1805 |       }
1806 |    put(tempedge.destinations, currstate)
1807 | 
1808 |    put(state2.edges, tempedge)
1809 |    tempedge := edge("\\", [])
1810 |    currstate := pop(myautomata.states)
1811 |    put(myautomata.states, currstate)
1812 | 
1813 |    while currstate.label ~= 74 do {
1814 |       currstate := pop(myautomata.states)
1815 |       put(myautomata.states, currstate)
1816 |       }
1817 |    put(tempedge.destinations, currstate)
1818 | 
1819 |    put(state2.edges, tempedge)
1820 |    tempedge := edge("\"", [])
1821 |    currstate := pop(myautomata.states)
1822 |    put(myautomata.states, currstate)
1823 | 
1824 |    while currstate.label ~= 75 do {
1825 |       currstate := pop(myautomata.states)
1826 |       put(myautomata.states, currstate)
1827 |       }
1828 |    put(tempedge.destinations, currstate)
1829 | 
1830 |    put(state2.edges, tempedge)
1831 |    currstate := pop(myautomata.states)
1832 |    put(myautomata.states, currstate)
1833 | 
1834 |    while currstate.label ~= 41 do {
1835 |       currstate := pop(myautomata.states)
1836 |       put(myautomata.states, currstate)
1837 |       }
1838 |    state2 := currstate
1839 | 
1840 |    currstate := pop(myautomata.states)
1841 |    put(myautomata.states, currstate)
1842 | 
1843 |    while currstate.label ~= 42 do {
1844 |       currstate := pop(myautomata.states)
1845 |       put(myautomata.states, currstate)
1846 |       }
1847 |    state2 := currstate
1848 | 
1849 |    tempedge := edge("r", [])
1850 |    currstate := pop(myautomata.states)
1851 |    put(myautomata.states, currstate)
1852 | 
1853 |    while currstate.label ~= 76 do {
1854 |       currstate := pop(myautomata.states)
1855 |       put(myautomata.states, currstate)
1856 |       }
1857 |    put(tempedge.destinations, currstate)
1858 | 
1859 |    put(state2.edges, tempedge)
1860 |    currstate := pop(myautomata.states)
1861 |    put(myautomata.states, currstate)
1862 | 
1863 |    while currstate.label ~= 43 do {
1864 |       currstate := pop(myautomata.states)
1865 |       put(myautomata.states, currstate)
1866 |       }
1867 |    state2 := currstate
1868 | 
1869 |    tempedge := edge("l", [])
1870 |    currstate := pop(myautomata.states)
1871 |    put(myautomata.states, currstate)
1872 | 
1873 |    while currstate.label ~= 77 do {
1874 |       currstate := pop(myautomata.states)
1875 |       put(myautomata.states, currstate)
1876 |       }
1877 |    put(tempedge.destinations, currstate)
1878 | 
1879 |    put(state2.edges, tempedge)
1880 |    currstate := pop(myautomata.states)
1881 |    put(myautomata.states, currstate)
1882 | 
1883 |    while currstate.label ~= 44 do {
1884 |       currstate := pop(myautomata.states)
1885 |       put(myautomata.states, currstate)
1886 |       }
1887 |    state2 := currstate
1888 | 
1889 |    tempedge := edge("b", [])
1890 |    currstate := pop(myautomata.states)
1891 |    put(myautomata.states, currstate)
1892 | 
1893 |    while currstate.label ~= 78 do {
1894 |       currstate := pop(myautomata.states)
1895 |       put(myautomata.states, currstate)
1896 |       }
1897 |    put(tempedge.destinations, currstate)
1898 | 
1899 |    put(state2.edges, tempedge)
1900 |    currstate := pop(myautomata.states)
1901 |    put(myautomata.states, currstate)
1902 | 
1903 |    while currstate.label ~= 45 do {
1904 |       currstate := pop(myautomata.states)
1905 |       put(myautomata.states, currstate)
1906 |       }
1907 |    state2 := currstate
1908 | 
1909 |    tempedge := edge("l", [])
1910 |    currstate := pop(myautomata.states)
1911 |    put(myautomata.states, currstate)
1912 | 
1913 |    while currstate.label ~= 79 do {
1914 |       currstate := pop(myautomata.states)
1915 |       put(myautomata.states, currstate)
1916 |       }
1917 |    put(tempedge.destinations, currstate)
1918 | 
1919 |    put(state2.edges, tempedge)
1920 |    currstate := pop(myautomata.states)
1921 |    put(myautomata.states, currstate)
1922 | 
1923 |    while currstate.label ~= 46 do {
1924 |       currstate := pop(myautomata.states)
1925 |       put(myautomata.states, currstate)
1926 |       }
1927 |    state2 := currstate
1928 | 
1929 |    tempedge := edge("u", [])
1930 |    currstate := pop(myautomata.states)
1931 |    put(myautomata.states, currstate)
1932 | 
1933 |    while currstate.label ~= 80 do {
1934 |       currstate := pop(myautomata.states)
1935 |       put(myautomata.states, currstate)
1936 |       }
1937 |    put(tempedge.destinations, currstate)
1938 | 
1939 |    put(state2.edges, tempedge)
1940 |    currstate := pop(myautomata.states)
1941 |    put(myautomata.states, currstate)
1942 | 
1943 |    while currstate.label ~= 47 do {
1944 |       currstate := pop(myautomata.states)
1945 |       put(myautomata.states, currstate)
1946 |       }
1947 |    state2 := currstate
1948 | 
1949 |    tempedge := edge("t", [])
1950 |    currstate := pop(myautomata.states)
1951 |    put(myautomata.states, currstate)
1952 | 
1953 |    while currstate.label ~= 81 do {
1954 |       currstate := pop(myautomata.states)
1955 |       put(myautomata.states, currstate)
1956 |       }
1957 |    put(tempedge.destinations, currstate)
1958 | 
1959 |    put(state2.edges, tempedge)
1960 |    currstate := pop(myautomata.states)
1961 |    put(myautomata.states, currstate)
1962 | 
1963 |    while currstate.label ~= 48 do {
1964 |       currstate := pop(myautomata.states)
1965 |       put(myautomata.states, currstate)
1966 |       }
1967 |    state2 := currstate
1968 | 
1969 |    tempedge := edge("e", [])
1970 |    currstate := pop(myautomata.states)
1971 |    put(myautomata.states, currstate)
1972 | 
1973 |    while currstate.label ~= 82 do {
1974 |       currstate := pop(myautomata.states)
1975 |       put(myautomata.states, currstate)
1976 |       }
1977 |    put(tempedge.destinations, currstate)
1978 | 
1979 |    put(state2.edges, tempedge)
1980 |    currstate := pop(myautomata.states)
1981 |    put(myautomata.states, currstate)
1982 | 
1983 |    while currstate.label ~= 49 do {
1984 |       currstate := pop(myautomata.states)
1985 |       put(myautomata.states, currstate)
1986 |       }
1987 |    state2 := currstate
1988 | 
1989 |    tempedge := edge("o", [])
1990 |    currstate := pop(myautomata.states)
1991 |    put(myautomata.states, currstate)
1992 | 
1993 |    while currstate.label ~= 83 do {
1994 |       currstate := pop(myautomata.states)
1995 |       put(myautomata.states, currstate)
1996 |       }
1997 |    put(tempedge.destinations, currstate)
1998 | 
1999 |    put(state2.edges, tempedge)
2000 |    currstate := pop(myautomata.states)
2001 |    put(myautomata.states, currstate)
2002 | 
2003 |    while currstate.label ~= 50 do {
2004 |       currstate := pop(myautomata.states)
2005 |       put(myautomata.states, currstate)
2006 |       }
2007 |    state2 := currstate
2008 | 
2009 |    tempedge := edge("i", [])
2010 |    currstate := pop(myautomata.states)
2011 |    put(myautomata.states, currstate)
2012 | 
2013 |    while currstate.label ~= 84 do {
2014 |       currstate := pop(myautomata.states)
2015 |       put(myautomata.states, currstate)
2016 |       }
2017 |    put(tempedge.destinations, currstate)
2018 | 
2019 |    put(state2.edges, tempedge)
2020 |    currstate := pop(myautomata.states)
2021 |    put(myautomata.states, currstate)
2022 | 
2023 |    while currstate.label ~= 51 do {
2024 |       currstate := pop(myautomata.states)
2025 |       put(myautomata.states, currstate)
2026 |       }
2027 |    state2 := currstate
2028 | 
2029 |    tempedge := edge("u", [])
2030 |    currstate := pop(myautomata.states)
2031 |    put(myautomata.states, currstate)
2032 | 
2033 |    while currstate.label ~= 85 do {
2034 |       currstate := pop(myautomata.states)
2035 |       put(myautomata.states, currstate)
2036 |       }
2037 |    put(tempedge.destinations, currstate)
2038 | 
2039 |    put(state2.edges, tempedge)
2040 |    currstate := pop(myautomata.states)
2041 |    put(myautomata.states, currstate)
2042 | 
2043 |    while currstate.label ~= 52 do {
2044 |       currstate := pop(myautomata.states)
2045 |       put(myautomata.states, currstate)
2046 |       }
2047 |    state2 := currstate
2048 | 
2049 |    tempedge := edge("i", [])
2050 |    currstate := pop(myautomata.states)
2051 |    put(myautomata.states, currstate)
2052 | 
2053 |    while currstate.label ~= 86 do {
2054 |       currstate := pop(myautomata.states)
2055 |       put(myautomata.states, currstate)
2056 |       }
2057 |    put(tempedge.destinations, currstate)
2058 | 
2059 |    put(state2.edges, tempedge)
2060 |    currstate := pop(myautomata.states)
2061 |    put(myautomata.states, currstate)
2062 | 
2063 |    while currstate.label ~= 53 do {
2064 |       currstate := pop(myautomata.states)
2065 |       put(myautomata.states, currstate)
2066 |       }
2067 |    state2 := currstate
2068 | 
2069 |    currstate := pop(myautomata.states)
2070 |    put(myautomata.states, currstate)
2071 | 
2072 |    while currstate.label ~= 54 do {
2073 |       currstate := pop(myautomata.states)
2074 |       put(myautomata.states, currstate)
2075 |       }
2076 |    state2 := currstate
2077 | 
2078 |    tempedge := edge("t", [])
2079 |    currstate := pop(myautomata.states)
2080 |    put(myautomata.states, currstate)
2081 | 
2082 |    while currstate.label ~= 87 do {
2083 |       currstate := pop(myautomata.states)
2084 |       put(myautomata.states, currstate)
2085 |       }
2086 |    put(tempedge.destinations, currstate)
2087 | 
2088 |    put(state2.edges, tempedge)
2089 |    currstate := pop(myautomata.states)
2090 |    put(myautomata.states, currstate)
2091 | 
2092 |    while currstate.label ~= 55 do {
2093 |       currstate := pop(myautomata.states)
2094 |       put(myautomata.states, currstate)
2095 |       }
2096 |    state2 := currstate
2097 | 
2098 |    tempedge := edge("s", [])
2099 |    currstate := pop(myautomata.states)
2100 |    put(myautomata.states, currstate)
2101 | 
2102 |    while currstate.label ~= 88 do {
2103 |       currstate := pop(myautomata.states)
2104 |       put(myautomata.states, currstate)
2105 |       }
2106 |    put(tempedge.destinations, currstate)
2107 | 
2108 |    put(state2.edges, tempedge)
2109 |    currstate := pop(myautomata.states)
2110 |    put(myautomata.states, currstate)
2111 | 
2112 |    while currstate.label ~= 56 do {
2113 |       currstate := pop(myautomata.states)
2114 |       put(myautomata.states, currstate)
2115 |       }
2116 |    state2 := currstate
2117 | 
2118 |    tempedge := edge("\a", [])
2119 |    currstate := pop(myautomata.states)
2120 |    put(myautomata.states, currstate)
2121 | 
2122 |    while currstate.label ~= 89 do {
2123 |       currstate := pop(myautomata.states)
2124 |       put(myautomata.states, currstate)
2125 |       }
2126 |    put(tempedge.destinations, currstate)
2127 | 
2128 |    put(state2.edges, tempedge)
2129 |    currstate := pop(myautomata.states)
2130 |    put(myautomata.states, currstate)
2131 | 
2132 |    while currstate.label ~= 57 do {
2133 |       currstate := pop(myautomata.states)
2134 |       put(myautomata.states, currstate)
2135 |       }
2136 |    state2 := currstate
2137 | 
2138 |    tempedge := edge("r", [])
2139 |    currstate := pop(myautomata.states)
2140 |    put(myautomata.states, currstate)
2141 | 
2142 |    while currstate.label ~= 90 do {
2143 |       currstate := pop(myautomata.states)
2144 |       put(myautomata.states, currstate)
2145 |       }
2146 |    put(tempedge.destinations, currstate)
2147 | 
2148 |    put(state2.edges, tempedge)
2149 |    tempedge := edge("\a", [])
2150 |    currstate := pop(myautomata.states)
2151 |    put(myautomata.states, currstate)
2152 | 
2153 |    while currstate.label ~= 91 do {
2154 |       currstate := pop(myautomata.states)
2155 |       put(myautomata.states, currstate)
2156 |       }
2157 |    put(tempedge.destinations, currstate)
2158 | 
2159 |    put(state2.edges, tempedge)
2160 |    currstate := pop(myautomata.states)
2161 |    put(myautomata.states, currstate)
2162 | 
2163 |    while currstate.label ~= 58 do {
2164 |       currstate := pop(myautomata.states)
2165 |       put(myautomata.states, currstate)
2166 |       }
2167 |    state2 := currstate
2168 | 
2169 |    tempedge := edge(csetfromrecset("[^*]"), [])
2170 |    currstate := pop(myautomata.states)
2171 |    put(myautomata.states, currstate)
2172 | 
2173 |    while currstate.label ~= 92 do {
2174 |       currstate := pop(myautomata.states)
2175 |       put(myautomata.states, currstate)
2176 |       }
2177 |    put(tempedge.destinations, currstate)
2178 | 
2179 |    put(state2.edges, tempedge)
2180 |    tempedge := edge("*", [])
2181 |    currstate := pop(myautomata.states)
2182 |    put(myautomata.states, currstate)
2183 | 
2184 |    while currstate.label ~= 93 do {
2185 |       currstate := pop(myautomata.states)
2186 |       put(myautomata.states, currstate)
2187 |       }
2188 |    put(tempedge.destinations, currstate)
2189 | 
2190 |    put(state2.edges, tempedge)
2191 |    currstate := pop(myautomata.states)
2192 |    put(myautomata.states, currstate)
2193 | 
2194 |    while currstate.label ~= 59 do {
2195 |       currstate := pop(myautomata.states)
2196 |       put(myautomata.states, currstate)
2197 |       }
2198 |    state2 := currstate
2199 | 
2200 |    tempedge := edge("\n"
2201 | , [])
2202 |    currstate := pop(myautomata.states)
2203 |    put(myautomata.states, currstate)
2204 | 
2205 |    while currstate.label ~= 94 do {
2206 |       currstate := pop(myautomata.states)
2207 |       put(myautomata.states, currstate)
2208 |       }
2209 |    put(tempedge.destinations, currstate)
2210 | 
2211 |    put(state2.edges, tempedge)
2212 |    tempedge := edge("r", [])
2213 |    currstate := pop(myautomata.states)
2214 |    put(myautomata.states, currstate)
2215 | 
2216 |    while currstate.label ~= 95 do {
2217 |       currstate := pop(myautomata.states)
2218 |       put(myautomata.states, currstate)
2219 |       }
2220 |    put(tempedge.destinations, currstate)
2221 | 
2222 |    put(state2.edges, tempedge)
2223 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2224 |    currstate := pop(myautomata.states)
2225 |    put(myautomata.states, currstate)
2226 | 
2227 |    while currstate.label ~= 96 do {
2228 |       currstate := pop(myautomata.states)
2229 |       put(myautomata.states, currstate)
2230 |       }
2231 |    put(tempedge.destinations, currstate)
2232 | 
2233 |    put(state2.edges, tempedge)
2234 |    currstate := pop(myautomata.states)
2235 |    put(myautomata.states, currstate)
2236 | 
2237 |    while currstate.label ~= 60 do {
2238 |       currstate := pop(myautomata.states)
2239 |       put(myautomata.states, currstate)
2240 |       }
2241 |    state2 := currstate
2242 | 
2243 |    currstate := pop(myautomata.states)
2244 |    put(myautomata.states, currstate)
2245 | 
2246 |    while currstate.label ~= 61 do {
2247 |       currstate := pop(myautomata.states)
2248 |       put(myautomata.states, currstate)
2249 |       }
2250 |    state2 := currstate
2251 | 
2252 |    currstate := pop(myautomata.states)
2253 |    put(myautomata.states, currstate)
2254 | 
2255 |    while currstate.label ~= 62 do {
2256 |       currstate := pop(myautomata.states)
2257 |       put(myautomata.states, currstate)
2258 |       }
2259 |    state2 := currstate
2260 | 
2261 |    currstate := pop(myautomata.states)
2262 |    put(myautomata.states, currstate)
2263 | 
2264 |    while currstate.label ~= 63 do {
2265 |       currstate := pop(myautomata.states)
2266 |       put(myautomata.states, currstate)
2267 |       }
2268 |    state2 := currstate
2269 | 
2270 |    currstate := pop(myautomata.states)
2271 |    put(myautomata.states, currstate)
2272 | 
2273 |    while currstate.label ~= 64 do {
2274 |       currstate := pop(myautomata.states)
2275 |       put(myautomata.states, currstate)
2276 |       }
2277 |    state2 := currstate
2278 | 
2279 |    currstate := pop(myautomata.states)
2280 |    put(myautomata.states, currstate)
2281 | 
2282 |    while currstate.label ~= 65 do {
2283 |       currstate := pop(myautomata.states)
2284 |       put(myautomata.states, currstate)
2285 |       }
2286 |    state2 := currstate
2287 | 
2288 |    currstate := pop(myautomata.states)
2289 |    put(myautomata.states, currstate)
2290 | 
2291 |    while currstate.label ~= 66 do {
2292 |       currstate := pop(myautomata.states)
2293 |       put(myautomata.states, currstate)
2294 |       }
2295 |    state2 := currstate
2296 | 
2297 |    currstate := pop(myautomata.states)
2298 |    put(myautomata.states, currstate)
2299 | 
2300 |    while currstate.label ~= 67 do {
2301 |       currstate := pop(myautomata.states)
2302 |       put(myautomata.states, currstate)
2303 |       }
2304 |    state2 := currstate
2305 | 
2306 |    currstate := pop(myautomata.states)
2307 |    put(myautomata.states, currstate)
2308 | 
2309 |    while currstate.label ~= 68 do {
2310 |       currstate := pop(myautomata.states)
2311 |       put(myautomata.states, currstate)
2312 |       }
2313 |    state2 := currstate
2314 | 
2315 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
2316 |    currstate := pop(myautomata.states)
2317 |    put(myautomata.states, currstate)
2318 | 
2319 |    while currstate.label ~= 68 do {
2320 |       currstate := pop(myautomata.states)
2321 |       put(myautomata.states, currstate)
2322 |       }
2323 |    put(tempedge.destinations, currstate)
2324 | 
2325 |    put(state2.edges, tempedge)
2326 |    currstate := pop(myautomata.states)
2327 |    put(myautomata.states, currstate)
2328 | 
2329 |    while currstate.label ~= 69 do {
2330 |       currstate := pop(myautomata.states)
2331 |       put(myautomata.states, currstate)
2332 |       }
2333 |    state2 := currstate
2334 | 
2335 |    tempedge := edge(csetfromrecset("[+-]"), [])
2336 |    currstate := pop(myautomata.states)
2337 |    put(myautomata.states, currstate)
2338 | 
2339 |    while currstate.label ~= 97 do {
2340 |       currstate := pop(myautomata.states)
2341 |       put(myautomata.states, currstate)
2342 |       }
2343 |    put(tempedge.destinations, currstate)
2344 | 
2345 |    put(state2.edges, tempedge)
2346 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2347 |    currstate := pop(myautomata.states)
2348 |    put(myautomata.states, currstate)
2349 | 
2350 |    while currstate.label ~= 98 do {
2351 |       currstate := pop(myautomata.states)
2352 |       put(myautomata.states, currstate)
2353 |       }
2354 |    put(tempedge.destinations, currstate)
2355 | 
2356 |    put(state2.edges, tempedge)
2357 |    currstate := pop(myautomata.states)
2358 |    put(myautomata.states, currstate)
2359 | 
2360 |    while currstate.label ~= 70 do {
2361 |       currstate := pop(myautomata.states)
2362 |       put(myautomata.states, currstate)
2363 |       }
2364 |    state2 := currstate
2365 | 
2366 |    tempedge := edge(csetfromrecset("[eE]"), [])
2367 |    currstate := pop(myautomata.states)
2368 |    put(myautomata.states, currstate)
2369 | 
2370 |    while currstate.label ~= 69 do {
2371 |       currstate := pop(myautomata.states)
2372 |       put(myautomata.states, currstate)
2373 |       }
2374 |    put(tempedge.destinations, currstate)
2375 | 
2376 |    put(state2.edges, tempedge)
2377 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2378 |    currstate := pop(myautomata.states)
2379 |    put(myautomata.states, currstate)
2380 | 
2381 |    while currstate.label ~= 70 do {
2382 |       currstate := pop(myautomata.states)
2383 |       put(myautomata.states, currstate)
2384 |       }
2385 |    put(tempedge.destinations, currstate)
2386 | 
2387 |    put(state2.edges, tempedge)
2388 |    currstate := pop(myautomata.states)
2389 |    put(myautomata.states, currstate)
2390 | 
2391 |    while currstate.label ~= 71 do {
2392 |       currstate := pop(myautomata.states)
2393 |       put(myautomata.states, currstate)
2394 |       }
2395 |    state2 := currstate
2396 | 
2397 |    tempedge := edge(csetfromrecset("[eE]"), [])
2398 |    currstate := pop(myautomata.states)
2399 |    put(myautomata.states, currstate)
2400 | 
2401 |    while currstate.label ~= 69 do {
2402 |       currstate := pop(myautomata.states)
2403 |       put(myautomata.states, currstate)
2404 |       }
2405 |    put(tempedge.destinations, currstate)
2406 | 
2407 |    put(state2.edges, tempedge)
2408 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2409 |    currstate := pop(myautomata.states)
2410 |    put(myautomata.states, currstate)
2411 | 
2412 |    while currstate.label ~= 70 do {
2413 |       currstate := pop(myautomata.states)
2414 |       put(myautomata.states, currstate)
2415 |       }
2416 |    put(tempedge.destinations, currstate)
2417 | 
2418 |    put(state2.edges, tempedge)
2419 |    currstate := pop(myautomata.states)
2420 |    put(myautomata.states, currstate)
2421 | 
2422 |    while currstate.label ~= 72 do {
2423 |       currstate := pop(myautomata.states)
2424 |       put(myautomata.states, currstate)
2425 |       }
2426 |    state2 := currstate
2427 | 
2428 |    tempedge := edge(csetfromrecset("[+-]"), [])
2429 |    currstate := pop(myautomata.states)
2430 |    put(myautomata.states, currstate)
2431 | 
2432 |    while currstate.label ~= 99 do {
2433 |       currstate := pop(myautomata.states)
2434 |       put(myautomata.states, currstate)
2435 |       }
2436 |    put(tempedge.destinations, currstate)
2437 | 
2438 |    put(state2.edges, tempedge)
2439 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2440 |    currstate := pop(myautomata.states)
2441 |    put(myautomata.states, currstate)
2442 | 
2443 |    while currstate.label ~= 100 do {
2444 |       currstate := pop(myautomata.states)
2445 |       put(myautomata.states, currstate)
2446 |       }
2447 |    put(tempedge.destinations, currstate)
2448 | 
2449 |    put(state2.edges, tempedge)
2450 |    currstate := pop(myautomata.states)
2451 |    put(myautomata.states, currstate)
2452 | 
2453 |    while currstate.label ~= 73 do {
2454 |       currstate := pop(myautomata.states)
2455 |       put(myautomata.states, currstate)
2456 |       }
2457 |    state2 := currstate
2458 | 
2459 |    tempedge := edge(csetfromrecset("[^\"]"), [])
2460 |    currstate := pop(myautomata.states)
2461 |    put(myautomata.states, currstate)
2462 | 
2463 |    while currstate.label ~= 73 do {
2464 |       currstate := pop(myautomata.states)
2465 |       put(myautomata.states, currstate)
2466 |       }
2467 |    put(tempedge.destinations, currstate)
2468 | 
2469 |    put(state2.edges, tempedge)
2470 |    tempedge := edge("\\", [])
2471 |    currstate := pop(myautomata.states)
2472 |    put(myautomata.states, currstate)
2473 | 
2474 |    while currstate.label ~= 74 do {
2475 |       currstate := pop(myautomata.states)
2476 |       put(myautomata.states, currstate)
2477 |       }
2478 |    put(tempedge.destinations, currstate)
2479 | 
2480 |    put(state2.edges, tempedge)
2481 |    tempedge := edge("\"", [])
2482 |    currstate := pop(myautomata.states)
2483 |    put(myautomata.states, currstate)
2484 | 
2485 |    while currstate.label ~= 75 do {
2486 |       currstate := pop(myautomata.states)
2487 |       put(myautomata.states, currstate)
2488 |       }
2489 |    put(tempedge.destinations, currstate)
2490 | 
2491 |    put(state2.edges, tempedge)
2492 |    currstate := pop(myautomata.states)
2493 |    put(myautomata.states, currstate)
2494 | 
2495 |    while currstate.label ~= 74 do {
2496 |       currstate := pop(myautomata.states)
2497 |       put(myautomata.states, currstate)
2498 |       }
2499 |    state2 := currstate
2500 | 
2501 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2502 |    currstate := pop(myautomata.states)
2503 |    put(myautomata.states, currstate)
2504 | 
2505 |    while currstate.label ~= 101 do {
2506 |       currstate := pop(myautomata.states)
2507 |       put(myautomata.states, currstate)
2508 |       }
2509 |    put(tempedge.destinations, currstate)
2510 | 
2511 |    put(state2.edges, tempedge)
2512 |    currstate := pop(myautomata.states)
2513 |    put(myautomata.states, currstate)
2514 | 
2515 |    while currstate.label ~= 75 do {
2516 |       currstate := pop(myautomata.states)
2517 |       put(myautomata.states, currstate)
2518 |       }
2519 |    state2 := currstate
2520 | 
2521 |    currstate := pop(myautomata.states)
2522 |    put(myautomata.states, currstate)
2523 | 
2524 |    while currstate.label ~= 76 do {
2525 |       currstate := pop(myautomata.states)
2526 |       put(myautomata.states, currstate)
2527 |       }
2528 |    state2 := currstate
2529 | 
2530 |    currstate := pop(myautomata.states)
2531 |    put(myautomata.states, currstate)
2532 | 
2533 |    while currstate.label ~= 77 do {
2534 |       currstate := pop(myautomata.states)
2535 |       put(myautomata.states, currstate)
2536 |       }
2537 |    state2 := currstate
2538 | 
2539 |    tempedge := edge("s", [])
2540 |    currstate := pop(myautomata.states)
2541 |    put(myautomata.states, currstate)
2542 | 
2543 |    while currstate.label ~= 102 do {
2544 |       currstate := pop(myautomata.states)
2545 |       put(myautomata.states, currstate)
2546 |       }
2547 |    put(tempedge.destinations, currstate)
2548 | 
2549 |    put(state2.edges, tempedge)
2550 |    currstate := pop(myautomata.states)
2551 |    put(myautomata.states, currstate)
2552 | 
2553 |    while currstate.label ~= 78 do {
2554 |       currstate := pop(myautomata.states)
2555 |       put(myautomata.states, currstate)
2556 |       }
2557 |    state2 := currstate
2558 | 
2559 |    tempedge := edge("l", [])
2560 |    currstate := pop(myautomata.states)
2561 |    put(myautomata.states, currstate)
2562 | 
2563 |    while currstate.label ~= 103 do {
2564 |       currstate := pop(myautomata.states)
2565 |       put(myautomata.states, currstate)
2566 |       }
2567 |    put(tempedge.destinations, currstate)
2568 | 
2569 |    put(state2.edges, tempedge)
2570 |    currstate := pop(myautomata.states)
2571 |    put(myautomata.states, currstate)
2572 | 
2573 |    while currstate.label ~= 79 do {
2574 |       currstate := pop(myautomata.states)
2575 |       put(myautomata.states, currstate)
2576 |       }
2577 |    state2 := currstate
2578 | 
2579 |    tempedge := edge("l", [])
2580 |    currstate := pop(myautomata.states)
2581 |    put(myautomata.states, currstate)
2582 | 
2583 |    while currstate.label ~= 104 do {
2584 |       currstate := pop(myautomata.states)
2585 |       put(myautomata.states, currstate)
2586 |       }
2587 |    put(tempedge.destinations, currstate)
2588 | 
2589 |    put(state2.edges, tempedge)
2590 |    currstate := pop(myautomata.states)
2591 |    put(myautomata.states, currstate)
2592 | 
2593 |    while currstate.label ~= 80 do {
2594 |       currstate := pop(myautomata.states)
2595 |       put(myautomata.states, currstate)
2596 |       }
2597 |    state2 := currstate
2598 | 
2599 |    tempedge := edge("e", [])
2600 |    currstate := pop(myautomata.states)
2601 |    put(myautomata.states, currstate)
2602 | 
2603 |    while currstate.label ~= 105 do {
2604 |       currstate := pop(myautomata.states)
2605 |       put(myautomata.states, currstate)
2606 |       }
2607 |    put(tempedge.destinations, currstate)
2608 | 
2609 |    put(state2.edges, tempedge)
2610 |    currstate := pop(myautomata.states)
2611 |    put(myautomata.states, currstate)
2612 | 
2613 |    while currstate.label ~= 81 do {
2614 |       currstate := pop(myautomata.states)
2615 |       put(myautomata.states, currstate)
2616 |       }
2617 |    state2 := currstate
2618 | 
2619 |    tempedge := edge("u", [])
2620 |    currstate := pop(myautomata.states)
2621 |    put(myautomata.states, currstate)
2622 | 
2623 |    while currstate.label ~= 106 do {
2624 |       currstate := pop(myautomata.states)
2625 |       put(myautomata.states, currstate)
2626 |       }
2627 |    put(tempedge.destinations, currstate)
2628 | 
2629 |    put(state2.edges, tempedge)
2630 |    currstate := pop(myautomata.states)
2631 |    put(myautomata.states, currstate)
2632 | 
2633 |    while currstate.label ~= 82 do {
2634 |       currstate := pop(myautomata.states)
2635 |       put(myautomata.states, currstate)
2636 |       }
2637 |    state2 := currstate
2638 | 
2639 |    tempedge := edge("\a", [])
2640 |    currstate := pop(myautomata.states)
2641 |    put(myautomata.states, currstate)
2642 | 
2643 |    while currstate.label ~= 107 do {
2644 |       currstate := pop(myautomata.states)
2645 |       put(myautomata.states, currstate)
2646 |       }
2647 |    put(tempedge.destinations, currstate)
2648 | 
2649 |    put(state2.edges, tempedge)
2650 |    currstate := pop(myautomata.states)
2651 |    put(myautomata.states, currstate)
2652 | 
2653 |    while currstate.label ~= 83 do {
2654 |       currstate := pop(myautomata.states)
2655 |       put(myautomata.states, currstate)
2656 |       }
2657 |    state2 := currstate
2658 | 
2659 |    tempedge := edge("l", [])
2660 |    currstate := pop(myautomata.states)
2661 |    put(myautomata.states, currstate)
2662 | 
2663 |    while currstate.label ~= 108 do {
2664 |       currstate := pop(myautomata.states)
2665 |       put(myautomata.states, currstate)
2666 |       }
2667 |    put(tempedge.destinations, currstate)
2668 | 
2669 |    put(state2.edges, tempedge)
2670 |    currstate := pop(myautomata.states)
2671 |    put(myautomata.states, currstate)
2672 | 
2673 |    while currstate.label ~= 84 do {
2674 |       currstate := pop(myautomata.states)
2675 |       put(myautomata.states, currstate)
2676 |       }
2677 |    state2 := currstate
2678 | 
2679 |    tempedge := edge("d", [])
2680 |    currstate := pop(myautomata.states)
2681 |    put(myautomata.states, currstate)
2682 | 
2683 |    while currstate.label ~= 109 do {
2684 |       currstate := pop(myautomata.states)
2685 |       put(myautomata.states, currstate)
2686 |       }
2687 |    put(tempedge.destinations, currstate)
2688 | 
2689 |    put(state2.edges, tempedge)
2690 |    currstate := pop(myautomata.states)
2691 |    put(myautomata.states, currstate)
2692 | 
2693 |    while currstate.label ~= 85 do {
2694 |       currstate := pop(myautomata.states)
2695 |       put(myautomata.states, currstate)
2696 |       }
2697 |    state2 := currstate
2698 | 
2699 |    tempedge := edge("b", [])
2700 |    currstate := pop(myautomata.states)
2701 |    put(myautomata.states, currstate)
2702 | 
2703 |    while currstate.label ~= 110 do {
2704 |       currstate := pop(myautomata.states)
2705 |       put(myautomata.states, currstate)
2706 |       }
2707 |    put(tempedge.destinations, currstate)
2708 | 
2709 |    put(state2.edges, tempedge)
2710 |    currstate := pop(myautomata.states)
2711 |    put(myautomata.states, currstate)
2712 | 
2713 |    while currstate.label ~= 86 do {
2714 |       currstate := pop(myautomata.states)
2715 |       put(myautomata.states, currstate)
2716 |       }
2717 |    state2 := currstate
2718 | 
2719 |    tempedge := edge("l", [])
2720 |    currstate := pop(myautomata.states)
2721 |    put(myautomata.states, currstate)
2722 | 
2723 |    while currstate.label ~= 111 do {
2724 |       currstate := pop(myautomata.states)
2725 |       put(myautomata.states, currstate)
2726 |       }
2727 |    put(tempedge.destinations, currstate)
2728 | 
2729 |    put(state2.edges, tempedge)
2730 |    currstate := pop(myautomata.states)
2731 |    put(myautomata.states, currstate)
2732 | 
2733 |    while currstate.label ~= 87 do {
2734 |       currstate := pop(myautomata.states)
2735 |       put(myautomata.states, currstate)
2736 |       }
2737 |    state2 := currstate
2738 | 
2739 |    currstate := pop(myautomata.states)
2740 |    put(myautomata.states, currstate)
2741 | 
2742 |    while currstate.label ~= 88 do {
2743 |       currstate := pop(myautomata.states)
2744 |       put(myautomata.states, currstate)
2745 |       }
2746 |    state2 := currstate
2747 | 
2748 |    tempedge := edge("e", [])
2749 |    currstate := pop(myautomata.states)
2750 |    put(myautomata.states, currstate)
2751 | 
2752 |    while currstate.label ~= 112 do {
2753 |       currstate := pop(myautomata.states)
2754 |       put(myautomata.states, currstate)
2755 |       }
2756 |    put(tempedge.destinations, currstate)
2757 | 
2758 |    put(state2.edges, tempedge)
2759 |    currstate := pop(myautomata.states)
2760 |    put(myautomata.states, currstate)
2761 | 
2762 |    while currstate.label ~= 89 do {
2763 |       currstate := pop(myautomata.states)
2764 |       put(myautomata.states, currstate)
2765 |       }
2766 |    state2 := currstate
2767 | 
2768 |    tempedge := edge("s", [])
2769 |    currstate := pop(myautomata.states)
2770 |    put(myautomata.states, currstate)
2771 | 
2772 |    while currstate.label ~= 113 do {
2773 |       currstate := pop(myautomata.states)
2774 |       put(myautomata.states, currstate)
2775 |       }
2776 |    put(tempedge.destinations, currstate)
2777 | 
2778 |    put(state2.edges, tempedge)
2779 |    currstate := pop(myautomata.states)
2780 |    put(myautomata.states, currstate)
2781 | 
2782 |    while currstate.label ~= 90 do {
2783 |       currstate := pop(myautomata.states)
2784 |       put(myautomata.states, currstate)
2785 |       }
2786 |    state2 := currstate
2787 | 
2788 |    tempedge := edge("i", [])
2789 |    currstate := pop(myautomata.states)
2790 |    put(myautomata.states, currstate)
2791 | 
2792 |    while currstate.label ~= 114 do {
2793 |       currstate := pop(myautomata.states)
2794 |       put(myautomata.states, currstate)
2795 |       }
2796 |    put(tempedge.destinations, currstate)
2797 | 
2798 |    put(state2.edges, tempedge)
2799 |    currstate := pop(myautomata.states)
2800 |    put(myautomata.states, currstate)
2801 | 
2802 |    while currstate.label ~= 91 do {
2803 |       currstate := pop(myautomata.states)
2804 |       put(myautomata.states, currstate)
2805 |       }
2806 |    state2 := currstate
2807 | 
2808 |    tempedge := edge("t", [])
2809 |    currstate := pop(myautomata.states)
2810 |    put(myautomata.states, currstate)
2811 | 
2812 |    while currstate.label ~= 115 do {
2813 |       currstate := pop(myautomata.states)
2814 |       put(myautomata.states, currstate)
2815 |       }
2816 |    put(tempedge.destinations, currstate)
2817 | 
2818 |    put(state2.edges, tempedge)
2819 |    currstate := pop(myautomata.states)
2820 |    put(myautomata.states, currstate)
2821 | 
2822 |    while currstate.label ~= 92 do {
2823 |       currstate := pop(myautomata.states)
2824 |       put(myautomata.states, currstate)
2825 |       }
2826 |    state2 := currstate
2827 | 
2828 |    tempedge := edge(csetfromrecset("[^*]"), [])
2829 |    currstate := pop(myautomata.states)
2830 |    put(myautomata.states, currstate)
2831 | 
2832 |    while currstate.label ~= 92 do {
2833 |       currstate := pop(myautomata.states)
2834 |       put(myautomata.states, currstate)
2835 |       }
2836 |    put(tempedge.destinations, currstate)
2837 | 
2838 |    put(state2.edges, tempedge)
2839 |    tempedge := edge("*", [])
2840 |    currstate := pop(myautomata.states)
2841 |    put(myautomata.states, currstate)
2842 | 
2843 |    while currstate.label ~= 93 do {
2844 |       currstate := pop(myautomata.states)
2845 |       put(myautomata.states, currstate)
2846 |       }
2847 |    put(tempedge.destinations, currstate)
2848 | 
2849 |    put(state2.edges, tempedge)
2850 |    currstate := pop(myautomata.states)
2851 |    put(myautomata.states, currstate)
2852 | 
2853 |    while currstate.label ~= 93 do {
2854 |       currstate := pop(myautomata.states)
2855 |       put(myautomata.states, currstate)
2856 |       }
2857 |    state2 := currstate
2858 | 
2859 |    tempedge := edge(csetfromrecset("[^/*]"), [])
2860 |    currstate := pop(myautomata.states)
2861 |    put(myautomata.states, currstate)
2862 | 
2863 |    while currstate.label ~= 116 do {
2864 |       currstate := pop(myautomata.states)
2865 |       put(myautomata.states, currstate)
2866 |       }
2867 |    put(tempedge.destinations, currstate)
2868 | 
2869 |    put(state2.edges, tempedge)
2870 |    tempedge := edge("*", [])
2871 |    currstate := pop(myautomata.states)
2872 |    put(myautomata.states, currstate)
2873 | 
2874 |    while currstate.label ~= 93 do {
2875 |       currstate := pop(myautomata.states)
2876 |       put(myautomata.states, currstate)
2877 |       }
2878 |    put(tempedge.destinations, currstate)
2879 | 
2880 |    put(state2.edges, tempedge)
2881 |    tempedge := edge("/", [])
2882 |    currstate := pop(myautomata.states)
2883 |    put(myautomata.states, currstate)
2884 | 
2885 |    while currstate.label ~= 117 do {
2886 |       currstate := pop(myautomata.states)
2887 |       put(myautomata.states, currstate)
2888 |       }
2889 |    put(tempedge.destinations, currstate)
2890 | 
2891 |    put(state2.edges, tempedge)
2892 |    currstate := pop(myautomata.states)
2893 |    put(myautomata.states, currstate)
2894 | 
2895 |    while currstate.label ~= 94 do {
2896 |       currstate := pop(myautomata.states)
2897 |       put(myautomata.states, currstate)
2898 |       }
2899 |    state2 := currstate
2900 | 
2901 |    currstate := pop(myautomata.states)
2902 |    put(myautomata.states, currstate)
2903 | 
2904 |    while currstate.label ~= 95 do {
2905 |       currstate := pop(myautomata.states)
2906 |       put(myautomata.states, currstate)
2907 |       }
2908 |    state2 := currstate
2909 | 
2910 |    tempedge := edge("\n"
2911 | , [])
2912 |    currstate := pop(myautomata.states)
2913 |    put(myautomata.states, currstate)
2914 | 
2915 |    while currstate.label ~= 94 do {
2916 |       currstate := pop(myautomata.states)
2917 |       put(myautomata.states, currstate)
2918 |       }
2919 |    put(tempedge.destinations, currstate)
2920 | 
2921 |    put(state2.edges, tempedge)
2922 |    currstate := pop(myautomata.states)
2923 |    put(myautomata.states, currstate)
2924 | 
2925 |    while currstate.label ~= 96 do {
2926 |       currstate := pop(myautomata.states)
2927 |       put(myautomata.states, currstate)
2928 |       }
2929 |    state2 := currstate
2930 | 
2931 |    tempedge := edge("\n"
2932 | , [])
2933 |    currstate := pop(myautomata.states)
2934 |    put(myautomata.states, currstate)
2935 | 
2936 |    while currstate.label ~= 94 do {
2937 |       currstate := pop(myautomata.states)
2938 |       put(myautomata.states, currstate)
2939 |       }
2940 |    put(tempedge.destinations, currstate)
2941 | 
2942 |    put(state2.edges, tempedge)
2943 |    tempedge := edge("r", [])
2944 |    currstate := pop(myautomata.states)
2945 |    put(myautomata.states, currstate)
2946 | 
2947 |    while currstate.label ~= 95 do {
2948 |       currstate := pop(myautomata.states)
2949 |       put(myautomata.states, currstate)
2950 |       }
2951 |    put(tempedge.destinations, currstate)
2952 | 
2953 |    put(state2.edges, tempedge)
2954 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2955 |    currstate := pop(myautomata.states)
2956 |    put(myautomata.states, currstate)
2957 | 
2958 |    while currstate.label ~= 96 do {
2959 |       currstate := pop(myautomata.states)
2960 |       put(myautomata.states, currstate)
2961 |       }
2962 |    put(tempedge.destinations, currstate)
2963 | 
2964 |    put(state2.edges, tempedge)
2965 |    currstate := pop(myautomata.states)
2966 |    put(myautomata.states, currstate)
2967 | 
2968 |    while currstate.label ~= 97 do {
2969 |       currstate := pop(myautomata.states)
2970 |       put(myautomata.states, currstate)
2971 |       }
2972 |    state2 := currstate
2973 | 
2974 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2975 |    currstate := pop(myautomata.states)
2976 |    put(myautomata.states, currstate)
2977 | 
2978 |    while currstate.label ~= 98 do {
2979 |       currstate := pop(myautomata.states)
2980 |       put(myautomata.states, currstate)
2981 |       }
2982 |    put(tempedge.destinations, currstate)
2983 | 
2984 |    put(state2.edges, tempedge)
2985 |    currstate := pop(myautomata.states)
2986 |    put(myautomata.states, currstate)
2987 | 
2988 |    while currstate.label ~= 98 do {
2989 |       currstate := pop(myautomata.states)
2990 |       put(myautomata.states, currstate)
2991 |       }
2992 |    state2 := currstate
2993 | 
2994 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2995 |    currstate := pop(myautomata.states)
2996 |    put(myautomata.states, currstate)
2997 | 
2998 |    while currstate.label ~= 98 do {
2999 |       currstate := pop(myautomata.states)
3000 |       put(myautomata.states, currstate)
3001 |       }
3002 |    put(tempedge.destinations, currstate)
3003 | 
3004 |    put(state2.edges, tempedge)
3005 |    currstate := pop(myautomata.states)
3006 |    put(myautomata.states, currstate)
3007 | 
3008 |    while currstate.label ~= 99 do {
3009 |       currstate := pop(myautomata.states)
3010 |       put(myautomata.states, currstate)
3011 |       }
3012 |    state2 := currstate
3013 | 
3014 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3015 |    currstate := pop(myautomata.states)
3016 |    put(myautomata.states, currstate)
3017 | 
3018 |    while currstate.label ~= 100 do {
3019 |       currstate := pop(myautomata.states)
3020 |       put(myautomata.states, currstate)
3021 |       }
3022 |    put(tempedge.destinations, currstate)
3023 | 
3024 |    put(state2.edges, tempedge)
3025 |    currstate := pop(myautomata.states)
3026 |    put(myautomata.states, currstate)
3027 | 
3028 |    while currstate.label ~= 100 do {
3029 |       currstate := pop(myautomata.states)
3030 |       put(myautomata.states, currstate)
3031 |       }
3032 |    state2 := currstate
3033 | 
3034 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3035 |    currstate := pop(myautomata.states)
3036 |    put(myautomata.states, currstate)
3037 | 
3038 |    while currstate.label ~= 100 do {
3039 |       currstate := pop(myautomata.states)
3040 |       put(myautomata.states, currstate)
3041 |       }
3042 |    put(tempedge.destinations, currstate)
3043 | 
3044 |    put(state2.edges, tempedge)
3045 |    currstate := pop(myautomata.states)
3046 |    put(myautomata.states, currstate)
3047 | 
3048 |    while currstate.label ~= 101 do {
3049 |       currstate := pop(myautomata.states)
3050 |       put(myautomata.states, currstate)
3051 |       }
3052 |    state2 := currstate
3053 | 
3054 |    tempedge := edge(csetfromrecset("[^\"]"), [])
3055 |    currstate := pop(myautomata.states)
3056 |    put(myautomata.states, currstate)
3057 | 
3058 |    while currstate.label ~= 73 do {
3059 |       currstate := pop(myautomata.states)
3060 |       put(myautomata.states, currstate)
3061 |       }
3062 |    put(tempedge.destinations, currstate)
3063 | 
3064 |    put(state2.edges, tempedge)
3065 |    tempedge := edge("\\", [])
3066 |    currstate := pop(myautomata.states)
3067 |    put(myautomata.states, currstate)
3068 | 
3069 |    while currstate.label ~= 74 do {
3070 |       currstate := pop(myautomata.states)
3071 |       put(myautomata.states, currstate)
3072 |       }
3073 |    put(tempedge.destinations, currstate)
3074 | 
3075 |    put(state2.edges, tempedge)
3076 |    tempedge := edge("\"", [])
3077 |    currstate := pop(myautomata.states)
3078 |    put(myautomata.states, currstate)
3079 | 
3080 |    while currstate.label ~= 75 do {
3081 |       currstate := pop(myautomata.states)
3082 |       put(myautomata.states, currstate)
3083 |       }
3084 |    put(tempedge.destinations, currstate)
3085 | 
3086 |    put(state2.edges, tempedge)
3087 |    currstate := pop(myautomata.states)
3088 |    put(myautomata.states, currstate)
3089 | 
3090 |    while currstate.label ~= 102 do {
3091 |       currstate := pop(myautomata.states)
3092 |       put(myautomata.states, currstate)
3093 |       }
3094 |    state2 := currstate
3095 | 
3096 |    tempedge := edge("e", [])
3097 |    currstate := pop(myautomata.states)
3098 |    put(myautomata.states, currstate)
3099 | 
3100 |    while currstate.label ~= 118 do {
3101 |       currstate := pop(myautomata.states)
3102 |       put(myautomata.states, currstate)
3103 |       }
3104 |    put(tempedge.destinations, currstate)
3105 | 
3106 |    put(state2.edges, tempedge)
3107 |    currstate := pop(myautomata.states)
3108 |    put(myautomata.states, currstate)
3109 | 
3110 |    while currstate.label ~= 103 do {
3111 |       currstate := pop(myautomata.states)
3112 |       put(myautomata.states, currstate)
3113 |       }
3114 |    state2 := currstate
3115 | 
3116 |    tempedge := edge("i", [])
3117 |    currstate := pop(myautomata.states)
3118 |    put(myautomata.states, currstate)
3119 | 
3120 |    while currstate.label ~= 119 do {
3121 |       currstate := pop(myautomata.states)
3122 |       put(myautomata.states, currstate)
3123 |       }
3124 |    put(tempedge.destinations, currstate)
3125 | 
3126 |    put(state2.edges, tempedge)
3127 |    currstate := pop(myautomata.states)
3128 |    put(myautomata.states, currstate)
3129 | 
3130 |    while currstate.label ~= 104 do {
3131 |       currstate := pop(myautomata.states)
3132 |       put(myautomata.states, currstate)
3133 |       }
3134 |    state2 := currstate
3135 | 
3136 |    currstate := pop(myautomata.states)
3137 |    put(myautomata.states, currstate)
3138 | 
3139 |    while currstate.label ~= 105 do {
3140 |       currstate := pop(myautomata.states)
3141 |       put(myautomata.states, currstate)
3142 |       }
3143 |    state2 := currstate
3144 | 
3145 |    currstate := pop(myautomata.states)
3146 |    put(myautomata.states, currstate)
3147 | 
3148 |    while currstate.label ~= 106 do {
3149 |       currstate := pop(myautomata.states)
3150 |       put(myautomata.states, currstate)
3151 |       }
3152 |    state2 := currstate
3153 | 
3154 |    tempedge := edge("r", [])
3155 |    currstate := pop(myautomata.states)
3156 |    put(myautomata.states, currstate)
3157 | 
3158 |    while currstate.label ~= 120 do {
3159 |       currstate := pop(myautomata.states)
3160 |       put(myautomata.states, currstate)
3161 |       }
3162 |    put(tempedge.destinations, currstate)
3163 | 
3164 |    put(state2.edges, tempedge)
3165 |    currstate := pop(myautomata.states)
3166 |    put(myautomata.states, currstate)
3167 | 
3168 |    while currstate.label ~= 107 do {
3169 |       currstate := pop(myautomata.states)
3170 |       put(myautomata.states, currstate)
3171 |       }
3172 |    state2 := currstate
3173 | 
3174 |    tempedge := edge("k", [])
3175 |    currstate := pop(myautomata.states)
3176 |    put(myautomata.states, currstate)
3177 | 
3178 |    while currstate.label ~= 121 do {
3179 |       currstate := pop(myautomata.states)
3180 |       put(myautomata.states, currstate)
3181 |       }
3182 |    put(tempedge.destinations, currstate)
3183 | 
3184 |    put(state2.edges, tempedge)
3185 |    currstate := pop(myautomata.states)
3186 |    put(myautomata.states, currstate)
3187 | 
3188 |    while currstate.label ~= 108 do {
3189 |       currstate := pop(myautomata.states)
3190 |       put(myautomata.states, currstate)
3191 |       }
3192 |    state2 := currstate
3193 | 
3194 |    currstate := pop(myautomata.states)
3195 |    put(myautomata.states, currstate)
3196 | 
3197 |    while currstate.label ~= 109 do {
3198 |       currstate := pop(myautomata.states)
3199 |       put(myautomata.states, currstate)
3200 |       }
3201 |    state2 := currstate
3202 | 
3203 |    currstate := pop(myautomata.states)
3204 |    put(myautomata.states, currstate)
3205 | 
3206 |    while currstate.label ~= 110 do {
3207 |       currstate := pop(myautomata.states)
3208 |       put(myautomata.states, currstate)
3209 |       }
3210 |    state2 := currstate
3211 | 
3212 |    tempedge := edge("l", [])
3213 |    currstate := pop(myautomata.states)
3214 |    put(myautomata.states, currstate)
3215 | 
3216 |    while currstate.label ~= 122 do {
3217 |       currstate := pop(myautomata.states)
3218 |       put(myautomata.states, currstate)
3219 |       }
3220 |    put(tempedge.destinations, currstate)
3221 | 
3222 |    put(state2.edges, tempedge)
3223 |    currstate := pop(myautomata.states)
3224 |    put(myautomata.states, currstate)
3225 | 
3226 |    while currstate.label ~= 111 do {
3227 |       currstate := pop(myautomata.states)
3228 |       put(myautomata.states, currstate)
3229 |       }
3230 |    state2 := currstate
3231 | 
3232 |    tempedge := edge("e", [])
3233 |    currstate := pop(myautomata.states)
3234 |    put(myautomata.states, currstate)
3235 | 
3236 |    while currstate.label ~= 123 do {
3237 |       currstate := pop(myautomata.states)
3238 |       put(myautomata.states, currstate)
3239 |       }
3240 |    put(tempedge.destinations, currstate)
3241 | 
3242 |    put(state2.edges, tempedge)
3243 |    currstate := pop(myautomata.states)
3244 |    put(myautomata.states, currstate)
3245 | 
3246 |    while currstate.label ~= 112 do {
3247 |       currstate := pop(myautomata.states)
3248 |       put(myautomata.states, currstate)
3249 |       }
3250 |    state2 := currstate
3251 | 
3252 |    currstate := pop(myautomata.states)
3253 |    put(myautomata.states, currstate)
3254 | 
3255 |    while currstate.label ~= 113 do {
3256 |       currstate := pop(myautomata.states)
3257 |       put(myautomata.states, currstate)
3258 |       }
3259 |    state2 := currstate
3260 | 
3261 |    tempedge := edge("s", [])
3262 |    currstate := pop(myautomata.states)
3263 |    put(myautomata.states, currstate)
3264 | 
3265 |    while currstate.label ~= 124 do {
3266 |       currstate := pop(myautomata.states)
3267 |       put(myautomata.states, currstate)
3268 |       }
3269 |    put(tempedge.destinations, currstate)
3270 | 
3271 |    put(state2.edges, tempedge)
3272 |    currstate := pop(myautomata.states)
3273 |    put(myautomata.states, currstate)
3274 | 
3275 |    while currstate.label ~= 114 do {
3276 |       currstate := pop(myautomata.states)
3277 |       put(myautomata.states, currstate)
3278 |       }
3279 |    state2 := currstate
3280 | 
3281 |    tempedge := edge("n", [])
3282 |    currstate := pop(myautomata.states)
3283 |    put(myautomata.states, currstate)
3284 | 
3285 |    while currstate.label ~= 125 do {
3286 |       currstate := pop(myautomata.states)
3287 |       put(myautomata.states, currstate)
3288 |       }
3289 |    put(tempedge.destinations, currstate)
3290 | 
3291 |    put(state2.edges, tempedge)
3292 |    currstate := pop(myautomata.states)
3293 |    put(myautomata.states, currstate)
3294 | 
3295 |    while currstate.label ~= 115 do {
3296 |       currstate := pop(myautomata.states)
3297 |       put(myautomata.states, currstate)
3298 |       }
3299 |    state2 := currstate
3300 | 
3301 |    tempedge := edge("i", [])
3302 |    currstate := pop(myautomata.states)
3303 |    put(myautomata.states, currstate)
3304 | 
3305 |    while currstate.label ~= 126 do {
3306 |       currstate := pop(myautomata.states)
3307 |       put(myautomata.states, currstate)
3308 |       }
3309 |    put(tempedge.destinations, currstate)
3310 | 
3311 |    put(state2.edges, tempedge)
3312 |    currstate := pop(myautomata.states)
3313 |    put(myautomata.states, currstate)
3314 | 
3315 |    while currstate.label ~= 116 do {
3316 |       currstate := pop(myautomata.states)
3317 |       put(myautomata.states, currstate)
3318 |       }
3319 |    state2 := currstate
3320 | 
3321 |    tempedge := edge(csetfromrecset("[^*]"), [])
3322 |    currstate := pop(myautomata.states)
3323 |    put(myautomata.states, currstate)
3324 | 
3325 |    while currstate.label ~= 92 do {
3326 |       currstate := pop(myautomata.states)
3327 |       put(myautomata.states, currstate)
3328 |       }
3329 |    put(tempedge.destinations, currstate)
3330 | 
3331 |    put(state2.edges, tempedge)
3332 |    tempedge := edge("*", [])
3333 |    currstate := pop(myautomata.states)
3334 |    put(myautomata.states, currstate)
3335 | 
3336 |    while currstate.label ~= 93 do {
3337 |       currstate := pop(myautomata.states)
3338 |       put(myautomata.states, currstate)
3339 |       }
3340 |    put(tempedge.destinations, currstate)
3341 | 
3342 |    put(state2.edges, tempedge)
3343 |    currstate := pop(myautomata.states)
3344 |    put(myautomata.states, currstate)
3345 | 
3346 |    while currstate.label ~= 117 do {
3347 |       currstate := pop(myautomata.states)
3348 |       put(myautomata.states, currstate)
3349 |       }
3350 |    state2 := currstate
3351 | 
3352 |    currstate := pop(myautomata.states)
3353 |    put(myautomata.states, currstate)
3354 | 
3355 |    while currstate.label ~= 118 do {
3356 |       currstate := pop(myautomata.states)
3357 |       put(myautomata.states, currstate)
3358 |       }
3359 |    state2 := currstate
3360 | 
3361 |    currstate := pop(myautomata.states)
3362 |    put(myautomata.states, currstate)
3363 | 
3364 |    while currstate.label ~= 119 do {
3365 |       currstate := pop(myautomata.states)
3366 |       put(myautomata.states, currstate)
3367 |       }
3368 |    state2 := currstate
3369 | 
3370 |    tempedge := edge("c", [])
3371 |    currstate := pop(myautomata.states)
3372 |    put(myautomata.states, currstate)
3373 | 
3374 |    while currstate.label ~= 127 do {
3375 |       currstate := pop(myautomata.states)
3376 |       put(myautomata.states, currstate)
3377 |       }
3378 |    put(tempedge.destinations, currstate)
3379 | 
3380 |    put(state2.edges, tempedge)
3381 |    currstate := pop(myautomata.states)
3382 |    put(myautomata.states, currstate)
3383 | 
3384 |    while currstate.label ~= 120 do {
3385 |       currstate := pop(myautomata.states)
3386 |       put(myautomata.states, currstate)
3387 |       }
3388 |    state2 := currstate
3389 | 
3390 |    tempedge := edge("n", [])
3391 |    currstate := pop(myautomata.states)
3392 |    put(myautomata.states, currstate)
3393 | 
3394 |    while currstate.label ~= 128 do {
3395 |       currstate := pop(myautomata.states)
3396 |       put(myautomata.states, currstate)
3397 |       }
3398 |    put(tempedge.destinations, currstate)
3399 | 
3400 |    put(state2.edges, tempedge)
3401 |    currstate := pop(myautomata.states)
3402 |    put(myautomata.states, currstate)
3403 | 
3404 |    while currstate.label ~= 121 do {
3405 |       currstate := pop(myautomata.states)
3406 |       put(myautomata.states, currstate)
3407 |       }
3408 |    state2 := currstate
3409 | 
3410 |    currstate := pop(myautomata.states)
3411 |    put(myautomata.states, currstate)
3412 | 
3413 |    while currstate.label ~= 122 do {
3414 |       currstate := pop(myautomata.states)
3415 |       put(myautomata.states, currstate)
3416 |       }
3417 |    state2 := currstate
3418 | 
3419 |    tempedge := edge("e", [])
3420 |    currstate := pop(myautomata.states)
3421 |    put(myautomata.states, currstate)
3422 | 
3423 |    while currstate.label ~= 129 do {
3424 |       currstate := pop(myautomata.states)
3425 |       put(myautomata.states, currstate)
3426 |       }
3427 |    put(tempedge.destinations, currstate)
3428 | 
3429 |    put(state2.edges, tempedge)
3430 |    currstate := pop(myautomata.states)
3431 |    put(myautomata.states, currstate)
3432 | 
3433 |    while currstate.label ~= 123 do {
3434 |       currstate := pop(myautomata.states)
3435 |       put(myautomata.states, currstate)
3436 |       }
3437 |    state2 := currstate
3438 | 
3439 |    currstate := pop(myautomata.states)
3440 |    put(myautomata.states, currstate)
3441 | 
3442 |    while currstate.label ~= 124 do {
3443 |       currstate := pop(myautomata.states)
3444 |       put(myautomata.states, currstate)
3445 |       }
3446 |    state2 := currstate
3447 | 
3448 |    currstate := pop(myautomata.states)
3449 |    put(myautomata.states, currstate)
3450 | 
3451 |    while currstate.label ~= 125 do {
3452 |       currstate := pop(myautomata.states)
3453 |       put(myautomata.states, currstate)
3454 |       }
3455 |    state2 := currstate
3456 | 
3457 |    tempedge := edge("g", [])
3458 |    currstate := pop(myautomata.states)
3459 |    put(myautomata.states, currstate)
3460 | 
3461 |    while currstate.label ~= 130 do {
3462 |       currstate := pop(myautomata.states)
3463 |       put(myautomata.states, currstate)
3464 |       }
3465 |    put(tempedge.destinations, currstate)
3466 | 
3467 |    put(state2.edges, tempedge)
3468 |    currstate := pop(myautomata.states)
3469 |    put(myautomata.states, currstate)
3470 | 
3471 |    while currstate.label ~= 126 do {
3472 |       currstate := pop(myautomata.states)
3473 |       put(myautomata.states, currstate)
3474 |       }
3475 |    state2 := currstate
3476 | 
3477 |    tempedge := edge("c", [])
3478 |    currstate := pop(myautomata.states)
3479 |    put(myautomata.states, currstate)
3480 | 
3481 |    while currstate.label ~= 131 do {
3482 |       currstate := pop(myautomata.states)
3483 |       put(myautomata.states, currstate)
3484 |       }
3485 |    put(tempedge.destinations, currstate)
3486 | 
3487 |    put(state2.edges, tempedge)
3488 |    currstate := pop(myautomata.states)
3489 |    put(myautomata.states, currstate)
3490 | 
3491 |    while currstate.label ~= 127 do {
3492 |       currstate := pop(myautomata.states)
3493 |       put(myautomata.states, currstate)
3494 |       }
3495 |    state2 := currstate
3496 | 
3497 |    currstate := pop(myautomata.states)
3498 |    put(myautomata.states, currstate)
3499 | 
3500 |    while currstate.label ~= 128 do {
3501 |       currstate := pop(myautomata.states)
3502 |       put(myautomata.states, currstate)
3503 |       }
3504 |    state2 := currstate
3505 | 
3506 |    currstate := pop(myautomata.states)
3507 |    put(myautomata.states, currstate)
3508 | 
3509 |    while currstate.label ~= 129 do {
3510 |       currstate := pop(myautomata.states)
3511 |       put(myautomata.states, currstate)
3512 |       }
3513 |    state2 := currstate
3514 | 
3515 |    currstate := pop(myautomata.states)
3516 |    put(myautomata.states, currstate)
3517 | 
3518 |    while currstate.label ~= 130 do {
3519 |       currstate := pop(myautomata.states)
3520 |       put(myautomata.states, currstate)
3521 |       }
3522 |    state2 := currstate
3523 | 
3524 |    currstate := pop(myautomata.states)
3525 |    put(myautomata.states, currstate)
3526 | 
3527 |    while currstate.label ~= 131 do {
3528 |       currstate := pop(myautomata.states)
3529 |       put(myautomata.states, currstate)
3530 |       }
3531 |    state2 := currstate
3532 | 
3533 |    init_semantic_actions()
3534 |    }
3535 | 
3536 |    return yyulex(myautomata)
3537 | 
3538 | end
3539 | 
3540 | procedure init_semantic_actions()
3541 | 
3542 |    semantic_action := table()
3543 |    semantic_action[1] := semantic_action_1
3544 |    semantic_action[2] := semantic_action_2
3545 |    semantic_action[3] := semantic_action_3
3546 |    semantic_action[4] := semantic_action_4
3547 |    semantic_action[5] := semantic_action_5
3548 |    semantic_action[6] := semantic_action_6
3549 |    semantic_action[7] := semantic_action_7
3550 |    semantic_action[8] := semantic_action_8
3551 |    semantic_action[9] := semantic_action_9
3552 |    semantic_action[10] := semantic_action_10
3553 |    semantic_action[11] := semantic_action_11
3554 |    semantic_action[12] := semantic_action_12
3555 |    semantic_action[13] := semantic_action_13
3556 |    semantic_action[14] := semantic_action_14
3557 |    semantic_action[15] := semantic_action_15
3558 |    semantic_action[16] := semantic_action_16
3559 |    semantic_action[17] := semantic_action_17
3560 |    semantic_action[18] := semantic_action_18
3561 |    semantic_action[19] := semantic_action_19
3562 |    semantic_action[20] := semantic_action_20
3563 |    semantic_action[21] := semantic_action_21
3564 |    semantic_action[22] := semantic_action_22
3565 |    semantic_action[23] := semantic_action_23
3566 |    semantic_action[24] := semantic_action_24
3567 |    semantic_action[25] := semantic_action_25
3568 |    semantic_action[26] := semantic_action_26
3569 |    semantic_action[27] := semantic_action_27
3570 |    semantic_action[28] := semantic_action_28
3571 |    semantic_action[29] := semantic_action_29
3572 |    semantic_action[30] := semantic_action_30
3573 |    semantic_action[31] := semantic_action_31
3574 |    semantic_action[32] := semantic_action_32
3575 |    semantic_action[33] := semantic_action_33
3576 |    semantic_action[34] := semantic_action_34
3577 |    semantic_action[35] := semantic_action_35
3578 |    semantic_action[36] := semantic_action_36
3579 |    semantic_action[37] := semantic_action_37
3580 |    semantic_action[38] := semantic_action_38
3581 |    semantic_action[39] := semantic_action_39
3582 |    semantic_action[40] := semantic_action_40
3583 |    semantic_action[41] := semantic_action_41
3584 |    semantic_action[42] := semantic_action_42
3585 |    semantic_action[43] := semantic_action_43
3586 |    semantic_action[44] := semantic_action_44
3587 |    semantic_action[45] := semantic_action_45
3588 |    semantic_action[46] := semantic_action_46
3589 |    semantic_action[47] := semantic_action_47
3590 |    semantic_action[48] := semantic_action_48
3591 |    semantic_action[49] := semantic_action_49
3592 |    semantic_action[50] := semantic_action_50
3593 |    semantic_action[51] := semantic_action_51
3594 |    semantic_action[52] := semantic_action_52
3595 |    semantic_action[53] := semantic_action_53
3596 |    semantic_action[54] := semantic_action_54
3597 | 
3598 | end
3599 | 
3600 | procedure semantic_action_3()
3601 |    { j0.whitespace(); }
3602 | end
3603 | 
3604 | procedure semantic_action_4()
3605 |    { j0.newline(); }
3606 | end
3607 | 
3608 | procedure semantic_action_22()
3609 |    { return j0.scan(j0.ord("("));}
3610 | end
3611 | 
3612 | procedure semantic_action_23()
3613 |    { return j0.scan(j0.ord(")"));}
3614 | end
3615 | 
3616 | procedure semantic_action_24()
3617 |    { return j0.scan(j0.ord("["));}
3618 | end
3619 | 
3620 | procedure semantic_action_25()
3621 |    { return j0.scan(j0.ord("]"));}
3622 | end
3623 | 
3624 | procedure semantic_action_26()
3625 |    { return j0.scan(j0.ord("{"));}
3626 | end
3627 | 
3628 | procedure semantic_action_27()
3629 |    { return j0.scan(j0.ord("}"));}
3630 | end
3631 | 
3632 | procedure semantic_action_28()
3633 |    { return j0.scan(j0.ord(";"));}
3634 | end
3635 | 
3636 | procedure semantic_action_29()
3637 |    { return j0.scan(j0.ord(":"));}
3638 | end
3639 | 
3640 | procedure semantic_action_31()
3641 |    { return j0.scan(j0.ord("*"));}
3642 | end
3643 | 
3644 | procedure semantic_action_32()
3645 |    { return j0.scan(j0.ord("/"));}
3646 | end
3647 | 
3648 | procedure semantic_action_33()
3649 |    { return j0.scan(j0.ord("%"));}
3650 | end
3651 | 
3652 | procedure semantic_action_36()
3653 |    { return j0.scan(j0.ord("<"));}
3654 | end
3655 | 
3656 | procedure semantic_action_38()
3657 |    { return j0.scan(j0.ord(">"));}
3658 | end
3659 | 
3660 | procedure semantic_action_30()
3661 |    { return j0.scan(j0.ord("!"));}
3662 | end
3663 | 
3664 | procedure semantic_action_34()
3665 |    { return j0.scan(j0.ord("+"));}
3666 | end
3667 | 
3668 | procedure semantic_action_35()
3669 |    { return j0.scan(j0.ord("-"));}
3670 | end
3671 | 
3672 | procedure semantic_action_44()
3673 |    { return j0.scan(j0.ord("=")); }
3674 | end
3675 | 
3676 | procedure semantic_action_47()
3677 |    { return j0.scan(j0.ord(",")); }
3678 | end
3679 | 
3680 | procedure semantic_action_49()
3681 |    { return j0.scan(parser.IDENTIFIER); }
3682 | end
3683 | 
3684 | procedure semantic_action_48()
3685 |    { return j0.scan(j0.ord(".")); }
3686 | end
3687 | 
3688 | procedure semantic_action_50()
3689 |    { return j0.scan(parser.INTLIT); }
3690 | end
3691 | 
3692 | procedure semantic_action_54()
3693 |    { j0.lexErr("unrecognized character"); }
3694 | end
3695 | 
3696 | procedure semantic_action_10()
3697 |    { return j0.scan(parser.IF); }
3698 | end
3699 | 
3700 | procedure semantic_action_37()
3701 |    { return j0.scan(parser.LESSTHANOREQUAL);}
3702 | end
3703 | 
3704 | procedure semantic_action_39()
3705 |    { return j0.scan(parser.GREATERTHANOREQUAL);}
3706 | end
3707 | 
3708 | procedure semantic_action_41()
3709 |    { return j0.scan(parser.NOTEQUALTO);}
3710 | end
3711 | 
3712 | procedure semantic_action_42()
3713 |    { return j0.scan(parser.LOGICALAND);}
3714 | end
3715 | 
3716 | procedure semantic_action_43()
3717 |    { return j0.scan(parser.LOGICALOR);}
3718 | end
3719 | 
3720 | procedure semantic_action_45()
3721 |    { return j0.scan(parser.INCREMENT); }
3722 | end
3723 | 
3724 | procedure semantic_action_46()
3725 |    { return j0.scan(parser.DECREMENT); }
3726 | end
3727 | 
3728 | procedure semantic_action_40()
3729 |    { return j0.scan(parser.ISEQUALTO);}
3730 | end
3731 | 
3732 | procedure semantic_action_53()
3733 |    { return j0.scan(parser.STRINGLIT); }
3734 | end
3735 | 
3736 | procedure semantic_action_9()
3737 |    { return j0.scan(parser.FOR); }
3738 | end
3739 | 
3740 | procedure semantic_action_11()
3741 |    { return j0.scan(parser.INT); }
3742 | end
3743 | 
3744 | procedure semantic_action_2()
3745 |    { j0.comment(); }
3746 | end
3747 | 
3748 | procedure semantic_action_51()
3749 |    { return j0.scan(parser.DOUBLELIT); }
3750 | end
3751 | 
3752 | procedure semantic_action_52()
3753 |    { return j0.scan(parser.DOUBLELIT); }
3754 | end
3755 | 
3756 | procedure semantic_action_12()
3757 |    { return j0.scan(parser.NULLVAL); }
3758 | end
3759 | 
3760 | procedure semantic_action_17()
3761 |    { return j0.scan(parser.BOOLLIT); }
3762 | end
3763 | 
3764 | procedure semantic_action_18()
3765 |    { return j0.scan(parser.BOOL); }
3766 | end
3767 | 
3768 | procedure semantic_action_19()
3769 |    { return j0.scan(parser.VOID); }
3770 | end
3771 | 
3772 | procedure semantic_action_7()
3773 |    { return j0.scan(parser.ELSE); }
3774 | end
3775 | 
3776 | procedure semantic_action_1()
3777 |    { j0.comment(); }
3778 | end
3779 | 
3780 | procedure semantic_action_8()
3781 |    { return j0.scan(parser.BOOLLIT); }
3782 | end
3783 | 
3784 | procedure semantic_action_5()
3785 |    { return j0.scan(parser.BREAK); }
3786 | end
3787 | 
3788 | procedure semantic_action_20()
3789 |    { return j0.scan(parser.WHILE); }
3790 | end
3791 | 
3792 | procedure semantic_action_21()
3793 |    { return j0.scan(parser.CLASS); }
3794 | end
3795 | 
3796 | procedure semantic_action_13()
3797 |    { return j0.scan(parser.PUBLIC); }
3798 | end
3799 | 
3800 | procedure semantic_action_14()
3801 |    { return j0.scan(parser.RETURN); }
3802 | end
3803 | 
3804 | procedure semantic_action_6()
3805 |    { return j0.scan(parser.DOUBLE); }
3806 | end
3807 | 
3808 | procedure semantic_action_16()
3809 |    { return j0.scan(parser.STRING); }
3810 | end
3811 | 
3812 | procedure semantic_action_15()
3813 |    { return j0.scan(parser.STATIC); }
3814 | end
3815 | 
3816 | 


--------------------------------------------------------------------------------
/ch7/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "null"                 { return j0.scan(parser.NULLVAL); }
18 | "public"               { return j0.scan(parser.PUBLIC); }
19 | "return"               { return j0.scan(parser.RETURN); }
20 | "static"               { return j0.scan(parser.STATIC); }
21 | "string"               { return j0.scan(parser.STRING); }
22 | "true"                 { return j0.scan(parser.BOOLLIT); }
23 | "bool"                 { return j0.scan(parser.BOOL); }
24 | "void"                 { return j0.scan(parser.VOID); }
25 | "while"                { return j0.scan(parser.WHILE); }
26 | "class"                { return j0.scan(parser.CLASS); }
27 | "("                    { return j0.scan(j0.ord("("));}
28 | ")"                    { return j0.scan(j0.ord(")"));}
29 | "["                    { return j0.scan(j0.ord("["));}
30 | "]"                    { return j0.scan(j0.ord("]"));}
31 | "{"                    { return j0.scan(j0.ord("{"));}
32 | "}"                    { return j0.scan(j0.ord("}"));}
33 | ";"                    { return j0.scan(j0.ord(";"));}
34 | ":"                    { return j0.scan(j0.ord(":"));}
35 | "!"                    { return j0.scan(j0.ord("!"));}
36 | "*"                    { return j0.scan(j0.ord("*"));}
37 | "/"                    { return j0.scan(j0.ord("/"));}
38 | "%"                    { return j0.scan(j0.ord("%"));}
39 | "+"                    { return j0.scan(j0.ord("+"));}
40 | "-"                    { return j0.scan(j0.ord("-"));}
41 | "<"                    { return j0.scan(j0.ord("<"));}
42 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
43 | ">"                    { return j0.scan(j0.ord(">"));}
44 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
45 | "=="                   { return j0.scan(parser.ISEQUALTO);}
46 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
47 | "&&"                   { return j0.scan(parser.LOGICALAND);}
48 | "||"                   { return j0.scan(parser.LOGICALOR);}
49 | "="                    { return j0.scan(j0.ord("=")); }
50 | "+="                   { return j0.scan(parser.INCREMENT); }
51 | "-="                   { return j0.scan(parser.DECREMENT); }
52 | ","                    { return j0.scan(j0.ord(",")); }
53 | "."                    { return j0.scan(j0.ord(".")); }
54 | {id}                   { return j0.scan(parser.IDENTIFIER); }
55 | [0-9]+                 { return j0.scan(parser.INTLIT); }
56 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
57 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
58 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
59 | .                      { j0.lexErr("unrecognized character"); }
60 | 


--------------------------------------------------------------------------------
/ch7/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u typeinfo.u
 6 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU)
 7 | unicon: j0
 8 | %.u : %.icn
 9 | 	unicon -c 
lt;
10 | j0: $(U)
11 | 	unicon $(U)
12 | javalex.icn: javalex.l
13 | 	uflex javalex.l
14 | j0gram.icn j0gram_tab.icn: j0gram.y
15 | 	iyacc -dd j0gram.y
16 | 
17 | # A typical run might use
18 | # set CLASSPATH=".;c:\users\username\byopl"
19 | # in order to run from c:\users\username\byopl\ch7
20 | LYSRC=Yylex.java parser.java parserVal.java
21 | TPJ=typeinfo.java arraytype.java classtype.java methodtype.java parameter.java
22 | STJ=symtab.java symtab_entry.java $(TPJ)
23 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ)
24 | BYJOPTS= -Jclass=parser -Jpackage=ch7
25 | BYJIMPS= -Jyylex=ch7.j0.yylex -Jyyerror=ch7.yyerror.yyerror
26 | java: j0.class
27 | 
28 | j: java
29 | 	java ch7.j0 hello.java
30 | 	dot -Tpng hello.java.dot >hello.png
31 | 
32 | j0.class: $(JSRC)
33 | 	javac $(JSRC)
34 | parser.java parserVal.java: j0gram.y
35 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
36 | Yylex.java: javalex.l
37 | 	jflex javalex.l
38 | 
39 | 


--------------------------------------------------------------------------------
/ch7/methodtype.java:
--------------------------------------------------------------------------------
1 | package ch7;
2 | public class methodtype extends typeinfo {
3 |    parameter [] parameters;
4 |    typeinfo return_type;
5 |    methodtype(parameter [] p, typeinfo rt){
6 |       parameters = p; return_type = rt;
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch7/parameter.java:
--------------------------------------------------------------------------------
1 | package ch7;
2 | public class parameter {
3 |    String name;
4 |    typeinfo param_type;
5 |    parameter(String s, typeinfo t) { name=s; param_type=t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch7/parserVal.java:
--------------------------------------------------------------------------------
 1 | //#############################################
 2 | //## file: parser.java
 3 | //## Generated by Byacc/j
 4 | //#############################################
 5 | package ch7;
 6 | 
 7 | /**
 8 |  * BYACC/J Semantic Value for parser: parser
 9 |  * This class provides some of the functionality
10 |  * of the yacc/C 'union' directive
11 |  */
12 | public class parserVal
13 | {
14 | /**
15 |  * integer value of this 'union'
16 |  */
17 | public int ival;
18 | 
19 | /**
20 |  * double value of this 'union'
21 |  */
22 | public double dval;
23 | 
24 | /**
25 |  * string value of this 'union'
26 |  */
27 | public String sval;
28 | 
29 | /**
30 |  * object value of this 'union'
31 |  */
32 | public Object obj;
33 | 
34 | //#############################################
35 | //## C O N S T R U C T O R S
36 | //#############################################
37 | /**
38 |  * Initialize me without a value
39 |  */
40 | public parserVal()
41 | {
42 | }
43 | /**
44 |  * Initialize me as an int
45 |  */
46 | public parserVal(int val)
47 | {
48 |   ival=val;
49 | }
50 | 
51 | /**
52 |  * Initialize me as a double
53 |  */
54 | public parserVal(double val)
55 | {
56 |   dval=val;
57 | }
58 | 
59 | /**
60 |  * Initialize me as a string
61 |  */
62 | public parserVal(String val)
63 | {
64 |   sval=val;
65 | }
66 | 
67 | /**
68 |  * Initialize me as an Object
69 |  */
70 | public parserVal(Object val)
71 | {
72 |   obj=val;
73 | }
74 | }//end class
75 | 
76 | //#############################################
77 | //## E N D    O F    F I L E
78 | //#############################################
79 | 


--------------------------------------------------------------------------------
/ch7/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch7/serial.java:
--------------------------------------------------------------------------------
1 | package ch7;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch7/symtab.icn:
--------------------------------------------------------------------------------
 1 | class symtab(scope, parent, t)
 2 |   method lookup(s)
 3 |     return if rv := \ (t[s]) then {
 4 |               rv }
 5 |            else {
 6 |              (\parent).lookup(s)
 7 |              }
 8 |   end
 9 |   method insert(s, isConst, sub, typ)
10 |       if \ (t[s]) then j0.semerror("redeclaration of " || s)
11 |       else { (\sub).parent := self
12 |              t[s] := symtab_entry(s, self, sub, isConst, typ) }
13 |   end
14 |   method print(level:0)
15 |     writes(repl(" ",level))
16 |     write(scope, " - ", *t, " symbols")
17 |     every (!t).print(level+1);
18 |   end
19 | 
20 | initially
21 |   t := table()
22 | end
23 | 


--------------------------------------------------------------------------------
/ch7/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | import java.util.HashMap;
 3 | public class symtab {
 4 |    String scope;
 5 |    symtab parent;
 6 |    HashMap<String,symtab_entry> t;
 7 |    symtab(String sc) {
 8 |       scope = sc;
 9 |       t = new HashMap<String,symtab_entry>();
10 |    }
11 |     symtab(String sc, symtab p) {
12 |       scope = sc; parent = p;
13 |       t = new HashMap<String,symtab_entry>();
14 |    }
15 |    symtab_entry lookup(String s) {
16 |        symtab_entry rv;
17 |        rv = t.get(s);
18 |        if (rv != null) {
19 | 	   return rv;
20 |        }
21 |       if (parent != null) return parent.lookup(s);
22 |       return null;
23 |    }
24 |    void insert(String s, Boolean iC, symtab sub, typeinfo typ) {
25 |       if (t.containsKey(s)) {
26 |          j0.semerror("redeclaration of " + s);
27 |       } else {
28 |          if (sub != null)
29 |             sub.parent = this;
30 |          t.put(s, new symtab_entry(s, this, iC, sub, typ));
31 |       }
32 |    }
33 |    void insert(String s, Boolean iC) {
34 |       if (t.containsKey(s)) {
35 |          j0.semerror("redeclaration of " + s);
36 |       } else {
37 |          t.put(s, new symtab_entry(s, this, iC));
38 |       }
39 |    }
40 |    void print() { print(0); }
41 |    void print(int level) {
42 |       for(int i=0; i<level; i++)
43 |         System.out.print(" ");
44 |       System.out.println(scope + " - " + t.size() + " symbols");
45 |       for(symtab_entry se : t.values()) se.print(level+1);
46 |    }
47 | }
48 | 


--------------------------------------------------------------------------------
/ch7/symtab_entry.icn:
--------------------------------------------------------------------------------
1 | class symtab_entry(sym,parent_st,st,isConst,typ)
2 |   method print(level:0)
3 |     writes(repl(" ",level), sym)
4 |     if \isconst then writes(" (const)")
5 |     write()
6 |     (\st).print(level+1);
7 |   end
8 | end
9 | 


--------------------------------------------------------------------------------
/ch7/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    typeinfo typ;
 7 |    void print(int level) {
 8 |       for(int i=0; i<level; i++) System.out.print(" ");
 9 |       System.out.print(sym);
10 |       if (isConst) System.out.print(" (const)");
11 |       System.out.println("");
12 |       if (st != null) st.print(level+1);
13 |    }
14 |    symtab_entry(String s, symtab p, boolean iC) {
15 |        sym = s; parent_st = p; isConst = iC; }
16 |    symtab_entry(String s, symtab p, boolean iC, symtab t, typeinfo ti) {
17 |       sym = s; parent_st = p; isConst = iC; st = t; typ = ti;
18 |  }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch7/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval, typ)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | method type(stab)
21 |   if \typ then return typ
22 |   if cat === parser.IDENTIFIER then
23 |     if rv := stab.lookup(text) then return typ := rv.typ
24 |   stop("cannot check the type of ", image(text))
25 | end
26 | initially
27 |    case cat of {
28 |      parser.INTLIT: { ival := integer(text); typ:=typeinfo("int") }
29 |      parser.DOUBLELIT: { dval := real(text); typ:=typeinfo("double") }
30 |      parser.STRINGLIT: { sval := deEscape(text); typ:=typeinfo("String") }
31 |      parser.BOOLLIT: { typ := typeinfo("boolean") }
32 |      parser.NULLVAL: { typ :=  typeinfo("null") }
33 |      ord("="|"+"|"-"): { typ := typeinfo("n/a") }
34 |    }
35 | end
36 | 


--------------------------------------------------------------------------------
/ch7/token.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | public class token {
 3 |   public int id;
 4 |   public int cat;
 5 |   public String text;
 6 |   public int lineno;
 7 |   public typeinfo typ;
 8 |   public token(int c, String s, int l) {
 9 |     cat = c; text = s; lineno = l;
10 |     id = serial.getid();
11 |     switch (cat) {
12 |     case parser.INTLIT: typ = new typeinfo("int"); break;
13 |     case parser.DOUBLELIT: typ = new typeinfo("double"); break;
14 |     case parser.STRINGLIT: typ = new typeinfo("String"); break;
15 |     case parser.BOOLLIT: typ = new typeinfo("boolean"); break;
16 |     case parser.NULLVAL: typ = new typeinfo("null"); break;
17 |     case '=': case '+': case '-': typ = new typeinfo("n/a"); break;
18 |     }
19 |    }
20 | public typeinfo type(symtab stab) {
21 |   symtab_entry rv;
22 |   if (typ != null) return typ;
23 |   if (cat == parser.IDENTIFIER)
24 |       if ((rv = stab.lookup(text)) != null) return typ=rv.typ;
25 |   j0.semerror("cannot check the type of " + text);
26 |   return null;
27 | }
28 | }
29 | 


--------------------------------------------------------------------------------
/ch7/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab,typ)
  2 |   method print(level:0)
  3 |     writes(repl(" ",level))
  4 |     if \tok then {
  5 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  6 |       }
  7 |     else {
  8 |        write(id, "   ", sym, " (", rule, "): ", nkids)
  9 |        every (!kids).print(level+1)
 10 |        }
 11 |   end
 12 |   method print_graph(fw)
 13 |     if type(filename) == "string" then {
 14 |       fw := open(filename,  "w") |
 15 |         stop("can't open ", image(filename), " for writing")
 16 |       write(fw, "digraph {")
 17 |       print_graph(fw)
 18 |       write(fw, "}")
 19 |       close(fw)
 20 |     }
 21 |     else if \tok then print_leaf(fw)
 22 |     else { 
 23 |       print_branch(fw)
 24 |       every i := 1 to nkids do
 25 |         if \kids[i] then {
 26 |           write(fw, "N",id," -> N",kids[i].id,";")
 27 |           kids[i].print_graph(fw)
 28 |         } else {
 29 |           write(fw, "N",id," -> N",id,"_",j,";")
 30 |           write(fw, "N", id, "_", j,
 31 |                     " [label=\"Empty rule\"];")
 32 |           j +:= 1
 33 |         }
 34 |     }
 35 |   end
 36 |   method print_leaf(pw)
 37 |     local s := parser.yyname[tok.cat]
 38 |     print_branch(pw)
 39 |     write(pw,"N",id,
 40 |           " [shape=box style=dotted label=\" ",s," \\n ")
 41 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 42 |              tok.lineno," \\l\"];\n")
 43 |   end
 44 |   method print_branch(pw)
 45 |     write(pw, "N",id," [shape=box label=\"",
 46 |           pretty_print_name(),"\"];\n");
 47 |   end
 48 |   method escape(s)
 49 |     if s[1] == "\"" then
 50 |       return "\\" || s[1:-1] || "\\\""
 51 |     else return s
 52 |   end
 53 |   method pretty_print_name()
 54 |     if /tok then return sym || "#" || (rule%10)
 55 |     else return escape(tok.text) || ":" || tok.cat
 56 |   end
 57 |   method mkSymTables(curr)
 58 |     stab := curr
 59 |     case sym of {
 60 |       "ClassDecl": { curr := symtab("class",curr) }
 61 |       "MethodDecl": { curr := symtab("method",curr) }
 62 |     }
 63 |     every (!\kids).mkSymTables(curr)
 64 |   end
 65 |   method populateSymTables()
 66 |   case sym of {
 67 |     "ClassDecl": {
 68 |        stab.insert(kids[1].tok.text, , kids[1].stab)
 69 |        }
 70 |     "FieldDecl" | "LocalVarDecl" : {
 71 |        k := kids[2]
 72 |        while \k & k.sym=="VarDecls" do {
 73 |          insert_vardeclarator(k.kids[2])
 74 |          k := k.kids[1]
 75 |          }
 76 |        insert_vardeclarator(k); return
 77 |        }
 78 |     "MethodDecl": {
 79 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab)
 80 |       }
 81 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 82 |     }
 83 |     every (!\kids).populateSymTables()
 84 |   end
 85 |   method insert_vardeclarator(vd)
 86 |    if \vd.tok then stab.insert(vd.tok.text,&null,&null,vd.typ)
 87 |    else insert_vardeclarator(vd.kids[1])
 88 |   end
 89 |   method calc_isConst()
 90 |    case sym of {
 91 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 92 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 93 |       "UnaryExpr": isConst := \kid[2].isConst
 94 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 95 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
 96 |       "MULEXPR"|
 97 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
 98 |       default: isConst := &null
 99 |    }
100 |    every (!\kids).calc_isConst()
101 |   end
102 |   method checkSymTables()
103 |     check_codeblocks()
104 |     
105 |   end
106 |   method check_codeblocks()
107 |    if sym == "MethodDecl" then { kids[2].check_block() }
108 |    else every k := !kids do
109 |          if k.nkids>0 then k.check_codeblocks()
110 |   end
111 |   method check_block()
112 |    case sym of {
113 |    "IDENTIFIER": {
114 |      if not (stab.lookup(tok.text)) then
115 |         j0.semerror("undeclared variable "||tok.text)
116 |      }
117 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
118 |    "MethodCall": {
119 |       kids[1].check_block()
120 |       if rule = 1290 then
121 |          kids[2].check_block()
122 |       else kids[3].check_block()
123 |      }
124 |    "LocalVarDecl": { } # skip
125 |    default:  {
126 |       every k := !\kids do {
127 |             k.check_block()
128 |          }
129 |       }
130 |    }
131 |   end
132 |   # calctype - synthesize the type of a variable declaration
133 |   method calctype()
134 |     every (!\kids).calctype()
135 |     case sym of {
136 |       "FieldDecl": typ := kids[1].typ
137 |       "token": {
138 |          case tok.cat of {
139 |          parser.IDENTIFIER:{ return typ := classtype(tok.text) }
140 |          parser.INT:{ return typ := typeinfo(tok.text) }
141 |          default:
142 |            stop("can't grok the type of ", image(tok.text))
143 |          }
144 |       }
145 |     default:
146 |        stop("can't grok the type of ", image(sym))
147 |     }
148 |   end
149 |   # assigntype - inherit the type of a variable declaration list
150 |   method assigntype(t)
151 |     typ := t
152 |     case sym of {
153 |     "VarDeclarator": { # we have an ARRAY of whatever type t was
154 |       kids[1].assigntype(arraytype(t))
155 |       return
156 |     }
157 |     "token": {
158 |       case tok.cat of {
159 |          parser.IDENTIFIER: return
160 |          default: stop("eh? ", image(tok.cat))
161 |       }
162 |     }
163 |     default:
164 |        stop("don't know how to assign the type of ", image(sym))
165 |     }
166 |     every (!\kids).assigntype(t)
167 |   end
168 | 
169 | method checkkids(in_codeblock)
170 |     case sym of {
171 |        # turn on in executable StmtBlock
172 |        "MethodDecl": { kids[2].checktype(1); return }
173 |        # turn off in LocalVarDecl list...(back on in initializers, if any)
174 |        "LocalVarDecl": { kids[2].checktype(); return }
175 |        "FieldAccess": { kids[1].checktype(in_codeblock);
176 |           return }
177 |         "QualifiedName": { # has to be a type you can . on
178 |            kids[1].checktype(in_codeblock);
179 |        }
180 |        default: { every (!\kids).checktype(in_codeblock) }
181 |        }
182 | end
183 | 
184 |   # checktype - check, and determine, the type of each expression
185 |   method checktype(in_codeblock)
186 |     if checkkids(in_codeblock) then return
187 |     if /in_codeblock then return
188 |     case sym of {
189 |     "Assignment": typ := check_types(kids[1].typ, kids[3].typ)
190 |     "AddExpr": typ := check_types(kids[1].typ, kids[2].typ)
191 |     "Block" | "BlockStmts": { typ := &null }
192 |     "MethodCall": { }
193 |     "QualifiedName": {
194 |        # get my type by look up kid #2 within kid #1
195 |        if type(kids[1].typ) == "classtype__state" then {
196 |          typ := (kids[1].typ.st.lookup(kids[2].tok.text)).typ
197 |        } else stop("illegal type for dot operator: ",kids[1].typ.str())
198 |     }
199 |     "token": typ := tok.type(stab)
200 |     default: stop("cannot check the type of ", image(sym))
201 |     }
202 |   end
203 |    method get_op()
204 |       return case sym of {
205 |           "Assignment" : "="
206 |           "AddExpr": if rule=1320 then "+" else "-"
207 |           default: fail
208 |       }
209 |    end
210 |    method check_types(op1, op2)
211 |       operator := get_op()
212 |       case operator of {
213 |          "="|"+"|"-" : {
214 |             if tok := findatoken() then
215 |                writes("line ", tok.tok.lineno, ": ")
216 |             if op1.basetype === op2.basetype === "int" then {
217 |                write("typecheck ",operator," on a ", op2.str(),
218 | 		      " and a ", op1.str(), " -> OK")
219 |                return op1
220 |                }
221 |             else stop("typecheck ",operator," on a ", op2.str(),
222 | 		      " and a ", op1.str(), " -> FAIL")
223 |             }
224 |          default: stop("don't know how to check ", image(operator))
225 |         }
226 |    end
227 | method findatoken()
228 | if sym==="token" then return self
229 | return (!kids).findatoken()
230 | end
231 | 
232 | initially (s,r,x[])
233 |    id := serial.getid(); sym := s; rule := r
234 |    if type(x[1]) == "token__state" then {
235 |       nkids := 0; tok := x[1]
236 |    } else {
237 |       nkids := *x;
238 |       kids := x
239 |    }
240 | end
241 | 


--------------------------------------------------------------------------------
/ch7/tree.java:
--------------------------------------------------------------------------------
  1 | package ch7;
  2 | import java.io.PrintWriter;
  3 | import java.io.BufferedWriter;
  4 | import java.io.FileWriter;
  5 | class tree {
  6 |   int id, rule, nkids;
  7 |   String sym;
  8 |   token tok;
  9 |   tree kids[];
 10 |   Boolean isConst;
 11 |   symtab stab;
 12 |   typeinfo typ;
 13 | 
 14 |   public String escape(String s) {
 15 |       if (s.charAt(0) == '\"')
 16 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 17 |       else return s;
 18 |   }
 19 | 
 20 |   public String pretty_print_name() {
 21 |     if (tok == null) return sym +"#"+(rule%10);
 22 |     else {
 23 | 	return escape(tok.text)+":"+tok.cat;
 24 | 	}
 25 |     }
 26 | 
 27 |   void print_graph(String filename){
 28 |     try {
 29 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 30 |       pw.printf("digraph {\n");
 31 |       j = 0;
 32 |       print_graph(pw);
 33 |       pw.printf("}\n");
 34 |       pw.close();
 35 |       }
 36 |     catch (java.io.IOException ioException) {
 37 |       System.err.println("printgraph exception");
 38 |       System.exit(1);
 39 |       }
 40 |     }
 41 | 
 42 |   int j;
 43 |   void print_graph(PrintWriter pw) {
 44 |   int i;
 45 |     if (tok != null) {
 46 | 	print_leaf(pw);
 47 |         return;
 48 |     }
 49 |     // from here on out, we know we are not a leaf
 50 |     print_branch(pw);
 51 |     
 52 |     for(i=0; i<nkids; i++) {
 53 |         if (kids[i] != null) {
 54 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 55 | 	    kids[i].print_graph(pw);
 56 |         } else {
 57 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 58 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 59 | 	    j++;
 60 |         }
 61 |     }
 62 |   }
 63 | 
 64 |   void print_leaf(PrintWriter pw) {
 65 |     String s = parser.yyname[tok.cat];
 66 |     print_branch(pw);
 67 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 68 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 69 | 	      escape(tok.text), tok.lineno);
 70 |   }
 71 | 
 72 |   void print_branch(PrintWriter pw) {
 73 |     pw.printf("N%d ",id);
 74 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 75 |     if (tok != null)
 76 | 	pw.printf("struct token* leaf %d", tok.id);
 77 |     pw.printf("\"];\n");
 78 |   }
 79 | 
 80 |   public void print(int level) {
 81 |     int i;
 82 |     for(i=0;i<level;i++) System.out.print(" ");
 83 |     if (tok != null) {
 84 |       System.out.println(id + "   " + tok.text +
 85 |                          " (" + tok.cat + "): "+tok.lineno);
 86 |     }
 87 |     else {
 88 |       System.out.println(id + "   " + sym +
 89 | 			 " (" + rule + "): "+nkids);
 90 |     }
 91 |     for(i=0; i<nkids; i++)
 92 |       kids[i].print(level+1);
 93 |   }
 94 |   public void print() {
 95 |     print(0);
 96 |   }
 97 | 
 98 |   void mkSymTables(symtab curr) {
 99 |    stab = curr;
100 |    switch (sym) {
101 |    case "ClassDecl": curr = new symtab("class", curr); break;
102 |    case "MethodDecl": curr = new symtab("method", curr); break;
103 |    }
104 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
105 |   }
106 | 
107 |   void populateSymTables() {
108 |     switch(sym) {
109 |     case "ClassDecl": {
110 | 	stab.insert(kids[0].tok.text, false, kids[0].stab,
111 | 		    new classtype(kids[0].tok.text, kids[0].stab));
112 |        break;
113 |     }
114 |     case "FieldDecl": case "LocalVarDecl": {
115 |        tree k = kids[1];
116 |        while ((k != null) && k.sym.equals("VarDecls")) {
117 |          insert_vardeclarator(k.kids[1]);
118 |          k = k.kids[0];
119 |          }
120 |        insert_vardeclarator(k); return;
121 |        }
122 |     case "MethodDecl": {
123 | 	String s = kids[0].kids[1].kids[0].tok.text;
124 | 	stab.insert(s, false, kids[0].stab,
125 | 		    new methodtype(null, null));
126 | 	break;
127 |     }
128 |     case "FormalParm": {
129 |       insert_vardeclarator(kids[1]); return;
130 |       }
131 |     }
132 |     if (kids!=null) {
133 | 	for(tree k : kids) {
134 | 	   if (k!=null) {
135 | 	      k.populateSymTables();
136 | 	   }
137 | 	}
138 |     }
139 |   }
140 | 
141 |   void insert_vardeclarator(tree vd) {
142 |     if (vd.tok != null) {
143 |       stab.insert(vd.tok.text, false, null, vd.typ);
144 |       }
145 |     else insert_vardeclarator(vd.kids[0]);
146 |   }
147 | 
148 |   void calc_isConst() {
149 |    switch(sym) {
150 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
151 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
152 |    case "UnaryExpr": isConst = kids[1].isConst; break;
153 |    case "RelExpr":
154 |       isConst = kids[0].isConst && kids[2].isConst; break;
155 |    case "CondOrExpr": case "CondAndExpr":
156 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
157 |       isConst = kids[0].isConst && kids[1].isConst; break;
158 |    default: isConst = false;
159 |    }
160 |    for(int i=0; i <nkids; i++)
161 |       kids[i].calc_isConst();
162 |   }
163 | 
164 |   void checkSymTables() { check_codeblocks(); }
165 |   void check_codeblocks() {
166 |   tree k;
167 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
168 |    else {
169 |       for(int i = 0; i<nkids; i++){
170 |          k = kids[i];
171 |          if (k.nkids>0) k.check_codeblocks();
172 |       }
173 |    }
174 |   }
175 | void check_block() {
176 |    switch (sym) {
177 |    case "IDENTIFIER": {
178 |      if (stab.lookup(tok.text) == null)
179 |         j0.semerror("undeclared variable " + tok.text);
180 |      break;
181 |      }
182 |    case "FieldAccess": case "QualifiedName":
183 |      kids[0].check_block();
184 |      break;
185 |   case "MethodCall": {
186 |       kids[0].check_block();
187 |       if (rule == 1290)
188 |          kids[1].check_block();
189 |       else kids[2].check_block();
190 |       break;
191 |      }
192 |    case "LocalVarDecl": break;
193 |    default:
194 |       for(int i=0;i<nkids;i++)
195 |             kids[i].check_block();
196 |    }
197 |   }
198 | 
199 |   typeinfo calctype() {
200 |     for(int i=0; i<nkids; i++) kids[i].calctype();
201 |     switch (sym) {
202 |       case "FieldDecl": return typ = kids[0].typ;
203 |       case "token": {
204 | 	  switch (tok.cat) {
205 | 	  case parser.IDENTIFIER:{ return typ=new classtype(tok.text); }
206 | 	  case parser.INT: { return typ=new typeinfo(tok.text); }
207 |           default: j0.semerror("can't grok the type of " + tok.text);
208 | 	  }
209 |       }
210 |       default: j0.semerror("don't know how to calctype " + sym);
211 |     }
212 |     return null;
213 |   }
214 | 
215 |   void assigntype(typeinfo t) {
216 |     typ = t;
217 |     switch (sym) {
218 |     case "VarDeclarator": {
219 |       kids[0].assigntype(new arraytype(t));
220 |       return;
221 |     }
222 |     case "token": {
223 |       switch (tok.cat) {
224 |         case parser.IDENTIFIER:{ return; }
225 |         default: j0.semerror("eh? " + tok.cat);
226 | 	  }
227 |         }
228 |       default: j0.semerror("don't know how to assigntype " + sym);
229 |     }
230 |     for(tree k : kids) k.assigntype(t);
231 |   }
232 | 
233 |   public boolean checkkids(boolean in_codeblock) {
234 |     switch (sym) {
235 |     case "MethodDecl": { kids[1].checktype(true); return true; }
236 |     case "LocalVarDecl": { kids[1].checktype(false); return true; }
237 |     case "FieldAccess": { kids[0].checktype(in_codeblock);
238 |                           return true; }
239 |     case "QualifiedName":
240 |        kids[0].checktype(in_codeblock); break;
241 |     default: if (kids != null) for (tree k : kids)
242 | 	       k.checktype(in_codeblock);
243 |     }
244 |     return false;
245 |   }
246 |     
247 |   void checktype(boolean in_codeblock) {
248 |     if (checkkids(in_codeblock)) return;
249 |     if (! in_codeblock) return;
250 |     switch (sym) {
251 |     case "Assignment": {
252 | 	if (kids[0].typ == null) System.out.println("kids[0]");
253 | 	if (kids[2].typ == null) System.out.println("kids[2]");
254 | 	typ = check_types(kids[0].typ, kids[2].typ); break;
255 |     }
256 |     case "AddExpr": typ = check_types(kids[0].typ, kids[1].typ); break;
257 |     case "Block": case "BlockStmts": typ = null; break;
258 |     case "MethodCall": break;
259 |     case "QualifiedName": {
260 | 	if (kids[0].typ instanceof classtype) {
261 | 	  classtype ct = (classtype)(kids[0].typ);
262 |           typ = (ct.st.lookup(kids[1].tok.text)).typ;
263 | 	} else j0.semerror("illegal . on  " + kids[0].typ.str());
264 | 	break;
265 |     }
266 |     case "token": typ = tok.type(stab); break;
267 |     default: j0.semerror("cannot check type of " + sym);
268 |     }
269 |   }
270 | 
271 |    public String get_op() {
272 |      switch (sym) {
273 |      case "Assignment" : return "=";
274 |      case "AddExpr": if (rule==1320) return "+"; else return "-";
275 |      }
276 |      return sym;
277 |    }
278 |    public typeinfo check_types(typeinfo op1, typeinfo op2) {
279 |      String operator = get_op();
280 |      switch (operator) {
281 |      case "=": case "+": case"-": {
282 |        tree tk;
283 |        if ((tk = findatoken())!=null)
284 |          System.out.print("line " + tk.tok.lineno + ": ");
285 |        if ((op1.basetype.equals(op2.basetype)) &&
286 | 	   (op1.basetype.equals("int"))) {
287 |          System.out.println("typecheck "+operator+" on a "+ op2.str()+
288 | 			    " and a "+ op1.str()+ " -> OK");
289 | 	 return op1;
290 | 	 }
291 |        else j0.semerror("typecheck "+operator+" on a "+ op2.str()+
292 | 			" and a "+ op1.str()+ " -> FAIL");
293 |        }
294 |      default: j0.semerror("don't know how to check " + operator);
295 |      }
296 |    return null;
297 |    }
298 |    public tree findatoken() {
299 |      tree rv;
300 |      if (sym=="token") return this;
301 |      for (tree t : kids) if ((rv=t.findatoken()) != null) return rv;
302 |      return null;
303 |    }
304 | 
305 |    public tree(String s, int r, token t) {
306 | 	id = serial.getid();
307 |         sym = s; rule = r; tok = t; }
308 | 
309 |     public tree(String s, int r, tree[] t) {
310 | 	id = serial.getid();
311 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
312 | 	sym = s; rule = r; nkids = t.length;
313 | 	kids = t;
314 |     }
315 | }
316 | 


--------------------------------------------------------------------------------
/ch7/typeinfo.icn:
--------------------------------------------------------------------------------
 1 | class typeinfo(basetype)
 2 |    method str()
 3 |       return string(basetype)|"unknown"
 4 |    end
 5 | end
 6 | class arraytype : typeinfo(element_type)
 7 | initially
 8 |    basetype := "array"
 9 | end
10 | class methodtype : typeinfo(parameters,return_type)
11 | initially
12 |    basetype := "method"
13 | end
14 | class classtype : typeinfo(name, st, fields, methods, constrs)
15 |    method str()
16 |       return name
17 |    end
18 | initially
19 |    basetype := "class"
20 | end
21 | class parameter(name, element_type)
22 | end
23 | 


--------------------------------------------------------------------------------
/ch7/typeinfo.java:
--------------------------------------------------------------------------------
1 | package ch7;
2 | public class typeinfo {
3 |    String basetype;
4 |    public typeinfo() { basetype = "unknown"; }
5 |    public typeinfo(String s) { basetype = s; }
6 |    public String str() { return basetype; }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch7/xy5.java:
--------------------------------------------------------------------------------
1 | public class xy5 {
2 |    static double y = 5.0;
3 |    public static void main(String argv[]) {
4 |        int x;
5 |        x = (int)y + 5;
6 |       System.out.println("y + 5 = " + x);
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch7/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     stop(s)
3 | end
4 | 


--------------------------------------------------------------------------------
/ch7/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch7;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch8/arraytype.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class arraytype extends typeinfo {
 3 |    typeinfo element_type;
 4 |     public String str() {
 5 | 	return "array of " + (element_type!=null?element_type.str():"undef");
 6 |     }
 7 |    public arraytype(typeinfo t) {
 8 |       basetype = "array"; element_type = t; }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch8/arrtst.java:
--------------------------------------------------------------------------------
 1 | public class arrtst {
 2 |    public static void main(String argv[]) {
 3 |       int x[];
 4 |       x = new int[3];
 5 |       x[1] = 0;
 6 |       x[0] = x[1];
 7 |       x[2] = argv[1];
 8 |       System.out.println("hello, world");
 9 |    }
10 | }
11 | 


--------------------------------------------------------------------------------
/ch8/classtype.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class classtype extends typeinfo {
 3 |    String name;
 4 |    symtab st;
 5 |    parameter [] methods;
 6 |    parameter [] fields;
 7 |    typeinfo [] constrs;
 8 |     public String str() {
 9 | 	return name;
10 |     }
11 |     public classtype(String s) { name = s; basetype="class";}
12 |     public classtype(String s, symtab stab) { name = s; st = stab; basetype="class";}
13 |    public classtype(String s, symtab stab,
14 | 		    parameter []ms, parameter[]fs, typeinfo[]cs) {
15 |        name = s; st = stab; methods=ms; fields=fs; constrs=cs; basetype="class";}
16 | }
17 | 


--------------------------------------------------------------------------------
/ch8/clstest.java:
--------------------------------------------------------------------------------
1 | public class clstest {
2 |    public static void main(String argv[]) {
3 |        clstest c;
4 |        c = new clstest();
5 |       System.out.println("hello, jzero!");
6 |    }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch8/funtest.java:
--------------------------------------------------------------------------------
 1 | public class funtest {
 2 |    public static int foo(int x, int y, String z) {
 3 |        return 0;
 4 |    }
 5 |    public static void main(String argv[]) {
 6 |       int x;
 7 |       x = foo(0,1,"howdy");
 8 |       x = x + 1;
 9 |       System.out.println("hello, jzero!");
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch8/hello.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       int x;
4 |       x = 0;
5 |       x = x + "hello";
6 |       System.out.println("hello, jzero!");
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch8/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yycolno, yylval, parser, global_st
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    serial := serial()
 5 |    parser := Parser()
 6 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 7 |    yylineno := yycolno := 1
 8 |    if yyparse() = 0 then
 9 |       write("no errors")
10 | end
11 | class j0()
12 |    method lexErr(s)
13 |       stop(s, ": ", yytext) 
14 |    end
15 |    method scan(cat)
16 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
17 |       yycolno +:= *yytext
18 |       return cat
19 |    end
20 |    method whitespace()
21 |       yycolno +:= *yytext
22 |    end
23 |    method newline()
24 |       yylineno +:= 1; yycolno := 1
25 |    end
26 |    method comment()
27 |       yytext ? {
28 |          while tab(find("\n")+1) do newline()
29 |          yycolno +:= *tab(0)
30 |       }
31 |    end
32 |    method ord(s)
33 |       return proc("ord",0)(s[1])
34 |    end
35 |    method print(root)
36 |       root.print()
37 |    end
38 |    method node(s,r,p[])
39 |       rv := tree ! ([s,r] ||| p)
40 |       return rv
41 |    end
42 |    method semantic(root)
43 |    local out_st, System_st
44 |      global_st := symtab("global")
45 |      System_st := symtab("class")
46 |      out_st := symtab("class")
47 |      out_st.insert("println", false, ,
48 |         methodtype([classtype("String")], typeinfo("void")))
49 |      System_st.insert("out", false, out_st, classtype("PrintStream",out_st))
50 |      global_st.insert("System", false, System_st, classtype("System",System_st))
51 |      if \verbose then write("making symbol tables")
52 |      root.mkSymTables(global_st)
53 |      root.populateSymTables()
54 |      if \verbose then write("checking symbol tables")
55 |      root.checkSymTables()
56 |      root.mkcls()
57 | #     global_st.print()
58 |      root.checktype()
59 |    end
60 |    method semerror(s)
61 |      stop("semantic error: ", s)
62 |    end
63 |    method calctype(t)
64 |      t.kids[1].calctype()
65 |      t.kids[2].assigntype(t.kids[1].typ)
66 |    end
67 | end
68 | 


--------------------------------------------------------------------------------
/ch8/j0.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | import java.io.FileReader;
 3 | public class j0 {
 4 |    public static Yylex yylexer;
 5 |    public static ch8.parser par;
 6 |    public static ch8.symtab global_st;
 7 |    public static void main(String argv[]) throws Exception {
 8 |       init(argv[0]);
 9 |       par = new ch8.parser();
10 |       //                  par.yydebug=true;
11 |       yylineno = 1;
12 |       int i = par.yyparse();
13 |       if (i == 0)
14 |          System.out.println("no errors");
15 |    }
16 |    public static int yylineno;
17 |    public static String yyfilename;
18 |     //   public static parserVal yylval;
19 |    public static void init(String s) throws Exception {
20 |       yyfilename = s;
21 |       yylexer = new Yylex(new FileReader(s));
22 |    }
23 |    public static int YYEOF() { return Yylex.YYEOF; }
24 |    public static int yylex() {
25 |       int rv = 0;
26 |       try {
27 |         rv = yylexer.yylex();
28 |       } catch(java.io.IOException ioException) {
29 |         rv = -1;
30 |       }
31 |       return rv;
32 |    }
33 |    public static String yytext() {
34 |       return yylexer.yytext();
35 |    }
36 |    public static void lexErr(String s) {
37 |       System.err.println(s);
38 |       System.exit(1);
39 |    }
40 |    public static int scan(int cat) {
41 |        ch8.j0.par.yylval =
42 | 	   new parserVal(new tree("token",cat,
43 | 		new token(cat, yytext(), yylineno)));
44 |       return cat;
45 |    }
46 |    public static void newline() {
47 |       yylineno++;
48 |    }
49 |    public static void whitespace() {
50 |    }
51 |    public static void comment() {
52 |    }
53 |    public static short ord(String s) { return (short)(s.charAt(0)); }
54 |    public static void print(parserVal root) {
55 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
56 |    }
57 |   public static tree unwrap(Object obj) {
58 |     if (obj instanceof token)
59 |       return new tree("token",0,(token)obj);
60 |     else return (tree)obj;
61 |   }
62 |   public static parserVal node(String s,int r,parserVal...p) {
63 |      tree[] t = new tree[p.length];
64 |      for(int i = 0; i < t.length; i++)
65 | 	 t[i] = (tree)(p[i].obj);
66 |      return new parserVal((Object)new tree(s,r,t));
67 |   }
68 |   public static void semantic(parserVal r) {
69 |     tree root = (tree)(r.obj);
70 |     ch8.symtab out_st, System_st;
71 |     global_st = new ch8.symtab("global");
72 |     System_st = new ch8.symtab("class");
73 |     out_st = new ch8.symtab("class");
74 |     out_st.insert("println", false, null,
75 | 		  new methodtype(new typeinfo[]{new classtype("String")},
76 | 				 new typeinfo("void")));
77 |     System_st.insert("out", false, out_st,
78 |        new classtype("PrintStream",out_st));
79 |     global_st.insert("System", false, System_st,
80 |        new classtype("System",System_st));
81 |    root.mkSymTables(global_st);
82 |    root.populateSymTables();
83 |    root.checkSymTables();
84 |    root.mkcls();
85 |    //   global_st.print();
86 |    root.checktype(false);
87 |   }
88 |   public static void semerror(String s) {
89 |    System.out.println("semantic error: " + s);
90 |    System.exit(1);
91 |   }
92 |   public static void calctype(parserVal pv){
93 |     tree t = (tree)pv.obj;
94 |     t.kids[0].calctype();
95 |     t.kids[1].assigntype(t.kids[0].typ);
96 |   }
97 | }
98 | 


--------------------------------------------------------------------------------
/ch8/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC NEW
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |  } ;
 12 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 13 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 14 | ClassBodyDecls: ClassBodyDecl
 15 | | ClassBodyDecls ClassBodyDecl {
 16 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 17 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 18 | FieldDecl: Type VarDecls ';' {
 19 |   $=j0.node("FieldDecl",1030,$1,$2);
 20 |   j0.calctype($);
 21 |   };
 22 | Type: INT | DOUBLE | BOOLEAN | STRING | Name ;
 23 | 
 24 | Name: IDENTIFIER | QualifiedName ;
 25 | QualifiedName: Name '.' IDENTIFIER {
 26 |   $=j0.node("QualifiedName",1040,$1,$3);};
 27 | 
 28 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 29 |   $=j0.node("VarDecls",1050,$1,$3); };
 30 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 31 |   $=j0.node("VarDeclarator",1060,$1); };
 32 | 
 33 | MethodReturnVal : Type | VOID ;
 34 | MethodDecl: MethodHeader Block {
 35 |   $=j0.node("MethodDecl",1380,$1,$2);
 36 |  };
 37 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 38 |   $=j0.node("MethodHeader",1070,$3,$4);
 39 |   j0.calctype($);
 40 |   };
 41 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 42 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 43 | 
 44 | FormalParmListOpt: FormalParmList | ;
 45 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 46 |   $=j0.node("FormalParmList",1090,$1,$3); };
 47 | FormalParm: Type VarDeclarator {
 48 |   $=j0.node("FormalParm",1100,$1,$2);
 49 |   j0.calctype($);
 50 |  };
 51 | 
 52 | ConstructorDecl: MethodDeclarator Block {
 53 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 54 | 
 55 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 56 | BlockStmtsOpt: BlockStmts | ;
 57 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 58 |   $=j0.node("BlockStmts",1130,$1,$2); };
 59 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 60 | 
 61 | LocalVarDeclStmt: LocalVarDecl ';' ;
 62 | LocalVarDecl: Type VarDecls {
 63 |   $=j0.node("LocalVarDecl",1140,$1,$2);
 64 |   j0.calctype($);
 65 |   };
 66 | 
 67 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 68 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 69 |       | WhileStmt | ForStmt ;
 70 | 
 71 | ExprStmt: StmtExpr ';' ;
 72 | 
 73 | StmtExpr: Assignment | MethodCall ;
 74 | 
 75 | IfThenStmt: IF '(' Expr ')' Block {
 76 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 77 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 78 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 79 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 80 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 81 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 82 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 83 | 
 84 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 85 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 86 | ElseIfStmt: ELSE IfThenStmt {
 87 |   $=j0.node("ElseIfStmt",1190,$2); };
 88 | WhileStmt: WHILE '(' Expr ')' Stmt {
 89 |   $=j0.node("WhileStmt",1210,$3,$5); };
 90 | 
 91 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 92 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 93 | ForInit: StmtExprList | LocalVarDecl | ;
 94 | ExprOpt: Expr |  ;
 95 | ForUpdate: StmtExprList | ;
 96 | 
 97 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 98 |   $=j0.node("StmtExprList",1230,$1,$3); };
 99 | 
100 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
101 |   $=j0.node("BreakStmt",1240,$2); };
102 | ReturnStmt: RETURN ExprOpt ';' {
103 |   $=j0.node("ReturnStmt",1250,$2); };
104 | 
105 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
106 | Primary:  Literal | FieldAccess | MethodCall | ArrayAccess |
107 |          '(' Expr ')' { $=$2;} | ArrayCreation | InstanceCreation;
108 | InstanceCreation: NEW Name '(' ArgListOpt ')' {
109 |   $=j0.node("InstanceCreation", 1261, $2, $4); };
110 | ArrayCreation: NEW Type '[' Expr ']' {
111 |   $=j0.node("ArrayCreation", 1260, $2, $4); };
112 | 
113 | ArgList: Expr | ArgList ',' Expr {
114 |   $=j0.node("ArgList",1270,$1,$3); };
115 | FieldAccess: Primary '.' IDENTIFIER {
116 |   $=j0.node("FieldAccess",1280,$1,$3); };
117 | 
118 | ArgListOpt:  ArgList | ;
119 | MethodCall: Name '(' ArgListOpt ')' {
120 |   $=j0.node("MethodCall",1290,$1,$3); }
121 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
122 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
123 | 	;
124 | 
125 | PostFixExpr: Primary | Name ;
126 | UnaryExpr:  '-' UnaryExpr {
127 |   $=j0.node("UnaryExpr",1300,$1,$2); }
128 |     | '!' UnaryExpr {
129 |   $=j0.node("UnaryExpr",1301,$1,$2); }
130 |     | PostFixExpr ;
131 | MulExpr: UnaryExpr
132 |     | MulExpr '*' UnaryExpr {
133 |       $=j0.node("MulExpr",1310,$1,$3); }
134 |     | MulExpr '/' UnaryExpr {
135 |       $=j0.node("MulExpr",1311,$1,$3); }
136 |     | MulExpr '%' UnaryExpr {
137 |       $=j0.node("MulExpr",1312,$1,$3); };
138 | AddExpr: MulExpr
139 |     | AddExpr '+' MulExpr {
140 |       $=j0.node("AddExpr",1320,$1,$3); }
141 |     | AddExpr '-' MulExpr {
142 |       $=j0.node("AddExpr",1321,$1,$3); };
143 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
144 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
145 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
146 | 
147 | EqExpr: RelExpr
148 |     | EqExpr ISEQUALTO RelExpr {
149 |   $=j0.node("EqExpr",1340,$1,$3); }
150 | | EqExpr NOTEQUALTO RelExpr {
151 |   $=j0.node("EqExpr",1341,$1,$3); };
152 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
153 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
154 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
155 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
156 | 
157 | ArrayAccess: Name '[' Expr ']' { $=j0.node("ArrayAccess",1390,$1,$3); };
158 | 
159 | Expr: CondOrExpr | Assignment ;
160 | Assignment: LeftHandSide AssignOp Expr {
161 |   $=j0.node("Assignment",1370, $1, $2, $3); };
162 | LeftHandSide: Name | FieldAccess | ArrayAccess ;
163 | AssignOp: '=' | INCREMENT | DECREMENT ;
164 | 


--------------------------------------------------------------------------------
/ch8/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "new"                  { return j0.scan(parser.NEW); }
18 | "null"                 { return j0.scan(parser.NULLVAL); }
19 | "public"               { return j0.scan(parser.PUBLIC); }
20 | "return"               { return j0.scan(parser.RETURN); }
21 | "static"               { return j0.scan(parser.STATIC); }
22 | "string"               { return j0.scan(parser.STRING); }
23 | "true"                 { return j0.scan(parser.BOOLLIT); }
24 | "boolean"              { return j0.scan(parser.BOOLEAN); }
25 | "void"                 { return j0.scan(parser.VOID); }
26 | "while"                { return j0.scan(parser.WHILE); }
27 | "class"                { return j0.scan(parser.CLASS); }
28 | "("                    { return j0.scan(j0.ord("("));}
29 | ")"                    { return j0.scan(j0.ord(")"));}
30 | "["                    { return j0.scan(j0.ord("["));}
31 | "]"                    { return j0.scan(j0.ord("]"));}
32 | "{"                    { return j0.scan(j0.ord("{"));}
33 | "}"                    { return j0.scan(j0.ord("}"));}
34 | ";"                    { return j0.scan(j0.ord(";"));}
35 | ":"                    { return j0.scan(j0.ord(":"));}
36 | "!"                    { return j0.scan(j0.ord("!"));}
37 | "*"                    { return j0.scan(j0.ord("*"));}
38 | "/"                    { return j0.scan(j0.ord("/"));}
39 | "%"                    { return j0.scan(j0.ord("%"));}
40 | "+"                    { return j0.scan(j0.ord("+"));}
41 | "-"                    { return j0.scan(j0.ord("-"));}
42 | "<"                    { return j0.scan(j0.ord("<"));}
43 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
44 | ">"                    { return j0.scan(j0.ord(">"));}
45 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
46 | "=="                   { return j0.scan(parser.ISEQUALTO);}
47 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
48 | "&&"                   { return j0.scan(parser.LOGICALAND);}
49 | "||"                   { return j0.scan(parser.LOGICALOR);}
50 | "="                    { return j0.scan(j0.ord("=")); }
51 | "+="                   { return j0.scan(parser.INCREMENT); }
52 | "-="                   { return j0.scan(parser.DECREMENT); }
53 | ","                    { return j0.scan(j0.ord(",")); }
54 | "."                    { return j0.scan(j0.ord(".")); }
55 | {id}                   { return j0.scan(parser.IDENTIFIER); }
56 | [0-9]+                 { return j0.scan(parser.INTLIT); }
57 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
58 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
59 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
60 | .                      { j0.lexErr("unrecognized character"); }
61 | 


--------------------------------------------------------------------------------
/ch8/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u typeinfo.u
 6 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU)
 7 | unicon: j0
 8 | %.u : %.icn
 9 | 	unicon -c 
lt;
10 | j0: $(U)
11 | 	unicon $(U)
12 | javalex.icn: javalex.l
13 | 	uflex javalex.l
14 | j0gram.icn j0gram_tab.icn: j0gram.y
15 | 	iyacc -dd j0gram.y
16 | 
17 | # A typical run might use
18 | # set CLASSPATH=".;c:\users\username\byopl"
19 | # in order to run from c:\users\username\byopl\ch8
20 | LYSRC=Yylex.java parser.java parserVal.java
21 | TPJ=typeinfo.java arraytype.java classtype.java methodtype.java parameter.java
22 | STJ=symtab.java symtab_entry.java $(TPJ)
23 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ)
24 | BYJOPTS= -Jclass=parser -Jpackage=ch8
25 | BYJIMPS= -Jyylex=ch8.j0.yylex -Jyyerror=ch8.yyerror.yyerror
26 | java: j0.class
27 | 
28 | j: java
29 | 	java ch8.j0 hello.java
30 | 	dot -Tpng hello.java.dot >hello.png
31 | 
32 | j0.class: $(JSRC)
33 | 	javac $(JSRC)
34 | parser.java parserVal.java: j0gram.y
35 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
36 | Yylex.java: javalex.l
37 | 	jflex javalex.l
38 | 
39 | 


--------------------------------------------------------------------------------
/ch8/methodtype.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class methodtype extends typeinfo {
 3 |    typeinfo [] parameters;
 4 |    typeinfo return_type;
 5 |     public String str() {
 6 | 	String s;
 7 | 	s = "method " + ((return_type!=null)?return_type.str():"undef") + "(";
 8 | 	for(typeinfo p : parameters)
 9 | 	    s = s + p.str() + ",";
10 | 	s = s.substring(0,s.length()-2) + ")";
11 | 	return s;
12 |     }
13 |    methodtype(typeinfo [] p, typeinfo rt){
14 |        parameters = p;
15 |        if (rt !=null) return_type = rt;
16 |        else return_type = new typeinfo("void");
17 |        basetype="method";
18 |    }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch8/parameter.java:
--------------------------------------------------------------------------------
1 | package ch8;
2 | public class parameter {
3 |    String name;
4 |    typeinfo param_type;
5 |    parameter(String s, typeinfo t) { name=s; param_type=t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch8/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch8/serial.java:
--------------------------------------------------------------------------------
1 | package ch8;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch8/symtab.icn:
--------------------------------------------------------------------------------
 1 | class symtab(scope, parent, t)
 2 |   method lookup(s)
 3 |     return if rv := \ (t[s]) then {
 4 |               rv }
 5 |            else {
 6 |              (\parent).lookup(s)
 7 |              }
 8 |   end
 9 |   method insert(s, isConst, sub, typ)
10 |       if \ (t[s]) then j0.semerror("redeclaration of " || s)
11 |       else { (\sub).parent := self
12 |              t[s] := symtab_entry(s, self, sub, isConst, typ) }
13 |   end
14 |   method print(level:0)
15 |     writes(repl(" ",level))
16 |     write(scope, " - ", *t, " symbols")
17 |     every (!t).print(level+1);
18 |   end
19 | 
20 | initially
21 |   t := table()
22 | end
23 | 


--------------------------------------------------------------------------------
/ch8/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | import java.util.HashMap;
 3 | public class symtab {
 4 |    String scope;
 5 |    symtab parent;
 6 |    HashMap<String,symtab_entry> t;
 7 |    symtab(String sc) {
 8 |       scope = sc;
 9 |       t = new HashMap<String,symtab_entry>();
10 |    }
11 |     symtab(String sc, symtab p) {
12 |       scope = sc; parent = p;
13 |       t = new HashMap<String,symtab_entry>();
14 |    }
15 |    symtab_entry lookup(String s) {
16 |        symtab_entry rv;
17 |        rv = t.get(s);
18 |        if (rv != null) {
19 | 	   return rv;
20 |        }
21 |       if (parent != null) return parent.lookup(s);
22 |       return null;
23 |    }
24 |    void insert(String s, Boolean iC, symtab sub, typeinfo typ) {
25 |       if (t.containsKey(s)) {
26 |          j0.semerror("redeclaration of " + s);
27 |       } else {
28 |          if (sub != null)
29 |             sub.parent = this;
30 |          t.put(s, new symtab_entry(s, this, iC, sub, typ));
31 |       }
32 |    }
33 |    void insert(String s, Boolean iC) {
34 |       if (t.containsKey(s)) {
35 |          j0.semerror("redeclaration of " + s);
36 |       } else {
37 |          t.put(s, new symtab_entry(s, this, iC));
38 |       }
39 |    }
40 |    void print() { print(0); }
41 |    void print(int level) {
42 |       for(int i=0; i<level; i++)
43 |         System.out.print(" ");
44 |       System.out.println(scope + " - " + t.size() + " symbols");
45 |       for(symtab_entry se : t.values()) se.print(level+1);
46 |    }
47 | }
48 | 


--------------------------------------------------------------------------------
/ch8/symtab_entry.icn:
--------------------------------------------------------------------------------
 1 | class symtab_entry(sym,parent_st,st,isConst,typ)
 2 |   method print(level:0)
 3 |     writes(repl(" ",level), sym)
 4 |     if \isconst then writes(" (const)")
 5 |     if \typ then writes(" ", typ.str())
 6 |     write()
 7 |     (\st).print(level+1);
 8 |   end
 9 | end
10 | 


--------------------------------------------------------------------------------
/ch8/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    typeinfo typ;
 7 |    void print(int level) {
 8 |       for(int i=0; i<level; i++) System.out.print(" ");
 9 |       System.out.print(sym);
10 |       if (isConst) System.out.print(" (const)");
11 |       System.out.println("");
12 |       if (st != null) st.print(level+1);
13 |    }
14 |    symtab_entry(String s, symtab p, boolean iC) {
15 |        sym = s; parent_st = p; isConst = iC; }
16 |    symtab_entry(String s, symtab p, boolean iC, symtab t, typeinfo ti) {
17 |       sym = s; parent_st = p; isConst = iC; st = t; typ = ti;
18 |  }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch8/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval, typ, isPublic, isStatic)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | method type(stab)
21 |   if \typ then return typ
22 |   if cat === parser.IDENTIFIER then
23 |     if rv := stab.lookup(text) then return typ := rv.typ
24 |   stop("line ", lineno ,": cannot check type of undeclared ", image(text))
25 | end
26 | initially
27 |    case cat of {
28 |      parser.INT:     typ := typeinfo("int")
29 |      parser.DOUBLE:  typ := typeinfo("double")
30 |      parser.BOOLEAN: typ := typeinfo("boolean")
31 |      parser.VOID:    typ := typeinfo("void")
32 |      parser.INTLIT: { ival := integer(text); typ:=typeinfo("int") }
33 |      parser.DOUBLELIT: { dval := real(text); typ:=typeinfo("double") }
34 |      parser.STRINGLIT: { sval := deEscape(text); typ:=classtype("String") }
35 |      parser.BOOLLIT: { typ := typeinfo("boolean") }
36 |      parser.NULLVAL: { typ := typeinfo("null") }
37 |      ord("="|"+"|"-"): { typ := typeinfo("n/a") }
38 |    }
39 | end
40 | 


--------------------------------------------------------------------------------
/ch8/token.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class token {
 3 |   public int id;
 4 |   public int cat;
 5 |   public String text;
 6 |   public int lineno;
 7 |   public typeinfo typ;
 8 |   public token(int c, String s, int l) {
 9 |     cat = c; text = s; lineno = l;
10 |     id = serial.getid();
11 |     switch (cat) {
12 |     case parser.INT: typ = new typeinfo("int"); break;
13 |     case parser.DOUBLE: typ = new typeinfo("double"); break;
14 |     case parser.BOOLEAN: typ = new typeinfo("boolean"); break;
15 |     case parser.VOID: typ = new typeinfo("void"); break;
16 |     case parser.INTLIT: typ = new typeinfo("int"); break;
17 |     case parser.DOUBLELIT: typ = new typeinfo("double"); break;
18 |     case parser.STRINGLIT: typ = new typeinfo("String"); break;
19 |     case parser.BOOLLIT: typ = new typeinfo("boolean"); break;
20 |     case parser.NULLVAL: typ = new typeinfo("null"); break;
21 |     case '=': case '+': case '-': typ = new typeinfo("n/a"); break;
22 |     }
23 |    }
24 | public typeinfo type(symtab stab) {
25 |   symtab_entry rv;
26 |   if (typ != null) return typ;
27 |   if (cat == parser.IDENTIFIER)
28 |       if ((rv = stab.lookup(text)) != null) return typ=rv.typ;
29 |   j0.semerror("cannot check the type of " + text);
30 |   return null;
31 | }
32 | }
33 | 


--------------------------------------------------------------------------------
/ch8/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab,typ)
  2 |   method print(level:0)
  3 |     writes(repl(" ",level))
  4 |     if \tok then {
  5 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  6 |       }
  7 |     else {
  8 |        write(id, "   ", sym, " (", rule, "): ", nkids)
  9 |        every (!kids).print(level+1)
 10 |        }
 11 |   end
 12 |   method print_graph(fw)
 13 |     if type(filename) == "string" then {
 14 |       fw := open(filename,  "w") |
 15 |         stop("can't open ", image(filename), " for writing")
 16 |       write(fw, "digraph {")
 17 |       print_graph(fw)
 18 |       write(fw, "}")
 19 |       close(fw)
 20 |     }
 21 |     else if \tok then print_leaf(fw)
 22 |     else { 
 23 |       print_branch(fw)
 24 |       every i := 1 to nkids do
 25 |         if \kids[i] then {
 26 |           write(fw, "N",id," -> N",kids[i].id,";")
 27 |           kids[i].print_graph(fw)
 28 |         } else {
 29 |           write(fw, "N",id," -> N",id,"_",j,";")
 30 |           write(fw, "N", id, "_", j,
 31 |                     " [label=\"Empty rule\"];")
 32 |           j +:= 1
 33 |         }
 34 |     }
 35 |   end
 36 |   method print_leaf(pw)
 37 |     local s := parser.yyname[tok.cat]
 38 |     print_branch(pw)
 39 |     write(pw,"N",id,
 40 |           " [shape=box style=dotted label=\" ",s," \\n ")
 41 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 42 |              tok.lineno," \\l\"];\n")
 43 |   end
 44 |   method print_branch(pw)
 45 |     write(pw, "N",id," [shape=box label=\"",
 46 |           pretty_print_name(),"\"];\n");
 47 |   end
 48 |   method escape(s)
 49 |     if s[1] == "\"" then
 50 |       return "\\" || s[1:-1] || "\\\""
 51 |     else return s
 52 |   end
 53 |   method pretty_print_name()
 54 |     if /tok then return sym || "#" || (rule%10)
 55 |     else return escape(tok.text) || ":" || tok.cat
 56 |   end
 57 |   method mkSymTables(curr)
 58 |     stab := curr
 59 |     case sym of {
 60 |       "ClassDecl": { curr := symtab("class",curr) }
 61 |       "MethodDecl": { curr := symtab("method",curr) }
 62 |     }
 63 |     every (!\kids).mkSymTables(curr)
 64 |   end
 65 |   method populateSymTables()
 66 |   case sym of {
 67 |     "ClassDecl": {
 68 |        stab.insert(kids[1].tok.text, , kids[1].stab) # new classtype() ?
 69 |        }
 70 |     "FieldDecl" | "LocalVarDecl" : {
 71 |        k := kids[2]
 72 |        while \k & k.sym=="VarDecls" do {
 73 |          insert_vardeclarator(k.kids[2])
 74 |          k := k.kids[1]
 75 |          }
 76 |        insert_vardeclarator(k); return
 77 |        }
 78 |     "MethodDecl": {
 79 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab,
 80 | 	          kids[1].kids[2].typ)
 81 |       kids[1].stab.insert("return", , , kids[1].kids[1].typ)
 82 |       }
 83 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 84 |     }
 85 |     every (!\kids).populateSymTables()
 86 |   end
 87 |   method insert_vardeclarator(vd)
 88 |    if \vd.tok then stab.insert(vd.tok.text,&null,&null,vd.typ)
 89 |    else insert_vardeclarator(vd.kids[1])
 90 |   end
 91 |   method calc_isConst()
 92 |    case sym of {
 93 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 94 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 95 |       "UnaryExpr": isConst := \kid[2].isConst
 96 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 97 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
 98 |       "MULEXPR"|
 99 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
100 |       default: isConst := &null
101 |    }
102 |    every (!\kids).calc_isConst()
103 |   end
104 |   # after symbol table population, we have enough information to fill in
105 |   # correct class type information.
106 |   method mkcls()
107 |     if sym == "ClassDecl" then {
108 |         rv := stab.lookup(kids[1].tok.text)
109 |         flds := []; methds := []; constrs := []
110 |         every k := key(rv.st.t) do
111 |            if match("method ", rv.st.t[k].typ.str()) then
112 |              put(methds, parameter(k, rv.st.t[k].typ))
113 |            else
114 |              put(flds, parameter(k, rv.st.t[k].typ))
115 |         (/(rv.typ) := classtype(kids[1].tok.text, rv.st, flds, methds, constrs))
116 |     }
117 |     else every k := !kids do
118 |       if k.nkids>0 then k.mkcls()
119 |   end
120 |   method checkSymTables()
121 |     check_codeblocks()
122 |   end
123 |   # this looks for undeclareds
124 |   method check_codeblocks()
125 |    if sym == "MethodDecl" then { kids[2].check_block() }
126 |    else every k := !kids do
127 |          if k.nkids>0 then k.check_codeblocks()
128 |   end
129 |   method check_block()
130 |    case sym of {
131 |    "IDENTIFIER": {
132 |      if not (stab.lookup(tok.text)) then
133 |         j0.semerror("undeclared variable "||tok.text)
134 |      }
135 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
136 |    "MethodCall": {
137 |       kids[1].check_block()
138 |       if rule = 1290 then
139 |          kids[2].check_block()
140 |       else kids[3].check_block()
141 |      }
142 |    "LocalVarDecl": { } # skip
143 |    default:  {
144 |       every k := !\kids do {
145 |             k.check_block()
146 |          }
147 |       }
148 |    }
149 |   end
150 |   # calctype - synthesize the type of a variable declaration
151 |   method calctype()
152 |     every (!\kids).calctype()
153 |     case sym of {
154 |       "FieldDecl": typ := kids[1].typ
155 |       "token": {
156 |          if typ := \ (tok.typ) then return
157 |          case tok.cat of {
158 |          parser.IDENTIFIER:{
159 |            if \ (rv := (\stab).lookup(tok.text)) then {
160 |               if typ := \ (rv.typ) then
161 |                  return typ
162 |               }
163 |            return typ := classtype(tok.text)
164 |            }
165 |          default:
166 |            stop("can't grok the type of ", image(tok.text))
167 |          }
168 |       }
169 |     default:
170 |        stop("can't grok the type of ", image(sym))
171 |     }
172 |   end
173 | 
174 |    # check a call against a signature
175 |    method cksig(sig)
176 |    local i:=*sig.parameters, nactual := 1, t := kids[2]
177 |      if /t then {
178 |        if i ~= 0 then stop("0 parameters, expected ", i)
179 |        }
180 |      else {
181 |        while t.sym == "ArgList" do { nactual +:= 1; t:=t.kids[1] }
182 |        if nactual ~= i then
183 |          stop(nactual, " parameters, expected ", i)
184 |        t := kids[2]
185 |        while t.sym == "ArgList" do {
186 |          check_types(t.kids[-1].typ, sig.parameters[i])
187 |          t := t.kids[1]; i-:=1
188 |          }
189 |        check_types(t.typ, sig.parameters[1])
190 |      }
191 |      typ := sig.return_type
192 |    end
193 | 
194 |   # return a list of types corresponding to a syntax subtree parameter list
195 |   method mksig()
196 |      case sym of {
197 |         "FormalParm": return [kids[1].typ]
198 |         "FormalParmList": return kids[1].mksig() ||| kids[2].mksig()
199 |         }
200 |   end
201 | 
202 |   # assigntype - inherit a type, typically into a variable declaration list
203 |   method assigntype(t)
204 |   local parmList
205 |     typ := t
206 |     case sym of {
207 |     "VarDeclarator": { # we have an ARRAY of whatever type t was
208 |       kids[1].assigntype(arraytype(t))
209 |       return
210 |     }
211 |     "MethodDeclarator": { # pass a return type into a method
212 |        parmList := (\ (kids[2]).mksig()) | []
213 |        kids[1].typ := typ := methodtype(parmList , t)
214 |        return
215 |     }
216 |     "token": {
217 |       case tok.cat of {
218 |          parser.IDENTIFIER: return
219 |          default: stop("eh? ", image(tok.cat))
220 |       }
221 |     }
222 |     default:
223 |        stop("don't know how to assign the type of ", image(sym))
224 |     }
225 |     every (!\kids).assigntype(t)
226 |   end
227 | 
228 | method checkkids(in_codeblock)
229 |     case sym of {
230 |        # turn on in executable StmtBlock
231 |        "MethodDecl": { kids[2].checktype(1); return }
232 |        # turn off in LocalVarDecl list...(back on in initializers, if any)
233 |        "LocalVarDecl": { kids[2].checktype(); return }
234 |        "FieldAccess": { kids[1].checktype(in_codeblock);
235 |           return }
236 |         "QualifiedName": { # has to be a type you can . on
237 |            kids[1].checktype(in_codeblock);
238 |        }
239 |        default: { every (!\kids).checktype(in_codeblock) }
240 |        }
241 | end
242 | 
243 |   # given a qualifiedname, return its type
244 |   method dequalify()
245 |   local rv, ste
246 |     if kids[1].sym == "QualifiedName" then
247 |       rv := kids[1].dequalify()
248 |     else if kids[1].sym=="token" &
249 |             kids[1].tok.cat=parser.IDENTIFIER then {
250 |       if not \ (rv := stab.lookup(kids[1].tok.text)) then
251 |          stop("unknown symbol ", kids[1].tok.text)
252 |       rv := rv.typ
253 |     }
254 |     else stop("can't dequalify ", sym)
255 |     if rv.basetype ~== "class" then
256 |       stop("can't dequalify ", rv.basetype)
257 |     if \ (ste := rv.st.lookup(kids[2].tok.text)) then
258 |       return ste.typ
259 |     else stop(kids[2].tok.text, " is not in ", rv.str())
260 | end
261 | 
262 |   # checktype - check, and determine, the type of each expression
263 |   method checktype(in_codeblock)
264 |     if checkkids(in_codeblock) then return
265 |     if /in_codeblock then return
266 |     case sym of {
267 |     "Assignment": typ := check_types(kids[1].typ, kids[3].typ)
268 |     "AddExpr": typ := check_types(kids[1].typ, kids[2].typ)
269 |     "ArgList"|"Block" | "BlockStmts": { typ := &null }
270 |     "MethodCall": {
271 |       if rule = 1290 then {
272 |         if kids[1].sym == "QualifiedName" then {
273 |           rv := kids[1].dequalify()
274 |           cksig(rv)
275 |           }
276 |         else {
277 |            if kids[1].sym ~== "token" then
278 |               stop("can't check type of Name ", kids[1].sym)
279 |            if (\ (kids[1].tok)).cat == parser.IDENTIFIER then {
280 |               write("checking the type of a call to ", kids[1].tok.text)
281 |               if ( \ (rv := stab.lookup(kids[1].tok.text))) then {
282 |                  rv := rv.typ
283 | #make sure it is actually a method
284 |                  if not match("method ", rv.str()) then
285 |                    stop("method expected, got ", rv.str())
286 |                  cksig(rv)
287 | 		}
288 |               }
289 |            else stop("can't check the type of token ", kids[1].tok.cat)
290 | }
291 |            }
292 |         else stop("Jzero does not handle complex calls")
293 |     }
294 |     "QualifiedName": {
295 |        # get my type by look up kid #2 within kid #1
296 |        if type(kids[1].typ) == "classtype__state" then {
297 |          typ := (kids[1].typ.st.lookup(kids[2].tok.text)).typ
298 |        } else stop("illegal type for dot operator: ",kids[1].typ.str())
299 |       }
300 |     "InstanceCreation": {
301 |       if not (rv := stab.lookup(kids[1].tok.text)) then
302 |         stop("unknown type ",kids[1].tok.text)
303 |       if not (typ := \ (rv.typ)) then
304 |         stop(kids[1].tok.text, " has unknown type")
305 |     }
306 |     "ArrayCreation": typ := arraytype(kids[1].typ)
307 |     "ArrayAccess": {
308 |        if match("array ", kids[1].typ.str()) then {
309 |           if kids[2].typ.str()=="int" then
310 |              typ := kids[1].typ.element_type
311 |           else stop("subscripting array with ",kids[2].typ.str())
312 |           }
313 |        else stop("illegal subscript on type ", kids[1].typ.str())
314 |        }
315 |     "ReturnStmt": {
316 |       # check the return type against the current function
317 |       if not (rt := ( \ (stab.lookup("return")).typ)) then
318 |          stop("stab did not find a returntype")
319 |       if \ (kids[1].typ) then
320 |           typ := check_types(rt, kids[1].typ)
321 |        else { # return; check that return type is void
322 |           if rt.str() ~== "void" then
323 |              stop("void return from non-void method")
324 |           typ := rt
325 |        }
326 |     }
327 |     "token": typ := tok.type(stab)
328 |     default: { stop("cannot check the type of: ", image(sym)) }
329 |     }
330 |   end
331 |    method get_op()
332 |       return case sym of {
333 |           "ReturnStmt" : "return"
334 |           "MethodCall" : "param"
335 |           "Assignment" : "="
336 |           "AddExpr": if rule=1320 then "+" else "-"
337 |           default: fail
338 |       }
339 |    end
340 | 
341 |    method check_types(op1, op2)
342 |       operator := get_op()
343 |       case operator of {
344 |          "param"|"return"|"="|"+"|"-" : {
345 |             if tok := findatoken() then
346 |                writes("line ", tok.tok.lineno, ": ")
347 |             if op1.str() === op2.str() ===
348 |                    ("int"|"double"|"String") then {
349 |                write("typecheck ",operator," on a ", op1.str(),
350 | 		      " and a ", op2.str(), " -> OK")
351 |                return op1
352 |                }
353 |             else if (op1.basetype===op2.basetype==="array") & operator==="=" &
354 |                     check_types(op1.element_type,op2.element_type) then {
355 |                write("typecheck ",operator," on a ", op1.str(),
356 | 		      " and a ", op2.str(), " -> OK")
357 |                return op1
358 |                }
359 |             else if (op1.str() == op2.str()) & operator ==="=" then {
360 |                write("typecheck ",operator," on a ", op1.str(),
361 | 		      " and a ", op2.str(), " -> OK")
362 |                return op1
363 |                }
364 |             else j0.semerror("typecheck "||operator||" on a "|| op1.str()||
365 | 			     " and a "|| op2.str()|| " -> FAIL")
366 |             }
367 |          default: j0.semerror("don't know how to check " || image(operator))
368 |         }
369 |    end
370 |   method findatoken()
371 |     if sym==="token" then return self
372 |     return (!kids).findatoken()
373 |   end
374 | 
375 | initially (s,r,x[])
376 |    id := serial.getid(); sym := s; rule := r
377 |    if type(x[1]) == "token__state" then {
378 |       nkids := 0; tok := x[1]
379 |       typ := (\tok).typ
380 |    } else {
381 |       nkids := *x;
382 |       kids := x
383 |    }
384 | end
385 | 


--------------------------------------------------------------------------------
/ch8/tree.java:
--------------------------------------------------------------------------------
  1 | package ch8;
  2 | import java.io.PrintWriter;
  3 | import java.io.BufferedWriter;
  4 | import java.io.FileWriter;
  5 | class tree {
  6 |   int id, rule, nkids;
  7 |   String sym;
  8 |   token tok;
  9 |   tree kids[];
 10 |   Boolean isConst;
 11 |   symtab stab;
 12 |   typeinfo typ;
 13 | 
 14 |   public String escape(String s) {
 15 |       if (s.charAt(0) == '\"')
 16 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 17 |       else return s;
 18 |   }
 19 | 
 20 |   public String pretty_print_name() {
 21 |     if (tok == null) return sym +"#"+(rule%10);
 22 |     else {
 23 | 	return escape(tok.text)+":"+tok.cat;
 24 | 	}
 25 |     }
 26 | 
 27 |   void print_graph(String filename){
 28 |     try {
 29 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 30 |       pw.printf("digraph {\n");
 31 |       j = 0;
 32 |       print_graph(pw);
 33 |       pw.printf("}\n");
 34 |       pw.close();
 35 |       }
 36 |     catch (java.io.IOException ioException) {
 37 |       System.err.println("printgraph exception");
 38 |       System.exit(1);
 39 |       }
 40 |     }
 41 | 
 42 |   int j;
 43 |   void print_graph(PrintWriter pw) {
 44 |   int i;
 45 |     if (tok != null) {
 46 | 	print_leaf(pw);
 47 |         return;
 48 |     }
 49 |     // from here on out, we know we are not a leaf
 50 |     print_branch(pw);
 51 |     
 52 |     for(i=0; i<nkids; i++) {
 53 |         if (kids[i] != null) {
 54 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 55 | 	    kids[i].print_graph(pw);
 56 |         } else {
 57 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 58 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 59 | 	    j++;
 60 |         }
 61 |     }
 62 |   }
 63 | 
 64 |   void print_leaf(PrintWriter pw) {
 65 |     String s = parser.yyname[tok.cat];
 66 |     print_branch(pw);
 67 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 68 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 69 | 	      escape(tok.text), tok.lineno);
 70 |   }
 71 | 
 72 |   void print_branch(PrintWriter pw) {
 73 |     pw.printf("N%d ",id);
 74 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 75 |     if (tok != null)
 76 | 	pw.printf("struct token* leaf %d", tok.id);
 77 |     pw.printf("\"];\n");
 78 |   }
 79 | 
 80 |   public void print(int level) {
 81 |     int i;
 82 |     for(i=0;i<level;i++) System.out.print(" ");
 83 |     if (tok != null) {
 84 |       System.out.println(id + "   " + tok.text +
 85 |                          " (" + tok.cat + "): "+tok.lineno);
 86 |     }
 87 |     else {
 88 |       System.out.println(id + "   " + sym +
 89 | 			 " (" + rule + "): "+nkids);
 90 |     }
 91 |     for(i=0; i<nkids; i++)
 92 |       kids[i].print(level+1);
 93 |   }
 94 |   public void print() {
 95 |     print(0);
 96 |   }
 97 | 
 98 |   void mkSymTables(symtab curr) {
 99 |    stab = curr;
100 |    switch (sym) {
101 |    case "ClassDecl": curr = new symtab("class", curr); break;
102 |    case "MethodDecl": curr = new symtab("method", curr); break;
103 |    }
104 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
105 |   }
106 | 
107 |   void populateSymTables() {
108 |     switch(sym) {
109 |     case "ClassDecl":
110 | 	stab.insert(kids[0].tok.text, false, kids[0].stab, null);
111 | 	//		    new classtype(kids[0].tok.text, kids[0].stab));
112 |        break;
113 |     case "FieldDecl": case "LocalVarDecl":
114 |        tree k = kids[1];
115 |        while ((k != null) && k.sym.equals("VarDecls")) {
116 |          insert_vardeclarator(k.kids[1]);
117 |          k = k.kids[0];
118 |          }
119 |        insert_vardeclarator(k); return;
120 |     case "MethodDecl":
121 | 	String s = kids[0].kids[1].kids[0].tok.text;
122 | 	stab.insert(s, false, kids[0].stab, kids[0].kids[1].typ);
123 | 	kids[0].stab.insert("return", false, null, kids[0].kids[0].typ);
124 | 	break;
125 |     case "FormalParm":
126 |       insert_vardeclarator(kids[1]); return;
127 |     }
128 |     if (kids!=null)
129 | 	for(tree k : kids)
130 | 	   if (k!=null)
131 | 	      k.populateSymTables();
132 |   }
133 | 
134 |   void insert_vardeclarator(tree vd) {
135 |     if (vd.tok != null) {
136 |       stab.insert(vd.tok.text, false, null, vd.typ);
137 |       }
138 |     else insert_vardeclarator(vd.kids[0]);
139 |   }
140 | 
141 |   void calc_isConst() {
142 |    switch(sym) {
143 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
144 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
145 |    case "UnaryExpr": isConst = kids[1].isConst; break;
146 |    case "RelExpr":
147 |       isConst = kids[0].isConst && kids[2].isConst; break;
148 |    case "CondOrExpr": case "CondAndExpr":
149 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
150 |       isConst = kids[0].isConst && kids[1].isConst; break;
151 |    default: isConst = false;
152 |    }
153 |    for(int i=0; i <nkids; i++)
154 |       kids[i].calc_isConst();
155 |   }
156 | 
157 |   void mkcls() {
158 |     symtab_entry rv;
159 |     if (sym.equals("ClassDecl")) {
160 |       int ms=0, fs=0;
161 |       rv = stab.lookup(kids[0].tok.text);
162 |       for(String k : rv.st.t.keySet()) {
163 | 	  symtab_entry ste = rv.st.t.get(k);
164 | 	  if ((ste.typ.str()).startsWith("method ")) ms++;
165 | 	  else fs++;
166 |       }
167 |       parameter flds[] = new parameter[fs];
168 |       parameter methds[] = new parameter[ms];
169 |       fs=0; ms=0;
170 |       for(String k : rv.st.t.keySet()) {
171 | 	  symtab_entry ste = rv.st.t.get(k);
172 | 	  if ((ste.typ.str()).startsWith("method "))
173 | 	      methds[ms++] = new parameter(k, ste.typ);
174 | 	  else flds[fs++] = new parameter(k, ste.typ);
175 |       }
176 |       rv.typ = new classtype(kids[0].tok.text, rv.st,
177 | 			       flds, methds, new typeinfo[0]);
178 |     }
179 |     else for(int i = 0; i<nkids; i++)
180 |       if (kids[i].nkids>0) kids[i].mkcls();
181 |   }
182 | 
183 |   void checkSymTables() { check_codeblocks(); }
184 |   void check_codeblocks() {
185 |   tree k;
186 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
187 |    else {
188 |       for(int i = 0; i<nkids; i++){
189 |          k = kids[i];
190 |          if (k.nkids>0) k.check_codeblocks();
191 |       }
192 |    }
193 |   }
194 | void check_block() {
195 |    switch (sym) {
196 |    case "IDENTIFIER":
197 |      if (stab.lookup(tok.text) == null)
198 |         j0.semerror("undeclared variable " + tok.text);
199 |      break;
200 |    case "FieldAccess": case "QualifiedName":
201 |      kids[0].check_block();
202 |      break;
203 |   case "MethodCall":
204 |       kids[0].check_block();
205 |       if (rule == 1290)
206 |          kids[1].check_block();
207 |       else kids[2].check_block();
208 |       break;
209 |    case "LocalVarDecl": break;
210 |    default:
211 |       for(int i=0;i<nkids;i++)
212 |          kids[i].check_block();
213 |    }
214 |   }
215 | 
216 |   void calctype() {
217 |     for(int i=0; i<nkids; i++) kids[i].calctype();
218 |     switch (sym) {
219 |     case "FieldDecl": typ = kids[0].typ; return;
220 |     case "token":
221 | 	if ((typ = tok.typ) != null) return;
222 | 	switch (tok.cat) {
223 | 	case parser.IDENTIFIER:
224 | 	    if (stab != null) {
225 | 		symtab_entry rv = stab.lookup(tok.text);
226 | 		if (rv != null)
227 | 		    if ((typ = rv.typ) != null) return;
228 | 	    }
229 | 	    typ = new classtype(tok.text);
230 | 	    return;
231 | 	default:
232 | 	  j0.semerror("can't grok the type of " + tok.text + " cat " + tok.cat);
233 | 	}
234 | 	break;
235 |     default: j0.semerror("don't know how to calctype " + sym);
236 |     }
237 |   }
238 | 
239 |   void cksig(methodtype sig) {
240 |     int i = sig.parameters.length, nactual = 1;
241 |     tree t = kids[1];
242 |       if (t == null) {
243 |         if (i != 0) j0.semerror("0 params, expected " + i);
244 |       }
245 |       else {
246 |         while (t.sym.equals("ArgList")) { nactual++; t=t.kids[0]; }
247 | 	if (nactual != i)
248 | 	    j0.semerror(nactual + " parameters, expected "+ i);
249 | 	t = kids[1];
250 | 	i--;
251 | 	while (t.sym.equals("ArgList")) {
252 | 	    check_types(t.kids[1].typ, sig.parameters[i]);
253 | 	    t = t.kids[0];
254 | 	    i--;
255 | 	}
256 | 	check_types(t.typ, sig.parameters[0]);
257 |       }
258 |       typ = sig.return_type;
259 |     }
260 | 
261 |   typeinfo [] mksig() {
262 |   switch (sym) {
263 |     case "FormalParm": return new typeinfo[]{kids[0].typ};
264 |     case "FormalParmList":
265 |       typeinfo ta1[] = kids[0].mksig();
266 |       typeinfo ta2[] = kids[1].mksig();
267 |       typeinfo ta[] = new typeinfo[ta1.length + ta2.length];
268 |       for(int i=0; i<ta1.length; i++) ta[i]=ta1[i];
269 |       for(int j=0; j<ta2.length; j++)
270 | 	ta[ta1.length+j]=ta2[j];
271 |       return ta;
272 |       }
273 |     return null;
274 |   }
275 | 
276 |   void assigntype(typeinfo t) {
277 |     typ = t;
278 |     switch (sym) {
279 |     case "VarDeclarator":
280 |       kids[0].assigntype(new arraytype(t));
281 |       return;
282 |     case "MethodDeclarator": // pass a return type into a method
283 | 	typeinfo parmList[];
284 | 	if (kids[1] != null) parmList = kids[1].mksig();
285 | 	else parmList = new typeinfo [0];
286 | 	kids[0].typ = typ = new methodtype(parmList , t);
287 | 	return;
288 |     case "token":
289 |       switch (tok.cat) {
290 |         case parser.IDENTIFIER: return;
291 |         default: j0.semerror("eh? " + tok.cat);
292 |       }
293 |       break;
294 |       default: j0.semerror("don't know how to assigntype " + sym);
295 |     }
296 |     if(kids!=null) for(tree k : kids) k.assigntype(t);
297 |   }
298 | 
299 |   public boolean checkkids(boolean in_codeblock) {
300 |     switch (sym) {
301 |     case "MethodDecl": { kids[1].checktype(true); return true; }
302 |     case "LocalVarDecl": { kids[1].checktype(false); return true; }
303 |     case "FieldAccess": { kids[0].checktype(in_codeblock);
304 |                           return true; }
305 |     case "QualifiedName":
306 |        kids[0].checktype(in_codeblock); break;
307 |     default: if (kids != null) for (tree k : kids)
308 | 	       k.checktype(in_codeblock);
309 |     }
310 |     return false;
311 |   }
312 |     
313 |   public typeinfo dequalify() {
314 |       typeinfo rv = null;
315 |       symtab_entry ste;
316 |       if (kids[0].sym.equals("QualifiedName"))
317 | 	  rv = kids[0].dequalify();
318 |       else if (kids[0].sym.equals("token") &
319 | 	       (kids[0].tok.cat==parser.IDENTIFIER)) {
320 | 	  if ((ste = stab.lookup(kids[0].tok.text)) == null)
321 | 	      j0.semerror("unknown symbol " + kids[0].tok.text);
322 | 	  rv = ste.typ;
323 |       }
324 |       else j0.semerror("can't dequalify " + sym);
325 |       if (!rv.basetype.equals("class"))
326 | 	  j0.semerror("can't dequalify " + rv.basetype);
327 |       ste = ((classtype)rv).st.lookup(kids[1].tok.text);
328 |       if (ste != null) return ste.typ;
329 |       j0.semerror("couldn't lookup " + kids[1].tok.text +
330 | 		  " in " + rv.str());
331 |       return null;
332 |   }
333 | 
334 |   void checktype(boolean in_codeblock) {
335 |     if (checkkids(in_codeblock)) return;
336 |     if (! in_codeblock) return;
337 |     switch (sym) {
338 |     case "Assignment": typ = check_types(kids[0].typ, kids[2].typ); break;
339 |     case "AddExpr": typ = check_types(kids[0].typ, kids[1].typ); break;
340 |     case "ArgList": case "Block": case "BlockStmts": typ = null; break;
341 |     case "MethodCall":
342 |       if (rule == 1290) {
343 |         symtab_entry rve;
344 |         methodtype rv;
345 |         if (kids[0].sym.equals("QualifiedName")) {
346 |           rv = (methodtype)(kids[0].dequalify());
347 |           cksig(rv);
348 |           }
349 |         else {
350 |           if (!kids[0].sym.equals("token"))
351 |             j0.semerror("can't check type of " + kids[0].sym);
352 |           if (kids[0].tok.cat == parser.IDENTIFIER) {
353 |             System.out.println("checking the type of a call to " +
354 |                                kids[0].tok.text);
355 |             if ((rve = stab.lookup(kids[0].tok.text)) != null) {
356 |   	    if (! (rve.typ instanceof methodtype))
357 |               j0.semerror("method expected, got " + rve.typ.str());
358 | 	    rv = (methodtype)rve.typ;
359 |             cksig(rv);
360 |             }
361 |           }
362 |           else j0.semerror("can't typecheck token " + kids[0].tok.cat);
363 |           }
364 |         }
365 |       else j0.semerror("Jzero does not handle complex calls");
366 |       break;
367 |     case "QualifiedName":
368 | 	if (kids[0].typ instanceof classtype) {
369 | 	  classtype ct = (classtype)(kids[0].typ);
370 |           typ = (ct.st.lookup(kids[1].tok.text)).typ;
371 | 	} else j0.semerror("illegal . on  " + kids[0].typ.str());
372 | 	break;
373 |     case "InstanceCreation": {
374 |       symtab_entry rv;
375 |       if ((rv = stab.lookup(kids[0].tok.text))==null)
376 |         j0.semerror("unknown type " + kids[0].tok.text);
377 |       if ((typ = rv.typ) == null)
378 |         j0.semerror(kids[0].tok.text + " has unknown type");
379 |       break;
380 |     }
381 |     case "ArrayCreation":
382 | 	typ = new arraytype(kids[0].typ); break;
383 |     case "ArrayAccess":
384 | 	if (kids[0].typ.str().startsWith("array ")) {
385 | 	    if (kids[1].typ.str().equals("int"))
386 | 		typ = ((arraytype)(kids[0].typ)).element_type;
387 | 	    else j0.semerror("subscripting array with "+kids[1].typ.str());
388 |           }
389 | 	else j0.semerror("illegal subscript on type "+ kids[0].typ.str());
390 | 	break;
391 |     case "ReturnStmt":
392 |       symtab_entry ste;
393 |       if ((ste=stab.lookup("return")) == null)
394 |          j0.semerror("stab did not find a returntype");
395 |       typeinfo rt = ste.typ;
396 |       if (kids[0].typ != null)
397 |           typ = check_types(rt, kids[0].typ);
398 |       else { // return; check that return type is void
399 |           if (!rt.str().equals("void"))
400 | 	      j0.semerror("void return from non-void method");
401 | 	  typ = rt;		    
402 |           }
403 |       break;
404 |     case "token": typ = tok.type(stab); break;
405 |     default: j0.semerror("cannot check type of " + sym);
406 |     }
407 |   }
408 | 
409 |    public String get_op() {
410 |      switch (sym) {
411 |      case "ReturnStmt" : return "return";
412 |      case "MethodCall" : return "param";
413 |      case "Assignment" : return "=";
414 |      case "AddExpr": if (rule==1320) return "+"; else return "-";
415 |      default: return null;
416 |      }
417 |    }
418 | 
419 |    public typeinfo check_types(typeinfo op1, typeinfo op2) {
420 |      String operator = get_op();
421 |      switch (operator) {
422 |      case "param": case "return": case "=": case "+": case"-": {
423 |        tree tk;
424 |        if ((tk = findatoken())!=null)
425 |          System.out.print("line " + tk.tok.lineno + ": ");
426 |        if (op1.str().equals(op2.str()) &&
427 | 	   (op1.str().equals("int") ||
428 | 	    op1.str().equals("double") ||
429 | 	    op1.str().equals("String"))) {
430 |          System.out.println("typecheck "+operator+" on a "+ op1.str()+
431 | 			    " and a "+ op2.str()+ " -> OK");
432 | 	 return op1;
433 | 	 }
434 |        else if (op1.basetype.equals("array") &&
435 |                 op2.basetype.equals("array") &&
436 |                 operator.equals("=") &&
437 |                 (check_types(((arraytype)op1).element_type,
438 | 			     ((arraytype)op2).element_type) != null)) {
439 |                 return op1;
440 |                }
441 |        else if (op1.str().equals(op2.str()) & operator.equals("=")) {
442 |           System.out.println("typecheck "+operator+" on a "+ op1.str()+
443 | 			     " and a "+ op2.str()+ " -> OK");
444 | 	  return op1;
445 |                }
446 |        else j0.semerror("typecheck "+operator+" on a "+ op2.str()+
447 | 			" and a "+ op1.str()+ " -> FAIL");
448 |        break;
449 |        }
450 |      default: j0.semerror("don't know how to check " + operator);
451 |      }
452 |    return null;
453 |    }
454 |    public tree findatoken() {
455 |      tree rv;
456 |      if (sym=="token") return this;
457 |      if (kids != null)
458 |      for (tree t : kids) if ((rv=t.findatoken()) != null) return rv;
459 |      return null;
460 |    }
461 | 
462 |    public tree(String s, int r, token t) {
463 | 	id = serial.getid();
464 |         sym = s; rule = r; tok = t; if (tok!=null) typ = tok.typ; }
465 | 
466 |     public tree(String s, int r, tree[] t) {
467 | 	id = serial.getid();
468 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
469 | 	sym = s; rule = r; nkids = t.length;
470 | 	kids = t;
471 |     }
472 | }
473 | 


--------------------------------------------------------------------------------
/ch8/typeinfo.icn:
--------------------------------------------------------------------------------
 1 | class typeinfo(basetype)
 2 |    method str()
 3 |       return string(basetype)|"unknown"
 4 |    end
 5 | end
 6 | class arraytype : typeinfo(element_type)
 7 |    method str()
 8 |       return "array of " || (\element_type).str()
 9 |    end
10 | initially
11 |    basetype := "array"
12 | end
13 | class methodtype : typeinfo(parameters,return_type)
14 |    method str()
15 |       s := "method " || ((\return_type).str()|"undef") || "("
16 |       every s ||:= (!parameters).str() do s ||:= ","
17 |       s[-1] := ")"
18 |       return s
19 |    end
20 | initially
21 |    basetype := "method"
22 |    /parameters := []
23 |    /return_type := typeinfo("void")
24 | end
25 | class classtype : typeinfo(name, st, fields, methods, constrs)
26 |    method str()
27 |       return name
28 |    end
29 | initially
30 |    basetype := "class"
31 |    /st := symtab("class",global_st)
32 |    /fields := []
33 |    /methods := []
34 |    /constrs := []
35 | end
36 | class parameter(name, element_type)
37 | end
38 | 


--------------------------------------------------------------------------------
/ch8/typeinfo.java:
--------------------------------------------------------------------------------
1 | package ch8;
2 | public class typeinfo {
3 |    String basetype;
4 |    public typeinfo() { basetype = "unknown"; }
5 |    public typeinfo(String s) { basetype = s; }
6 |    public String str() { return basetype; }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch8/xy5.java:
--------------------------------------------------------------------------------
1 | public class xy5 {
2 |    static double y = 5.0;
3 |    public static void main(String argv[]) {
4 |        int x;
5 |        x = (int)y + 5;
6 |       System.out.println("y + 5 = " + x);
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch8/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     writes(&errout, yylineno, ": ", image(yytext),": ")
3 |     stop(s)
4 | end
5 | 


--------------------------------------------------------------------------------
/ch8/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch8;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/ch9/Yylex.java:
--------------------------------------------------------------------------------
  1 | // DO NOT EDIT
  2 | // Generated by JFlex 1.8.2 http://jflex.de/
  3 | // source: javalex.l
  4 | 
  5 | package ch9;
  6 | 
  7 | // See https://github.com/jflex-de/jflex/issues/222
  8 | @SuppressWarnings("FallThrough")
  9 | class Yylex {
 10 | 
 11 |   /** This character denotes the end of file. */
 12 |   public static final int YYEOF = -1;
 13 | 
 14 |   /** Initial size of the lookahead buffer. */
 15 |   private static final int ZZ_BUFFERSIZE = 16384;
 16 | 
 17 |   // Lexical states.
 18 |   public static final int YYINITIAL = 0;
 19 | 
 20 |   /**
 21 |    * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
 22 |    * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
 23 |    *                  at the beginning of a line
 24 |    * l is of the form l = 2*k, k a non negative integer
 25 |    */
 26 |   private static final int ZZ_LEXSTATE[] = {
 27 |      0, 0
 28 |   };
 29 | 
 30 |   /**
 31 |    * Top-level table for translating characters to character classes
 32 |    */
 33 |   private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
 34 | 
 35 |   private static final String ZZ_CMAP_TOP_PACKED_0 =
 36 |     "\1\0\37\u0100\1\u0200\267\u0100\10\u0300\u1020\u0100";
 37 | 
 38 |   private static int [] zzUnpackcmap_top() {
 39 |     int [] result = new int[4352];
 40 |     int offset = 0;
 41 |     offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
 42 |     return result;
 43 |   }
 44 | 
 45 |   private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
 46 |     int i = 0;       /* index in packed string  */
 47 |     int j = offset;  /* index in unpacked array */
 48 |     int l = packed.length();
 49 |     while (i < l) {
 50 |       int count = packed.charAt(i++);
 51 |       int value = packed.charAt(i++);
 52 |       do result[j++] = value; while (--count > 0);
 53 |     }
 54 |     return j;
 55 |   }
 56 | 
 57 | 
 58 |   /**
 59 |    * Second-level tables for translating characters to character classes
 60 |    */
 61 |   private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
 62 | 
 63 |   private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
 64 |     "\11\0\1\1\1\2\1\3\1\4\1\5\22\0\1\1"+
 65 |     "\1\6\1\7\2\0\1\10\1\11\1\0\1\12\1\13"+
 66 |     "\1\14\1\15\1\16\1\17\1\20\1\21\12\22\1\23"+
 67 |     "\1\24\1\25\1\26\1\27\2\0\4\30\1\31\25\30"+
 68 |     "\1\32\1\33\1\34\1\0\1\30\1\0\1\35\1\36"+
 69 |     "\1\37\1\40\1\41\1\42\1\43\1\44\1\45\1\30"+
 70 |     "\1\46\1\47\1\30\1\50\1\51\1\52\1\30\1\53"+
 71 |     "\1\54\1\55\1\56\1\57\1\60\3\30\1\61\1\62"+
 72 |     "\1\63\7\0\1\3\u01a2\0\2\3\326\0\u0100\3";
 73 | 
 74 |   private static int [] zzUnpackcmap_blocks() {
 75 |     int [] result = new int[1024];
 76 |     int offset = 0;
 77 |     offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
 78 |     return result;
 79 |   }
 80 | 
 81 |   private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
 82 |     int i = 0;       /* index in packed string  */
 83 |     int j = offset;  /* index in unpacked array */
 84 |     int l = packed.length();
 85 |     while (i < l) {
 86 |       int count = packed.charAt(i++);
 87 |       int value = packed.charAt(i++);
 88 |       do result[j++] = value; while (--count > 0);
 89 |     }
 90 |     return j;
 91 |   }
 92 | 
 93 |   /**
 94 |    * Translates DFA states to action switch labels.
 95 |    */
 96 |   private static final int [] ZZ_ACTION = zzUnpackAction();
 97 | 
 98 |   private static final String ZZ_ACTION_PACKED_0 =
 99 |     "\1\0\1\1\1\2\1\3\1\4\1\1\1\5\1\1"+
100 |     "\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1\15"+
101 |     "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
102 |     "\1\26\15\24\1\27\1\1\1\30\1\31\1\0\1\32"+
103 |     "\1\0\1\33\1\34\1\35\1\36\3\0\1\37\1\40"+
104 |     "\1\41\7\24\1\42\11\24\1\43\1\32\1\0\1\36"+
105 |     "\1\0\1\44\1\0\6\24\1\45\1\46\1\47\14\24"+
106 |     "\1\50\1\51\4\24\1\52\1\53\2\24\1\54\1\55"+
107 |     "\5\24\1\56\1\24\1\57\1\60\1\61\1\62\1\63"+
108 |     "\1\64";
109 | 
110 |   private static int [] zzUnpackAction() {
111 |     int [] result = new int[125];
112 |     int offset = 0;
113 |     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
114 |     return result;
115 |   }
116 | 
117 |   private static int zzUnpackAction(String packed, int offset, int [] result) {
118 |     int i = 0;       /* index in packed string  */
119 |     int j = offset;  /* index in unpacked array */
120 |     int l = packed.length();
121 |     while (i < l) {
122 |       int count = packed.charAt(i++);
123 |       int value = packed.charAt(i++);
124 |       do result[j++] = value; while (--count > 0);
125 |     }
126 |     return j;
127 |   }
128 | 
129 | 
130 |   /**
131 |    * Translates a state to a row index in the transition table
132 |    */
133 |   private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
134 | 
135 |   private static final String ZZ_ROWMAP_PACKED_0 =
136 |     "\0\0\0\64\0\150\0\64\0\234\0\320\0\64\0\u0104"+
137 |     "\0\64\0\64\0\64\0\u0138\0\64\0\u016c\0\u01a0\0\u01d4"+
138 |     "\0\u0208\0\64\0\64\0\u023c\0\u0270\0\u02a4\0\u02d8\0\64"+
139 |     "\0\64\0\u030c\0\u0340\0\u0374\0\u03a8\0\u03dc\0\u0410\0\u0444"+
140 |     "\0\u0478\0\u04ac\0\u04e0\0\u0514\0\u0548\0\u057c\0\64\0\u05b0"+
141 |     "\0\64\0\64\0\320\0\64\0\u05e4\0\64\0\64\0\64"+
142 |     "\0\u01a0\0\u0618\0\u064c\0\u0680\0\64\0\64\0\64\0\u06b4"+
143 |     "\0\u06e8\0\u071c\0\u0750\0\u0784\0\u07b8\0\u07ec\0\u02d8\0\u0820"+
144 |     "\0\u0854\0\u0888\0\u08bc\0\u08f0\0\u0924\0\u0958\0\u098c\0\u09c0"+
145 |     "\0\64\0\320\0\u09f4\0\u09f4\0\u0a28\0\64\0\u0a5c\0\u0a90"+
146 |     "\0\u0ac4\0\u0af8\0\u0b2c\0\u0b60\0\u0b94\0\u02d8\0\u02d8\0\u02d8"+
147 |     "\0\u0bc8\0\u0bfc\0\u0c30\0\u0c64\0\u0c98\0\u0ccc\0\u0d00\0\u0d34"+
148 |     "\0\u0d68\0\u0d9c\0\u0dd0\0\u0e04\0\u02d8\0\u02d8\0\u0e38\0\u0e6c"+
149 |     "\0\u0ea0\0\u0ed4\0\u02d8\0\u02d8\0\u0f08\0\u0f3c\0\u02d8\0\u02d8"+
150 |     "\0\u0f70\0\u0fa4\0\u0fd8\0\u100c\0\u1040\0\u02d8\0\u1074\0\u02d8"+
151 |     "\0\u02d8\0\u02d8\0\u02d8\0\u02d8\0\u02d8";
152 | 
153 |   private static int [] zzUnpackRowMap() {
154 |     int [] result = new int[125];
155 |     int offset = 0;
156 |     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
157 |     return result;
158 |   }
159 | 
160 |   private static int zzUnpackRowMap(String packed, int offset, int [] result) {
161 |     int i = 0;  /* index in packed string  */
162 |     int j = offset;  /* index in unpacked array */
163 |     int l = packed.length();
164 |     while (i < l) {
165 |       int high = packed.charAt(i++) << 16;
166 |       result[j++] = high | packed.charAt(i++);
167 |     }
168 |     return j;
169 |   }
170 | 
171 |   /**
172 |    * The transition table of the DFA
173 |    */
174 |   private static final int [] ZZ_TRANS = zzUnpackTrans();
175 | 
176 |   private static final String ZZ_TRANS_PACKED_0 =
177 |     "\1\2\1\3\1\4\1\0\2\3\1\5\1\6\1\7"+
178 |     "\1\10\1\11\1\12\1\13\1\14\1\15\1\16\1\17"+
179 |     "\1\20\1\21\1\22\1\23\1\24\1\25\1\26\2\27"+
180 |     "\1\30\1\2\1\31\1\27\1\32\1\33\1\34\1\35"+
181 |     "\1\36\2\27\1\37\2\27\1\40\1\27\1\41\1\42"+
182 |     "\1\43\1\44\1\27\1\45\1\46\1\47\1\50\1\51"+
183 |     "\65\0\1\3\2\0\2\3\104\0\1\52\35\0\7\53"+
184 |     "\1\54\23\53\1\55\30\53\11\0\1\56\100\0\1\57"+
185 |     "\63\0\1\60\57\0\1\61\6\0\1\62\7\0\1\62"+
186 |     "\36\0\1\63\4\0\1\64\62\0\1\61\1\0\1\21"+
187 |     "\6\0\1\62\7\0\1\62\50\0\1\65\63\0\1\66"+
188 |     "\63\0\1\67\57\0\1\27\5\0\2\27\3\0\24\27"+
189 |     "\25\0\1\27\5\0\2\27\3\0\14\27\1\70\1\27"+
190 |     "\1\71\5\27\25\0\1\27\5\0\2\27\3\0\12\27"+
191 |     "\1\72\11\27\25\0\1\27\5\0\2\27\3\0\14\27"+
192 |     "\1\73\7\27\25\0\1\27\5\0\2\27\3\0\12\27"+
193 |     "\1\74\11\27\25\0\1\27\5\0\2\27\3\0\1\75"+
194 |     "\13\27\1\76\7\27\25\0\1\27\5\0\2\27\3\0"+
195 |     "\5\27\1\77\5\27\1\100\10\27\25\0\1\27\5\0"+
196 |     "\2\27\3\0\4\27\1\101\14\27\1\102\2\27\25\0"+
197 |     "\1\27\5\0\2\27\3\0\21\27\1\103\2\27\25\0"+
198 |     "\1\27\5\0\2\27\3\0\4\27\1\104\17\27\25\0"+
199 |     "\1\27\5\0\2\27\3\0\20\27\1\105\3\27\25\0"+
200 |     "\1\27\5\0\2\27\3\0\16\27\1\106\5\27\25\0"+
201 |     "\1\27\5\0\2\27\3\0\14\27\1\107\7\27\25\0"+
202 |     "\1\27\5\0\2\27\3\0\7\27\1\110\14\27\65\0"+
203 |     "\1\111\1\0\7\53\1\112\23\53\1\55\30\53\15\0"+
204 |     "\1\113\1\0\1\113\2\0\1\114\41\0\14\63\1\115"+
205 |     "\47\63\2\64\1\116\2\0\1\117\56\64\22\0\1\27"+
206 |     "\5\0\2\27\3\0\14\27\1\120\7\27\25\0\1\27"+
207 |     "\5\0\2\27\3\0\4\27\1\121\17\27\25\0\1\27"+
208 |     "\5\0\2\27\3\0\1\122\23\27\25\0\1\27\5\0"+
209 |     "\2\27\3\0\21\27\1\123\2\27\25\0\1\27\5\0"+
210 |     "\2\27\3\0\17\27\1\124\4\27\25\0\1\27\5\0"+
211 |     "\2\27\3\0\12\27\1\125\11\27\25\0\1\27\5\0"+
212 |     "\2\27\3\0\16\27\1\126\5\27\25\0\1\27\5\0"+
213 |     "\2\27\3\0\20\27\1\127\3\27\25\0\1\27\5\0"+
214 |     "\2\27\3\0\23\27\1\130\25\0\1\27\5\0\2\27"+
215 |     "\3\0\12\27\1\131\11\27\25\0\1\27\5\0\2\27"+
216 |     "\3\0\1\27\1\132\22\27\25\0\1\27\5\0\2\27"+
217 |     "\3\0\20\27\1\133\3\27\25\0\1\27\5\0\2\27"+
218 |     "\3\0\1\134\15\27\1\135\5\27\25\0\1\27\5\0"+
219 |     "\2\27\3\0\21\27\1\136\2\27\25\0\1\27\5\0"+
220 |     "\2\27\3\0\10\27\1\137\13\27\25\0\1\27\5\0"+
221 |     "\2\27\3\0\10\27\1\140\13\27\25\0\1\114\41\0"+
222 |     "\14\63\1\115\4\63\1\116\42\63\2\0\1\116\103\0"+
223 |     "\1\27\5\0\2\27\3\0\12\27\1\141\11\27\25\0"+
224 |     "\1\27\5\0\2\27\3\0\1\142\23\27\25\0\1\27"+
225 |     "\5\0\2\27\3\0\17\27\1\143\4\27\25\0\1\27"+
226 |     "\5\0\2\27\3\0\1\27\1\144\22\27\25\0\1\27"+
227 |     "\5\0\2\27\3\0\4\27\1\145\17\27\25\0\1\27"+
228 |     "\5\0\2\27\3\0\17\27\1\136\4\27\25\0\1\27"+
229 |     "\5\0\2\27\3\0\12\27\1\146\11\27\25\0\1\27"+
230 |     "\5\0\2\27\3\0\12\27\1\147\11\27\25\0\1\27"+
231 |     "\5\0\2\27\3\0\21\27\1\150\2\27\25\0\1\27"+
232 |     "\5\0\2\27\3\0\20\27\1\151\3\27\25\0\1\27"+
233 |     "\5\0\2\27\3\0\10\27\1\152\13\27\25\0\1\27"+
234 |     "\5\0\2\27\3\0\4\27\1\153\17\27\25\0\1\27"+
235 |     "\5\0\2\27\3\0\3\27\1\154\20\27\25\0\1\27"+
236 |     "\5\0\2\27\3\0\12\27\1\155\11\27\25\0\1\27"+
237 |     "\5\0\2\27\3\0\4\27\1\156\17\27\25\0\1\27"+
238 |     "\5\0\2\27\3\0\11\27\1\157\12\27\25\0\1\27"+
239 |     "\5\0\2\27\3\0\17\27\1\160\4\27\25\0\1\27"+
240 |     "\5\0\2\27\3\0\12\27\1\161\11\27\25\0\1\27"+
241 |     "\5\0\2\27\3\0\10\27\1\162\13\27\25\0\1\27"+
242 |     "\5\0\2\27\3\0\16\27\1\163\5\27\25\0\1\27"+
243 |     "\5\0\2\27\3\0\10\27\1\164\13\27\25\0\1\27"+
244 |     "\5\0\2\27\3\0\13\27\1\165\10\27\25\0\1\27"+
245 |     "\5\0\2\27\3\0\4\27\1\166\17\27\25\0\1\27"+
246 |     "\5\0\2\27\3\0\1\167\23\27\25\0\1\27\5\0"+
247 |     "\2\27\3\0\4\27\1\170\17\27\25\0\1\27\5\0"+
248 |     "\2\27\3\0\2\27\1\171\21\27\25\0\1\27\5\0"+
249 |     "\2\27\3\0\13\27\1\172\10\27\25\0\1\27\5\0"+
250 |     "\2\27\3\0\2\27\1\173\21\27\25\0\1\27\5\0"+
251 |     "\2\27\3\0\6\27\1\174\15\27\25\0\1\27\5\0"+
252 |     "\2\27\3\0\13\27\1\175\10\27\3\0";
253 | 
254 |   private static int [] zzUnpackTrans() {
255 |     int [] result = new int[4264];
256 |     int offset = 0;
257 |     offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
258 |     return result;
259 |   }
260 | 
261 |   private static int zzUnpackTrans(String packed, int offset, int [] result) {
262 |     int i = 0;       /* index in packed string  */
263 |     int j = offset;  /* index in unpacked array */
264 |     int l = packed.length();
265 |     while (i < l) {
266 |       int count = packed.charAt(i++);
267 |       int value = packed.charAt(i++);
268 |       value--;
269 |       do result[j++] = value; while (--count > 0);
270 |     }
271 |     return j;
272 |   }
273 | 
274 | 
275 |   /** Error code for "Unknown internal scanner error". */
276 |   private static final int ZZ_UNKNOWN_ERROR = 0;
277 |   /** Error code for "could not match input". */
278 |   private static final int ZZ_NO_MATCH = 1;
279 |   /** Error code for "pushback value was too large". */
280 |   private static final int ZZ_PUSHBACK_2BIG = 2;
281 | 
282 |   /**
283 |    * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
284 |    * {@link #ZZ_PUSHBACK_2BIG} respectively.
285 |    */
286 |   private static final String ZZ_ERROR_MSG[] = {
287 |     "Unknown internal scanner error",
288 |     "Error: could not match input",
289 |     "Error: pushback value was too large"
290 |   };
291 | 
292 |   /**
293 |    * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
294 |    */
295 |   private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
296 | 
297 |   private static final String ZZ_ATTRIBUTE_PACKED_0 =
298 |     "\1\0\1\11\1\1\1\11\2\1\1\11\1\1\3\11"+
299 |     "\1\1\1\11\4\1\2\11\4\1\2\11\15\1\1\11"+
300 |     "\1\1\2\11\1\0\1\11\1\0\3\11\1\1\3\0"+
301 |     "\3\11\21\1\1\11\1\1\1\0\1\1\1\0\1\11"+
302 |     "\1\0\56\1";
303 | 
304 |   private static int [] zzUnpackAttribute() {
305 |     int [] result = new int[125];
306 |     int offset = 0;
307 |     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
308 |     return result;
309 |   }
310 | 
311 |   private static int zzUnpackAttribute(String packed, int offset, int [] result) {
312 |     int i = 0;       /* index in packed string  */
313 |     int j = offset;  /* index in unpacked array */
314 |     int l = packed.length();
315 |     while (i < l) {
316 |       int count = packed.charAt(i++);
317 |       int value = packed.charAt(i++);
318 |       do result[j++] = value; while (--count > 0);
319 |     }
320 |     return j;
321 |   }
322 | 
323 |   /** Input device. */
324 |   private java.io.Reader zzReader;
325 | 
326 |   /** Current state of the DFA. */
327 |   private int zzState;
328 | 
329 |   /** Current lexical state. */
330 |   private int zzLexicalState = YYINITIAL;
331 | 
332 |   /**
333 |    * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
334 |    * string.
335 |    */
336 |   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
337 | 
338 |   /** Text position at the last accepting state. */
339 |   private int zzMarkedPos;
340 | 
341 |   /** Current text position in the buffer. */
342 |   private int zzCurrentPos;
343 | 
344 |   /** Marks the beginning of the {@link #yytext()} string in the buffer. */
345 |   private int zzStartRead;
346 | 
347 |   /** Marks the last character in the buffer, that has been read from input. */
348 |   private int zzEndRead;
349 | 
350 |   /**
351 |    * Whether the scanner is at the end of file.
352 |    * @see #yyatEOF
353 |    */
354 |   private boolean zzAtEOF;
355 | 
356 |   /**
357 |    * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
358 |    *
359 |    * <p>When a lead/high surrogate has been read from the input stream into the final
360 |    * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
361 |    */
362 |   private int zzFinalHighSurrogate = 0;
363 | 
364 |   /** Number of newlines encountered up to the start of the matched text. */
365 |   @SuppressWarnings("unused")
366 |   private int yyline;
367 | 
368 |   /** Number of characters from the last newline up to the start of the matched text. */
369 |   @SuppressWarnings("unused")
370 |   private int yycolumn;
371 | 
372 |   /** Number of characters up to the start of the matched text. */
373 |   @SuppressWarnings("unused")
374 |   private long yychar;
375 | 
376 |   /** Whether the scanner is currently at the beginning of a line. */
377 |   @SuppressWarnings("unused")
378 |   private boolean zzAtBOL = true;
379 | 
380 |   /** Whether the user-EOF-code has already been executed. */
381 |   @SuppressWarnings("unused")
382 |   private boolean zzEOFDone;
383 | 
384 | 
385 |   /**
386 |    * Creates a new scanner
387 |    *
388 |    * @param   in  the java.io.Reader to read input from.
389 |    */
390 |   Yylex(java.io.Reader in) {
391 |     this.zzReader = in;
392 |   }
393 | 
394 |   /**
395 |    * Translates raw input code points to DFA table row
396 |    */
397 |   private static int zzCMap(int input) {
398 |     int offset = input & 255;
399 |     return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
400 |   }
401 | 
402 |   /**
403 |    * Refills the input buffer.
404 |    *
405 |    * @return {@code false} iff there was new input.
406 |    * @exception java.io.IOException  if any I/O-Error occurs
407 |    */
408 |   private boolean zzRefill() throws java.io.IOException {
409 | 
410 |     /* first: make room (if you can) */
411 |     if (zzStartRead > 0) {
412 |       zzEndRead += zzFinalHighSurrogate;
413 |       zzFinalHighSurrogate = 0;
414 |       System.arraycopy(zzBuffer, zzStartRead,
415 |                        zzBuffer, 0,
416 |                        zzEndRead - zzStartRead);
417 | 
418 |       /* translate stored positions */
419 |       zzEndRead -= zzStartRead;
420 |       zzCurrentPos -= zzStartRead;
421 |       zzMarkedPos -= zzStartRead;
422 |       zzStartRead = 0;
423 |     }
424 | 
425 |     /* is the buffer big enough? */
426 |     if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {
427 |       /* if not: blow it up */
428 |       char newBuffer[] = new char[zzBuffer.length * 2];
429 |       System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
430 |       zzBuffer = newBuffer;
431 |       zzEndRead += zzFinalHighSurrogate;
432 |       zzFinalHighSurrogate = 0;
433 |     }
434 | 
435 |     /* fill the buffer with new input */
436 |     int requested = zzBuffer.length - zzEndRead;
437 |     int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
438 | 
439 |     /* not supposed to occur according to specification of java.io.Reader */
440 |     if (numRead == 0) {
441 |       throw new java.io.IOException(
442 |           "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
443 |     }
444 |     if (numRead > 0) {
445 |       zzEndRead += numRead;
446 |       if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
447 |         if (numRead == requested) { // We requested too few chars to encode a full Unicode character
448 |           --zzEndRead;
449 |           zzFinalHighSurrogate = 1;
450 |         } else {                    // There is room in the buffer for at least one more char
451 |           int c = zzReader.read();  // Expecting to read a paired low surrogate char
452 |           if (c == -1) {
453 |             return true;
454 |           } else {
455 |             zzBuffer[zzEndRead++] = (char)c;
456 |           }
457 |         }
458 |       }
459 |       /* potentially more input available */
460 |       return false;
461 |     }
462 | 
463 |     /* numRead < 0 ==> end of stream */
464 |     return true;
465 |   }
466 | 
467 | 
468 |   /**
469 |    * Closes the input reader.
470 |    *
471 |    * @throws java.io.IOException if the reader could not be closed.
472 |    */
473 |   public final void yyclose() throws java.io.IOException {
474 |     zzAtEOF = true; // indicate end of file
475 |     zzEndRead = zzStartRead; // invalidate buffer
476 | 
477 |     if (zzReader != null) {
478 |       zzReader.close();
479 |     }
480 |   }
481 | 
482 | 
483 |   /**
484 |    * Resets the scanner to read from a new input stream.
485 |    *
486 |    * <p>Does not close the old reader.
487 |    *
488 |    * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
489 |    * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
490 |    *
491 |    * <p>Internal scan buffer is resized down to its initial length, if it has grown.
492 |    *
493 |    * @param reader The new input stream.
494 |    */
495 |   public final void yyreset(java.io.Reader reader) {
496 |     zzReader = reader;
497 |     zzEOFDone = false;
498 |     yyResetPosition();
499 |     zzLexicalState = YYINITIAL;
500 |     if (zzBuffer.length > ZZ_BUFFERSIZE) {
501 |       zzBuffer = new char[ZZ_BUFFERSIZE];
502 |     }
503 |   }
504 | 
505 |   /**
506 |    * Resets the input position.
507 |    */
508 |   private final void yyResetPosition() {
509 |       zzAtBOL  = true;
510 |       zzAtEOF  = false;
511 |       zzCurrentPos = 0;
512 |       zzMarkedPos = 0;
513 |       zzStartRead = 0;
514 |       zzEndRead = 0;
515 |       zzFinalHighSurrogate = 0;
516 |       yyline = 0;
517 |       yycolumn = 0;
518 |       yychar = 0L;
519 |   }
520 | 
521 | 
522 |   /**
523 |    * Returns whether the scanner has reached the end of the reader it reads from.
524 |    *
525 |    * @return whether the scanner has reached EOF.
526 |    */
527 |   public final boolean yyatEOF() {
528 |     return zzAtEOF;
529 |   }
530 | 
531 | 
532 |   /**
533 |    * Returns the current lexical state.
534 |    *
535 |    * @return the current lexical state.
536 |    */
537 |   public final int yystate() {
538 |     return zzLexicalState;
539 |   }
540 | 
541 | 
542 |   /**
543 |    * Enters a new lexical state.
544 |    *
545 |    * @param newState the new lexical state
546 |    */
547 |   public final void yybegin(int newState) {
548 |     zzLexicalState = newState;
549 |   }
550 | 
551 | 
552 |   /**
553 |    * Returns the text matched by the current regular expression.
554 |    *
555 |    * @return the matched text.
556 |    */
557 |   public final String yytext() {
558 |     return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
559 |   }
560 | 
561 | 
562 |   /**
563 |    * Returns the character at the given position from the matched text.
564 |    *
565 |    * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
566 |    *
567 |    * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
568 |    *
569 |    * @return the character at {@code position}.
570 |    */
571 |   public final char yycharat(int position) {
572 |     return zzBuffer[zzStartRead + position];
573 |   }
574 | 
575 | 
576 |   /**
577 |    * How many characters were matched.
578 |    *
579 |    * @return the length of the matched text region.
580 |    */
581 |   public final int yylength() {
582 |     return zzMarkedPos-zzStartRead;
583 |   }
584 | 
585 | 
586 |   /**
587 |    * Reports an error that occurred while scanning.
588 |    *
589 |    * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
590 |    * match-all fallback rule) this method will only be called with things that
591 |    * "Can't Possibly Happen".
592 |    *
593 |    * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
594 |    * scanner etc.).
595 |    *
596 |    * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
597 |    *
598 |    * @param errorCode the code of the error message to display.
599 |    */
600 |   private static void zzScanError(int errorCode) {
601 |     String message;
602 |     try {
603 |       message = ZZ_ERROR_MSG[errorCode];
604 |     } catch (ArrayIndexOutOfBoundsException e) {
605 |       message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
606 |     }
607 | 
608 |     throw new Error(message);
609 |   }
610 | 
611 | 
612 |   /**
613 |    * Pushes the specified amount of characters back into the input stream.
614 |    *
615 |    * <p>They will be read again by then next call of the scanning method.
616 |    *
617 |    * @param number the number of characters to be read again. This number must not be greater than
618 |    *     {@link #yylength()}.
619 |    */
620 |   public void yypushback(int number)  {
621 |     if ( number > yylength() )
622 |       zzScanError(ZZ_PUSHBACK_2BIG);
623 | 
624 |     zzMarkedPos -= number;
625 |   }
626 | 
627 | 
628 | 
629 | 
630 |   /**
631 |    * Resumes scanning until the next regular expression is matched, the end of input is encountered
632 |    * or an I/O-Error occurs.
633 |    *
634 |    * @return the next token.
635 |    * @exception java.io.IOException if any I/O-Error occurs.
636 |    */
637 |   public int yylex() throws java.io.IOException {
638 |     int zzInput;
639 |     int zzAction;
640 | 
641 |     // cached fields:
642 |     int zzCurrentPosL;
643 |     int zzMarkedPosL;
644 |     int zzEndReadL = zzEndRead;
645 |     char[] zzBufferL = zzBuffer;
646 | 
647 |     int [] zzTransL = ZZ_TRANS;
648 |     int [] zzRowMapL = ZZ_ROWMAP;
649 |     int [] zzAttrL = ZZ_ATTRIBUTE;
650 | 
651 |     while (true) {
652 |       zzMarkedPosL = zzMarkedPos;
653 | 
654 |       zzAction = -1;
655 | 
656 |       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
657 | 
658 |       zzState = ZZ_LEXSTATE[zzLexicalState];
659 | 
660 |       // set up zzAction for empty match case:
661 |       int zzAttributes = zzAttrL[zzState];
662 |       if ( (zzAttributes & 1) == 1 ) {
663 |         zzAction = zzState;
664 |       }
665 | 
666 | 
667 |       zzForAction: {
668 |         while (true) {
669 | 
670 |           if (zzCurrentPosL < zzEndReadL) {
671 |             zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
672 |             zzCurrentPosL += Character.charCount(zzInput);
673 |           }
674 |           else if (zzAtEOF) {
675 |             zzInput = YYEOF;
676 |             break zzForAction;
677 |           }
678 |           else {
679 |             // store back cached positions
680 |             zzCurrentPos  = zzCurrentPosL;
681 |             zzMarkedPos   = zzMarkedPosL;
682 |             boolean eof = zzRefill();
683 |             // get translated positions and possibly new buffer
684 |             zzCurrentPosL  = zzCurrentPos;
685 |             zzMarkedPosL   = zzMarkedPos;
686 |             zzBufferL      = zzBuffer;
687 |             zzEndReadL     = zzEndRead;
688 |             if (eof) {
689 |               zzInput = YYEOF;
690 |               break zzForAction;
691 |             }
692 |             else {
693 |               zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
694 |               zzCurrentPosL += Character.charCount(zzInput);
695 |             }
696 |           }
697 |           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
698 |           if (zzNext == -1) break zzForAction;
699 |           zzState = zzNext;
700 | 
701 |           zzAttributes = zzAttrL[zzState];
702 |           if ( (zzAttributes & 1) == 1 ) {
703 |             zzAction = zzState;
704 |             zzMarkedPosL = zzCurrentPosL;
705 |             if ( (zzAttributes & 8) == 8 ) break zzForAction;
706 |           }
707 | 
708 |         }
709 |       }
710 | 
711 |       // store back cached position
712 |       zzMarkedPos = zzMarkedPosL;
713 | 
714 |       if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
715 |         zzAtEOF = true;
716 |         return YYEOF;
717 |       }
718 |       else {
719 |         switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
720 |           case 1:
721 |             { j0.lexErr("unrecognized character");
722 |             }
723 |             // fall through
724 |           case 53: break;
725 |           case 2:
726 |             { j0.whitespace();
727 |             }
728 |             // fall through
729 |           case 54: break;
730 |           case 3:
731 |             { j0.newline();
732 |             }
733 |             // fall through
734 |           case 55: break;
735 |           case 4:
736 |             { return j0.scan(j0.ord("!"));
737 |             }
738 |             // fall through
739 |           case 56: break;
740 |           case 5:
741 |             { return j0.scan(j0.ord("%"));
742 |             }
743 |             // fall through
744 |           case 57: break;
745 |           case 6:
746 |             { return j0.scan(j0.ord("("));
747 |             }
748 |             // fall through
749 |           case 58: break;
750 |           case 7:
751 |             { return j0.scan(j0.ord(")"));
752 |             }
753 |             // fall through
754 |           case 59: break;
755 |           case 8:
756 |             { return j0.scan(j0.ord("*"));
757 |             }
758 |             // fall through
759 |           case 60: break;
760 |           case 9:
761 |             { return j0.scan(j0.ord("+"));
762 |             }
763 |             // fall through
764 |           case 61: break;
765 |           case 10:
766 |             { return j0.scan(j0.ord(","));
767 |             }
768 |             // fall through
769 |           case 62: break;
770 |           case 11:
771 |             { return j0.scan(j0.ord("-"));
772 |             }
773 |             // fall through
774 |           case 63: break;
775 |           case 12:
776 |             { return j0.scan(j0.ord("."));
777 |             }
778 |             // fall through
779 |           case 64: break;
780 |           case 13:
781 |             { return j0.scan(j0.ord("/"));
782 |             }
783 |             // fall through
784 |           case 65: break;
785 |           case 14:
786 |             { return j0.scan(parser.INTLIT);
787 |             }
788 |             // fall through
789 |           case 66: break;
790 |           case 15:
791 |             { return j0.scan(j0.ord(":"));
792 |             }
793 |             // fall through
794 |           case 67: break;
795 |           case 16:
796 |             { return j0.scan(j0.ord(";"));
797 |             }
798 |             // fall through
799 |           case 68: break;
800 |           case 17:
801 |             { return j0.scan(j0.ord("<"));
802 |             }
803 |             // fall through
804 |           case 69: break;
805 |           case 18:
806 |             { return j0.scan(j0.ord("="));
807 |             }
808 |             // fall through
809 |           case 70: break;
810 |           case 19:
811 |             { return j0.scan(j0.ord(">"));
812 |             }
813 |             // fall through
814 |           case 71: break;
815 |           case 20:
816 |             { return j0.scan(parser.IDENTIFIER);
817 |             }
818 |             // fall through
819 |           case 72: break;
820 |           case 21:
821 |             { return j0.scan(j0.ord("["));
822 |             }
823 |             // fall through
824 |           case 73: break;
825 |           case 22:
826 |             { return j0.scan(j0.ord("]"));
827 |             }
828 |             // fall through
829 |           case 74: break;
830 |           case 23:
831 |             { return j0.scan(j0.ord("{"));
832 |             }
833 |             // fall through
834 |           case 75: break;
835 |           case 24:
836 |             { return j0.scan(j0.ord("}"));
837 |             }
838 |             // fall through
839 |           case 76: break;
840 |           case 25:
841 |             { return j0.scan(parser.NOTEQUALTO);
842 |             }
843 |             // fall through
844 |           case 77: break;
845 |           case 26:
846 |             { return j0.scan(parser.STRINGLIT);
847 |             }
848 |             // fall through
849 |           case 78: break;
850 |           case 27:
851 |             { return j0.scan(parser.LOGICALAND);
852 |             }
853 |             // fall through
854 |           case 79: break;
855 |           case 28:
856 |             { return j0.scan(parser.INCREMENT);
857 |             }
858 |             // fall through
859 |           case 80: break;
860 |           case 29:
861 |             { return j0.scan(parser.DECREMENT);
862 |             }
863 |             // fall through
864 |           case 81: break;
865 |           case 30:
866 |             { return j0.scan(parser.DOUBLELIT);
867 |             }
868 |             // fall through
869 |           case 82: break;
870 |           case 31:
871 |             { return j0.scan(parser.LESSTHANOREQUAL);
872 |             }
873 |             // fall through
874 |           case 83: break;
875 |           case 32:
876 |             { return j0.scan(parser.ISEQUALTO);
877 |             }
878 |             // fall through
879 |           case 84: break;
880 |           case 33:
881 |             { return j0.scan(parser.GREATERTHANOREQUAL);
882 |             }
883 |             // fall through
884 |           case 85: break;
885 |           case 34:
886 |             { return j0.scan(parser.IF);
887 |             }
888 |             // fall through
889 |           case 86: break;
890 |           case 35:
891 |             { return j0.scan(parser.LOGICALOR);
892 |             }
893 |             // fall through
894 |           case 87: break;
895 |           case 36:
896 |             { j0.comment();
897 |             }
898 |             // fall through
899 |           case 88: break;
900 |           case 37:
901 |             { return j0.scan(parser.FOR);
902 |             }
903 |             // fall through
904 |           case 89: break;
905 |           case 38:
906 |             { return j0.scan(parser.INT);
907 |             }
908 |             // fall through
909 |           case 90: break;
910 |           case 39:
911 |             { return j0.scan(parser.NEW);
912 |             }
913 |             // fall through
914 |           case 91: break;
915 |           case 40:
916 |             { return j0.scan(parser.ELSE);
917 |             }
918 |             // fall through
919 |           case 92: break;
920 |           case 41:
921 |             { return j0.scan(parser.NULLVAL);
922 |             }
923 |             // fall through
924 |           case 93: break;
925 |           case 42:
926 |             { return j0.scan(parser.BOOLLIT);
927 |             }
928 |             // fall through
929 |           case 94: break;
930 |           case 43:
931 |             { return j0.scan(parser.VOID);
932 |             }
933 |             // fall through
934 |           case 95: break;
935 |           case 44:
936 |             { return j0.scan(parser.BREAK);
937 |             }
938 |             // fall through
939 |           case 96: break;
940 |           case 45:
941 |             { return j0.scan(parser.CLASS);
942 |             }
943 |             // fall through
944 |           case 97: break;
945 |           case 46:
946 |             { return j0.scan(parser.WHILE);
947 |             }
948 |             // fall through
949 |           case 98: break;
950 |           case 47:
951 |             { return j0.scan(parser.DOUBLE);
952 |             }
953 |             // fall through
954 |           case 99: break;
955 |           case 48:
956 |             { return j0.scan(parser.PUBLIC);
957 |             }
958 |             // fall through
959 |           case 100: break;
960 |           case 49:
961 |             { return j0.scan(parser.RETURN);
962 |             }
963 |             // fall through
964 |           case 101: break;
965 |           case 50:
966 |             { return j0.scan(parser.STATIC);
967 |             }
968 |             // fall through
969 |           case 102: break;
970 |           case 51:
971 |             { return j0.scan(parser.STRING);
972 |             }
973 |             // fall through
974 |           case 103: break;
975 |           case 52:
976 |             { return j0.scan(parser.BOOLEAN);
977 |             }
978 |             // fall through
979 |           case 104: break;
980 |           default:
981 |             zzScanError(ZZ_NO_MATCH);
982 |         }
983 |       }
984 |     }
985 |   }
986 | 
987 | 
988 | }
989 | 


--------------------------------------------------------------------------------
/ch9/address.icn:
--------------------------------------------------------------------------------
 1 | class address(region, offset)
 2 | method regaddr()
 3 |   return if region == "method" then "loc" else region
 4 | end
 5 | method str()
 6 |   case region of {
 7 |   "lab": return "L"||offset
 8 |   "loc"|"imm"|"method"|"global"|"class"|"strings":
 9 |     return regaddr() || ":" || offset
10 |   }
11 |   return region
12 | end
13 | method print()
14 |   writes(str())
15 | end
16 | end
17 | 


--------------------------------------------------------------------------------
/ch9/address.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class address {
 3 |     public String region;
 4 |     public int offset;
 5 |     public String regaddr() { return region.equals("method")?"loc":region; }
 6 |     public String str() {
 7 | 	switch (region) {
 8 | 	case "lab": return "L" + offset;
 9 | 	case "loc": case "imm": case "method":
10 | 	case "global": case "class": case "strings":
11 | 	    return regaddr() + ":" + offset;
12 | 	}
13 | 	return region;
14 |     }
15 |     public void print() { System.out.print(str()); }
16 |     address(String s, int o) { region = s; offset = o; }
17 | }
18 | 


--------------------------------------------------------------------------------
/ch9/arraytype.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class arraytype extends typeinfo {
 3 |    typeinfo element_type;
 4 |     public String str() {
 5 | 	return "array of " + (element_type!=null?element_type.str():"undef");
 6 |     }
 7 |    public arraytype(typeinfo t) {
 8 |       basetype = "array"; element_type = t; }
 9 | }
10 | 


--------------------------------------------------------------------------------
/ch9/arrtst.java:
--------------------------------------------------------------------------------
 1 | public class arrtst {
 2 |    public static void main(String argv[]) {
 3 |       int x[];
 4 |       x = new int[3];
 5 |       x[1] = 0;
 6 |       x[0] = x[1];
 7 |       x[2] = argv[1];
 8 |       System.out.println("hello, world");
 9 |    }
10 | }
11 | 


--------------------------------------------------------------------------------
/ch9/classtype.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class classtype extends typeinfo {
 3 |    String name;
 4 |    symtab st;
 5 |    parameter [] methods;
 6 |    parameter [] fields;
 7 |    typeinfo [] constrs;
 8 |     public String str() {
 9 | 	return name;
10 |     }
11 |     public classtype(String s) { name = s; basetype="class";}
12 |     public classtype(String s, symtab stab) { name = s; st = stab; basetype="class";}
13 |    public classtype(String s, symtab stab,
14 | 		    parameter []ms, parameter[]fs, typeinfo[]cs) {
15 |        name = s; st = stab; methods=ms; fields=fs; constrs=cs; basetype="class";}
16 | }
17 | 


--------------------------------------------------------------------------------
/ch9/clstest.java:
--------------------------------------------------------------------------------
1 | public class clstest {
2 |    public static void main(String argv[]) {
3 |        clstest c;
4 |        c = new clstest();
5 |       System.out.println("hello, jzero!");
6 |    }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch9/funtest.java:
--------------------------------------------------------------------------------
 1 | public class funtest {
 2 |    public static int foo(int x, int y, String z) {
 3 |        return 0;
 4 |    }
 5 |    public static void main(String argv[]) {
 6 |       int x;
 7 |       x = foo(0,1,"howdy");
 8 |       x = x + 1;
 9 |       System.out.println("hello, jzero!");
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch9/hello.java:
--------------------------------------------------------------------------------
 1 | public class hello {
 2 |    public static void main(String argv[]) {
 3 |       int x;
 4 |       x = argv.length;
 5 |       x = x + 2;
 6 |       while (x > 3) {
 7 |          System.out.println("hello, jzero!");
 8 |          x = x - 1;
 9 |       }
10 |    }
11 | }
12 | 


--------------------------------------------------------------------------------
/ch9/helloerror.java:
--------------------------------------------------------------------------------
1 | public class hello {
2 |    public static void main(String argv[]) {
3 |       System.out.println("hello, jzero!")
4 |    }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch9/j0.icn:
--------------------------------------------------------------------------------
 1 | global yylineno, yycolno, yylval, parser, global_st, stringtab
 2 | procedure main(argv)
 3 |    j0 := j0()
 4 |    serial := serial()
 5 |    parser := Parser()
 6 |    yyin := open(argv[1]) | stop("usage: j0 filename")
 7 |    yylineno := yycolno := 1
 8 |    if yyparse() = 0 then
 9 |       write("no errors")
10 | end
11 | class j0()
12 |    method lexErr(s)
13 |       stop(s, ": ", yytext) 
14 |    end
15 |    method scan(cat)
16 |       yylval := tree("token", cat, token(cat, yytext, yylineno, yycolno))
17 |       yycolno +:= *yytext
18 |       return cat
19 |    end
20 |    method whitespace()
21 |       yycolno +:= *yytext
22 |    end
23 |    method newline()
24 |       yylineno +:= 1; yycolno := 1
25 |    end
26 |    method comment()
27 |       yytext ? {
28 |          while tab(find("\n")+1) do newline()
29 |          yycolno +:= *tab(0)
30 |       }
31 |    end
32 |    method ord(s)
33 |       return proc("ord",0)(s[1])
34 |    end
35 |    method print(root)
36 |       root.print()
37 |    end
38 |    method node(s,r,p[])
39 |       rv := tree ! ([s,r] ||| p)
40 |       return rv
41 |    end
42 |    method semantic(root)
43 |    local out_st, System_st
44 |      global_st := symtab("global")
45 |      stringtab := symtab("strings")
46 |      System_st := symtab("class")
47 |      out_st := symtab("class")
48 |      out_st.insert("println", false, ,
49 |         methodtype([classtype("String")], typeinfo("void")))
50 |      System_st.insert("out", false, out_st, classtype("PrintStream",out_st))
51 |      global_st.insert("System", false, System_st, classtype("System",System_st))
52 |      if \verbose then write("making symbol tables")
53 |      root.mkSymTables(global_st)
54 |      root.populateSymTables()
55 |      if \verbose then write("checking symbol tables")
56 |      root.checkSymTables()
57 |      root.mkcls()
58 | #     global_st.print()
59 |      root.checktype()
60 |    end
61 |    method semErr(s)
62 |      stop("semantic error: ", s)
63 |    end
64 |    method calctype(t)
65 |      t.kids[1].calctype()
66 |      t.kids[2].assigntype(t.kids[1].typ)
67 |    end
68 |    method gencode(root)
69 |       root.genfirst()
70 |       root.genfollow()
71 |       root.gentargets()
72 |       root.gencode()
73 |       every (! (\root.icode)).print()
74 |    end
75 | end
76 | 


--------------------------------------------------------------------------------
/ch9/j0.java:
--------------------------------------------------------------------------------
  1 | package ch9;
  2 | import java.io.FileReader;
  3 | public class j0 {
  4 |    public static Yylex yylexer;
  5 |    public static ch9.parser par;
  6 |    public static ch9.symtab global_st, stringtab;
  7 |    public static void main(String argv[]) throws Exception {
  8 |       init(argv[0]);
  9 |       par = new parser();
 10 |       //                  par.yydebug=true;
 11 |       yylineno = 1;
 12 |       int i = par.yyparse();
 13 |       if (i == 0)
 14 |          System.out.println("no errors");
 15 |    }
 16 |    public static int yylineno;
 17 |    public static String yyfilename;
 18 |     //   public static parserVal yylval;
 19 |    public static void init(String s) throws Exception {
 20 |       yyfilename = s;
 21 |       yylexer = new Yylex(new FileReader(s));
 22 |    }
 23 |    public static int YYEOF() { return Yylex.YYEOF; }
 24 |    public static int yylex() {
 25 |       int rv = 0;
 26 |       try {
 27 |         rv = yylexer.yylex();
 28 |       } catch(java.io.IOException ioException) {
 29 |         rv = -1;
 30 |       }
 31 |       return rv;
 32 |    }
 33 |    public static String yytext() {
 34 |       return yylexer.yytext();
 35 |    }
 36 |    public static void lexErr(String s) {
 37 |       System.err.println(s);
 38 |       System.exit(1);
 39 |    }
 40 |    public static int scan(int cat) {
 41 |        ch9.j0.par.yylval =
 42 | 	   new parserVal(new tree("token",cat,
 43 | 		new token(cat, yytext(), yylineno)));
 44 |       return cat;
 45 |    }
 46 |    public static void newline() {
 47 |       yylineno++;
 48 |    }
 49 |    public static void whitespace() {
 50 |    }
 51 |    public static void comment() {
 52 |    }
 53 |    public static short ord(String s) { return (short)(s.charAt(0)); }
 54 |    public static void print(parserVal root) {
 55 |        ((tree)root.obj).print_graph(yyfilename + ".dot");
 56 |    }
 57 |   public static tree unwrap(Object obj) {
 58 |     if (obj instanceof token)
 59 |       return new tree("token",0,(token)obj);
 60 |     else return (tree)obj;
 61 |   }
 62 |   public static parserVal node(String s,int r,parserVal...p) {
 63 |      tree[] t = new tree[p.length];
 64 |      for(int i = 0; i < t.length; i++)
 65 | 	 t[i] = (tree)(p[i].obj);
 66 |      return new parserVal((Object)new tree(s,r,t));
 67 |   }
 68 |   public static void semantic(parserVal r) {
 69 |     tree root = (tree)(r.obj);
 70 |     ch9.symtab out_st, System_st;
 71 |     global_st = new ch9.symtab("global");
 72 |     stringtab = new ch9.symtab("strings");
 73 |     System_st = new ch9.symtab("class");
 74 |     out_st = new ch9.symtab("class");
 75 |     out_st.insert("println", false, null,
 76 | 		  new methodtype(new typeinfo[]{new classtype("String")},
 77 | 				 new typeinfo("void")));
 78 |     System_st.insert("out", false, out_st,
 79 |        new classtype("PrintStream",out_st));
 80 |     global_st.insert("System", false, System_st,
 81 |        new classtype("System",System_st));
 82 |    root.mkSymTables(global_st);
 83 |    root.populateSymTables();
 84 |    root.checkSymTables();
 85 |    root.mkcls();
 86 |    //   global_st.print();
 87 |    root.checktype(false);
 88 |   }
 89 |   public static void semErr(String s) {
 90 |    System.out.println("semantic error: " + s);
 91 |    System.exit(1);
 92 |   }
 93 |   public static void calctype(parserVal pv){
 94 |     tree t = (tree)pv.obj;
 95 |     t.kids[0].calctype();
 96 |     t.kids[1].assigntype(t.kids[0].typ);
 97 |   }
 98 |   public static void gencode(parserVal r) {
 99 |     tree root = (tree)(r.obj);
100 |     root.genfirst();
101 |     root.genfollow();
102 |     root.gentargets();
103 |     root.gencode();
104 |     if (root.icode != null) {
105 | 	for(int i = 0; i < root.icode.size(); i++) {
106 | 	    root.icode.get(i).print();
107 | 	}
108 |     }
109 |   }
110 | }
111 | 


--------------------------------------------------------------------------------
/ch9/j0gram.icn:
--------------------------------------------------------------------------------
  1 | ### This file created by IYACC 1.1
  2 | ### Please send bug reports to jeffery@cs.nmt.edu
  3 | #define YYPREFIX "yy"
  4 | $define BREAK 257
  5 | $define DOUBLE 258
  6 | $define ELSE 259
  7 | $define FOR 260
  8 | $define IF 261
  9 | $define INT 262
 10 | $define RETURN 263
 11 | $define VOID 264
 12 | $define WHILE 265
 13 | $define IDENTIFIER 266
 14 | $define CLASSNAME 267
 15 | $define CLASS 268
 16 | $define STRING 269
 17 | $define BOOL 270
 18 | $define INTLIT 271
 19 | $define DOUBLELIT 272
 20 | $define STRINGLIT 273
 21 | $define BOOLLIT 274
 22 | $define NULLVAL 275
 23 | $define LESSTHANOREQUAL 276
 24 | $define GREATERTHANOREQUAL 277
 25 | $define ISEQUALTO 278
 26 | $define NOTEQUALTO 279
 27 | $define LOGICALAND 280
 28 | $define LOGICALOR 281
 29 | $define INCREMENT 282
 30 | $define DECREMENT 283
 31 | $define PUBLIC 284
 32 | $define STATIC 285
 33 | $define NEW 286
 34 | $define BOOLEAN 287
 35 | $define YYERRCODE 256
 36 | procedure init() 
 37 |   yylhs := [                                        -1,
 38 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 39 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 40 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 41 |    18,    6,   14,   19,   19,   20,   20,   21,   21,   22,
 42 |    24,   23,   23,   23,   23,   23,   23,   23,   23,   23,
 43 |    23,   25,   33,   33,   28,   29,   30,   30,   37,   37,
 44 |    38,   31,   32,   39,   39,   39,   40,   40,   41,   41,
 45 |    42,   42,   26,   26,   27,   43,   43,   43,   43,   43,
 46 |    44,   44,   44,   44,   44,   44,   44,   48,   47,   50,
 47 |    50,   45,   49,   49,   35,   35,   51,   51,   52,   52,
 48 |    52,   53,   53,   53,   53,   54,   54,   54,   55,   55,
 49 |    55,   55,   56,   56,   57,   57,   57,   58,   58,   59,
 50 |    59,   46,   36,   36,   34,   60,   60,   60,   61,   61,
 51 |    61,
 52 |   ]
 53 |   yylen := [                            2,
 54 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 55 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 56 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 57 |     2,    2,    3,    1,    0,    1,    2,    1,    1,    2,
 58 |     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 59 |     1,    2,    1,    1,    5,    7,    6,    8,    1,    2,
 60 |     2,    5,    9,    1,    1,    0,    1,    0,    1,    0,
 61 |     1,    3,    2,    3,    3,    1,    1,    1,    1,    1,
 62 |     1,    1,    1,    1,    3,    1,    1,    5,    5,    1,
 63 |     3,    3,    1,    0,    4,    6,    1,    1,    2,    2,
 64 |     1,    1,    3,    3,    3,    1,    3,    3,    1,    1,
 65 |     1,    1,    1,    3,    1,    3,    3,    1,    3,    1,
 66 |     3,    4,    1,    1,    3,    1,    1,    1,    1,    1,
 67 |     1,
 68 |   ]
 69 |   yydefred := [                         0,
 70 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 71 |     0,    3,   12,    0,    4,    6,    7,    8,    0,    0,
 72 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 73 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 74 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 75 |     0,   76,   77,   79,   78,   80,    0,   43,    0,    0,
 76 |     0,   42,    0,    0,   36,   38,   39,    0,   44,   45,
 77 |    46,   47,   48,   49,   50,   51,    0,   53,    0,   81,
 78 |     0,    0,    0,   86,   87,    0,    0,   26,    0,    0,
 79 |    25,    0,   21,    0,   73,    0,    0,    0,    0,    0,
 80 |   124,   83,   67,    0,    0,  101,  102,    0,    0,    0,
 81 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 82 |    33,   37,   40,   52,    0,  130,  131,  129,    0,   30,
 83 |    74,   65,   71,    0,    0,    0,    0,   82,   84,   99,
 84 |   100,   75,    0,    0,    0,    0,    0,  109,  110,  111,
 85 |   112,    0,    0,    0,    0,    0,    0,    0,    0,   85,
 86 |     0,   90,    0,    0,    0,  125,    0,    0,    0,  103,
 87 |   104,  105,    0,    0,    0,    0,    0,    0,    0,    0,
 88 |     0,    0,  122,   95,    0,    0,    0,    0,   72,    0,
 89 |    62,   89,   88,   91,    0,    0,    0,    0,   59,   96,
 90 |     0,    0,    0,   56,   61,    0,   60,    0,    0,   58,
 91 |    63,    0,    0,   55,
 92 |   ]
 93 |   yydgoto := [                          2,
 94 |     6,   14,   15,   16,   17,   18,   60,   29,  100,   21,
 95 |    30,   42,   22,   62,   23,   37,   38,   39,   63,   64,
 96 |    65,   66,   67,   68,   69,   70,   71,   72,   73,   74,
 97 |    75,   76,   77,  101,  102,  162,  198,  199,  134,  104,
 98 |   201,  135,   80,  105,   82,   83,   84,   85,  163,  164,
 99 |   106,  107,  108,  109,  152,  110,  111,  112,  113,   86,
100 |   129,
101 |   ]
102 |   yysindex := [                      -241,
103 |  -196,    0, -206,  -46,  204,    0,    0,    0,   44,    0,
104 |  -194,    0,    0,  304,    0,    0,    0,    0, -177,   52,
105 |     0,   -2,   -2, -163, -208,    0,    0,    0,  -38,   35,
106 |  -162,   48,    0,    0,    0, -177,   84,   85,    0,    0,
107 |     0, -132,    0, -177,   42,    0,  -51,   96,   97,  -33,
108 |   101,    0,    0,    0,    0,    0, -163,    0,  -33, -177,
109 |   -36,    0,   20,   48,    0,    0,    0,   87,    0,    0,
110 |     0,    0,    0,    0,    0,    0,   98,    0,    0,    0,
111 |   109,    0,    0,    0,    0,  -47,   35,    0, -163,   44,
112 |     0,   35,    0,   99,    0,   70,  -33,  -33,  -33,  -36,
113 |     0,    0,    0,  100,  109,    0,    0,   55,   -4,  -57,
114 |  -227, -124, -121,  -33,   89,  -27,  120,  118,  -33,  -33,
115 |     0,    0,    0,    0,  -85,    0,    0,    0,  -33,    0,
116 |     0,    0,    0,  128,  145,  149,  -36,    0,    0,    0,
117 |     0,    0,  -33,  -33,  -33,  -33,  -33,    0,    0,    0,
118 |     0,  -33,  -33,  -33,  -33,  -33,  154,  -33,  -33,    0,
119 |   103,    0,  156,  158,  164,    0,  -33,  130,   -2,    0,
120 |     0,    0,   55,   55,   -4,  -57,  -57, -227, -124,  104,
121 |   105,  167,    0,    0,  -33,  -33,  146,  -36,    0,  -50,
122 |     0,    0,    0,    0,  176,  130, -107,  -41,    0,    0,
123 |   181,  145,  186,    0,    0, -107,    0,   -2,  -33,    0,
124 |     0,  189,   -2,    0,
125 |   ]
126 |   yyrindex := [                         0,
127 |     0,    0,    0,    0,    0,    0,    0,    0,  -45,    0,
128 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -34,
129 |     0,    0,    0,  196,    0,    0,    0,    0,    0,  -19,
130 |     0,  125,    0,    0,    0,    0,    0,  213,    0,    0,
131 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  197,
132 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
133 |   -59,    0,    0,  151,    0,    0,    0,    0,    0,    0,
134 |     0,    0,    0,    0,    0,    0,    0,    0,   27,    0,
135 |     0,  -13,   71,    0,    0,    0,   18,    0,    0,    0,
136 |     0,  -17,    0,    0,    0,  212,    0,    0,    0,  132,
137 |     0,    0,    0,    0,  141,    0,    0,  382,  240,   46,
138 |    79,   26,  -24,    0,    0,  194,    0,  228,    0,  252,
139 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
140 |     0,    0,    0,    0,  239,    0,  169,    0,    0,    0,
141 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
142 |     0,    0,    0,    0,    0,    0,    0,    0,  252,    0,
143 |     0,    0,    0,  260,  106,    0,  197,    0,    0,    0,
144 |     0,    0,  392,  412,  399,  253,  314,  419,   34,    0,
145 |     0,    0,    0,    0,    0,  252,    0,   13,    0,  -14,
146 |     0,    0,    0,    0,    0,  275,    0,   17,    0,    0,
147 |     0,  277,    0,    0,    0,    0,    0,    0,    0,    0,
148 |     0,    0,    0,    0,
149 |   ]
150 |   yygindex := [                         0,
151 |     0,    0,  231,    0,    0,    0,   39,  270,  551,    0,
152 |   -21,    0,    0,  340,  289,    0,    0,  248,    0,    0,
153 |   274,    0,  160,  272,    0,    0,    0, -188,    0,    0,
154 |     0,    0,  -74,  334,  342,  445,    0,  173,    0,  205,
155 |     0,  184,    0,  400,  473,  568,    0,    0, -148,    0,
156 |     0,  -62,  -81,  229,    0,  -53,  236,  237,    0,    0,
157 |     0,
158 |   ]
159 | $define YYTABLESIZE 747
160 |   yytable := [                         99,
161 |    15,  126,  150,  120,  151,   44,   59,   95,  205,   31,
162 |   182,   98,  159,  128,   87,   32,  123,  205,   31,  123,
163 |    43,  133,   92,   82,   18,   55,   19,   82,   82,   82,
164 |    82,   82,   82,   82,  123,  140,  141,  195,  147,   18,
165 |   146,   19,    1,   19,   55,   82,   82,  127,   82,    7,
166 |   153,  154,   19,    8,  119,   40,   57,   35,   31,    4,
167 |    10,   31,   36,   41,  173,  174,  120,   54,  123,  120,
168 |    54,    3,   83,  126,  121,   57,    5,  121,   13,   82,
169 |   170,  171,  172,   24,  120,   54,  115,   59,   28,  115,
170 |    25,  145,  121,  189,    7,  115,  143,   31,    8,  176,
171 |   177,  144,   35,   46,  115,   10,   58,   84,   55,   59,
172 |    55,   84,   84,   84,   84,   84,   84,   84,  120,  118,
173 |    32,  133,  118,   13,   88,   45,  121,   36,   89,   84,
174 |    84,  128,   84,   90,   93,   96,   97,  118,  115,   57,
175 |   114,   57,   92,   59,  121,  123,   92,   92,   92,   92,
176 |    92,   92,   92,  203,  125,  155,  124,  131,  142,  156,
177 |   160,   44,   58,   84,   92,   92,   92,   92,   98,   59,
178 |    32,  118,   98,   98,   98,   98,   98,   97,   98,  158,
179 |   165,   97,   97,   97,   97,   97,  167,   97,  168,  169,
180 |    98,   98,  126,   98,  180,  183,  184,  192,   92,   97,
181 |    97,  185,   97,  186,  196,   98,   14,  193,  197,   98,
182 |    98,   98,   98,   98,   94,   98,  200,  206,  148,  149,
183 |    15,  208,  126,  126,   98,  209,   32,   98,   98,  213,
184 |    98,   14,   35,   97,  126,  127,   28,   52,   53,   54,
185 |    55,   56,   55,   55,   27,   55,   55,   55,   55,   35,
186 |    55,   55,   57,   27,   55,   68,   55,   55,   55,   55,
187 |    55,   98,   82,   82,   82,   82,   82,   82,  127,  127,
188 |    66,   55,   55,   57,   57,   34,   57,   57,   57,   57,
189 |   113,   57,   57,  113,   14,   57,   41,   57,   57,   57,
190 |    57,   57,   94,  116,  126,  126,  116,   64,  113,  113,
191 |    93,  113,   57,   57,   47,    7,  120,   48,   49,    8,
192 |    50,  116,   51,   35,  121,   70,   10,   69,   52,   53,
193 |    54,   55,   56,  115,  115,  115,  115,    7,   12,  118,
194 |    91,    8,  113,   57,   13,   35,  130,  122,   10,  191,
195 |    52,   53,   54,   55,   56,  116,   84,   84,   84,   84,
196 |    84,   84,  128,  128,  117,   57,   13,  117,  118,  118,
197 |    47,   33,   34,   48,   49,   78,   50,  132,   51,   35,
198 |   207,  187,  117,   79,   52,   53,   54,   55,   56,  202,
199 |   175,   92,   92,   92,   92,   92,   92,   92,   92,   57,
200 |   178,    0,  179,    0,    0,   35,    0,   78,    0,    0,
201 |    52,   53,   54,   55,   56,   79,  117,   98,   98,   98,
202 |    98,   98,   98,  126,  126,   57,   97,   97,   97,   97,
203 |    97,   97,  106,    0,  106,  106,  106,    0,   26,   78,
204 |     0,   81,  108,    0,  108,  108,  108,   79,    0,  114,
205 |   106,  106,  114,  106,   98,   98,   98,   98,   98,   98,
206 |   108,  108,  107,  108,  107,  107,  107,  114,  114,  119,
207 |   114,    7,  119,   81,    0,    8,    0,    0,    0,    9,
208 |   107,  107,   10,  107,  106,    0,    0,  119,    0,    0,
209 |     0,    0,    0,    0,  108,    0,    0,   11,    0,    0,
210 |    13,  114,    0,    0,  103,   81,    0,    0,    0,    0,
211 |     0,   78,    0,  117,  107,    0,    0,    0,  190,   79,
212 |     0,  119,    0,   78,    0,  113,  113,  113,  113,  113,
213 |   113,   79,    0,    0,    0,    0,    0,    0,    0,   78,
214 |   116,  116,  116,  116,    0,    0,  204,   79,    0,    0,
215 |     0,  136,    0,    0,    0,  210,    0,  211,    0,    0,
216 |     0,    0,  214,    0,    0,   20,    0,    0,  157,    0,
217 |     0,    7,    0,  161,   20,    8,    0,   81,    0,    9,
218 |   138,  138,   10,  166,   20,   20,    0,    0,    0,   81,
219 |     0,    0,   61,    0,    0,    0,    0,   11,    0,    0,
220 |    13,  117,  117,  117,  117,   81,    0,    0,    0,    0,
221 |     0,    0,  181,    0,    0,    0,    0,  116,    0,    0,
222 |     0,  103,    0,    0,   61,  138,  138,  138,  138,  138,
223 |     0,    0,    0,    0,  138,  138,  138,  138,  138,  194,
224 |     0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
225 |     0,    0,    0,    0,    0,    0,   61,    0,  137,  137,
226 |     0,    0,    0,  212,    0,    0,    0,  106,  106,  106,
227 |   106,  106,  106,    0,    0,  139,  139,  108,  108,  108,
228 |   108,  108,  108,    0,  114,  114,  114,  114,  114,  114,
229 |     0,    0,    0,    0,    0,    0,    0,  107,  107,  107,
230 |   107,  107,  107,  137,  137,  137,  137,  137,  119,  119,
231 |     0,    0,  137,  137,  137,  137,  137,    0,    0,    0,
232 |   139,  139,  139,  139,  139,    0,    0,    0,  188,  139,
233 |   139,  139,  139,  139,    0,    0,    0,    0,    0,    0,
234 |   188,    0,    0,    0,    0,    0,    0,    0,    0,    0,
235 |     0,    0,    0,    0,    0,    0,  188,
236 |   ]
237 |   yycheck := [                         33,
238 |    46,   61,   60,   40,   62,   44,   40,   59,  197,   46,
239 |   159,   45,   40,   61,   36,  123,   41,  206,   46,   44,
240 |    59,   96,   44,   37,   44,   40,   44,   41,   42,   43,
241 |    44,   45,   46,   47,   59,   98,   99,  186,   43,   59,
242 |    45,   59,  284,    5,   59,   59,   60,   61,   62,  258,
243 |   278,  279,   14,  262,   91,  264,   40,  266,   41,  266,
244 |   269,   44,   24,   25,  146,  147,   41,   41,   93,   44,
245 |    44,  268,   46,   61,   41,   59,  123,   44,  287,   93,
246 |   143,  144,  145,   40,   59,   59,   41,   40,  266,   44,
247 |   285,   37,   59,  168,  258,   57,   42,   46,  262,  153,
248 |   154,   47,  266,  266,   59,  269,   59,   37,  123,   40,
249 |   125,   41,   42,   43,   44,   45,   46,   47,   93,   41,
250 |   123,  196,   44,  287,   41,   91,   93,   89,   44,   59,
251 |    60,   61,   62,  266,   93,   40,   40,   59,   93,  123,
252 |    40,  125,   37,   40,  125,   59,   41,   42,   43,   44,
253 |    45,   46,   47,  261,   46,  280,   59,   59,   59,  281,
254 |    41,   44,   59,   93,   59,   60,   61,   62,   37,   40,
255 |   123,   93,   41,   42,   43,   44,   45,   37,   47,   91,
256 |   266,   41,   42,   43,   44,   45,   59,   47,   44,   41,
257 |    59,   60,   61,   62,   41,   93,   41,   93,   93,   59,
258 |    60,   44,   62,   40,   59,   37,  266,   41,  259,   41,
259 |    42,   43,   44,   45,  266,   47,   41,  259,  276,  277,
260 |   266,   41,  282,  283,   93,   40,  123,   59,   60,   41,
261 |    62,  266,  266,   93,  282,  283,   41,  271,  272,  273,
262 |   274,  275,  257,  258,   14,  260,  261,  262,  263,  125,
263 |   265,  266,  286,   41,  269,   59,  271,  272,  273,  274,
264 |   275,   93,  276,  277,  278,  279,  280,  281,  282,  283,
265 |    59,  286,  287,  257,  258,  125,  260,  261,  262,  263,
266 |    41,  265,  266,   44,   91,  269,   59,  271,  272,  273,
267 |   274,  275,   41,   41,  282,  283,   44,   59,   59,   60,
268 |    41,   62,  286,  287,  257,  258,  281,  260,  261,  262,
269 |   263,   59,  265,  266,  281,   41,  269,   41,  271,  272,
270 |   273,  274,  275,  278,  279,  280,  281,  258,  125,   60,
271 |    42,  262,   93,  286,  287,  266,   89,   64,  269,  180,
272 |   271,  272,  273,  274,  275,   93,  276,  277,  278,  279,
273 |   280,  281,  282,  283,   41,  286,  287,   44,  280,  281,
274 |   257,   22,   23,  260,  261,   32,  263,   96,  265,  266,
275 |   198,  167,   59,   32,  271,  272,  273,  274,  275,  196,
276 |   152,  276,  277,  278,  279,  280,  281,  282,  283,  286,
277 |   155,   -1,  156,   -1,   -1,  266,   -1,   64,   -1,   -1,
278 |   271,  272,  273,  274,  275,   64,   93,  276,  277,  278,
279 |   279,  280,  281,  282,  283,  286,  276,  277,  278,  279,
280 |   280,  281,   41,   -1,   43,   44,   45,   -1,  125,   96,
281 |    -1,   32,   41,   -1,   43,   44,   45,   96,   -1,   41,
282 |    59,   60,   44,   62,  276,  277,  278,  279,  280,  281,
283 |    59,   60,   41,   62,   43,   44,   45,   59,   60,   41,
284 |    62,  258,   44,   64,   -1,  262,   -1,   -1,   -1,  266,
285 |    59,   60,  269,   62,   93,   -1,   -1,   59,   -1,   -1,
286 |    -1,   -1,   -1,   -1,   93,   -1,   -1,  284,   -1,   -1,
287 |   287,   93,   -1,   -1,   50,   96,   -1,   -1,   -1,   -1,
288 |    -1,  168,   -1,   59,   93,   -1,   -1,   -1,  169,  168,
289 |    -1,   93,   -1,  180,   -1,  276,  277,  278,  279,  280,
290 |   281,  180,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  196,
291 |   278,  279,  280,  281,   -1,   -1,  197,  196,   -1,   -1,
292 |    -1,   97,   -1,   -1,   -1,  206,   -1,  208,   -1,   -1,
293 |    -1,   -1,  213,   -1,   -1,    5,   -1,   -1,  114,   -1,
294 |    -1,  258,   -1,  119,   14,  262,   -1,  168,   -1,  266,
295 |    98,   99,  269,  129,   24,   25,   -1,   -1,   -1,  180,
296 |    -1,   -1,   32,   -1,   -1,   -1,   -1,  284,   -1,   -1,
297 |   287,  278,  279,  280,  281,  196,   -1,   -1,   -1,   -1,
298 |    -1,   -1,  158,   -1,   -1,   -1,   -1,   57,   -1,   -1,
299 |    -1,  167,   -1,   -1,   64,  143,  144,  145,  146,  147,
300 |    -1,   -1,   -1,   -1,  152,  153,  154,  155,  156,  185,
301 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   89,
302 |    -1,   -1,   -1,   -1,   -1,   -1,   96,   -1,   98,   99,
303 |    -1,   -1,   -1,  209,   -1,   -1,   -1,  276,  277,  278,
304 |   279,  280,  281,   -1,   -1,   98,   99,  276,  277,  278,
305 |   279,  280,  281,   -1,  276,  277,  278,  279,  280,  281,
306 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,  278,
307 |   279,  280,  281,  143,  144,  145,  146,  147,  280,  281,
308 |    -1,   -1,  152,  153,  154,  155,  156,   -1,   -1,   -1,
309 |   143,  144,  145,  146,  147,   -1,   -1,   -1,  168,  152,
310 |   153,  154,  155,  156,   -1,   -1,   -1,   -1,   -1,   -1,
311 |   180,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
312 |    -1,   -1,   -1,   -1,   -1,   -1,  196,
313 |   ]
314 | $define YYFINAL 2
315 | $define YYMAXTOKEN 287
316 |   yyname := [
317 | "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
318 | "'!'",0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,
319 | 0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
320 | 0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
321 | 0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
322 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
323 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
324 | 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"BREAK","DOUBLE","ELSE","FOR","IF",
325 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
326 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
327 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
328 | "INCREMENT","DECREMENT","PUBLIC","STATIC","NEW","BOOLEAN",
329 |   ]
330 |   yyrule := [
331 | "$accept : ClassDecl",
332 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
333 | "ClassBody : '{' ClassBodyDecls '}'",
334 | "ClassBody : '{' '}'",
335 | "ClassBodyDecls : ClassBodyDecl",
336 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
337 | "ClassBodyDecl : FieldDecl",
338 | "ClassBodyDecl : MethodDecl",
339 | "ClassBodyDecl : ConstructorDecl",
340 | "FieldDecl : Type VarDecls ';'",
341 | "Type : INT",
342 | "Type : DOUBLE",
343 | "Type : BOOLEAN",
344 | "Type : STRING",
345 | "Type : Name",
346 | "Name : IDENTIFIER",
347 | "Name : QualifiedName",
348 | "QualifiedName : Name '.' IDENTIFIER",
349 | "VarDecls : VarDeclarator",
350 | "VarDecls : VarDecls ',' VarDeclarator",
351 | "VarDeclarator : IDENTIFIER",
352 | "VarDeclarator : VarDeclarator '[' ']'",
353 | "MethodReturnVal : Type",
354 | "MethodReturnVal : VOID",
355 | "MethodDecl : MethodHeader Block",
356 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
357 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
358 | "FormalParmListOpt : FormalParmList",
359 | "FormalParmListOpt :",
360 | "FormalParmList : FormalParm",
361 | "FormalParmList : FormalParmList ',' FormalParm",
362 | "FormalParm : Type VarDeclarator",
363 | "ConstructorDecl : MethodDeclarator Block",
364 | "Block : '{' BlockStmtsOpt '}'",
365 | "BlockStmtsOpt : BlockStmts",
366 | "BlockStmtsOpt :",
367 | "BlockStmts : BlockStmt",
368 | "BlockStmts : BlockStmts BlockStmt",
369 | "BlockStmt : LocalVarDeclStmt",
370 | "BlockStmt : Stmt",
371 | "LocalVarDeclStmt : LocalVarDecl ';'",
372 | "LocalVarDecl : Type VarDecls",
373 | "Stmt : Block",
374 | "Stmt : ';'",
375 | "Stmt : ExprStmt",
376 | "Stmt : BreakStmt",
377 | "Stmt : ReturnStmt",
378 | "Stmt : IfThenStmt",
379 | "Stmt : IfThenElseStmt",
380 | "Stmt : IfThenElseIfStmt",
381 | "Stmt : WhileStmt",
382 | "Stmt : ForStmt",
383 | "ExprStmt : StmtExpr ';'",
384 | "StmtExpr : Assignment",
385 | "StmtExpr : MethodCall",
386 | "IfThenStmt : IF '(' Expr ')' Block",
387 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
388 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
389 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
390 | "ElseIfSequence : ElseIfStmt",
391 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
392 | "ElseIfStmt : ELSE IfThenStmt",
393 | "WhileStmt : WHILE '(' Expr ')' Stmt",
394 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
395 | "ForInit : StmtExprList",
396 | "ForInit : LocalVarDecl",
397 | "ForInit :",
398 | "ExprOpt : Expr",
399 | "ExprOpt :",
400 | "ForUpdate : StmtExprList",
401 | "ForUpdate :",
402 | "StmtExprList : StmtExpr",
403 | "StmtExprList : StmtExprList ',' StmtExpr",
404 | "BreakStmt : BREAK ';'",
405 | "BreakStmt : BREAK IDENTIFIER ';'",
406 | "ReturnStmt : RETURN ExprOpt ';'",
407 | "Literal : INTLIT",
408 | "Literal : DOUBLELIT",
409 | "Literal : BOOLLIT",
410 | "Literal : STRINGLIT",
411 | "Literal : NULLVAL",
412 | "Primary : Literal",
413 | "Primary : FieldAccess",
414 | "Primary : MethodCall",
415 | "Primary : ArrayAccess",
416 | "Primary : '(' Expr ')'",
417 | "Primary : ArrayCreation",
418 | "Primary : InstanceCreation",
419 | "InstanceCreation : NEW Name '(' ArgListOpt ')'",
420 | "ArrayCreation : NEW Type '[' Expr ']'",
421 | "ArgList : Expr",
422 | "ArgList : ArgList ',' Expr",
423 | "FieldAccess : Primary '.' IDENTIFIER",
424 | "ArgListOpt : ArgList",
425 | "ArgListOpt :",
426 | "MethodCall : Name '(' ArgListOpt ')'",
427 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
428 | "PostFixExpr : Primary",
429 | "PostFixExpr : Name",
430 | "UnaryExpr : '-' UnaryExpr",
431 | "UnaryExpr : '!' UnaryExpr",
432 | "UnaryExpr : PostFixExpr",
433 | "MulExpr : UnaryExpr",
434 | "MulExpr : MulExpr '*' UnaryExpr",
435 | "MulExpr : MulExpr '/' UnaryExpr",
436 | "MulExpr : MulExpr '%' UnaryExpr",
437 | "AddExpr : MulExpr",
438 | "AddExpr : AddExpr '+' MulExpr",
439 | "AddExpr : AddExpr '-' MulExpr",
440 | "RelOp : LESSTHANOREQUAL",
441 | "RelOp : GREATERTHANOREQUAL",
442 | "RelOp : '<'",
443 | "RelOp : '>'",
444 | "RelExpr : AddExpr",
445 | "RelExpr : RelExpr RelOp AddExpr",
446 | "EqExpr : RelExpr",
447 | "EqExpr : EqExpr ISEQUALTO RelExpr",
448 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
449 | "CondAndExpr : EqExpr",
450 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
451 | "CondOrExpr : CondAndExpr",
452 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
453 | "ArrayAccess : Name '[' Expr ']'",
454 | "Expr : CondOrExpr",
455 | "Expr : Assignment",
456 | "Assignment : LeftHandSide AssignOp Expr",
457 | "LeftHandSide : Name",
458 | "LeftHandSide : FieldAccess",
459 | "LeftHandSide : ArrayAccess",
460 | "AssignOp : '='",
461 | "AssignOp : INCREMENT",
462 | "AssignOp : DECREMENT",
463 |   ]
464 | 
465 | end
466 | 
467 | #####################################################################
468 | #####################################################################
469 | invocable all    # need to look up semantic actions by name
470 | 
471 | global yytext    # user variable to return contextual strings
472 | global yyval     # used to return semantic vals from action routines
473 | global yylval    # the 'lval' (result) I got from yylex()
474 | global yydebug   # (boolean) do I want debug output?
475 | global yynerrs   # (integer) number of errors so far
476 | global yyerrflag # (integer) was there an error?
477 | global yychar    # (integer) the current working character
478 | global action    # maps an integer to a semantic action procedure
479 | 
480 | global yylhs
481 | global yylen
482 | global yydefred
483 | global yydgoto
484 | global yysindex
485 | global yyrindex
486 | global yygindex
487 | global yytable
488 | global yycheck
489 | global yyname
490 | global yyrule
491 | 
492 | global statestk         # state stack
493 | global valstk           # value stack
494 | ################################################################
495 | # procedure: init_stacks : allocate and prepare stacks
496 | ################################################################
497 | procedure init_stacks()
498 |   local i
499 |   statestk := []
500 |   valstk := []
501 |   yyval  := 0 
502 |   yylval := 0 
503 |   action := list(1000, action_null)  # remove hard coded 1000 later
504 |   every i := 1 to 1000 do action[i] := proc("action_" || i)
505 | end
506 | 
507 | $define YYACCEPT return 0
508 | $define YYABORT return 1
509 | ################################################################
510 | # procedure: yyparse : parse input and execute indicated items
511 | ################################################################
512 | procedure yyparse()
513 |   local yyn        # next next thing to do
514 |   local yym        #
515 |   local yystate    # current parsing state from state table
516 |   local yys        # current token string
517 |   local doaction   # set to 1 if there need to execute action
518 |   local token      # current token
519 | 
520 |   if /yytable then init() 
521 |   init_stacks() 
522 |   yynerrs   := 0 
523 |   yyerrflag := 0 
524 |   yychar    := -1           # impossible char forces a read
525 |   yystate   := 0            # initial state
526 |   push(statestk, yystate)   # save it
527 | 
528 |   repeat { # until parsing is done, either correctly, or w/error
529 |     doaction := 1 
530 | 
531 |     ##### NEXT ACTION (from reduction table)
532 | 	yyn := yydefred[yystate+1]
533 | 
534 |     while yyn = 0 do {
535 | 
536 |       if yychar < 0 then {   # we want a char?
537 |         yychar := yylex()    # get next token
538 |         ##### ERROR CHECK ####
539 |         if yychar < 0 then { # it it didn't work/error
540 |           yychar := 0        # change it to default string (no -1!)
541 |           if \yydebug = 1 then yylexdebug(yystate, yychar) 
542 |           }
543 |         } # yychar < 0
544 | 	  
545 |       yyn := yysindex[yystate+1]  # get amount to shift by (shift index)
546 | 
547 |       if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
548 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
549 | 		
550 |         ##### NEXT STATE ####
551 |         yystate := yytable[yyn+1] # we are in a new state
552 |         push(statestk, yystate)   # save it
553 |         push(valstk, yylval)      # push our lval as the input for next rule
554 |         yychar := -1              # since we have 'eaten' a token, say we need another
555 |         if yyerrflag > 0 then     # have we recovered an error?
556 |            yyerrflag -:= 1        # give ourselves credit
557 |         doaction := 0             # but don't process yet
558 |         break                     # quit the yyn=0 loop
559 |         }
560 | 
561 |     yyn := yyrindex[yystate+1]    # reduce
562 | 
563 |     if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
564 |        (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
565 |       # e reduced!
566 |       yyn      := yytable[yyn+1] 
567 |       doaction := 1  # get ready to execute
568 |       break          # drop down to actions
569 |       }
570 |     else { #ERROR RECOVERY
571 |       if yyerrflag == 0 then {
572 |         (\yyerror | write)("syntax error") 
573 |         yynerrs +:= 1 
574 |       }
575 |       if yyerrflag < 3 then {     # low error count?
576 |         yyerrflag := 3 
577 |         repeat { #do until break
578 |           if *statestk < 1 then {  # check for under & overflow here
579 |             (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
580 |             return 1 
581 |           }
582 |           yyn := yysindex[statestk[1]] 
583 |           if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
584 |                     yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
585 |             yystate := yytable[yyn+1] 
586 |             push(statestk, yystate) 
587 |             push(valstk, yylval) 
588 |             doaction := 0 
589 |             break 
590 |           }
591 |           else {
592 |             if *statestk = 0 then { # check for under & overflow here
593 |               write("Stack underflow. aborting...") # capital 'S'
594 |               return 1 
595 |             }
596 |             pop(statestk) 
597 |             pop(valstk) 
598 |             }
599 |           }
600 |         }
601 |       else  # discard this token
602 |         {
603 |         if yychar = 0 then return 1  # yyabort
604 |         if \yydebug = 1 then {
605 |           yys := &null 
606 |           if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
607 |           if integer(yys) & yys = 0 then yys := "illegal-symbol" 
608 |           write("state ",  yystate, ", error recovery discards token ",
609 |                 yychar, " (", yys, ")") 
610 |           }
611 |         yychar := -1       # read another
612 |         }
613 |       } # end error recovery
614 |       yyn := yydefred[yystate+1] 
615 |     }# yyn = 0 loop
616 | 
617 |     if doaction = 0 then   # any reason not to proceed?
618 |       next                 # skip action
619 | 
620 |     yym := yylen[yyn+1]    # get count of terminals on rhs
621 |     yyval := valstk[yym]   # get current semantic value
622 |     if arv := action[yyn]() then return arv # execute the semantic action
623 | 
624 |     ##### Now let's reduce... ####
625 |     every 1 to yym do pop(statestk)# we just reduced yylen states
626 |     yystate := statestk[1]        # get new state
627 | 
628 |     every 1 to yym do pop(valstk) # corresponding value drop
629 |     yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
630 |     if yystate = 0 & yym = 0 then {
631 |                                   # done? 'rest' state and at first TERMINAL
632 |       yystate := YYFINAL          # explicitly say we're done
633 |       push(statestk, YYFINAL)     # and save it
634 |       push(valstk, yyval)         # also save the semantic value of parsing
635 |       if yychar < 0 then {        # we want another character?
636 |         yychar := yylex()         # get next character
637 |         if yychar < 0 then yychar := 0   #clean, if necessary
638 |       }
639 |       if yychar = 0 then break    # Good exit (if lex returns 0  -)
640 |                                   # quit the loop--all DONE
641 |     } # if yystate
642 |     else {                        #else not done yet
643 |       # get next state and push, for next yydefred[]
644 |       yyn := yygindex[yym+1]        # find out where to go
645 |       if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
646 |          (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
647 |         yystate := yytable[yyn+1]   # get new state
648 |         }
649 |       else {
650 |         yystate := yydgoto[yym+1]   # else go to new defred
651 | 	     }
652 |       push(statestk, yystate)       # going again, so push state & val...
653 |       push(valstk, yyval)           # for next action
654 |       }
655 |     } # main loop
656 | 
657 |   return 0 # yyaccept!!
658 | end
659 | 
660 | ### end of procedure parse() ######################################
661 | 
662 | ### start semantic actions ########################################
663 | 
664 | procedure action_null()
665 |   #write("null action")
666 | end
667 | 
668 | procedure action_1()
669 | #line 8 "j0gram.y"
670 | 
671 |   yyval:=j0.node("ClassDecl",1000,valstk[2],valstk[1]);
672 |   j0.semantic(yyval);
673 |   j0.gencode(yyval);
674 |  
675 | end
676 | 
677 | procedure action_2()
678 | #line 13 "j0gram.y"
679 |  yyval:=j0.node("ClassBody",1010,valstk[2]); 
680 | end
681 | 
682 | procedure action_3()
683 | #line 14 "j0gram.y"
684 |  yyval:=j0.node("ClassBody",1011); 
685 | end
686 | 
687 | procedure action_5()
688 | #line 16 "j0gram.y"
689 | 
690 |   yyval:=j0.node("ClassBodyDecls",1020,valstk[2],valstk[1]); 
691 | end
692 | 
693 | procedure action_9()
694 | #line 19 "j0gram.y"
695 | 
696 |   yyval:=j0.node("FieldDecl",1030,valstk[3],valstk[2]);
697 |   j0.calctype(yyval);
698 |   
699 | end
700 | 
701 | procedure action_17()
702 | #line 26 "j0gram.y"
703 | 
704 |   yyval:=j0.node("QualifiedName",1040,valstk[3],valstk[1]);
705 | end
706 | 
707 | procedure action_19()
708 | #line 29 "j0gram.y"
709 | 
710 |   yyval:=j0.node("VarDecls",1050,valstk[3],valstk[1]); 
711 | end
712 | 
713 | procedure action_21()
714 | #line 31 "j0gram.y"
715 | 
716 |   yyval:=j0.node("VarDeclarator",1060,valstk[3]); 
717 | end
718 | 
719 | procedure action_24()
720 | #line 35 "j0gram.y"
721 | 
722 |   yyval:=j0.node("MethodDecl",1380,valstk[2],valstk[1]);
723 |  
724 | end
725 | 
726 | procedure action_25()
727 | #line 38 "j0gram.y"
728 | 
729 |   yyval:=j0.node("MethodHeader",1070,valstk[2],valstk[1]);
730 |   j0.calctype(yyval);
731 |   
732 | end
733 | 
734 | procedure action_26()
735 | #line 42 "j0gram.y"
736 | 
737 |   yyval:=j0.node("MethodDeclarator",1080,valstk[4],valstk[2]); 
738 | end
739 | 
740 | procedure action_30()
741 | #line 46 "j0gram.y"
742 | 
743 |   yyval:=j0.node("FormalParmList",1090,valstk[3],valstk[1]); 
744 | end
745 | 
746 | procedure action_31()
747 | #line 48 "j0gram.y"
748 | 
749 |   yyval:=j0.node("FormalParm",1100,valstk[2],valstk[1]);
750 |   j0.calctype(yyval);
751 |  
752 | end
753 | 
754 | procedure action_32()
755 | #line 53 "j0gram.y"
756 | 
757 |   yyval:=j0.node("ConstructorDecl",1110,valstk[2],valstk[1]); 
758 | end
759 | 
760 | procedure action_33()
761 | #line 56 "j0gram.y"
762 | yyval:=j0.node("Block",1200,valstk[2]);
763 | end
764 | 
765 | procedure action_37()
766 | #line 58 "j0gram.y"
767 | 
768 |   yyval:=j0.node("BlockStmts",1130,valstk[2],valstk[1]); 
769 | end
770 | 
771 | procedure action_41()
772 | #line 63 "j0gram.y"
773 | 
774 |   yyval:=j0.node("LocalVarDecl",1140,valstk[2],valstk[1]);
775 |   j0.calctype(yyval);
776 |   
777 | end
778 | 
779 | procedure action_55()
780 | #line 76 "j0gram.y"
781 | 
782 |   yyval:=j0.node("IfThenStmt",1150,valstk[3],valstk[1]); 
783 | end
784 | 
785 | procedure action_56()
786 | #line 78 "j0gram.y"
787 | 
788 |   yyval:=j0.node("IfThenElseStmt",1160,valstk[5],valstk[3],valstk[1]); 
789 | end
790 | 
791 | procedure action_57()
792 | #line 80 "j0gram.y"
793 | 
794 |   yyval:=j0.node("IfThenElseIfStmt",1170,valstk[4],valstk[2],valstk[1]); 
795 | end
796 | 
797 | procedure action_58()
798 | #line 82 "j0gram.y"
799 | 
800 |   yyval:=j0.node("IfThenElseIfStmt",1171,valstk[6],valstk[4],valstk[3],valstk[1]); 
801 | end
802 | 
803 | procedure action_60()
804 | #line 85 "j0gram.y"
805 | 
806 |   yyval:=j0.node("ElseIfSequence",1180,valstk[2],valstk[1]); 
807 | end
808 | 
809 | procedure action_61()
810 | #line 87 "j0gram.y"
811 | 
812 |   yyval:=j0.node("ElseIfStmt",1190,valstk[1]); 
813 | end
814 | 
815 | procedure action_62()
816 | #line 89 "j0gram.y"
817 | 
818 |   yyval:=j0.node("WhileStmt",1210,valstk[3],valstk[1]); 
819 | end
820 | 
821 | procedure action_63()
822 | #line 92 "j0gram.y"
823 | 
824 |   yyval:=j0.node("ForStmt",1220,valstk[7],valstk[5],valstk[3],valstk[1]); 
825 | end
826 | 
827 | procedure action_72()
828 | #line 98 "j0gram.y"
829 | 
830 |   yyval:=j0.node("StmtExprList",1230,valstk[3],valstk[1]); 
831 | end
832 | 
833 | procedure action_74()
834 | #line 101 "j0gram.y"
835 | 
836 |   yyval:=j0.node("BreakStmt",1240,valstk[2]); 
837 | end
838 | 
839 | procedure action_75()
840 | #line 103 "j0gram.y"
841 | 
842 |   yyval:=j0.node("ReturnStmt",1250,valstk[2]); 
843 | end
844 | 
845 | procedure action_85()
846 | #line 108 "j0gram.y"
847 |  yyval:=valstk[2];
848 | end
849 | 
850 | procedure action_88()
851 | #line 109 "j0gram.y"
852 | 
853 |   yyval:=j0.node("InstanceCreation", 1261, valstk[4], valstk[2]); 
854 | end
855 | 
856 | procedure action_89()
857 | #line 111 "j0gram.y"
858 | 
859 |   yyval:=j0.node("ArrayCreation", 1260, valstk[4], valstk[2]); 
860 | end
861 | 
862 | procedure action_91()
863 | #line 114 "j0gram.y"
864 | 
865 |   yyval:=j0.node("ArgList",1270,valstk[3],valstk[1]); 
866 | end
867 | 
868 | procedure action_92()
869 | #line 116 "j0gram.y"
870 | 
871 |   yyval:=j0.node("FieldAccess",1280,valstk[3],valstk[1]); 
872 | end
873 | 
874 | procedure action_95()
875 | #line 120 "j0gram.y"
876 | 
877 |   yyval:=j0.node("MethodCall",1290,valstk[4],valstk[2]); 
878 | end
879 | 
880 | procedure action_96()
881 | #line 122 "j0gram.y"
882 | 
883 |     yyval:=j0.node("MethodCall",1291,valstk[6],valstk[4],valstk[2]); 
884 | end
885 | 
886 | procedure action_99()
887 | #line 127 "j0gram.y"
888 | 
889 |   yyval:=j0.node("UnaryExpr",1300,valstk[2],valstk[1]); 
890 | end
891 | 
892 | procedure action_100()
893 | #line 129 "j0gram.y"
894 | 
895 |   yyval:=j0.node("UnaryExpr",1301,valstk[2],valstk[1]); 
896 | end
897 | 
898 | procedure action_103()
899 | #line 133 "j0gram.y"
900 | 
901 |       yyval:=j0.node("MulExpr",1310,valstk[3],valstk[1]); 
902 | end
903 | 
904 | procedure action_104()
905 | #line 135 "j0gram.y"
906 | 
907 |       yyval:=j0.node("MulExpr",1311,valstk[3],valstk[1]); 
908 | end
909 | 
910 | procedure action_105()
911 | #line 137 "j0gram.y"
912 | 
913 |       yyval:=j0.node("MulExpr",1312,valstk[3],valstk[1]); 
914 | end
915 | 
916 | procedure action_107()
917 | #line 140 "j0gram.y"
918 | 
919 |       yyval:=j0.node("AddExpr",1320,valstk[3],valstk[1]); 
920 | end
921 | 
922 | procedure action_108()
923 | #line 142 "j0gram.y"
924 | 
925 |       yyval:=j0.node("AddExpr",1321,valstk[3],valstk[1]); 
926 | end
927 | 
928 | procedure action_114()
929 | #line 145 "j0gram.y"
930 | 
931 |   yyval:=j0.node("RelExpr",1330,valstk[3],valstk[2],valstk[1]); 
932 | end
933 | 
934 | procedure action_116()
935 | #line 149 "j0gram.y"
936 | 
937 |   yyval:=j0.node("EqExpr",1340,valstk[3],valstk[1]); 
938 | end
939 | 
940 | procedure action_117()
941 | #line 151 "j0gram.y"
942 | 
943 |   yyval:=j0.node("EqExpr",1341,valstk[3],valstk[1]); 
944 | end
945 | 
946 | procedure action_119()
947 | #line 153 "j0gram.y"
948 | 
949 |   yyval:=j0.node("CondAndExpr", 1350, valstk[3], valstk[1]); 
950 | end
951 | 
952 | procedure action_121()
953 | #line 155 "j0gram.y"
954 | 
955 |   yyval:=j0.node("CondOrExpr", 1360, valstk[3], valstk[1]); 
956 | end
957 | 
958 | procedure action_122()
959 | #line 158 "j0gram.y"
960 |  yyval:=j0.node("ArrayAccess",1390,valstk[4],valstk[2]); 
961 | end
962 | 
963 | procedure action_125()
964 | #line 161 "j0gram.y"
965 | 
966 |   yyval:=j0.node("Assignment",1370, valstk[3], valstk[2], valstk[1]); 
967 | end
968 | 
969 | #line 974 "j0gram.icn"
970 | 


--------------------------------------------------------------------------------
/ch9/j0gram.y:
--------------------------------------------------------------------------------
  1 | %token BREAK DOUBLE ELSE FOR IF INT RETURN VOID WHILE
  2 | %token IDENTIFIER CLASSNAME CLASS STRING BOOL
  3 | %token INTLIT DOUBLELIT STRINGLIT BOOLLIT NULLVAL
  4 | %token LESSTHANOREQUAL GREATERTHANOREQUAL
  5 | %token ISEQUALTO NOTEQUALTO LOGICALAND LOGICALOR
  6 | %token INCREMENT DECREMENT PUBLIC STATIC NEW
  7 | %%
  8 | ClassDecl: PUBLIC CLASS IDENTIFIER ClassBody {
  9 |   $=j0.node("ClassDecl",1000,$3,$4);
 10 |   j0.semantic($);
 11 |   j0.gencode($);
 12 |  } ;
 13 | ClassBody: '{' ClassBodyDecls '}' { $=j0.node("ClassBody",1010,$2); }
 14 |          | '{' '}' { $=j0.node("ClassBody",1011); };
 15 | ClassBodyDecls: ClassBodyDecl
 16 | | ClassBodyDecls ClassBodyDecl {
 17 |   $=j0.node("ClassBodyDecls",1020,$1,$2); };
 18 | ClassBodyDecl: FieldDecl | MethodDecl | ConstructorDecl ;
 19 | FieldDecl: Type VarDecls ';' {
 20 |   $=j0.node("FieldDecl",1030,$1,$2);
 21 |   j0.calctype($);
 22 |   };
 23 | Type: INT | DOUBLE | BOOLEAN | STRING | Name ;
 24 | 
 25 | Name: IDENTIFIER | QualifiedName ;
 26 | QualifiedName: Name '.' IDENTIFIER {
 27 |   $=j0.node("QualifiedName",1040,$1,$3);};
 28 | 
 29 | VarDecls: VarDeclarator | VarDecls ',' VarDeclarator {
 30 |   $=j0.node("VarDecls",1050,$1,$3); };
 31 | VarDeclarator: IDENTIFIER | VarDeclarator '[' ']' {
 32 |   $=j0.node("VarDeclarator",1060,$1); };
 33 | 
 34 | MethodReturnVal : Type | VOID ;
 35 | MethodDecl: MethodHeader Block {
 36 |   $=j0.node("MethodDecl",1380,$1,$2);
 37 |  };
 38 | MethodHeader: PUBLIC STATIC MethodReturnVal MethodDeclarator {
 39 |   $=j0.node("MethodHeader",1070,$3,$4);
 40 |   j0.calctype($);
 41 |   };
 42 | MethodDeclarator: IDENTIFIER '(' FormalParmListOpt ')' {
 43 |   $=j0.node("MethodDeclarator",1080,$1,$3); };
 44 | 
 45 | FormalParmListOpt: FormalParmList | ;
 46 | FormalParmList: FormalParm | FormalParmList ',' FormalParm {
 47 |   $=j0.node("FormalParmList",1090,$1,$3); };
 48 | FormalParm: Type VarDeclarator {
 49 |   $=j0.node("FormalParm",1100,$1,$2);
 50 |   j0.calctype($);
 51 |  };
 52 | 
 53 | ConstructorDecl: MethodDeclarator Block {
 54 |   $=j0.node("ConstructorDecl",1110,$1,$2); };
 55 | 
 56 | Block: '{' BlockStmtsOpt '}' {$=j0.node("Block",1200,$2);};
 57 | BlockStmtsOpt: BlockStmts | ;
 58 | BlockStmts:  BlockStmt | BlockStmts BlockStmt {
 59 |   $=j0.node("BlockStmts",1130,$1,$2); };
 60 | BlockStmt:   LocalVarDeclStmt | Stmt ;
 61 | 
 62 | LocalVarDeclStmt: LocalVarDecl ';' ;
 63 | LocalVarDecl: Type VarDecls {
 64 |   $=j0.node("LocalVarDecl",1140,$1,$2);
 65 |   j0.calctype($);
 66 |   };
 67 | 
 68 | Stmt: Block | ';' | ExprStmt | BreakStmt | ReturnStmt
 69 |       | IfThenStmt | IfThenElseStmt | IfThenElseIfStmt
 70 |       | WhileStmt | ForStmt ;
 71 | 
 72 | ExprStmt: StmtExpr ';' ;
 73 | 
 74 | StmtExpr: Assignment | MethodCall ;
 75 | 
 76 | IfThenStmt: IF '(' Expr ')' Block {
 77 |   $=j0.node("IfThenStmt",1150,$3,$5); };
 78 | IfThenElseStmt: IF '(' Expr ')' Block ELSE Block {
 79 |   $=j0.node("IfThenElseStmt",1160,$3,$5,$7); };
 80 | IfThenElseIfStmt: IF '(' Expr ')' Block ElseIfSequence {
 81 |   $=j0.node("IfThenElseIfStmt",1170,$3,$5,$6); }
 82 | |  IF '(' Expr ')' Block ElseIfSequence ELSE Block {
 83 |   $=j0.node("IfThenElseIfStmt",1171,$3,$5,$6,$8); };
 84 | 
 85 | ElseIfSequence: ElseIfStmt | ElseIfSequence ElseIfStmt {
 86 |   $=j0.node("ElseIfSequence",1180,$1,$2); };
 87 | ElseIfStmt: ELSE IfThenStmt {
 88 |   $=j0.node("ElseIfStmt",1190,$2); };
 89 | WhileStmt: WHILE '(' Expr ')' Stmt {
 90 |   $=j0.node("WhileStmt",1210,$3,$5); };
 91 | 
 92 | ForStmt: FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block {
 93 |   $=j0.node("ForStmt",1220,$3,$5,$7,$9); };
 94 | ForInit: StmtExprList | LocalVarDecl | ;
 95 | ExprOpt: Expr |  ;
 96 | ForUpdate: StmtExprList | ;
 97 | 
 98 | StmtExprList: StmtExpr | StmtExprList ',' StmtExpr {
 99 |   $=j0.node("StmtExprList",1230,$1,$3); };
100 | 
101 | BreakStmt: BREAK ';' | BREAK IDENTIFIER ';' {
102 |   $=j0.node("BreakStmt",1240,$2); };
103 | ReturnStmt: RETURN ExprOpt ';' {
104 |   $=j0.node("ReturnStmt",1250,$2); };
105 | 
106 | Literal: INTLIT	| DOUBLELIT | BOOLLIT | STRINGLIT | NULLVAL ;
107 | Primary:  Literal | FieldAccess | MethodCall | ArrayAccess |
108 |          '(' Expr ')' { $=$2;} | ArrayCreation | InstanceCreation;
109 | InstanceCreation: NEW Name '(' ArgListOpt ')' {
110 |   $=j0.node("InstanceCreation", 1261, $2, $4); };
111 | ArrayCreation: NEW Type '[' Expr ']' {
112 |   $=j0.node("ArrayCreation", 1260, $2, $4); };
113 | 
114 | ArgList: Expr | ArgList ',' Expr {
115 |   $=j0.node("ArgList",1270,$1,$3); };
116 | FieldAccess: Primary '.' IDENTIFIER {
117 |   $=j0.node("FieldAccess",1280,$1,$3); };
118 | 
119 | ArgListOpt:  ArgList | ;
120 | MethodCall: Name '(' ArgListOpt ')' {
121 |   $=j0.node("MethodCall",1290,$1,$3); }
122 |   | Primary '.' IDENTIFIER '(' ArgListOpt ')' {
123 |     $=j0.node("MethodCall",1291,$1,$3,$5); }
124 | 	;
125 | 
126 | PostFixExpr: Primary | Name ;
127 | UnaryExpr:  '-' UnaryExpr {
128 |   $=j0.node("UnaryExpr",1300,$1,$2); }
129 |     | '!' UnaryExpr {
130 |   $=j0.node("UnaryExpr",1301,$1,$2); }
131 |     | PostFixExpr ;
132 | MulExpr: UnaryExpr
133 |     | MulExpr '*' UnaryExpr {
134 |       $=j0.node("MulExpr",1310,$1,$3); }
135 |     | MulExpr '/' UnaryExpr {
136 |       $=j0.node("MulExpr",1311,$1,$3); }
137 |     | MulExpr '%' UnaryExpr {
138 |       $=j0.node("MulExpr",1312,$1,$3); };
139 | AddExpr: MulExpr
140 |     | AddExpr '+' MulExpr {
141 |       $=j0.node("AddExpr",1320,$1,$3); }
142 |     | AddExpr '-' MulExpr {
143 |       $=j0.node("AddExpr",1321,$1,$3); };
144 | RelOp: LESSTHANOREQUAL | GREATERTHANOREQUAL | '<' | '>' ;
145 | RelExpr: AddExpr | RelExpr RelOp AddExpr {
146 |   $=j0.node("RelExpr",1330,$1,$2,$3); };
147 | 
148 | EqExpr: RelExpr
149 |     | EqExpr ISEQUALTO RelExpr {
150 |   $=j0.node("EqExpr",1340,$1,$3); }
151 | | EqExpr NOTEQUALTO RelExpr {
152 |   $=j0.node("EqExpr",1341,$1,$3); };
153 | CondAndExpr: EqExpr | CondAndExpr LOGICALAND EqExpr {
154 |   $=j0.node("CondAndExpr", 1350, $1, $3); };
155 | CondOrExpr: CondAndExpr | CondOrExpr LOGICALOR CondAndExpr {
156 |   $=j0.node("CondOrExpr", 1360, $1, $3); };
157 | 
158 | ArrayAccess: Name '[' Expr ']' { $=j0.node("ArrayAccess",1390,$1,$3); };
159 | 
160 | Expr: CondOrExpr | Assignment ;
161 | Assignment: LeftHandSide AssignOp Expr {
162 |   $=j0.node("Assignment",1370, $1, $2, $3); };
163 | LeftHandSide: Name | FieldAccess | ArrayAccess ;
164 | AssignOp: '=' | INCREMENT | DECREMENT ;
165 | 


--------------------------------------------------------------------------------
/ch9/j0gram_tab.icn:
--------------------------------------------------------------------------------
 1 | class Parser(BREAK, DOUBLE, ELSE, FOR, IF, INT, RETURN, VOID, WHILE, IDENTIFIER, CLASSNAME, CLASS, STRING, BOOL, INTLIT, DOUBLELIT, STRINGLIT, BOOLLIT, NULLVAL, LESSTHANOREQUAL, GREATERTHANOREQUAL, ISEQUALTO, NOTEQUALTO, LOGICALAND, LOGICALOR, INCREMENT, DECREMENT, PUBLIC, STATIC, NEW, BOOLEAN)
 2 | initially
 3 |    BREAK := 257
 4 |    DOUBLE := 258
 5 |    ELSE := 259
 6 |    FOR := 260
 7 |    IF := 261
 8 |    INT := 262
 9 |    RETURN := 263
10 |    VOID := 264
11 |    WHILE := 265
12 |    IDENTIFIER := 266
13 |    CLASSNAME := 267
14 |    CLASS := 268
15 |    STRING := 269
16 |    BOOL := 270
17 |    INTLIT := 271
18 |    DOUBLELIT := 272
19 |    STRINGLIT := 273
20 |    BOOLLIT := 274
21 |    NULLVAL := 275
22 |    LESSTHANOREQUAL := 276
23 |    GREATERTHANOREQUAL := 277
24 |    ISEQUALTO := 278
25 |    NOTEQUALTO := 279
26 |    LOGICALAND := 280
27 |    LOGICALOR := 281
28 |    INCREMENT := 282
29 |    DECREMENT := 283
30 |    PUBLIC := 284
31 |    STATIC := 285
32 |    NEW := 286
33 |    BOOLEAN := 287
34 | end
35 | 


--------------------------------------------------------------------------------
/ch9/javalex.icn:
--------------------------------------------------------------------------------
   1 | #
   2 | # uflex skeleton.
   3 | # do not edit by hand, this file is machine-generated
   4 | #
   5 | 
   6 | record edge(symbol, destinations)
   7 | record anode(label, rulenum, edges, epsilon, dot)
   8 | record automata(start, states, accepting)
   9 | 
  10 | global yychar, yytext, yyin, yyleng
  11 | 
  12 | #
  13 | # matchstrings reads from a specified input file and calls the simulate
  14 | # function repeatedly on smaller and smaller pieces of the input until
  15 | # it finds a match. It reports what parts of the input
  16 | # it could parse and what rule accepted the string.
  17 | #
  18 | 
  19 | global stringseq
  20 | 
  21 | procedure yyulex(aut)
  22 | local rulenum, readfrom, position, less, currstring, getln
  23 | local maxrule, maxleng
  24 | 
  25 | initial {
  26 |    if /yyin then yyin := &input
  27 |    readfrom := yyin
  28 | 
  29 |    stringseq := read(readfrom) || "\n"
  30 | 
  31 |    while getln := read(readfrom) do
  32 |       stringseq ||:= getln || "\n"
  33 | 
  34 |    close(readfrom)
  35 |    }
  36 | 
  37 |    repeat {
  38 |       if stringseq == "" then {
  39 |          yychar := -1
  40 |          fail
  41 |          }
  42 | 
  43 |       leng := 1
  44 |       while i := simulate(aut, stringseq[1:leng+1]) do {
  45 |          if i > 0 then {
  46 |             maxrule := i
  47 |             maxleng := leng
  48 |          }
  49 |          leng +:= 1
  50 |       }
  51 |       if \maxrule then {
  52 |          yytext := stringseq[1 : maxleng+1]; yyleng := maxleng
  53 |          stringseq := stringseq[maxleng+1:0]
  54 |          if yychar := (semantic_action)[maxrule] () then return yychar
  55 |       } else {
  56 |          writes(stringseq[1])
  57 |          stringseq := stringseq[2:0]
  58 |       }
  59 |    }
  60 | end
  61 | 
  62 | #
  63 | # simulate(automata, word) determines whether or not the word
  64 | # would be accepted by the given automata. It gets the possible
  65 | # destinations at each symbol of the string and then adds on wherever it
  66 | # could also get if we use any epsilon transitions out of those states.
  67 | # Then the list of accepting states is compared to the reachable set
  68 | # of states to determine if the word was accepted and by which rule.
  69 | #
  70 | procedure simulate(myaut, word)
  71 | local first, currstates, acceptcheck, currsymbol, build, rv
  72 |    currstates := list(0) # should be set()
  73 |    put(currstates, myaut.start) # insert(currstates, myaut.start)
  74 |    acceptcheck := copy(myaut.accepting)
  75 |    currsymbol := word
  76 |    while *currsymbol > 0 do {
  77 |       currstates := getdestinations(currstates, currsymbol)
  78 |       if *currstates = 0 then
  79 |          fail
  80 |       currsymbol := currsymbol[2:0]
  81 |       }
  82 |    while *acceptcheck > 0 do {
  83 |       value1 := pop(acceptcheck)
  84 |       check2 := copy(currstates)
  85 | 
  86 |       while *check2 > 0 do {
  87 |          value2 := pop(check2)
  88 | 
  89 |          if value1.label = value2.label then {
  90 |             if /rv | rv > value1.rulenum then
  91 |                rv := value1.rulenum
  92 |             }
  93 |          }
  94 |       }
  95 |    if \yydebug>0 then write("simulate() returns ", image(\rv)|0)
  96 |    return \rv | -(currstates[1].label)
  97 | end
  98 | 
  99 | #
 100 | # like |||:= except no duplicates. Destructive of L1 but not L2
 101 | #
 102 | procedure yyunionin(L1, L2)
 103 | t1 := table()
 104 |   every x := !L1 do {
 105 |      t1[x.label] := x
 106 |      }
 107 |   every x := !L2 do {
 108 |      if /t1[x.label] then {
 109 |         t1[x.label] := x
 110 |          put(L1, x)
 111 |          }
 112 |       }
 113 | end
 114 | procedure yyonein(L1, L2)
 115 |   if (!L1).label === L2[1].label then fail
 116 |   put(L1, L2[1])
 117 | end
 118 | 
 119 | #
 120 | # getdestinations uses the current set of states and
 121 | # simulates one step of automata computation on the given
 122 | # string and returns the resulting set of destinations
 123 | #
 124 | procedure getdestinations(currstates, currsymbol)
 125 | local result, current, buildresult, reached
 126 | 
 127 |    result := list(0)
 128 |    if *currstates ~= 0 then {
 129 | 
 130 |       buildresult := copy(currstates)
 131 |       while *buildresult > 0 do {
 132 |           reached := reach(pop(buildresult), currsymbol)
 133 |           if *reached>0 then {
 134 |              yyunionin(result, reached)
 135 |              }
 136 |           }
 137 |        }
 138 |     return result
 139 | end
 140 | 
 141 | #
 142 | # reach returns the list of states that can be reached
 143 | # on character symbol from the state state.
 144 | #
 145 | procedure reach(state, symbol)
 146 | local edgeset, answer, edgesymbol, bound1, bound2, curredge
 147 | 
 148 |    edgeset := copy(state.edges)
 149 |    answer := list(0)
 150 | 
 151 |    while *edgeset > 0 do {
 152 |       curredge := pop(edgeset)
 153 |       edgesymbol := copy(curredge.symbol)
 154 |       if type(edgesymbol) == "cset" then {
 155 |          if any(edgesymbol, symbol[1]) then {
 156 |             yyunionin(answer, curredge.destinations)
 157 |           }
 158 |       }
 159 |       else {
 160 |       if (edgesymbol[1] == symbol[1] ~== "[") |
 161 |          (edgesymbol == symbol[1] == "[") then # sometimes a [ is just a [
 162 |              yyunionin(answer, curredge.destinations)
 163 | 
 164 |       else if edgesymbol[1] == "\\" then {
 165 |          if (edgesymbol[2] == "n") & (symbol[1] == "\n") then
 166 |             yyunionin(answer, curredge.destinations)
 167 |          else if (edgesymbol[2] == "t") & (symbol[1] == "\t") then
 168 |             yyunionin(answer, curredge.destinations)
 169 |          else if (edgesymbol[2] == "r") & (symbol[1] == "\r") then
 170 |             yyunionin(answer, curredge.destinations)
 171 |          else if (edgesymbol[2] == "f") & (symbol[1] == "\f") then
 172 |             yyunionin(answer, curredge.destinations)
 173 |          else if (edgesymbol[2] == "\\") & (symbol[1] == "\\") then
 174 |             yyunionin(answer, curredge.destinations)
 175 |          # should handle all escapes here, and error on bogus ones
 176 |          else if edgesymbol[2] == symbol[1] then
 177 |             yyunionin(answer, curredge.destinations)
 178 |          } # escape
 179 | 
 180 | 
 181 |       }
 182 | 
 183 |       } # while edgeset > 0
 184 |    if *(state.dot)>0 then {
 185 |       yyunionin(answer, state.dot)
 186 |       }
 187 |    return answer
 188 | end
 189 | 
 190 | # "recset" == "regular expression cset"
 191 | procedure csetfromrecset(recset)
 192 | local rv, lastchar, origcset := recset
 193 |    if not (recset[1]=="[" & recset[-1]=="]") then
 194 |       stop("malformed recset ", image(recset))
 195 |    recset := recset[2:-1]
 196 | 
 197 |    if recset[1]=="^" then { # not in this cset, subtract from &cset
 198 |       rv := &cset -- csetfromrecset("["||recset[2:0]||"]")
 199 |       return rv
 200 |       }
 201 |    # positive cset construction
 202 |    rv := ''
 203 |    while *recset>0 do {
 204 | 
 205 |       if recset[1] == "-" & \lastchar & *recset>1 then
 206 |          genrangefrom := lastchar
 207 |       else {
 208 |          # did not trigger a new range. Process one char
 209 | 
 210 |          if recset[1] == "\\" then { # escape
 211 |             recset := recset[2:0]
 212 |             case recset[1] of {
 213 |                "n":  recset[1] := "\n"
 214 |                "t":  recset[1] := "\t"
 215 |                "r":  recset[1] := "\r"
 216 |                "v":  recset[1] := "\v"
 217 |                "-":  recset[1] := "\-"
 218 |                "f":  recset[1] := "\f"
 219 |                "'":  recset[1] := "\'"
 220 |                "\"":  recset[1] := "\""
 221 |                "\\": recset[1] := "\\"
 222 |                "0": {
 223 |                   if any('01234567', recset[2]) then {
 224 |                      if any('01234567', recset[3]) then {
 225 |                         o := char(recset[1]*64+recset[2]*8+recset[3])
 226 |                         recset := o || recset[4:0]
 227 |                      }
 228 |                      else stop("argh2 ", image(recset))
 229 |                      }
 230 |                   else recset[1] := "\0"
 231 |                }
 232 |                # should handle all escapes here, and error on bogus ones
 233 |                default: stop("unrecognized escape ", image(recset[1]))
 234 |                }
 235 |             }
 236 | 
 237 |          rv ++:= recset[1]
 238 | 
 239 |          if \genrangefrom then { #if we have a pending range
 240 |             ord1 := ord(genrangefrom)
 241 |              ord2 := ord(recset[1])
 242 |              while ord1 < ord2 do {
 243 |                rv ++:= char(ord1)
 244 |                ord1 +:= 1
 245 |                }
 246 |             genrangefrom := &null
 247 |             }
 248 |          lastchar := recset[1]
 249 |           }
 250 |        recset := recset[2:0]
 251 |        }
 252 | 
 253 |    return rv
 254 | end
 255 | 
 256 | procedure printautomaton(a)
 257 |    write("Automaton:")
 258 |    write("start: ", image(a.start.label),
 259 |          " for rulenum ", image(a.start.rulenum))
 260 |    write("states:")
 261 |    every printstate(!a.states)
 262 |    writes("accepting: ")
 263 |    every writes((!a.accepting).label, " ")
 264 |    write()
 265 | end
 266 | 
 267 | procedure printstate(state)
 268 |    write("state ", state.label, " is for rule #", state.rulenum)
 269 |    if (*state.edges)>0 then {
 270 |       writes("\tedges: "); every printedge(!state.edges); write()
 271 |       }
 272 |    if *state.epsilon>0 then {
 273 |       writes("\tepsilon: ")
 274 |       every writes((!state.epsilon).label, " "); write()
 275 |       }
 276 |    if (*state.dot)>0 then {
 277 |       writes("\tdot: ")
 278 |       every writes((!state.dot).label, " "); write()
 279 |       }
 280 | end
 281 | 
 282 | procedure printedge(edge)
 283 |    writes(image(edge.symbol), " -> ")
 284 |    every writes((!edge.destinations).label)
 285 |    writes("; ")
 286 | end
 287 | 
 288 | procedure printstates(states)
 289 | local statecopy, current
 290 | 
 291 |    write("printstates size ", *states, " in entity ", image(states))
 292 |    statecopy := copy(states)
 293 | 
 294 |    while *statecopy > 1 do {
 295 |       current := pop(statecopy)
 296 |       write(current.label, ", ")
 297 |       }
 298 | 
 299 |    if *statecopy > 0 then {
 300 |       current := pop(statecopy)
 301 |       write(current.label)
 302 |       }
 303 |     else write("state list is empty")
 304 | end
 305 | global semantic_action
 306 | 
 307 | procedure yylex()
 308 | static myautomata
 309 | local currstate, state2, tempedge
 310 | 
 311 |  initial {
 312 |    myautomata := automata()
 313 | 
 314 |    myautomata.states := []
 315 |    myautomata.accepting := []
 316 |    put(myautomata.states, currstate := anode(1, 0, [], [], []))
 317 |    myautomata.start := currstate
 318 | 
 319 |    put(myautomata.states, currstate := anode(2, 3, [], [], []))
 320 |    put(myautomata.accepting, currstate)
 321 | 
 322 |    put(myautomata.states, currstate := anode(3, 4, [], [], []))
 323 |    put(myautomata.accepting, currstate)
 324 | 
 325 |    put(myautomata.states, currstate := anode(4, 0, [], [], []))
 326 | 
 327 |    put(myautomata.states, currstate := anode(5, 0, [], [], []))
 328 | 
 329 |    put(myautomata.states, currstate := anode(6, 0, [], [], []))
 330 | 
 331 |    put(myautomata.states, currstate := anode(7, 0, [], [], []))
 332 | 
 333 |    put(myautomata.states, currstate := anode(8, 0, [], [], []))
 334 | 
 335 |    put(myautomata.states, currstate := anode(9, 0, [], [], []))
 336 | 
 337 |    put(myautomata.states, currstate := anode(10, 0, [], [], []))
 338 | 
 339 |    put(myautomata.states, currstate := anode(11, 0, [], [], []))
 340 | 
 341 |    put(myautomata.states, currstate := anode(12, 0, [], [], []))
 342 | 
 343 |    put(myautomata.states, currstate := anode(13, 0, [], [], []))
 344 | 
 345 |    put(myautomata.states, currstate := anode(14, 0, [], [], []))
 346 | 
 347 |    put(myautomata.states, currstate := anode(15, 0, [], [], []))
 348 | 
 349 |    put(myautomata.states, currstate := anode(16, 0, [], [], []))
 350 | 
 351 |    put(myautomata.states, currstate := anode(17, 23, [], [], []))
 352 |    put(myautomata.accepting, currstate)
 353 | 
 354 |    put(myautomata.states, currstate := anode(18, 24, [], [], []))
 355 |    put(myautomata.accepting, currstate)
 356 | 
 357 |    put(myautomata.states, currstate := anode(19, 25, [], [], []))
 358 |    put(myautomata.accepting, currstate)
 359 | 
 360 |    put(myautomata.states, currstate := anode(20, 26, [], [], []))
 361 |    put(myautomata.accepting, currstate)
 362 | 
 363 |    put(myautomata.states, currstate := anode(21, 27, [], [], []))
 364 |    put(myautomata.accepting, currstate)
 365 | 
 366 |    put(myautomata.states, currstate := anode(22, 28, [], [], []))
 367 |    put(myautomata.accepting, currstate)
 368 | 
 369 |    put(myautomata.states, currstate := anode(23, 29, [], [], []))
 370 |    put(myautomata.accepting, currstate)
 371 | 
 372 |    put(myautomata.states, currstate := anode(24, 30, [], [], []))
 373 |    put(myautomata.accepting, currstate)
 374 | 
 375 |    put(myautomata.states, currstate := anode(25, 32, [], [], []))
 376 |    put(myautomata.accepting, currstate)
 377 | 
 378 |    put(myautomata.states, currstate := anode(26, 33, [], [], []))
 379 |    put(myautomata.accepting, currstate)
 380 | 
 381 |    put(myautomata.states, currstate := anode(27, 34, [], [], []))
 382 |    put(myautomata.accepting, currstate)
 383 | 
 384 |    put(myautomata.states, currstate := anode(28, 37, [], [], []))
 385 |    put(myautomata.accepting, currstate)
 386 | 
 387 |    put(myautomata.states, currstate := anode(29, 39, [], [], []))
 388 |    put(myautomata.accepting, currstate)
 389 | 
 390 |    put(myautomata.states, currstate := anode(30, 31, [], [], []))
 391 |    put(myautomata.accepting, currstate)
 392 | 
 393 |    put(myautomata.states, currstate := anode(31, 0, [], [], []))
 394 | 
 395 |    put(myautomata.states, currstate := anode(32, 0, [], [], []))
 396 | 
 397 |    put(myautomata.states, currstate := anode(33, 35, [], [], []))
 398 |    put(myautomata.accepting, currstate)
 399 | 
 400 |    put(myautomata.states, currstate := anode(34, 36, [], [], []))
 401 |    put(myautomata.accepting, currstate)
 402 | 
 403 |    put(myautomata.states, currstate := anode(35, 45, [], [], []))
 404 |    put(myautomata.accepting, currstate)
 405 | 
 406 |    put(myautomata.states, currstate := anode(36, 48, [], [], []))
 407 |    put(myautomata.accepting, currstate)
 408 | 
 409 |    put(myautomata.states, currstate := anode(37, 50, [], [], []))
 410 |    put(myautomata.accepting, currstate)
 411 | 
 412 |    put(myautomata.states, currstate := anode(38, 49, [], [], []))
 413 |    put(myautomata.accepting, currstate)
 414 | 
 415 |    put(myautomata.states, currstate := anode(39, 51, [], [], []))
 416 |    put(myautomata.accepting, currstate)
 417 | 
 418 |    put(myautomata.states, currstate := anode(40, 0, [], [], []))
 419 | 
 420 |    put(myautomata.states, currstate := anode(41, 55, [], [], []))
 421 |    put(myautomata.accepting, currstate)
 422 | 
 423 |    put(myautomata.states, currstate := anode(42, 0, [], [], []))
 424 | 
 425 |    put(myautomata.states, currstate := anode(43, 0, [], [], []))
 426 | 
 427 |    put(myautomata.states, currstate := anode(44, 0, [], [], []))
 428 | 
 429 |    put(myautomata.states, currstate := anode(45, 0, [], [], []))
 430 | 
 431 |    put(myautomata.states, currstate := anode(46, 0, [], [], []))
 432 | 
 433 |    put(myautomata.states, currstate := anode(47, 0, [], [], []))
 434 | 
 435 |    put(myautomata.states, currstate := anode(48, 0, [], [], []))
 436 | 
 437 |    put(myautomata.states, currstate := anode(49, 0, [], [], []))
 438 | 
 439 |    put(myautomata.states, currstate := anode(50, 0, [], [], []))
 440 | 
 441 |    put(myautomata.states, currstate := anode(51, 0, [], [], []))
 442 | 
 443 |    put(myautomata.states, currstate := anode(52, 0, [], [], []))
 444 | 
 445 |    put(myautomata.states, currstate := anode(53, 0, [], [], []))
 446 | 
 447 |    put(myautomata.states, currstate := anode(54, 10, [], [], []))
 448 |    put(myautomata.accepting, currstate)
 449 | 
 450 |    put(myautomata.states, currstate := anode(55, 0, [], [], []))
 451 | 
 452 |    put(myautomata.states, currstate := anode(56, 0, [], [], []))
 453 | 
 454 |    put(myautomata.states, currstate := anode(57, 0, [], [], []))
 455 | 
 456 |    put(myautomata.states, currstate := anode(58, 0, [], [], []))
 457 | 
 458 |    put(myautomata.states, currstate := anode(59, 0, [], [], []))
 459 | 
 460 |    put(myautomata.states, currstate := anode(60, 0, [], [], []))
 461 | 
 462 |    put(myautomata.states, currstate := anode(61, 38, [], [], []))
 463 |    put(myautomata.accepting, currstate)
 464 | 
 465 |    put(myautomata.states, currstate := anode(62, 40, [], [], []))
 466 |    put(myautomata.accepting, currstate)
 467 | 
 468 |    put(myautomata.states, currstate := anode(63, 42, [], [], []))
 469 |    put(myautomata.accepting, currstate)
 470 | 
 471 |    put(myautomata.states, currstate := anode(64, 43, [], [], []))
 472 |    put(myautomata.accepting, currstate)
 473 | 
 474 |    put(myautomata.states, currstate := anode(65, 44, [], [], []))
 475 |    put(myautomata.accepting, currstate)
 476 | 
 477 |    put(myautomata.states, currstate := anode(66, 46, [], [], []))
 478 |    put(myautomata.accepting, currstate)
 479 | 
 480 |    put(myautomata.states, currstate := anode(67, 47, [], [], []))
 481 |    put(myautomata.accepting, currstate)
 482 | 
 483 |    put(myautomata.states, currstate := anode(68, 41, [], [], []))
 484 |    put(myautomata.accepting, currstate)
 485 | 
 486 |    put(myautomata.states, currstate := anode(69, 50, [], [], []))
 487 |    put(myautomata.accepting, currstate)
 488 | 
 489 |    put(myautomata.states, currstate := anode(70, 0, [], [], []))
 490 | 
 491 |    put(myautomata.states, currstate := anode(71, 0, [], [], []))
 492 | 
 493 |    put(myautomata.states, currstate := anode(72, 0, [], [], []))
 494 | 
 495 |    put(myautomata.states, currstate := anode(73, 0, [], [], []))
 496 | 
 497 |    put(myautomata.states, currstate := anode(74, 0, [], [], []))
 498 | 
 499 |    put(myautomata.states, currstate := anode(75, 0, [], [], []))
 500 | 
 501 |    put(myautomata.states, currstate := anode(76, 54, [], [], []))
 502 |    put(myautomata.accepting, currstate)
 503 | 
 504 |    put(myautomata.states, currstate := anode(77, 9, [], [], []))
 505 |    put(myautomata.accepting, currstate)
 506 | 
 507 |    put(myautomata.states, currstate := anode(78, 0, [], [], []))
 508 | 
 509 |    put(myautomata.states, currstate := anode(79, 0, [], [], []))
 510 | 
 511 |    put(myautomata.states, currstate := anode(80, 0, [], [], []))
 512 | 
 513 |    put(myautomata.states, currstate := anode(81, 0, [], [], []))
 514 | 
 515 |    put(myautomata.states, currstate := anode(82, 0, [], [], []))
 516 | 
 517 |    put(myautomata.states, currstate := anode(83, 0, [], [], []))
 518 | 
 519 |    put(myautomata.states, currstate := anode(84, 0, [], [], []))
 520 | 
 521 |    put(myautomata.states, currstate := anode(85, 12, [], [], []))
 522 |    put(myautomata.accepting, currstate)
 523 | 
 524 |    put(myautomata.states, currstate := anode(86, 0, [], [], []))
 525 | 
 526 |    put(myautomata.states, currstate := anode(87, 0, [], [], []))
 527 | 
 528 |    put(myautomata.states, currstate := anode(88, 0, [], [], []))
 529 | 
 530 |    put(myautomata.states, currstate := anode(89, 11, [], [], []))
 531 |    put(myautomata.accepting, currstate)
 532 | 
 533 |    put(myautomata.states, currstate := anode(90, 0, [], [], []))
 534 | 
 535 |    put(myautomata.states, currstate := anode(91, 0, [], [], []))
 536 | 
 537 |    put(myautomata.states, currstate := anode(92, 0, [], [], []))
 538 | 
 539 |    put(myautomata.states, currstate := anode(93, 0, [], [], []))
 540 | 
 541 |    put(myautomata.states, currstate := anode(94, 0, [], [], []))
 542 | 
 543 |    put(myautomata.states, currstate := anode(95, 0, [], [], []))
 544 | 
 545 |    put(myautomata.states, currstate := anode(96, 2, [], [], []))
 546 |    put(myautomata.accepting, currstate)
 547 | 
 548 |    put(myautomata.states, currstate := anode(97, 0, [], [], []))
 549 | 
 550 |    put(myautomata.states, currstate := anode(98, 0, [], [], []))
 551 | 
 552 |    put(myautomata.states, currstate := anode(99, 0, [], [], []))
 553 | 
 554 |    put(myautomata.states, currstate := anode(100, 52, [], [], []))
 555 |    put(myautomata.accepting, currstate)
 556 | 
 557 |    put(myautomata.states, currstate := anode(101, 0, [], [], []))
 558 | 
 559 |    put(myautomata.states, currstate := anode(102, 53, [], [], []))
 560 |    put(myautomata.accepting, currstate)
 561 | 
 562 |    put(myautomata.states, currstate := anode(103, 0, [], [], []))
 563 | 
 564 |    put(myautomata.states, currstate := anode(104, 0, [], [], []))
 565 | 
 566 |    put(myautomata.states, currstate := anode(105, 0, [], [], []))
 567 | 
 568 |    put(myautomata.states, currstate := anode(106, 18, [], [], []))
 569 |    put(myautomata.accepting, currstate)
 570 | 
 571 |    put(myautomata.states, currstate := anode(107, 0, [], [], []))
 572 | 
 573 |    put(myautomata.states, currstate := anode(108, 0, [], [], []))
 574 | 
 575 |    put(myautomata.states, currstate := anode(109, 0, [], [], []))
 576 | 
 577 |    put(myautomata.states, currstate := anode(110, 13, [], [], []))
 578 |    put(myautomata.accepting, currstate)
 579 | 
 580 |    put(myautomata.states, currstate := anode(111, 20, [], [], []))
 581 |    put(myautomata.accepting, currstate)
 582 | 
 583 |    put(myautomata.states, currstate := anode(112, 0, [], [], []))
 584 | 
 585 |    put(myautomata.states, currstate := anode(113, 0, [], [], []))
 586 | 
 587 |    put(myautomata.states, currstate := anode(114, 7, [], [], []))
 588 |    put(myautomata.accepting, currstate)
 589 | 
 590 |    put(myautomata.states, currstate := anode(115, 0, [], [], []))
 591 | 
 592 |    put(myautomata.states, currstate := anode(116, 0, [], [], []))
 593 | 
 594 |    put(myautomata.states, currstate := anode(117, 0, [], [], []))
 595 | 
 596 |    put(myautomata.states, currstate := anode(118, 0, [], [], []))
 597 | 
 598 |    put(myautomata.states, currstate := anode(119, 1, [], [], []))
 599 |    put(myautomata.accepting, currstate)
 600 | 
 601 |    put(myautomata.states, currstate := anode(120, 8, [], [], []))
 602 |    put(myautomata.accepting, currstate)
 603 | 
 604 |    put(myautomata.states, currstate := anode(121, 0, [], [], []))
 605 | 
 606 |    put(myautomata.states, currstate := anode(122, 0, [], [], []))
 607 | 
 608 |    put(myautomata.states, currstate := anode(123, 5, [], [], []))
 609 |    put(myautomata.accepting, currstate)
 610 | 
 611 |    put(myautomata.states, currstate := anode(124, 0, [], [], []))
 612 | 
 613 |    put(myautomata.states, currstate := anode(125, 0, [], [], []))
 614 | 
 615 |    put(myautomata.states, currstate := anode(126, 21, [], [], []))
 616 |    put(myautomata.accepting, currstate)
 617 | 
 618 |    put(myautomata.states, currstate := anode(127, 22, [], [], []))
 619 |    put(myautomata.accepting, currstate)
 620 | 
 621 |    put(myautomata.states, currstate := anode(128, 0, [], [], []))
 622 | 
 623 |    put(myautomata.states, currstate := anode(129, 0, [], [], []))
 624 | 
 625 |    put(myautomata.states, currstate := anode(130, 14, [], [], []))
 626 |    put(myautomata.accepting, currstate)
 627 | 
 628 |    put(myautomata.states, currstate := anode(131, 15, [], [], []))
 629 |    put(myautomata.accepting, currstate)
 630 | 
 631 |    put(myautomata.states, currstate := anode(132, 0, [], [], []))
 632 | 
 633 |    put(myautomata.states, currstate := anode(133, 6, [], [], []))
 634 |    put(myautomata.accepting, currstate)
 635 | 
 636 |    put(myautomata.states, currstate := anode(134, 17, [], [], []))
 637 |    put(myautomata.accepting, currstate)
 638 | 
 639 |    put(myautomata.states, currstate := anode(135, 16, [], [], []))
 640 |    put(myautomata.accepting, currstate)
 641 | 
 642 |    put(myautomata.states, currstate := anode(136, 19, [], [], []))
 643 |    put(myautomata.accepting, currstate)
 644 | 
 645 |    currstate := pop(myautomata.states)
 646 |    put(myautomata.states, currstate)
 647 | 
 648 |    while currstate.label ~= 1 do {
 649 |       currstate := pop(myautomata.states)
 650 |       put(myautomata.states, currstate)
 651 |       }
 652 |    state2 := currstate
 653 | 
 654 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
 655 |    currstate := pop(myautomata.states)
 656 |    put(myautomata.states, currstate)
 657 | 
 658 |    while currstate.label ~= 2 do {
 659 |       currstate := pop(myautomata.states)
 660 |       put(myautomata.states, currstate)
 661 |       }
 662 |    put(tempedge.destinations, currstate)
 663 | 
 664 |    put(state2.edges, tempedge)
 665 |    tempedge := edge("\n"
 666 | , [])
 667 |    currstate := pop(myautomata.states)
 668 |    put(myautomata.states, currstate)
 669 | 
 670 |    while currstate.label ~= 3 do {
 671 |       currstate := pop(myautomata.states)
 672 |       put(myautomata.states, currstate)
 673 |       }
 674 |    put(tempedge.destinations, currstate)
 675 | 
 676 |    put(state2.edges, tempedge)
 677 |    tempedge := edge("f", [])
 678 |    currstate := pop(myautomata.states)
 679 |    put(myautomata.states, currstate)
 680 | 
 681 |    while currstate.label ~= 4 do {
 682 |       currstate := pop(myautomata.states)
 683 |       put(myautomata.states, currstate)
 684 |       }
 685 |    put(tempedge.destinations, currstate)
 686 | 
 687 |    put(state2.edges, tempedge)
 688 |    tempedge := edge("p", [])
 689 |    currstate := pop(myautomata.states)
 690 |    put(myautomata.states, currstate)
 691 | 
 692 |    while currstate.label ~= 5 do {
 693 |       currstate := pop(myautomata.states)
 694 |       put(myautomata.states, currstate)
 695 |       }
 696 |    put(tempedge.destinations, currstate)
 697 | 
 698 |    put(state2.edges, tempedge)
 699 |    tempedge := edge("t", [])
 700 |    currstate := pop(myautomata.states)
 701 |    put(myautomata.states, currstate)
 702 | 
 703 |    while currstate.label ~= 6 do {
 704 |       currstate := pop(myautomata.states)
 705 |       put(myautomata.states, currstate)
 706 |       }
 707 |    put(tempedge.destinations, currstate)
 708 | 
 709 |    put(state2.edges, tempedge)
 710 |    tempedge := edge("r", [])
 711 |    currstate := pop(myautomata.states)
 712 |    put(myautomata.states, currstate)
 713 | 
 714 |    while currstate.label ~= 7 do {
 715 |       currstate := pop(myautomata.states)
 716 |       put(myautomata.states, currstate)
 717 |       }
 718 |    put(tempedge.destinations, currstate)
 719 | 
 720 |    put(state2.edges, tempedge)
 721 |    tempedge := edge("b", [])
 722 |    currstate := pop(myautomata.states)
 723 |    put(myautomata.states, currstate)
 724 | 
 725 |    while currstate.label ~= 8 do {
 726 |       currstate := pop(myautomata.states)
 727 |       put(myautomata.states, currstate)
 728 |       }
 729 |    put(tempedge.destinations, currstate)
 730 | 
 731 |    put(state2.edges, tempedge)
 732 |    tempedge := edge("n", [])
 733 |    currstate := pop(myautomata.states)
 734 |    put(myautomata.states, currstate)
 735 | 
 736 |    while currstate.label ~= 9 do {
 737 |       currstate := pop(myautomata.states)
 738 |       put(myautomata.states, currstate)
 739 |       }
 740 |    put(tempedge.destinations, currstate)
 741 | 
 742 |    put(state2.edges, tempedge)
 743 |    tempedge := edge("v", [])
 744 |    currstate := pop(myautomata.states)
 745 |    put(myautomata.states, currstate)
 746 | 
 747 |    while currstate.label ~= 10 do {
 748 |       currstate := pop(myautomata.states)
 749 |       put(myautomata.states, currstate)
 750 |       }
 751 |    put(tempedge.destinations, currstate)
 752 | 
 753 |    put(state2.edges, tempedge)
 754 |    tempedge := edge("d", [])
 755 |    currstate := pop(myautomata.states)
 756 |    put(myautomata.states, currstate)
 757 | 
 758 |    while currstate.label ~= 11 do {
 759 |       currstate := pop(myautomata.states)
 760 |       put(myautomata.states, currstate)
 761 |       }
 762 |    put(tempedge.destinations, currstate)
 763 | 
 764 |    put(state2.edges, tempedge)
 765 |    tempedge := edge("w", [])
 766 |    currstate := pop(myautomata.states)
 767 |    put(myautomata.states, currstate)
 768 | 
 769 |    while currstate.label ~= 12 do {
 770 |       currstate := pop(myautomata.states)
 771 |       put(myautomata.states, currstate)
 772 |       }
 773 |    put(tempedge.destinations, currstate)
 774 | 
 775 |    put(state2.edges, tempedge)
 776 |    tempedge := edge("i", [])
 777 |    currstate := pop(myautomata.states)
 778 |    put(myautomata.states, currstate)
 779 | 
 780 |    while currstate.label ~= 13 do {
 781 |       currstate := pop(myautomata.states)
 782 |       put(myautomata.states, currstate)
 783 |       }
 784 |    put(tempedge.destinations, currstate)
 785 | 
 786 |    put(state2.edges, tempedge)
 787 |    tempedge := edge("e", [])
 788 |    currstate := pop(myautomata.states)
 789 |    put(myautomata.states, currstate)
 790 | 
 791 |    while currstate.label ~= 14 do {
 792 |       currstate := pop(myautomata.states)
 793 |       put(myautomata.states, currstate)
 794 |       }
 795 |    put(tempedge.destinations, currstate)
 796 | 
 797 |    put(state2.edges, tempedge)
 798 |    tempedge := edge("c", [])
 799 |    currstate := pop(myautomata.states)
 800 |    put(myautomata.states, currstate)
 801 | 
 802 |    while currstate.label ~= 15 do {
 803 |       currstate := pop(myautomata.states)
 804 |       put(myautomata.states, currstate)
 805 |       }
 806 |    put(tempedge.destinations, currstate)
 807 | 
 808 |    put(state2.edges, tempedge)
 809 |    tempedge := edge("s", [])
 810 |    currstate := pop(myautomata.states)
 811 |    put(myautomata.states, currstate)
 812 | 
 813 |    while currstate.label ~= 16 do {
 814 |       currstate := pop(myautomata.states)
 815 |       put(myautomata.states, currstate)
 816 |       }
 817 |    put(tempedge.destinations, currstate)
 818 | 
 819 |    put(state2.edges, tempedge)
 820 |    tempedge := edge("(", [])
 821 |    currstate := pop(myautomata.states)
 822 |    put(myautomata.states, currstate)
 823 | 
 824 |    while currstate.label ~= 17 do {
 825 |       currstate := pop(myautomata.states)
 826 |       put(myautomata.states, currstate)
 827 |       }
 828 |    put(tempedge.destinations, currstate)
 829 | 
 830 |    put(state2.edges, tempedge)
 831 |    tempedge := edge(")", [])
 832 |    currstate := pop(myautomata.states)
 833 |    put(myautomata.states, currstate)
 834 | 
 835 |    while currstate.label ~= 18 do {
 836 |       currstate := pop(myautomata.states)
 837 |       put(myautomata.states, currstate)
 838 |       }
 839 |    put(tempedge.destinations, currstate)
 840 | 
 841 |    put(state2.edges, tempedge)
 842 |    tempedge := edge("[", [])
 843 |    currstate := pop(myautomata.states)
 844 |    put(myautomata.states, currstate)
 845 | 
 846 |    while currstate.label ~= 19 do {
 847 |       currstate := pop(myautomata.states)
 848 |       put(myautomata.states, currstate)
 849 |       }
 850 |    put(tempedge.destinations, currstate)
 851 | 
 852 |    put(state2.edges, tempedge)
 853 |    tempedge := edge("]", [])
 854 |    currstate := pop(myautomata.states)
 855 |    put(myautomata.states, currstate)
 856 | 
 857 |    while currstate.label ~= 20 do {
 858 |       currstate := pop(myautomata.states)
 859 |       put(myautomata.states, currstate)
 860 |       }
 861 |    put(tempedge.destinations, currstate)
 862 | 
 863 |    put(state2.edges, tempedge)
 864 |    tempedge := edge("{", [])
 865 |    currstate := pop(myautomata.states)
 866 |    put(myautomata.states, currstate)
 867 | 
 868 |    while currstate.label ~= 21 do {
 869 |       currstate := pop(myautomata.states)
 870 |       put(myautomata.states, currstate)
 871 |       }
 872 |    put(tempedge.destinations, currstate)
 873 | 
 874 |    put(state2.edges, tempedge)
 875 |    tempedge := edge("}", [])
 876 |    currstate := pop(myautomata.states)
 877 |    put(myautomata.states, currstate)
 878 | 
 879 |    while currstate.label ~= 22 do {
 880 |       currstate := pop(myautomata.states)
 881 |       put(myautomata.states, currstate)
 882 |       }
 883 |    put(tempedge.destinations, currstate)
 884 | 
 885 |    put(state2.edges, tempedge)
 886 |    tempedge := edge(";", [])
 887 |    currstate := pop(myautomata.states)
 888 |    put(myautomata.states, currstate)
 889 | 
 890 |    while currstate.label ~= 23 do {
 891 |       currstate := pop(myautomata.states)
 892 |       put(myautomata.states, currstate)
 893 |       }
 894 |    put(tempedge.destinations, currstate)
 895 | 
 896 |    put(state2.edges, tempedge)
 897 |    tempedge := edge(":", [])
 898 |    currstate := pop(myautomata.states)
 899 |    put(myautomata.states, currstate)
 900 | 
 901 |    while currstate.label ~= 24 do {
 902 |       currstate := pop(myautomata.states)
 903 |       put(myautomata.states, currstate)
 904 |       }
 905 |    put(tempedge.destinations, currstate)
 906 | 
 907 |    put(state2.edges, tempedge)
 908 |    tempedge := edge("*", [])
 909 |    currstate := pop(myautomata.states)
 910 |    put(myautomata.states, currstate)
 911 | 
 912 |    while currstate.label ~= 25 do {
 913 |       currstate := pop(myautomata.states)
 914 |       put(myautomata.states, currstate)
 915 |       }
 916 |    put(tempedge.destinations, currstate)
 917 | 
 918 |    put(state2.edges, tempedge)
 919 |    tempedge := edge("/", [])
 920 |    currstate := pop(myautomata.states)
 921 |    put(myautomata.states, currstate)
 922 | 
 923 |    while currstate.label ~= 26 do {
 924 |       currstate := pop(myautomata.states)
 925 |       put(myautomata.states, currstate)
 926 |       }
 927 |    put(tempedge.destinations, currstate)
 928 | 
 929 |    put(state2.edges, tempedge)
 930 |    tempedge := edge("%", [])
 931 |    currstate := pop(myautomata.states)
 932 |    put(myautomata.states, currstate)
 933 | 
 934 |    while currstate.label ~= 27 do {
 935 |       currstate := pop(myautomata.states)
 936 |       put(myautomata.states, currstate)
 937 |       }
 938 |    put(tempedge.destinations, currstate)
 939 | 
 940 |    put(state2.edges, tempedge)
 941 |    tempedge := edge("<", [])
 942 |    currstate := pop(myautomata.states)
 943 |    put(myautomata.states, currstate)
 944 | 
 945 |    while currstate.label ~= 28 do {
 946 |       currstate := pop(myautomata.states)
 947 |       put(myautomata.states, currstate)
 948 |       }
 949 |    put(tempedge.destinations, currstate)
 950 | 
 951 |    put(state2.edges, tempedge)
 952 |    tempedge := edge(">", [])
 953 |    currstate := pop(myautomata.states)
 954 |    put(myautomata.states, currstate)
 955 | 
 956 |    while currstate.label ~= 29 do {
 957 |       currstate := pop(myautomata.states)
 958 |       put(myautomata.states, currstate)
 959 |       }
 960 |    put(tempedge.destinations, currstate)
 961 | 
 962 |    put(state2.edges, tempedge)
 963 |    tempedge := edge("!", [])
 964 |    currstate := pop(myautomata.states)
 965 |    put(myautomata.states, currstate)
 966 | 
 967 |    while currstate.label ~= 30 do {
 968 |       currstate := pop(myautomata.states)
 969 |       put(myautomata.states, currstate)
 970 |       }
 971 |    put(tempedge.destinations, currstate)
 972 | 
 973 |    put(state2.edges, tempedge)
 974 |    tempedge := edge("&", [])
 975 |    currstate := pop(myautomata.states)
 976 |    put(myautomata.states, currstate)
 977 | 
 978 |    while currstate.label ~= 31 do {
 979 |       currstate := pop(myautomata.states)
 980 |       put(myautomata.states, currstate)
 981 |       }
 982 |    put(tempedge.destinations, currstate)
 983 | 
 984 |    put(state2.edges, tempedge)
 985 |    tempedge := edge("|", [])
 986 |    currstate := pop(myautomata.states)
 987 |    put(myautomata.states, currstate)
 988 | 
 989 |    while currstate.label ~= 32 do {
 990 |       currstate := pop(myautomata.states)
 991 |       put(myautomata.states, currstate)
 992 |       }
 993 |    put(tempedge.destinations, currstate)
 994 | 
 995 |    put(state2.edges, tempedge)
 996 |    tempedge := edge("+", [])
 997 |    currstate := pop(myautomata.states)
 998 |    put(myautomata.states, currstate)
 999 | 
1000 |    while currstate.label ~= 33 do {
1001 |       currstate := pop(myautomata.states)
1002 |       put(myautomata.states, currstate)
1003 |       }
1004 |    put(tempedge.destinations, currstate)
1005 | 
1006 |    put(state2.edges, tempedge)
1007 |    tempedge := edge("-", [])
1008 |    currstate := pop(myautomata.states)
1009 |    put(myautomata.states, currstate)
1010 | 
1011 |    while currstate.label ~= 34 do {
1012 |       currstate := pop(myautomata.states)
1013 |       put(myautomata.states, currstate)
1014 |       }
1015 |    put(tempedge.destinations, currstate)
1016 | 
1017 |    put(state2.edges, tempedge)
1018 |    tempedge := edge("=", [])
1019 |    currstate := pop(myautomata.states)
1020 |    put(myautomata.states, currstate)
1021 | 
1022 |    while currstate.label ~= 35 do {
1023 |       currstate := pop(myautomata.states)
1024 |       put(myautomata.states, currstate)
1025 |       }
1026 |    put(tempedge.destinations, currstate)
1027 | 
1028 |    put(state2.edges, tempedge)
1029 |    tempedge := edge(",", [])
1030 |    currstate := pop(myautomata.states)
1031 |    put(myautomata.states, currstate)
1032 | 
1033 |    while currstate.label ~= 36 do {
1034 |       currstate := pop(myautomata.states)
1035 |       put(myautomata.states, currstate)
1036 |       }
1037 |    put(tempedge.destinations, currstate)
1038 | 
1039 |    put(state2.edges, tempedge)
1040 |    tempedge := edge(csetfromrecset("[\a-zA-Z_]"), [])
1041 |    currstate := pop(myautomata.states)
1042 |    put(myautomata.states, currstate)
1043 | 
1044 |    while currstate.label ~= 37 do {
1045 |       currstate := pop(myautomata.states)
1046 |       put(myautomata.states, currstate)
1047 |       }
1048 |    put(tempedge.destinations, currstate)
1049 | 
1050 |    put(state2.edges, tempedge)
1051 |    tempedge := edge(".", [])
1052 |    currstate := pop(myautomata.states)
1053 |    put(myautomata.states, currstate)
1054 | 
1055 |    while currstate.label ~= 38 do {
1056 |       currstate := pop(myautomata.states)
1057 |       put(myautomata.states, currstate)
1058 |       }
1059 |    put(tempedge.destinations, currstate)
1060 | 
1061 |    put(state2.edges, tempedge)
1062 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1063 |    currstate := pop(myautomata.states)
1064 |    put(myautomata.states, currstate)
1065 | 
1066 |    while currstate.label ~= 39 do {
1067 |       currstate := pop(myautomata.states)
1068 |       put(myautomata.states, currstate)
1069 |       }
1070 |    put(tempedge.destinations, currstate)
1071 | 
1072 |    put(state2.edges, tempedge)
1073 |    tempedge := edge("\"", [])
1074 |    currstate := pop(myautomata.states)
1075 |    put(myautomata.states, currstate)
1076 | 
1077 |    while currstate.label ~= 40 do {
1078 |       currstate := pop(myautomata.states)
1079 |       put(myautomata.states, currstate)
1080 |       }
1081 |    put(tempedge.destinations, currstate)
1082 | 
1083 |    put(state2.edges, tempedge)
1084 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
1085 |    currstate := pop(myautomata.states)
1086 |    put(myautomata.states, currstate)
1087 | 
1088 |    while currstate.label ~= 41 do {
1089 |       currstate := pop(myautomata.states)
1090 |       put(myautomata.states, currstate)
1091 |       }
1092 |    put(tempedge.destinations, currstate)
1093 | 
1094 |    put(state2.edges, tempedge)
1095 |    currstate := pop(myautomata.states)
1096 |    put(myautomata.states, currstate)
1097 | 
1098 |    while currstate.label ~= 2 do {
1099 |       currstate := pop(myautomata.states)
1100 |       put(myautomata.states, currstate)
1101 |       }
1102 |    state2 := currstate
1103 | 
1104 |    tempedge := edge(csetfromrecset("[ \\t\\r\\f]"), [])
1105 |    currstate := pop(myautomata.states)
1106 |    put(myautomata.states, currstate)
1107 | 
1108 |    while currstate.label ~= 2 do {
1109 |       currstate := pop(myautomata.states)
1110 |       put(myautomata.states, currstate)
1111 |       }
1112 |    put(tempedge.destinations, currstate)
1113 | 
1114 |    put(state2.edges, tempedge)
1115 |    currstate := pop(myautomata.states)
1116 |    put(myautomata.states, currstate)
1117 | 
1118 |    while currstate.label ~= 3 do {
1119 |       currstate := pop(myautomata.states)
1120 |       put(myautomata.states, currstate)
1121 |       }
1122 |    state2 := currstate
1123 | 
1124 |    currstate := pop(myautomata.states)
1125 |    put(myautomata.states, currstate)
1126 | 
1127 |    while currstate.label ~= 4 do {
1128 |       currstate := pop(myautomata.states)
1129 |       put(myautomata.states, currstate)
1130 |       }
1131 |    state2 := currstate
1132 | 
1133 |    tempedge := edge("o", [])
1134 |    currstate := pop(myautomata.states)
1135 |    put(myautomata.states, currstate)
1136 | 
1137 |    while currstate.label ~= 42 do {
1138 |       currstate := pop(myautomata.states)
1139 |       put(myautomata.states, currstate)
1140 |       }
1141 |    put(tempedge.destinations, currstate)
1142 | 
1143 |    put(state2.edges, tempedge)
1144 |    tempedge := edge("\a", [])
1145 |    currstate := pop(myautomata.states)
1146 |    put(myautomata.states, currstate)
1147 | 
1148 |    while currstate.label ~= 43 do {
1149 |       currstate := pop(myautomata.states)
1150 |       put(myautomata.states, currstate)
1151 |       }
1152 |    put(tempedge.destinations, currstate)
1153 | 
1154 |    put(state2.edges, tempedge)
1155 |    currstate := pop(myautomata.states)
1156 |    put(myautomata.states, currstate)
1157 | 
1158 |    while currstate.label ~= 5 do {
1159 |       currstate := pop(myautomata.states)
1160 |       put(myautomata.states, currstate)
1161 |       }
1162 |    state2 := currstate
1163 | 
1164 |    tempedge := edge("u", [])
1165 |    currstate := pop(myautomata.states)
1166 |    put(myautomata.states, currstate)
1167 | 
1168 |    while currstate.label ~= 44 do {
1169 |       currstate := pop(myautomata.states)
1170 |       put(myautomata.states, currstate)
1171 |       }
1172 |    put(tempedge.destinations, currstate)
1173 | 
1174 |    put(state2.edges, tempedge)
1175 |    currstate := pop(myautomata.states)
1176 |    put(myautomata.states, currstate)
1177 | 
1178 |    while currstate.label ~= 6 do {
1179 |       currstate := pop(myautomata.states)
1180 |       put(myautomata.states, currstate)
1181 |       }
1182 |    state2 := currstate
1183 | 
1184 |    tempedge := edge("r", [])
1185 |    currstate := pop(myautomata.states)
1186 |    put(myautomata.states, currstate)
1187 | 
1188 |    while currstate.label ~= 45 do {
1189 |       currstate := pop(myautomata.states)
1190 |       put(myautomata.states, currstate)
1191 |       }
1192 |    put(tempedge.destinations, currstate)
1193 | 
1194 |    put(state2.edges, tempedge)
1195 |    currstate := pop(myautomata.states)
1196 |    put(myautomata.states, currstate)
1197 | 
1198 |    while currstate.label ~= 7 do {
1199 |       currstate := pop(myautomata.states)
1200 |       put(myautomata.states, currstate)
1201 |       }
1202 |    state2 := currstate
1203 | 
1204 |    tempedge := edge("e", [])
1205 |    currstate := pop(myautomata.states)
1206 |    put(myautomata.states, currstate)
1207 | 
1208 |    while currstate.label ~= 46 do {
1209 |       currstate := pop(myautomata.states)
1210 |       put(myautomata.states, currstate)
1211 |       }
1212 |    put(tempedge.destinations, currstate)
1213 | 
1214 |    put(state2.edges, tempedge)
1215 |    currstate := pop(myautomata.states)
1216 |    put(myautomata.states, currstate)
1217 | 
1218 |    while currstate.label ~= 8 do {
1219 |       currstate := pop(myautomata.states)
1220 |       put(myautomata.states, currstate)
1221 |       }
1222 |    state2 := currstate
1223 | 
1224 |    tempedge := edge("r", [])
1225 |    currstate := pop(myautomata.states)
1226 |    put(myautomata.states, currstate)
1227 | 
1228 |    while currstate.label ~= 47 do {
1229 |       currstate := pop(myautomata.states)
1230 |       put(myautomata.states, currstate)
1231 |       }
1232 |    put(tempedge.destinations, currstate)
1233 | 
1234 |    put(state2.edges, tempedge)
1235 |    tempedge := edge("o", [])
1236 |    currstate := pop(myautomata.states)
1237 |    put(myautomata.states, currstate)
1238 | 
1239 |    while currstate.label ~= 48 do {
1240 |       currstate := pop(myautomata.states)
1241 |       put(myautomata.states, currstate)
1242 |       }
1243 |    put(tempedge.destinations, currstate)
1244 | 
1245 |    put(state2.edges, tempedge)
1246 |    currstate := pop(myautomata.states)
1247 |    put(myautomata.states, currstate)
1248 | 
1249 |    while currstate.label ~= 9 do {
1250 |       currstate := pop(myautomata.states)
1251 |       put(myautomata.states, currstate)
1252 |       }
1253 |    state2 := currstate
1254 | 
1255 |    tempedge := edge("u", [])
1256 |    currstate := pop(myautomata.states)
1257 |    put(myautomata.states, currstate)
1258 | 
1259 |    while currstate.label ~= 49 do {
1260 |       currstate := pop(myautomata.states)
1261 |       put(myautomata.states, currstate)
1262 |       }
1263 |    put(tempedge.destinations, currstate)
1264 | 
1265 |    put(state2.edges, tempedge)
1266 |    tempedge := edge("e", [])
1267 |    currstate := pop(myautomata.states)
1268 |    put(myautomata.states, currstate)
1269 | 
1270 |    while currstate.label ~= 50 do {
1271 |       currstate := pop(myautomata.states)
1272 |       put(myautomata.states, currstate)
1273 |       }
1274 |    put(tempedge.destinations, currstate)
1275 | 
1276 |    put(state2.edges, tempedge)
1277 |    currstate := pop(myautomata.states)
1278 |    put(myautomata.states, currstate)
1279 | 
1280 |    while currstate.label ~= 10 do {
1281 |       currstate := pop(myautomata.states)
1282 |       put(myautomata.states, currstate)
1283 |       }
1284 |    state2 := currstate
1285 | 
1286 |    tempedge := edge("o", [])
1287 |    currstate := pop(myautomata.states)
1288 |    put(myautomata.states, currstate)
1289 | 
1290 |    while currstate.label ~= 51 do {
1291 |       currstate := pop(myautomata.states)
1292 |       put(myautomata.states, currstate)
1293 |       }
1294 |    put(tempedge.destinations, currstate)
1295 | 
1296 |    put(state2.edges, tempedge)
1297 |    currstate := pop(myautomata.states)
1298 |    put(myautomata.states, currstate)
1299 | 
1300 |    while currstate.label ~= 11 do {
1301 |       currstate := pop(myautomata.states)
1302 |       put(myautomata.states, currstate)
1303 |       }
1304 |    state2 := currstate
1305 | 
1306 |    tempedge := edge("o", [])
1307 |    currstate := pop(myautomata.states)
1308 |    put(myautomata.states, currstate)
1309 | 
1310 |    while currstate.label ~= 52 do {
1311 |       currstate := pop(myautomata.states)
1312 |       put(myautomata.states, currstate)
1313 |       }
1314 |    put(tempedge.destinations, currstate)
1315 | 
1316 |    put(state2.edges, tempedge)
1317 |    currstate := pop(myautomata.states)
1318 |    put(myautomata.states, currstate)
1319 | 
1320 |    while currstate.label ~= 12 do {
1321 |       currstate := pop(myautomata.states)
1322 |       put(myautomata.states, currstate)
1323 |       }
1324 |    state2 := currstate
1325 | 
1326 |    tempedge := edge("h", [])
1327 |    currstate := pop(myautomata.states)
1328 |    put(myautomata.states, currstate)
1329 | 
1330 |    while currstate.label ~= 53 do {
1331 |       currstate := pop(myautomata.states)
1332 |       put(myautomata.states, currstate)
1333 |       }
1334 |    put(tempedge.destinations, currstate)
1335 | 
1336 |    put(state2.edges, tempedge)
1337 |    currstate := pop(myautomata.states)
1338 |    put(myautomata.states, currstate)
1339 | 
1340 |    while currstate.label ~= 13 do {
1341 |       currstate := pop(myautomata.states)
1342 |       put(myautomata.states, currstate)
1343 |       }
1344 |    state2 := currstate
1345 | 
1346 |    tempedge := edge("f", [])
1347 |    currstate := pop(myautomata.states)
1348 |    put(myautomata.states, currstate)
1349 | 
1350 |    while currstate.label ~= 54 do {
1351 |       currstate := pop(myautomata.states)
1352 |       put(myautomata.states, currstate)
1353 |       }
1354 |    put(tempedge.destinations, currstate)
1355 | 
1356 |    put(state2.edges, tempedge)
1357 |    tempedge := edge("n", [])
1358 |    currstate := pop(myautomata.states)
1359 |    put(myautomata.states, currstate)
1360 | 
1361 |    while currstate.label ~= 55 do {
1362 |       currstate := pop(myautomata.states)
1363 |       put(myautomata.states, currstate)
1364 |       }
1365 |    put(tempedge.destinations, currstate)
1366 | 
1367 |    put(state2.edges, tempedge)
1368 |    currstate := pop(myautomata.states)
1369 |    put(myautomata.states, currstate)
1370 | 
1371 |    while currstate.label ~= 14 do {
1372 |       currstate := pop(myautomata.states)
1373 |       put(myautomata.states, currstate)
1374 |       }
1375 |    state2 := currstate
1376 | 
1377 |    tempedge := edge("l", [])
1378 |    currstate := pop(myautomata.states)
1379 |    put(myautomata.states, currstate)
1380 | 
1381 |    while currstate.label ~= 56 do {
1382 |       currstate := pop(myautomata.states)
1383 |       put(myautomata.states, currstate)
1384 |       }
1385 |    put(tempedge.destinations, currstate)
1386 | 
1387 |    put(state2.edges, tempedge)
1388 |    currstate := pop(myautomata.states)
1389 |    put(myautomata.states, currstate)
1390 | 
1391 |    while currstate.label ~= 15 do {
1392 |       currstate := pop(myautomata.states)
1393 |       put(myautomata.states, currstate)
1394 |       }
1395 |    state2 := currstate
1396 | 
1397 |    tempedge := edge("l", [])
1398 |    currstate := pop(myautomata.states)
1399 |    put(myautomata.states, currstate)
1400 | 
1401 |    while currstate.label ~= 57 do {
1402 |       currstate := pop(myautomata.states)
1403 |       put(myautomata.states, currstate)
1404 |       }
1405 |    put(tempedge.destinations, currstate)
1406 | 
1407 |    put(state2.edges, tempedge)
1408 |    currstate := pop(myautomata.states)
1409 |    put(myautomata.states, currstate)
1410 | 
1411 |    while currstate.label ~= 16 do {
1412 |       currstate := pop(myautomata.states)
1413 |       put(myautomata.states, currstate)
1414 |       }
1415 |    state2 := currstate
1416 | 
1417 |    tempedge := edge("t", [])
1418 |    currstate := pop(myautomata.states)
1419 |    put(myautomata.states, currstate)
1420 | 
1421 |    while currstate.label ~= 58 do {
1422 |       currstate := pop(myautomata.states)
1423 |       put(myautomata.states, currstate)
1424 |       }
1425 |    put(tempedge.destinations, currstate)
1426 | 
1427 |    put(state2.edges, tempedge)
1428 |    currstate := pop(myautomata.states)
1429 |    put(myautomata.states, currstate)
1430 | 
1431 |    while currstate.label ~= 17 do {
1432 |       currstate := pop(myautomata.states)
1433 |       put(myautomata.states, currstate)
1434 |       }
1435 |    state2 := currstate
1436 | 
1437 |    currstate := pop(myautomata.states)
1438 |    put(myautomata.states, currstate)
1439 | 
1440 |    while currstate.label ~= 18 do {
1441 |       currstate := pop(myautomata.states)
1442 |       put(myautomata.states, currstate)
1443 |       }
1444 |    state2 := currstate
1445 | 
1446 |    currstate := pop(myautomata.states)
1447 |    put(myautomata.states, currstate)
1448 | 
1449 |    while currstate.label ~= 19 do {
1450 |       currstate := pop(myautomata.states)
1451 |       put(myautomata.states, currstate)
1452 |       }
1453 |    state2 := currstate
1454 | 
1455 |    currstate := pop(myautomata.states)
1456 |    put(myautomata.states, currstate)
1457 | 
1458 |    while currstate.label ~= 20 do {
1459 |       currstate := pop(myautomata.states)
1460 |       put(myautomata.states, currstate)
1461 |       }
1462 |    state2 := currstate
1463 | 
1464 |    currstate := pop(myautomata.states)
1465 |    put(myautomata.states, currstate)
1466 | 
1467 |    while currstate.label ~= 21 do {
1468 |       currstate := pop(myautomata.states)
1469 |       put(myautomata.states, currstate)
1470 |       }
1471 |    state2 := currstate
1472 | 
1473 |    currstate := pop(myautomata.states)
1474 |    put(myautomata.states, currstate)
1475 | 
1476 |    while currstate.label ~= 22 do {
1477 |       currstate := pop(myautomata.states)
1478 |       put(myautomata.states, currstate)
1479 |       }
1480 |    state2 := currstate
1481 | 
1482 |    currstate := pop(myautomata.states)
1483 |    put(myautomata.states, currstate)
1484 | 
1485 |    while currstate.label ~= 23 do {
1486 |       currstate := pop(myautomata.states)
1487 |       put(myautomata.states, currstate)
1488 |       }
1489 |    state2 := currstate
1490 | 
1491 |    currstate := pop(myautomata.states)
1492 |    put(myautomata.states, currstate)
1493 | 
1494 |    while currstate.label ~= 24 do {
1495 |       currstate := pop(myautomata.states)
1496 |       put(myautomata.states, currstate)
1497 |       }
1498 |    state2 := currstate
1499 | 
1500 |    currstate := pop(myautomata.states)
1501 |    put(myautomata.states, currstate)
1502 | 
1503 |    while currstate.label ~= 25 do {
1504 |       currstate := pop(myautomata.states)
1505 |       put(myautomata.states, currstate)
1506 |       }
1507 |    state2 := currstate
1508 | 
1509 |    currstate := pop(myautomata.states)
1510 |    put(myautomata.states, currstate)
1511 | 
1512 |    while currstate.label ~= 26 do {
1513 |       currstate := pop(myautomata.states)
1514 |       put(myautomata.states, currstate)
1515 |       }
1516 |    state2 := currstate
1517 | 
1518 |    tempedge := edge("*", [])
1519 |    currstate := pop(myautomata.states)
1520 |    put(myautomata.states, currstate)
1521 | 
1522 |    while currstate.label ~= 59 do {
1523 |       currstate := pop(myautomata.states)
1524 |       put(myautomata.states, currstate)
1525 |       }
1526 |    put(tempedge.destinations, currstate)
1527 | 
1528 |    put(state2.edges, tempedge)
1529 |    tempedge := edge("/", [])
1530 |    currstate := pop(myautomata.states)
1531 |    put(myautomata.states, currstate)
1532 | 
1533 |    while currstate.label ~= 60 do {
1534 |       currstate := pop(myautomata.states)
1535 |       put(myautomata.states, currstate)
1536 |       }
1537 |    put(tempedge.destinations, currstate)
1538 | 
1539 |    put(state2.edges, tempedge)
1540 |    currstate := pop(myautomata.states)
1541 |    put(myautomata.states, currstate)
1542 | 
1543 |    while currstate.label ~= 27 do {
1544 |       currstate := pop(myautomata.states)
1545 |       put(myautomata.states, currstate)
1546 |       }
1547 |    state2 := currstate
1548 | 
1549 |    currstate := pop(myautomata.states)
1550 |    put(myautomata.states, currstate)
1551 | 
1552 |    while currstate.label ~= 28 do {
1553 |       currstate := pop(myautomata.states)
1554 |       put(myautomata.states, currstate)
1555 |       }
1556 |    state2 := currstate
1557 | 
1558 |    tempedge := edge("=", [])
1559 |    currstate := pop(myautomata.states)
1560 |    put(myautomata.states, currstate)
1561 | 
1562 |    while currstate.label ~= 61 do {
1563 |       currstate := pop(myautomata.states)
1564 |       put(myautomata.states, currstate)
1565 |       }
1566 |    put(tempedge.destinations, currstate)
1567 | 
1568 |    put(state2.edges, tempedge)
1569 |    currstate := pop(myautomata.states)
1570 |    put(myautomata.states, currstate)
1571 | 
1572 |    while currstate.label ~= 29 do {
1573 |       currstate := pop(myautomata.states)
1574 |       put(myautomata.states, currstate)
1575 |       }
1576 |    state2 := currstate
1577 | 
1578 |    tempedge := edge("=", [])
1579 |    currstate := pop(myautomata.states)
1580 |    put(myautomata.states, currstate)
1581 | 
1582 |    while currstate.label ~= 62 do {
1583 |       currstate := pop(myautomata.states)
1584 |       put(myautomata.states, currstate)
1585 |       }
1586 |    put(tempedge.destinations, currstate)
1587 | 
1588 |    put(state2.edges, tempedge)
1589 |    currstate := pop(myautomata.states)
1590 |    put(myautomata.states, currstate)
1591 | 
1592 |    while currstate.label ~= 30 do {
1593 |       currstate := pop(myautomata.states)
1594 |       put(myautomata.states, currstate)
1595 |       }
1596 |    state2 := currstate
1597 | 
1598 |    tempedge := edge("=", [])
1599 |    currstate := pop(myautomata.states)
1600 |    put(myautomata.states, currstate)
1601 | 
1602 |    while currstate.label ~= 63 do {
1603 |       currstate := pop(myautomata.states)
1604 |       put(myautomata.states, currstate)
1605 |       }
1606 |    put(tempedge.destinations, currstate)
1607 | 
1608 |    put(state2.edges, tempedge)
1609 |    currstate := pop(myautomata.states)
1610 |    put(myautomata.states, currstate)
1611 | 
1612 |    while currstate.label ~= 31 do {
1613 |       currstate := pop(myautomata.states)
1614 |       put(myautomata.states, currstate)
1615 |       }
1616 |    state2 := currstate
1617 | 
1618 |    tempedge := edge("&", [])
1619 |    currstate := pop(myautomata.states)
1620 |    put(myautomata.states, currstate)
1621 | 
1622 |    while currstate.label ~= 64 do {
1623 |       currstate := pop(myautomata.states)
1624 |       put(myautomata.states, currstate)
1625 |       }
1626 |    put(tempedge.destinations, currstate)
1627 | 
1628 |    put(state2.edges, tempedge)
1629 |    currstate := pop(myautomata.states)
1630 |    put(myautomata.states, currstate)
1631 | 
1632 |    while currstate.label ~= 32 do {
1633 |       currstate := pop(myautomata.states)
1634 |       put(myautomata.states, currstate)
1635 |       }
1636 |    state2 := currstate
1637 | 
1638 |    tempedge := edge("|", [])
1639 |    currstate := pop(myautomata.states)
1640 |    put(myautomata.states, currstate)
1641 | 
1642 |    while currstate.label ~= 65 do {
1643 |       currstate := pop(myautomata.states)
1644 |       put(myautomata.states, currstate)
1645 |       }
1646 |    put(tempedge.destinations, currstate)
1647 | 
1648 |    put(state2.edges, tempedge)
1649 |    currstate := pop(myautomata.states)
1650 |    put(myautomata.states, currstate)
1651 | 
1652 |    while currstate.label ~= 33 do {
1653 |       currstate := pop(myautomata.states)
1654 |       put(myautomata.states, currstate)
1655 |       }
1656 |    state2 := currstate
1657 | 
1658 |    tempedge := edge("=", [])
1659 |    currstate := pop(myautomata.states)
1660 |    put(myautomata.states, currstate)
1661 | 
1662 |    while currstate.label ~= 66 do {
1663 |       currstate := pop(myautomata.states)
1664 |       put(myautomata.states, currstate)
1665 |       }
1666 |    put(tempedge.destinations, currstate)
1667 | 
1668 |    put(state2.edges, tempedge)
1669 |    currstate := pop(myautomata.states)
1670 |    put(myautomata.states, currstate)
1671 | 
1672 |    while currstate.label ~= 34 do {
1673 |       currstate := pop(myautomata.states)
1674 |       put(myautomata.states, currstate)
1675 |       }
1676 |    state2 := currstate
1677 | 
1678 |    tempedge := edge("=", [])
1679 |    currstate := pop(myautomata.states)
1680 |    put(myautomata.states, currstate)
1681 | 
1682 |    while currstate.label ~= 67 do {
1683 |       currstate := pop(myautomata.states)
1684 |       put(myautomata.states, currstate)
1685 |       }
1686 |    put(tempedge.destinations, currstate)
1687 | 
1688 |    put(state2.edges, tempedge)
1689 |    currstate := pop(myautomata.states)
1690 |    put(myautomata.states, currstate)
1691 | 
1692 |    while currstate.label ~= 35 do {
1693 |       currstate := pop(myautomata.states)
1694 |       put(myautomata.states, currstate)
1695 |       }
1696 |    state2 := currstate
1697 | 
1698 |    tempedge := edge("=", [])
1699 |    currstate := pop(myautomata.states)
1700 |    put(myautomata.states, currstate)
1701 | 
1702 |    while currstate.label ~= 68 do {
1703 |       currstate := pop(myautomata.states)
1704 |       put(myautomata.states, currstate)
1705 |       }
1706 |    put(tempedge.destinations, currstate)
1707 | 
1708 |    put(state2.edges, tempedge)
1709 |    currstate := pop(myautomata.states)
1710 |    put(myautomata.states, currstate)
1711 | 
1712 |    while currstate.label ~= 36 do {
1713 |       currstate := pop(myautomata.states)
1714 |       put(myautomata.states, currstate)
1715 |       }
1716 |    state2 := currstate
1717 | 
1718 |    currstate := pop(myautomata.states)
1719 |    put(myautomata.states, currstate)
1720 | 
1721 |    while currstate.label ~= 37 do {
1722 |       currstate := pop(myautomata.states)
1723 |       put(myautomata.states, currstate)
1724 |       }
1725 |    state2 := currstate
1726 | 
1727 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
1728 |    currstate := pop(myautomata.states)
1729 |    put(myautomata.states, currstate)
1730 | 
1731 |    while currstate.label ~= 69 do {
1732 |       currstate := pop(myautomata.states)
1733 |       put(myautomata.states, currstate)
1734 |       }
1735 |    put(tempedge.destinations, currstate)
1736 | 
1737 |    put(state2.edges, tempedge)
1738 |    currstate := pop(myautomata.states)
1739 |    put(myautomata.states, currstate)
1740 | 
1741 |    while currstate.label ~= 38 do {
1742 |       currstate := pop(myautomata.states)
1743 |       put(myautomata.states, currstate)
1744 |       }
1745 |    state2 := currstate
1746 | 
1747 |    tempedge := edge(csetfromrecset("[eE]"), [])
1748 |    currstate := pop(myautomata.states)
1749 |    put(myautomata.states, currstate)
1750 | 
1751 |    while currstate.label ~= 70 do {
1752 |       currstate := pop(myautomata.states)
1753 |       put(myautomata.states, currstate)
1754 |       }
1755 |    put(tempedge.destinations, currstate)
1756 | 
1757 |    put(state2.edges, tempedge)
1758 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1759 |    currstate := pop(myautomata.states)
1760 |    put(myautomata.states, currstate)
1761 | 
1762 |    while currstate.label ~= 71 do {
1763 |       currstate := pop(myautomata.states)
1764 |       put(myautomata.states, currstate)
1765 |       }
1766 |    put(tempedge.destinations, currstate)
1767 | 
1768 |    put(state2.edges, tempedge)
1769 |    currstate := pop(myautomata.states)
1770 |    put(myautomata.states, currstate)
1771 | 
1772 |    while currstate.label ~= 39 do {
1773 |       currstate := pop(myautomata.states)
1774 |       put(myautomata.states, currstate)
1775 |       }
1776 |    state2 := currstate
1777 | 
1778 |    tempedge := edge(".", [])
1779 |    currstate := pop(myautomata.states)
1780 |    put(myautomata.states, currstate)
1781 | 
1782 |    while currstate.label ~= 72 do {
1783 |       currstate := pop(myautomata.states)
1784 |       put(myautomata.states, currstate)
1785 |       }
1786 |    put(tempedge.destinations, currstate)
1787 | 
1788 |    put(state2.edges, tempedge)
1789 |    tempedge := edge(csetfromrecset("[eE]"), [])
1790 |    currstate := pop(myautomata.states)
1791 |    put(myautomata.states, currstate)
1792 | 
1793 |    while currstate.label ~= 73 do {
1794 |       currstate := pop(myautomata.states)
1795 |       put(myautomata.states, currstate)
1796 |       }
1797 |    put(tempedge.destinations, currstate)
1798 | 
1799 |    put(state2.edges, tempedge)
1800 |    tempedge := edge(csetfromrecset("[0-9]"), [])
1801 |    currstate := pop(myautomata.states)
1802 |    put(myautomata.states, currstate)
1803 | 
1804 |    while currstate.label ~= 39 do {
1805 |       currstate := pop(myautomata.states)
1806 |       put(myautomata.states, currstate)
1807 |       }
1808 |    put(tempedge.destinations, currstate)
1809 | 
1810 |    put(state2.edges, tempedge)
1811 |    currstate := pop(myautomata.states)
1812 |    put(myautomata.states, currstate)
1813 | 
1814 |    while currstate.label ~= 40 do {
1815 |       currstate := pop(myautomata.states)
1816 |       put(myautomata.states, currstate)
1817 |       }
1818 |    state2 := currstate
1819 | 
1820 |    tempedge := edge(csetfromrecset("[^\"]"), [])
1821 |    currstate := pop(myautomata.states)
1822 |    put(myautomata.states, currstate)
1823 | 
1824 |    while currstate.label ~= 74 do {
1825 |       currstate := pop(myautomata.states)
1826 |       put(myautomata.states, currstate)
1827 |       }
1828 |    put(tempedge.destinations, currstate)
1829 | 
1830 |    put(state2.edges, tempedge)
1831 |    tempedge := edge("\\", [])
1832 |    currstate := pop(myautomata.states)
1833 |    put(myautomata.states, currstate)
1834 | 
1835 |    while currstate.label ~= 75 do {
1836 |       currstate := pop(myautomata.states)
1837 |       put(myautomata.states, currstate)
1838 |       }
1839 |    put(tempedge.destinations, currstate)
1840 | 
1841 |    put(state2.edges, tempedge)
1842 |    tempedge := edge("\"", [])
1843 |    currstate := pop(myautomata.states)
1844 |    put(myautomata.states, currstate)
1845 | 
1846 |    while currstate.label ~= 76 do {
1847 |       currstate := pop(myautomata.states)
1848 |       put(myautomata.states, currstate)
1849 |       }
1850 |    put(tempedge.destinations, currstate)
1851 | 
1852 |    put(state2.edges, tempedge)
1853 |    currstate := pop(myautomata.states)
1854 |    put(myautomata.states, currstate)
1855 | 
1856 |    while currstate.label ~= 41 do {
1857 |       currstate := pop(myautomata.states)
1858 |       put(myautomata.states, currstate)
1859 |       }
1860 |    state2 := currstate
1861 | 
1862 |    currstate := pop(myautomata.states)
1863 |    put(myautomata.states, currstate)
1864 | 
1865 |    while currstate.label ~= 42 do {
1866 |       currstate := pop(myautomata.states)
1867 |       put(myautomata.states, currstate)
1868 |       }
1869 |    state2 := currstate
1870 | 
1871 |    tempedge := edge("r", [])
1872 |    currstate := pop(myautomata.states)
1873 |    put(myautomata.states, currstate)
1874 | 
1875 |    while currstate.label ~= 77 do {
1876 |       currstate := pop(myautomata.states)
1877 |       put(myautomata.states, currstate)
1878 |       }
1879 |    put(tempedge.destinations, currstate)
1880 | 
1881 |    put(state2.edges, tempedge)
1882 |    currstate := pop(myautomata.states)
1883 |    put(myautomata.states, currstate)
1884 | 
1885 |    while currstate.label ~= 43 do {
1886 |       currstate := pop(myautomata.states)
1887 |       put(myautomata.states, currstate)
1888 |       }
1889 |    state2 := currstate
1890 | 
1891 |    tempedge := edge("l", [])
1892 |    currstate := pop(myautomata.states)
1893 |    put(myautomata.states, currstate)
1894 | 
1895 |    while currstate.label ~= 78 do {
1896 |       currstate := pop(myautomata.states)
1897 |       put(myautomata.states, currstate)
1898 |       }
1899 |    put(tempedge.destinations, currstate)
1900 | 
1901 |    put(state2.edges, tempedge)
1902 |    currstate := pop(myautomata.states)
1903 |    put(myautomata.states, currstate)
1904 | 
1905 |    while currstate.label ~= 44 do {
1906 |       currstate := pop(myautomata.states)
1907 |       put(myautomata.states, currstate)
1908 |       }
1909 |    state2 := currstate
1910 | 
1911 |    tempedge := edge("b", [])
1912 |    currstate := pop(myautomata.states)
1913 |    put(myautomata.states, currstate)
1914 | 
1915 |    while currstate.label ~= 79 do {
1916 |       currstate := pop(myautomata.states)
1917 |       put(myautomata.states, currstate)
1918 |       }
1919 |    put(tempedge.destinations, currstate)
1920 | 
1921 |    put(state2.edges, tempedge)
1922 |    currstate := pop(myautomata.states)
1923 |    put(myautomata.states, currstate)
1924 | 
1925 |    while currstate.label ~= 45 do {
1926 |       currstate := pop(myautomata.states)
1927 |       put(myautomata.states, currstate)
1928 |       }
1929 |    state2 := currstate
1930 | 
1931 |    tempedge := edge("u", [])
1932 |    currstate := pop(myautomata.states)
1933 |    put(myautomata.states, currstate)
1934 | 
1935 |    while currstate.label ~= 80 do {
1936 |       currstate := pop(myautomata.states)
1937 |       put(myautomata.states, currstate)
1938 |       }
1939 |    put(tempedge.destinations, currstate)
1940 | 
1941 |    put(state2.edges, tempedge)
1942 |    currstate := pop(myautomata.states)
1943 |    put(myautomata.states, currstate)
1944 | 
1945 |    while currstate.label ~= 46 do {
1946 |       currstate := pop(myautomata.states)
1947 |       put(myautomata.states, currstate)
1948 |       }
1949 |    state2 := currstate
1950 | 
1951 |    tempedge := edge("t", [])
1952 |    currstate := pop(myautomata.states)
1953 |    put(myautomata.states, currstate)
1954 | 
1955 |    while currstate.label ~= 81 do {
1956 |       currstate := pop(myautomata.states)
1957 |       put(myautomata.states, currstate)
1958 |       }
1959 |    put(tempedge.destinations, currstate)
1960 | 
1961 |    put(state2.edges, tempedge)
1962 |    currstate := pop(myautomata.states)
1963 |    put(myautomata.states, currstate)
1964 | 
1965 |    while currstate.label ~= 47 do {
1966 |       currstate := pop(myautomata.states)
1967 |       put(myautomata.states, currstate)
1968 |       }
1969 |    state2 := currstate
1970 | 
1971 |    tempedge := edge("e", [])
1972 |    currstate := pop(myautomata.states)
1973 |    put(myautomata.states, currstate)
1974 | 
1975 |    while currstate.label ~= 82 do {
1976 |       currstate := pop(myautomata.states)
1977 |       put(myautomata.states, currstate)
1978 |       }
1979 |    put(tempedge.destinations, currstate)
1980 | 
1981 |    put(state2.edges, tempedge)
1982 |    currstate := pop(myautomata.states)
1983 |    put(myautomata.states, currstate)
1984 | 
1985 |    while currstate.label ~= 48 do {
1986 |       currstate := pop(myautomata.states)
1987 |       put(myautomata.states, currstate)
1988 |       }
1989 |    state2 := currstate
1990 | 
1991 |    tempedge := edge("o", [])
1992 |    currstate := pop(myautomata.states)
1993 |    put(myautomata.states, currstate)
1994 | 
1995 |    while currstate.label ~= 83 do {
1996 |       currstate := pop(myautomata.states)
1997 |       put(myautomata.states, currstate)
1998 |       }
1999 |    put(tempedge.destinations, currstate)
2000 | 
2001 |    put(state2.edges, tempedge)
2002 |    currstate := pop(myautomata.states)
2003 |    put(myautomata.states, currstate)
2004 | 
2005 |    while currstate.label ~= 49 do {
2006 |       currstate := pop(myautomata.states)
2007 |       put(myautomata.states, currstate)
2008 |       }
2009 |    state2 := currstate
2010 | 
2011 |    tempedge := edge("l", [])
2012 |    currstate := pop(myautomata.states)
2013 |    put(myautomata.states, currstate)
2014 | 
2015 |    while currstate.label ~= 84 do {
2016 |       currstate := pop(myautomata.states)
2017 |       put(myautomata.states, currstate)
2018 |       }
2019 |    put(tempedge.destinations, currstate)
2020 | 
2021 |    put(state2.edges, tempedge)
2022 |    currstate := pop(myautomata.states)
2023 |    put(myautomata.states, currstate)
2024 | 
2025 |    while currstate.label ~= 50 do {
2026 |       currstate := pop(myautomata.states)
2027 |       put(myautomata.states, currstate)
2028 |       }
2029 |    state2 := currstate
2030 | 
2031 |    tempedge := edge("w", [])
2032 |    currstate := pop(myautomata.states)
2033 |    put(myautomata.states, currstate)
2034 | 
2035 |    while currstate.label ~= 85 do {
2036 |       currstate := pop(myautomata.states)
2037 |       put(myautomata.states, currstate)
2038 |       }
2039 |    put(tempedge.destinations, currstate)
2040 | 
2041 |    put(state2.edges, tempedge)
2042 |    currstate := pop(myautomata.states)
2043 |    put(myautomata.states, currstate)
2044 | 
2045 |    while currstate.label ~= 51 do {
2046 |       currstate := pop(myautomata.states)
2047 |       put(myautomata.states, currstate)
2048 |       }
2049 |    state2 := currstate
2050 | 
2051 |    tempedge := edge("i", [])
2052 |    currstate := pop(myautomata.states)
2053 |    put(myautomata.states, currstate)
2054 | 
2055 |    while currstate.label ~= 86 do {
2056 |       currstate := pop(myautomata.states)
2057 |       put(myautomata.states, currstate)
2058 |       }
2059 |    put(tempedge.destinations, currstate)
2060 | 
2061 |    put(state2.edges, tempedge)
2062 |    currstate := pop(myautomata.states)
2063 |    put(myautomata.states, currstate)
2064 | 
2065 |    while currstate.label ~= 52 do {
2066 |       currstate := pop(myautomata.states)
2067 |       put(myautomata.states, currstate)
2068 |       }
2069 |    state2 := currstate
2070 | 
2071 |    tempedge := edge("u", [])
2072 |    currstate := pop(myautomata.states)
2073 |    put(myautomata.states, currstate)
2074 | 
2075 |    while currstate.label ~= 87 do {
2076 |       currstate := pop(myautomata.states)
2077 |       put(myautomata.states, currstate)
2078 |       }
2079 |    put(tempedge.destinations, currstate)
2080 | 
2081 |    put(state2.edges, tempedge)
2082 |    currstate := pop(myautomata.states)
2083 |    put(myautomata.states, currstate)
2084 | 
2085 |    while currstate.label ~= 53 do {
2086 |       currstate := pop(myautomata.states)
2087 |       put(myautomata.states, currstate)
2088 |       }
2089 |    state2 := currstate
2090 | 
2091 |    tempedge := edge("i", [])
2092 |    currstate := pop(myautomata.states)
2093 |    put(myautomata.states, currstate)
2094 | 
2095 |    while currstate.label ~= 88 do {
2096 |       currstate := pop(myautomata.states)
2097 |       put(myautomata.states, currstate)
2098 |       }
2099 |    put(tempedge.destinations, currstate)
2100 | 
2101 |    put(state2.edges, tempedge)
2102 |    currstate := pop(myautomata.states)
2103 |    put(myautomata.states, currstate)
2104 | 
2105 |    while currstate.label ~= 54 do {
2106 |       currstate := pop(myautomata.states)
2107 |       put(myautomata.states, currstate)
2108 |       }
2109 |    state2 := currstate
2110 | 
2111 |    currstate := pop(myautomata.states)
2112 |    put(myautomata.states, currstate)
2113 | 
2114 |    while currstate.label ~= 55 do {
2115 |       currstate := pop(myautomata.states)
2116 |       put(myautomata.states, currstate)
2117 |       }
2118 |    state2 := currstate
2119 | 
2120 |    tempedge := edge("t", [])
2121 |    currstate := pop(myautomata.states)
2122 |    put(myautomata.states, currstate)
2123 | 
2124 |    while currstate.label ~= 89 do {
2125 |       currstate := pop(myautomata.states)
2126 |       put(myautomata.states, currstate)
2127 |       }
2128 |    put(tempedge.destinations, currstate)
2129 | 
2130 |    put(state2.edges, tempedge)
2131 |    currstate := pop(myautomata.states)
2132 |    put(myautomata.states, currstate)
2133 | 
2134 |    while currstate.label ~= 56 do {
2135 |       currstate := pop(myautomata.states)
2136 |       put(myautomata.states, currstate)
2137 |       }
2138 |    state2 := currstate
2139 | 
2140 |    tempedge := edge("s", [])
2141 |    currstate := pop(myautomata.states)
2142 |    put(myautomata.states, currstate)
2143 | 
2144 |    while currstate.label ~= 90 do {
2145 |       currstate := pop(myautomata.states)
2146 |       put(myautomata.states, currstate)
2147 |       }
2148 |    put(tempedge.destinations, currstate)
2149 | 
2150 |    put(state2.edges, tempedge)
2151 |    currstate := pop(myautomata.states)
2152 |    put(myautomata.states, currstate)
2153 | 
2154 |    while currstate.label ~= 57 do {
2155 |       currstate := pop(myautomata.states)
2156 |       put(myautomata.states, currstate)
2157 |       }
2158 |    state2 := currstate
2159 | 
2160 |    tempedge := edge("\a", [])
2161 |    currstate := pop(myautomata.states)
2162 |    put(myautomata.states, currstate)
2163 | 
2164 |    while currstate.label ~= 91 do {
2165 |       currstate := pop(myautomata.states)
2166 |       put(myautomata.states, currstate)
2167 |       }
2168 |    put(tempedge.destinations, currstate)
2169 | 
2170 |    put(state2.edges, tempedge)
2171 |    currstate := pop(myautomata.states)
2172 |    put(myautomata.states, currstate)
2173 | 
2174 |    while currstate.label ~= 58 do {
2175 |       currstate := pop(myautomata.states)
2176 |       put(myautomata.states, currstate)
2177 |       }
2178 |    state2 := currstate
2179 | 
2180 |    tempedge := edge("r", [])
2181 |    currstate := pop(myautomata.states)
2182 |    put(myautomata.states, currstate)
2183 | 
2184 |    while currstate.label ~= 92 do {
2185 |       currstate := pop(myautomata.states)
2186 |       put(myautomata.states, currstate)
2187 |       }
2188 |    put(tempedge.destinations, currstate)
2189 | 
2190 |    put(state2.edges, tempedge)
2191 |    tempedge := edge("\a", [])
2192 |    currstate := pop(myautomata.states)
2193 |    put(myautomata.states, currstate)
2194 | 
2195 |    while currstate.label ~= 93 do {
2196 |       currstate := pop(myautomata.states)
2197 |       put(myautomata.states, currstate)
2198 |       }
2199 |    put(tempedge.destinations, currstate)
2200 | 
2201 |    put(state2.edges, tempedge)
2202 |    currstate := pop(myautomata.states)
2203 |    put(myautomata.states, currstate)
2204 | 
2205 |    while currstate.label ~= 59 do {
2206 |       currstate := pop(myautomata.states)
2207 |       put(myautomata.states, currstate)
2208 |       }
2209 |    state2 := currstate
2210 | 
2211 |    tempedge := edge(csetfromrecset("[^*]"), [])
2212 |    currstate := pop(myautomata.states)
2213 |    put(myautomata.states, currstate)
2214 | 
2215 |    while currstate.label ~= 94 do {
2216 |       currstate := pop(myautomata.states)
2217 |       put(myautomata.states, currstate)
2218 |       }
2219 |    put(tempedge.destinations, currstate)
2220 | 
2221 |    put(state2.edges, tempedge)
2222 |    tempedge := edge("*", [])
2223 |    currstate := pop(myautomata.states)
2224 |    put(myautomata.states, currstate)
2225 | 
2226 |    while currstate.label ~= 95 do {
2227 |       currstate := pop(myautomata.states)
2228 |       put(myautomata.states, currstate)
2229 |       }
2230 |    put(tempedge.destinations, currstate)
2231 | 
2232 |    put(state2.edges, tempedge)
2233 |    currstate := pop(myautomata.states)
2234 |    put(myautomata.states, currstate)
2235 | 
2236 |    while currstate.label ~= 60 do {
2237 |       currstate := pop(myautomata.states)
2238 |       put(myautomata.states, currstate)
2239 |       }
2240 |    state2 := currstate
2241 | 
2242 |    tempedge := edge("\n"
2243 | , [])
2244 |    currstate := pop(myautomata.states)
2245 |    put(myautomata.states, currstate)
2246 | 
2247 |    while currstate.label ~= 96 do {
2248 |       currstate := pop(myautomata.states)
2249 |       put(myautomata.states, currstate)
2250 |       }
2251 |    put(tempedge.destinations, currstate)
2252 | 
2253 |    put(state2.edges, tempedge)
2254 |    tempedge := edge("r", [])
2255 |    currstate := pop(myautomata.states)
2256 |    put(myautomata.states, currstate)
2257 | 
2258 |    while currstate.label ~= 97 do {
2259 |       currstate := pop(myautomata.states)
2260 |       put(myautomata.states, currstate)
2261 |       }
2262 |    put(tempedge.destinations, currstate)
2263 | 
2264 |    put(state2.edges, tempedge)
2265 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2266 |    currstate := pop(myautomata.states)
2267 |    put(myautomata.states, currstate)
2268 | 
2269 |    while currstate.label ~= 98 do {
2270 |       currstate := pop(myautomata.states)
2271 |       put(myautomata.states, currstate)
2272 |       }
2273 |    put(tempedge.destinations, currstate)
2274 | 
2275 |    put(state2.edges, tempedge)
2276 |    currstate := pop(myautomata.states)
2277 |    put(myautomata.states, currstate)
2278 | 
2279 |    while currstate.label ~= 61 do {
2280 |       currstate := pop(myautomata.states)
2281 |       put(myautomata.states, currstate)
2282 |       }
2283 |    state2 := currstate
2284 | 
2285 |    currstate := pop(myautomata.states)
2286 |    put(myautomata.states, currstate)
2287 | 
2288 |    while currstate.label ~= 62 do {
2289 |       currstate := pop(myautomata.states)
2290 |       put(myautomata.states, currstate)
2291 |       }
2292 |    state2 := currstate
2293 | 
2294 |    currstate := pop(myautomata.states)
2295 |    put(myautomata.states, currstate)
2296 | 
2297 |    while currstate.label ~= 63 do {
2298 |       currstate := pop(myautomata.states)
2299 |       put(myautomata.states, currstate)
2300 |       }
2301 |    state2 := currstate
2302 | 
2303 |    currstate := pop(myautomata.states)
2304 |    put(myautomata.states, currstate)
2305 | 
2306 |    while currstate.label ~= 64 do {
2307 |       currstate := pop(myautomata.states)
2308 |       put(myautomata.states, currstate)
2309 |       }
2310 |    state2 := currstate
2311 | 
2312 |    currstate := pop(myautomata.states)
2313 |    put(myautomata.states, currstate)
2314 | 
2315 |    while currstate.label ~= 65 do {
2316 |       currstate := pop(myautomata.states)
2317 |       put(myautomata.states, currstate)
2318 |       }
2319 |    state2 := currstate
2320 | 
2321 |    currstate := pop(myautomata.states)
2322 |    put(myautomata.states, currstate)
2323 | 
2324 |    while currstate.label ~= 66 do {
2325 |       currstate := pop(myautomata.states)
2326 |       put(myautomata.states, currstate)
2327 |       }
2328 |    state2 := currstate
2329 | 
2330 |    currstate := pop(myautomata.states)
2331 |    put(myautomata.states, currstate)
2332 | 
2333 |    while currstate.label ~= 67 do {
2334 |       currstate := pop(myautomata.states)
2335 |       put(myautomata.states, currstate)
2336 |       }
2337 |    state2 := currstate
2338 | 
2339 |    currstate := pop(myautomata.states)
2340 |    put(myautomata.states, currstate)
2341 | 
2342 |    while currstate.label ~= 68 do {
2343 |       currstate := pop(myautomata.states)
2344 |       put(myautomata.states, currstate)
2345 |       }
2346 |    state2 := currstate
2347 | 
2348 |    currstate := pop(myautomata.states)
2349 |    put(myautomata.states, currstate)
2350 | 
2351 |    while currstate.label ~= 69 do {
2352 |       currstate := pop(myautomata.states)
2353 |       put(myautomata.states, currstate)
2354 |       }
2355 |    state2 := currstate
2356 | 
2357 |    tempedge := edge(csetfromrecset("[\a-zA-Z0-9_]"), [])
2358 |    currstate := pop(myautomata.states)
2359 |    put(myautomata.states, currstate)
2360 | 
2361 |    while currstate.label ~= 69 do {
2362 |       currstate := pop(myautomata.states)
2363 |       put(myautomata.states, currstate)
2364 |       }
2365 |    put(tempedge.destinations, currstate)
2366 | 
2367 |    put(state2.edges, tempedge)
2368 |    currstate := pop(myautomata.states)
2369 |    put(myautomata.states, currstate)
2370 | 
2371 |    while currstate.label ~= 70 do {
2372 |       currstate := pop(myautomata.states)
2373 |       put(myautomata.states, currstate)
2374 |       }
2375 |    state2 := currstate
2376 | 
2377 |    tempedge := edge(csetfromrecset("[+-]"), [])
2378 |    currstate := pop(myautomata.states)
2379 |    put(myautomata.states, currstate)
2380 | 
2381 |    while currstate.label ~= 99 do {
2382 |       currstate := pop(myautomata.states)
2383 |       put(myautomata.states, currstate)
2384 |       }
2385 |    put(tempedge.destinations, currstate)
2386 | 
2387 |    put(state2.edges, tempedge)
2388 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2389 |    currstate := pop(myautomata.states)
2390 |    put(myautomata.states, currstate)
2391 | 
2392 |    while currstate.label ~= 100 do {
2393 |       currstate := pop(myautomata.states)
2394 |       put(myautomata.states, currstate)
2395 |       }
2396 |    put(tempedge.destinations, currstate)
2397 | 
2398 |    put(state2.edges, tempedge)
2399 |    currstate := pop(myautomata.states)
2400 |    put(myautomata.states, currstate)
2401 | 
2402 |    while currstate.label ~= 71 do {
2403 |       currstate := pop(myautomata.states)
2404 |       put(myautomata.states, currstate)
2405 |       }
2406 |    state2 := currstate
2407 | 
2408 |    tempedge := edge(csetfromrecset("[eE]"), [])
2409 |    currstate := pop(myautomata.states)
2410 |    put(myautomata.states, currstate)
2411 | 
2412 |    while currstate.label ~= 70 do {
2413 |       currstate := pop(myautomata.states)
2414 |       put(myautomata.states, currstate)
2415 |       }
2416 |    put(tempedge.destinations, currstate)
2417 | 
2418 |    put(state2.edges, tempedge)
2419 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2420 |    currstate := pop(myautomata.states)
2421 |    put(myautomata.states, currstate)
2422 | 
2423 |    while currstate.label ~= 71 do {
2424 |       currstate := pop(myautomata.states)
2425 |       put(myautomata.states, currstate)
2426 |       }
2427 |    put(tempedge.destinations, currstate)
2428 | 
2429 |    put(state2.edges, tempedge)
2430 |    currstate := pop(myautomata.states)
2431 |    put(myautomata.states, currstate)
2432 | 
2433 |    while currstate.label ~= 72 do {
2434 |       currstate := pop(myautomata.states)
2435 |       put(myautomata.states, currstate)
2436 |       }
2437 |    state2 := currstate
2438 | 
2439 |    tempedge := edge(csetfromrecset("[eE]"), [])
2440 |    currstate := pop(myautomata.states)
2441 |    put(myautomata.states, currstate)
2442 | 
2443 |    while currstate.label ~= 70 do {
2444 |       currstate := pop(myautomata.states)
2445 |       put(myautomata.states, currstate)
2446 |       }
2447 |    put(tempedge.destinations, currstate)
2448 | 
2449 |    put(state2.edges, tempedge)
2450 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2451 |    currstate := pop(myautomata.states)
2452 |    put(myautomata.states, currstate)
2453 | 
2454 |    while currstate.label ~= 71 do {
2455 |       currstate := pop(myautomata.states)
2456 |       put(myautomata.states, currstate)
2457 |       }
2458 |    put(tempedge.destinations, currstate)
2459 | 
2460 |    put(state2.edges, tempedge)
2461 |    currstate := pop(myautomata.states)
2462 |    put(myautomata.states, currstate)
2463 | 
2464 |    while currstate.label ~= 73 do {
2465 |       currstate := pop(myautomata.states)
2466 |       put(myautomata.states, currstate)
2467 |       }
2468 |    state2 := currstate
2469 | 
2470 |    tempedge := edge(csetfromrecset("[+-]"), [])
2471 |    currstate := pop(myautomata.states)
2472 |    put(myautomata.states, currstate)
2473 | 
2474 |    while currstate.label ~= 101 do {
2475 |       currstate := pop(myautomata.states)
2476 |       put(myautomata.states, currstate)
2477 |       }
2478 |    put(tempedge.destinations, currstate)
2479 | 
2480 |    put(state2.edges, tempedge)
2481 |    tempedge := edge(csetfromrecset("[0-9]"), [])
2482 |    currstate := pop(myautomata.states)
2483 |    put(myautomata.states, currstate)
2484 | 
2485 |    while currstate.label ~= 102 do {
2486 |       currstate := pop(myautomata.states)
2487 |       put(myautomata.states, currstate)
2488 |       }
2489 |    put(tempedge.destinations, currstate)
2490 | 
2491 |    put(state2.edges, tempedge)
2492 |    currstate := pop(myautomata.states)
2493 |    put(myautomata.states, currstate)
2494 | 
2495 |    while currstate.label ~= 74 do {
2496 |       currstate := pop(myautomata.states)
2497 |       put(myautomata.states, currstate)
2498 |       }
2499 |    state2 := currstate
2500 | 
2501 |    tempedge := edge(csetfromrecset("[^\"]"), [])
2502 |    currstate := pop(myautomata.states)
2503 |    put(myautomata.states, currstate)
2504 | 
2505 |    while currstate.label ~= 74 do {
2506 |       currstate := pop(myautomata.states)
2507 |       put(myautomata.states, currstate)
2508 |       }
2509 |    put(tempedge.destinations, currstate)
2510 | 
2511 |    put(state2.edges, tempedge)
2512 |    tempedge := edge("\\", [])
2513 |    currstate := pop(myautomata.states)
2514 |    put(myautomata.states, currstate)
2515 | 
2516 |    while currstate.label ~= 75 do {
2517 |       currstate := pop(myautomata.states)
2518 |       put(myautomata.states, currstate)
2519 |       }
2520 |    put(tempedge.destinations, currstate)
2521 | 
2522 |    put(state2.edges, tempedge)
2523 |    tempedge := edge("\"", [])
2524 |    currstate := pop(myautomata.states)
2525 |    put(myautomata.states, currstate)
2526 | 
2527 |    while currstate.label ~= 76 do {
2528 |       currstate := pop(myautomata.states)
2529 |       put(myautomata.states, currstate)
2530 |       }
2531 |    put(tempedge.destinations, currstate)
2532 | 
2533 |    put(state2.edges, tempedge)
2534 |    currstate := pop(myautomata.states)
2535 |    put(myautomata.states, currstate)
2536 | 
2537 |    while currstate.label ~= 75 do {
2538 |       currstate := pop(myautomata.states)
2539 |       put(myautomata.states, currstate)
2540 |       }
2541 |    state2 := currstate
2542 | 
2543 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
2544 |    currstate := pop(myautomata.states)
2545 |    put(myautomata.states, currstate)
2546 | 
2547 |    while currstate.label ~= 103 do {
2548 |       currstate := pop(myautomata.states)
2549 |       put(myautomata.states, currstate)
2550 |       }
2551 |    put(tempedge.destinations, currstate)
2552 | 
2553 |    put(state2.edges, tempedge)
2554 |    currstate := pop(myautomata.states)
2555 |    put(myautomata.states, currstate)
2556 | 
2557 |    while currstate.label ~= 76 do {
2558 |       currstate := pop(myautomata.states)
2559 |       put(myautomata.states, currstate)
2560 |       }
2561 |    state2 := currstate
2562 | 
2563 |    currstate := pop(myautomata.states)
2564 |    put(myautomata.states, currstate)
2565 | 
2566 |    while currstate.label ~= 77 do {
2567 |       currstate := pop(myautomata.states)
2568 |       put(myautomata.states, currstate)
2569 |       }
2570 |    state2 := currstate
2571 | 
2572 |    currstate := pop(myautomata.states)
2573 |    put(myautomata.states, currstate)
2574 | 
2575 |    while currstate.label ~= 78 do {
2576 |       currstate := pop(myautomata.states)
2577 |       put(myautomata.states, currstate)
2578 |       }
2579 |    state2 := currstate
2580 | 
2581 |    tempedge := edge("s", [])
2582 |    currstate := pop(myautomata.states)
2583 |    put(myautomata.states, currstate)
2584 | 
2585 |    while currstate.label ~= 104 do {
2586 |       currstate := pop(myautomata.states)
2587 |       put(myautomata.states, currstate)
2588 |       }
2589 |    put(tempedge.destinations, currstate)
2590 | 
2591 |    put(state2.edges, tempedge)
2592 |    currstate := pop(myautomata.states)
2593 |    put(myautomata.states, currstate)
2594 | 
2595 |    while currstate.label ~= 79 do {
2596 |       currstate := pop(myautomata.states)
2597 |       put(myautomata.states, currstate)
2598 |       }
2599 |    state2 := currstate
2600 | 
2601 |    tempedge := edge("l", [])
2602 |    currstate := pop(myautomata.states)
2603 |    put(myautomata.states, currstate)
2604 | 
2605 |    while currstate.label ~= 105 do {
2606 |       currstate := pop(myautomata.states)
2607 |       put(myautomata.states, currstate)
2608 |       }
2609 |    put(tempedge.destinations, currstate)
2610 | 
2611 |    put(state2.edges, tempedge)
2612 |    currstate := pop(myautomata.states)
2613 |    put(myautomata.states, currstate)
2614 | 
2615 |    while currstate.label ~= 80 do {
2616 |       currstate := pop(myautomata.states)
2617 |       put(myautomata.states, currstate)
2618 |       }
2619 |    state2 := currstate
2620 | 
2621 |    tempedge := edge("e", [])
2622 |    currstate := pop(myautomata.states)
2623 |    put(myautomata.states, currstate)
2624 | 
2625 |    while currstate.label ~= 106 do {
2626 |       currstate := pop(myautomata.states)
2627 |       put(myautomata.states, currstate)
2628 |       }
2629 |    put(tempedge.destinations, currstate)
2630 | 
2631 |    put(state2.edges, tempedge)
2632 |    currstate := pop(myautomata.states)
2633 |    put(myautomata.states, currstate)
2634 | 
2635 |    while currstate.label ~= 81 do {
2636 |       currstate := pop(myautomata.states)
2637 |       put(myautomata.states, currstate)
2638 |       }
2639 |    state2 := currstate
2640 | 
2641 |    tempedge := edge("u", [])
2642 |    currstate := pop(myautomata.states)
2643 |    put(myautomata.states, currstate)
2644 | 
2645 |    while currstate.label ~= 107 do {
2646 |       currstate := pop(myautomata.states)
2647 |       put(myautomata.states, currstate)
2648 |       }
2649 |    put(tempedge.destinations, currstate)
2650 | 
2651 |    put(state2.edges, tempedge)
2652 |    currstate := pop(myautomata.states)
2653 |    put(myautomata.states, currstate)
2654 | 
2655 |    while currstate.label ~= 82 do {
2656 |       currstate := pop(myautomata.states)
2657 |       put(myautomata.states, currstate)
2658 |       }
2659 |    state2 := currstate
2660 | 
2661 |    tempedge := edge("\a", [])
2662 |    currstate := pop(myautomata.states)
2663 |    put(myautomata.states, currstate)
2664 | 
2665 |    while currstate.label ~= 108 do {
2666 |       currstate := pop(myautomata.states)
2667 |       put(myautomata.states, currstate)
2668 |       }
2669 |    put(tempedge.destinations, currstate)
2670 | 
2671 |    put(state2.edges, tempedge)
2672 |    currstate := pop(myautomata.states)
2673 |    put(myautomata.states, currstate)
2674 | 
2675 |    while currstate.label ~= 83 do {
2676 |       currstate := pop(myautomata.states)
2677 |       put(myautomata.states, currstate)
2678 |       }
2679 |    state2 := currstate
2680 | 
2681 |    tempedge := edge("l", [])
2682 |    currstate := pop(myautomata.states)
2683 |    put(myautomata.states, currstate)
2684 | 
2685 |    while currstate.label ~= 109 do {
2686 |       currstate := pop(myautomata.states)
2687 |       put(myautomata.states, currstate)
2688 |       }
2689 |    put(tempedge.destinations, currstate)
2690 | 
2691 |    put(state2.edges, tempedge)
2692 |    currstate := pop(myautomata.states)
2693 |    put(myautomata.states, currstate)
2694 | 
2695 |    while currstate.label ~= 84 do {
2696 |       currstate := pop(myautomata.states)
2697 |       put(myautomata.states, currstate)
2698 |       }
2699 |    state2 := currstate
2700 | 
2701 |    tempedge := edge("l", [])
2702 |    currstate := pop(myautomata.states)
2703 |    put(myautomata.states, currstate)
2704 | 
2705 |    while currstate.label ~= 110 do {
2706 |       currstate := pop(myautomata.states)
2707 |       put(myautomata.states, currstate)
2708 |       }
2709 |    put(tempedge.destinations, currstate)
2710 | 
2711 |    put(state2.edges, tempedge)
2712 |    currstate := pop(myautomata.states)
2713 |    put(myautomata.states, currstate)
2714 | 
2715 |    while currstate.label ~= 85 do {
2716 |       currstate := pop(myautomata.states)
2717 |       put(myautomata.states, currstate)
2718 |       }
2719 |    state2 := currstate
2720 | 
2721 |    currstate := pop(myautomata.states)
2722 |    put(myautomata.states, currstate)
2723 | 
2724 |    while currstate.label ~= 86 do {
2725 |       currstate := pop(myautomata.states)
2726 |       put(myautomata.states, currstate)
2727 |       }
2728 |    state2 := currstate
2729 | 
2730 |    tempedge := edge("d", [])
2731 |    currstate := pop(myautomata.states)
2732 |    put(myautomata.states, currstate)
2733 | 
2734 |    while currstate.label ~= 111 do {
2735 |       currstate := pop(myautomata.states)
2736 |       put(myautomata.states, currstate)
2737 |       }
2738 |    put(tempedge.destinations, currstate)
2739 | 
2740 |    put(state2.edges, tempedge)
2741 |    currstate := pop(myautomata.states)
2742 |    put(myautomata.states, currstate)
2743 | 
2744 |    while currstate.label ~= 87 do {
2745 |       currstate := pop(myautomata.states)
2746 |       put(myautomata.states, currstate)
2747 |       }
2748 |    state2 := currstate
2749 | 
2750 |    tempedge := edge("b", [])
2751 |    currstate := pop(myautomata.states)
2752 |    put(myautomata.states, currstate)
2753 | 
2754 |    while currstate.label ~= 112 do {
2755 |       currstate := pop(myautomata.states)
2756 |       put(myautomata.states, currstate)
2757 |       }
2758 |    put(tempedge.destinations, currstate)
2759 | 
2760 |    put(state2.edges, tempedge)
2761 |    currstate := pop(myautomata.states)
2762 |    put(myautomata.states, currstate)
2763 | 
2764 |    while currstate.label ~= 88 do {
2765 |       currstate := pop(myautomata.states)
2766 |       put(myautomata.states, currstate)
2767 |       }
2768 |    state2 := currstate
2769 | 
2770 |    tempedge := edge("l", [])
2771 |    currstate := pop(myautomata.states)
2772 |    put(myautomata.states, currstate)
2773 | 
2774 |    while currstate.label ~= 113 do {
2775 |       currstate := pop(myautomata.states)
2776 |       put(myautomata.states, currstate)
2777 |       }
2778 |    put(tempedge.destinations, currstate)
2779 | 
2780 |    put(state2.edges, tempedge)
2781 |    currstate := pop(myautomata.states)
2782 |    put(myautomata.states, currstate)
2783 | 
2784 |    while currstate.label ~= 89 do {
2785 |       currstate := pop(myautomata.states)
2786 |       put(myautomata.states, currstate)
2787 |       }
2788 |    state2 := currstate
2789 | 
2790 |    currstate := pop(myautomata.states)
2791 |    put(myautomata.states, currstate)
2792 | 
2793 |    while currstate.label ~= 90 do {
2794 |       currstate := pop(myautomata.states)
2795 |       put(myautomata.states, currstate)
2796 |       }
2797 |    state2 := currstate
2798 | 
2799 |    tempedge := edge("e", [])
2800 |    currstate := pop(myautomata.states)
2801 |    put(myautomata.states, currstate)
2802 | 
2803 |    while currstate.label ~= 114 do {
2804 |       currstate := pop(myautomata.states)
2805 |       put(myautomata.states, currstate)
2806 |       }
2807 |    put(tempedge.destinations, currstate)
2808 | 
2809 |    put(state2.edges, tempedge)
2810 |    currstate := pop(myautomata.states)
2811 |    put(myautomata.states, currstate)
2812 | 
2813 |    while currstate.label ~= 91 do {
2814 |       currstate := pop(myautomata.states)
2815 |       put(myautomata.states, currstate)
2816 |       }
2817 |    state2 := currstate
2818 | 
2819 |    tempedge := edge("s", [])
2820 |    currstate := pop(myautomata.states)
2821 |    put(myautomata.states, currstate)
2822 | 
2823 |    while currstate.label ~= 115 do {
2824 |       currstate := pop(myautomata.states)
2825 |       put(myautomata.states, currstate)
2826 |       }
2827 |    put(tempedge.destinations, currstate)
2828 | 
2829 |    put(state2.edges, tempedge)
2830 |    currstate := pop(myautomata.states)
2831 |    put(myautomata.states, currstate)
2832 | 
2833 |    while currstate.label ~= 92 do {
2834 |       currstate := pop(myautomata.states)
2835 |       put(myautomata.states, currstate)
2836 |       }
2837 |    state2 := currstate
2838 | 
2839 |    tempedge := edge("i", [])
2840 |    currstate := pop(myautomata.states)
2841 |    put(myautomata.states, currstate)
2842 | 
2843 |    while currstate.label ~= 116 do {
2844 |       currstate := pop(myautomata.states)
2845 |       put(myautomata.states, currstate)
2846 |       }
2847 |    put(tempedge.destinations, currstate)
2848 | 
2849 |    put(state2.edges, tempedge)
2850 |    currstate := pop(myautomata.states)
2851 |    put(myautomata.states, currstate)
2852 | 
2853 |    while currstate.label ~= 93 do {
2854 |       currstate := pop(myautomata.states)
2855 |       put(myautomata.states, currstate)
2856 |       }
2857 |    state2 := currstate
2858 | 
2859 |    tempedge := edge("t", [])
2860 |    currstate := pop(myautomata.states)
2861 |    put(myautomata.states, currstate)
2862 | 
2863 |    while currstate.label ~= 117 do {
2864 |       currstate := pop(myautomata.states)
2865 |       put(myautomata.states, currstate)
2866 |       }
2867 |    put(tempedge.destinations, currstate)
2868 | 
2869 |    put(state2.edges, tempedge)
2870 |    currstate := pop(myautomata.states)
2871 |    put(myautomata.states, currstate)
2872 | 
2873 |    while currstate.label ~= 94 do {
2874 |       currstate := pop(myautomata.states)
2875 |       put(myautomata.states, currstate)
2876 |       }
2877 |    state2 := currstate
2878 | 
2879 |    tempedge := edge(csetfromrecset("[^*]"), [])
2880 |    currstate := pop(myautomata.states)
2881 |    put(myautomata.states, currstate)
2882 | 
2883 |    while currstate.label ~= 94 do {
2884 |       currstate := pop(myautomata.states)
2885 |       put(myautomata.states, currstate)
2886 |       }
2887 |    put(tempedge.destinations, currstate)
2888 | 
2889 |    put(state2.edges, tempedge)
2890 |    tempedge := edge("*", [])
2891 |    currstate := pop(myautomata.states)
2892 |    put(myautomata.states, currstate)
2893 | 
2894 |    while currstate.label ~= 95 do {
2895 |       currstate := pop(myautomata.states)
2896 |       put(myautomata.states, currstate)
2897 |       }
2898 |    put(tempedge.destinations, currstate)
2899 | 
2900 |    put(state2.edges, tempedge)
2901 |    currstate := pop(myautomata.states)
2902 |    put(myautomata.states, currstate)
2903 | 
2904 |    while currstate.label ~= 95 do {
2905 |       currstate := pop(myautomata.states)
2906 |       put(myautomata.states, currstate)
2907 |       }
2908 |    state2 := currstate
2909 | 
2910 |    tempedge := edge(csetfromrecset("[^/*]"), [])
2911 |    currstate := pop(myautomata.states)
2912 |    put(myautomata.states, currstate)
2913 | 
2914 |    while currstate.label ~= 118 do {
2915 |       currstate := pop(myautomata.states)
2916 |       put(myautomata.states, currstate)
2917 |       }
2918 |    put(tempedge.destinations, currstate)
2919 | 
2920 |    put(state2.edges, tempedge)
2921 |    tempedge := edge("*", [])
2922 |    currstate := pop(myautomata.states)
2923 |    put(myautomata.states, currstate)
2924 | 
2925 |    while currstate.label ~= 95 do {
2926 |       currstate := pop(myautomata.states)
2927 |       put(myautomata.states, currstate)
2928 |       }
2929 |    put(tempedge.destinations, currstate)
2930 | 
2931 |    put(state2.edges, tempedge)
2932 |    tempedge := edge("/", [])
2933 |    currstate := pop(myautomata.states)
2934 |    put(myautomata.states, currstate)
2935 | 
2936 |    while currstate.label ~= 119 do {
2937 |       currstate := pop(myautomata.states)
2938 |       put(myautomata.states, currstate)
2939 |       }
2940 |    put(tempedge.destinations, currstate)
2941 | 
2942 |    put(state2.edges, tempedge)
2943 |    currstate := pop(myautomata.states)
2944 |    put(myautomata.states, currstate)
2945 | 
2946 |    while currstate.label ~= 96 do {
2947 |       currstate := pop(myautomata.states)
2948 |       put(myautomata.states, currstate)
2949 |       }
2950 |    state2 := currstate
2951 | 
2952 |    currstate := pop(myautomata.states)
2953 |    put(myautomata.states, currstate)
2954 | 
2955 |    while currstate.label ~= 97 do {
2956 |       currstate := pop(myautomata.states)
2957 |       put(myautomata.states, currstate)
2958 |       }
2959 |    state2 := currstate
2960 | 
2961 |    tempedge := edge("\n"
2962 | , [])
2963 |    currstate := pop(myautomata.states)
2964 |    put(myautomata.states, currstate)
2965 | 
2966 |    while currstate.label ~= 96 do {
2967 |       currstate := pop(myautomata.states)
2968 |       put(myautomata.states, currstate)
2969 |       }
2970 |    put(tempedge.destinations, currstate)
2971 | 
2972 |    put(state2.edges, tempedge)
2973 |    currstate := pop(myautomata.states)
2974 |    put(myautomata.states, currstate)
2975 | 
2976 |    while currstate.label ~= 98 do {
2977 |       currstate := pop(myautomata.states)
2978 |       put(myautomata.states, currstate)
2979 |       }
2980 |    state2 := currstate
2981 | 
2982 |    tempedge := edge("\n"
2983 | , [])
2984 |    currstate := pop(myautomata.states)
2985 |    put(myautomata.states, currstate)
2986 | 
2987 |    while currstate.label ~= 96 do {
2988 |       currstate := pop(myautomata.states)
2989 |       put(myautomata.states, currstate)
2990 |       }
2991 |    put(tempedge.destinations, currstate)
2992 | 
2993 |    put(state2.edges, tempedge)
2994 |    tempedge := edge("r", [])
2995 |    currstate := pop(myautomata.states)
2996 |    put(myautomata.states, currstate)
2997 | 
2998 |    while currstate.label ~= 97 do {
2999 |       currstate := pop(myautomata.states)
3000 |       put(myautomata.states, currstate)
3001 |       }
3002 |    put(tempedge.destinations, currstate)
3003 | 
3004 |    put(state2.edges, tempedge)
3005 |    tempedge := edge(csetfromrecset("[^\\n]"), [])
3006 |    currstate := pop(myautomata.states)
3007 |    put(myautomata.states, currstate)
3008 | 
3009 |    while currstate.label ~= 98 do {
3010 |       currstate := pop(myautomata.states)
3011 |       put(myautomata.states, currstate)
3012 |       }
3013 |    put(tempedge.destinations, currstate)
3014 | 
3015 |    put(state2.edges, tempedge)
3016 |    currstate := pop(myautomata.states)
3017 |    put(myautomata.states, currstate)
3018 | 
3019 |    while currstate.label ~= 99 do {
3020 |       currstate := pop(myautomata.states)
3021 |       put(myautomata.states, currstate)
3022 |       }
3023 |    state2 := currstate
3024 | 
3025 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3026 |    currstate := pop(myautomata.states)
3027 |    put(myautomata.states, currstate)
3028 | 
3029 |    while currstate.label ~= 100 do {
3030 |       currstate := pop(myautomata.states)
3031 |       put(myautomata.states, currstate)
3032 |       }
3033 |    put(tempedge.destinations, currstate)
3034 | 
3035 |    put(state2.edges, tempedge)
3036 |    currstate := pop(myautomata.states)
3037 |    put(myautomata.states, currstate)
3038 | 
3039 |    while currstate.label ~= 100 do {
3040 |       currstate := pop(myautomata.states)
3041 |       put(myautomata.states, currstate)
3042 |       }
3043 |    state2 := currstate
3044 | 
3045 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3046 |    currstate := pop(myautomata.states)
3047 |    put(myautomata.states, currstate)
3048 | 
3049 |    while currstate.label ~= 100 do {
3050 |       currstate := pop(myautomata.states)
3051 |       put(myautomata.states, currstate)
3052 |       }
3053 |    put(tempedge.destinations, currstate)
3054 | 
3055 |    put(state2.edges, tempedge)
3056 |    currstate := pop(myautomata.states)
3057 |    put(myautomata.states, currstate)
3058 | 
3059 |    while currstate.label ~= 101 do {
3060 |       currstate := pop(myautomata.states)
3061 |       put(myautomata.states, currstate)
3062 |       }
3063 |    state2 := currstate
3064 | 
3065 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3066 |    currstate := pop(myautomata.states)
3067 |    put(myautomata.states, currstate)
3068 | 
3069 |    while currstate.label ~= 102 do {
3070 |       currstate := pop(myautomata.states)
3071 |       put(myautomata.states, currstate)
3072 |       }
3073 |    put(tempedge.destinations, currstate)
3074 | 
3075 |    put(state2.edges, tempedge)
3076 |    currstate := pop(myautomata.states)
3077 |    put(myautomata.states, currstate)
3078 | 
3079 |    while currstate.label ~= 102 do {
3080 |       currstate := pop(myautomata.states)
3081 |       put(myautomata.states, currstate)
3082 |       }
3083 |    state2 := currstate
3084 | 
3085 |    tempedge := edge(csetfromrecset("[0-9]"), [])
3086 |    currstate := pop(myautomata.states)
3087 |    put(myautomata.states, currstate)
3088 | 
3089 |    while currstate.label ~= 102 do {
3090 |       currstate := pop(myautomata.states)
3091 |       put(myautomata.states, currstate)
3092 |       }
3093 |    put(tempedge.destinations, currstate)
3094 | 
3095 |    put(state2.edges, tempedge)
3096 |    currstate := pop(myautomata.states)
3097 |    put(myautomata.states, currstate)
3098 | 
3099 |    while currstate.label ~= 103 do {
3100 |       currstate := pop(myautomata.states)
3101 |       put(myautomata.states, currstate)
3102 |       }
3103 |    state2 := currstate
3104 | 
3105 |    tempedge := edge(csetfromrecset("[^\"]"), [])
3106 |    currstate := pop(myautomata.states)
3107 |    put(myautomata.states, currstate)
3108 | 
3109 |    while currstate.label ~= 74 do {
3110 |       currstate := pop(myautomata.states)
3111 |       put(myautomata.states, currstate)
3112 |       }
3113 |    put(tempedge.destinations, currstate)
3114 | 
3115 |    put(state2.edges, tempedge)
3116 |    tempedge := edge("\\", [])
3117 |    currstate := pop(myautomata.states)
3118 |    put(myautomata.states, currstate)
3119 | 
3120 |    while currstate.label ~= 75 do {
3121 |       currstate := pop(myautomata.states)
3122 |       put(myautomata.states, currstate)
3123 |       }
3124 |    put(tempedge.destinations, currstate)
3125 | 
3126 |    put(state2.edges, tempedge)
3127 |    tempedge := edge("\"", [])
3128 |    currstate := pop(myautomata.states)
3129 |    put(myautomata.states, currstate)
3130 | 
3131 |    while currstate.label ~= 76 do {
3132 |       currstate := pop(myautomata.states)
3133 |       put(myautomata.states, currstate)
3134 |       }
3135 |    put(tempedge.destinations, currstate)
3136 | 
3137 |    put(state2.edges, tempedge)
3138 |    currstate := pop(myautomata.states)
3139 |    put(myautomata.states, currstate)
3140 | 
3141 |    while currstate.label ~= 104 do {
3142 |       currstate := pop(myautomata.states)
3143 |       put(myautomata.states, currstate)
3144 |       }
3145 |    state2 := currstate
3146 | 
3147 |    tempedge := edge("e", [])
3148 |    currstate := pop(myautomata.states)
3149 |    put(myautomata.states, currstate)
3150 | 
3151 |    while currstate.label ~= 120 do {
3152 |       currstate := pop(myautomata.states)
3153 |       put(myautomata.states, currstate)
3154 |       }
3155 |    put(tempedge.destinations, currstate)
3156 | 
3157 |    put(state2.edges, tempedge)
3158 |    currstate := pop(myautomata.states)
3159 |    put(myautomata.states, currstate)
3160 | 
3161 |    while currstate.label ~= 105 do {
3162 |       currstate := pop(myautomata.states)
3163 |       put(myautomata.states, currstate)
3164 |       }
3165 |    state2 := currstate
3166 | 
3167 |    tempedge := edge("i", [])
3168 |    currstate := pop(myautomata.states)
3169 |    put(myautomata.states, currstate)
3170 | 
3171 |    while currstate.label ~= 121 do {
3172 |       currstate := pop(myautomata.states)
3173 |       put(myautomata.states, currstate)
3174 |       }
3175 |    put(tempedge.destinations, currstate)
3176 | 
3177 |    put(state2.edges, tempedge)
3178 |    currstate := pop(myautomata.states)
3179 |    put(myautomata.states, currstate)
3180 | 
3181 |    while currstate.label ~= 106 do {
3182 |       currstate := pop(myautomata.states)
3183 |       put(myautomata.states, currstate)
3184 |       }
3185 |    state2 := currstate
3186 | 
3187 |    currstate := pop(myautomata.states)
3188 |    put(myautomata.states, currstate)
3189 | 
3190 |    while currstate.label ~= 107 do {
3191 |       currstate := pop(myautomata.states)
3192 |       put(myautomata.states, currstate)
3193 |       }
3194 |    state2 := currstate
3195 | 
3196 |    tempedge := edge("r", [])
3197 |    currstate := pop(myautomata.states)
3198 |    put(myautomata.states, currstate)
3199 | 
3200 |    while currstate.label ~= 122 do {
3201 |       currstate := pop(myautomata.states)
3202 |       put(myautomata.states, currstate)
3203 |       }
3204 |    put(tempedge.destinations, currstate)
3205 | 
3206 |    put(state2.edges, tempedge)
3207 |    currstate := pop(myautomata.states)
3208 |    put(myautomata.states, currstate)
3209 | 
3210 |    while currstate.label ~= 108 do {
3211 |       currstate := pop(myautomata.states)
3212 |       put(myautomata.states, currstate)
3213 |       }
3214 |    state2 := currstate
3215 | 
3216 |    tempedge := edge("k", [])
3217 |    currstate := pop(myautomata.states)
3218 |    put(myautomata.states, currstate)
3219 | 
3220 |    while currstate.label ~= 123 do {
3221 |       currstate := pop(myautomata.states)
3222 |       put(myautomata.states, currstate)
3223 |       }
3224 |    put(tempedge.destinations, currstate)
3225 | 
3226 |    put(state2.edges, tempedge)
3227 |    currstate := pop(myautomata.states)
3228 |    put(myautomata.states, currstate)
3229 | 
3230 |    while currstate.label ~= 109 do {
3231 |       currstate := pop(myautomata.states)
3232 |       put(myautomata.states, currstate)
3233 |       }
3234 |    state2 := currstate
3235 | 
3236 |    tempedge := edge("e", [])
3237 |    currstate := pop(myautomata.states)
3238 |    put(myautomata.states, currstate)
3239 | 
3240 |    while currstate.label ~= 124 do {
3241 |       currstate := pop(myautomata.states)
3242 |       put(myautomata.states, currstate)
3243 |       }
3244 |    put(tempedge.destinations, currstate)
3245 | 
3246 |    put(state2.edges, tempedge)
3247 |    currstate := pop(myautomata.states)
3248 |    put(myautomata.states, currstate)
3249 | 
3250 |    while currstate.label ~= 110 do {
3251 |       currstate := pop(myautomata.states)
3252 |       put(myautomata.states, currstate)
3253 |       }
3254 |    state2 := currstate
3255 | 
3256 |    currstate := pop(myautomata.states)
3257 |    put(myautomata.states, currstate)
3258 | 
3259 |    while currstate.label ~= 111 do {
3260 |       currstate := pop(myautomata.states)
3261 |       put(myautomata.states, currstate)
3262 |       }
3263 |    state2 := currstate
3264 | 
3265 |    currstate := pop(myautomata.states)
3266 |    put(myautomata.states, currstate)
3267 | 
3268 |    while currstate.label ~= 112 do {
3269 |       currstate := pop(myautomata.states)
3270 |       put(myautomata.states, currstate)
3271 |       }
3272 |    state2 := currstate
3273 | 
3274 |    tempedge := edge("l", [])
3275 |    currstate := pop(myautomata.states)
3276 |    put(myautomata.states, currstate)
3277 | 
3278 |    while currstate.label ~= 125 do {
3279 |       currstate := pop(myautomata.states)
3280 |       put(myautomata.states, currstate)
3281 |       }
3282 |    put(tempedge.destinations, currstate)
3283 | 
3284 |    put(state2.edges, tempedge)
3285 |    currstate := pop(myautomata.states)
3286 |    put(myautomata.states, currstate)
3287 | 
3288 |    while currstate.label ~= 113 do {
3289 |       currstate := pop(myautomata.states)
3290 |       put(myautomata.states, currstate)
3291 |       }
3292 |    state2 := currstate
3293 | 
3294 |    tempedge := edge("e", [])
3295 |    currstate := pop(myautomata.states)
3296 |    put(myautomata.states, currstate)
3297 | 
3298 |    while currstate.label ~= 126 do {
3299 |       currstate := pop(myautomata.states)
3300 |       put(myautomata.states, currstate)
3301 |       }
3302 |    put(tempedge.destinations, currstate)
3303 | 
3304 |    put(state2.edges, tempedge)
3305 |    currstate := pop(myautomata.states)
3306 |    put(myautomata.states, currstate)
3307 | 
3308 |    while currstate.label ~= 114 do {
3309 |       currstate := pop(myautomata.states)
3310 |       put(myautomata.states, currstate)
3311 |       }
3312 |    state2 := currstate
3313 | 
3314 |    currstate := pop(myautomata.states)
3315 |    put(myautomata.states, currstate)
3316 | 
3317 |    while currstate.label ~= 115 do {
3318 |       currstate := pop(myautomata.states)
3319 |       put(myautomata.states, currstate)
3320 |       }
3321 |    state2 := currstate
3322 | 
3323 |    tempedge := edge("s", [])
3324 |    currstate := pop(myautomata.states)
3325 |    put(myautomata.states, currstate)
3326 | 
3327 |    while currstate.label ~= 127 do {
3328 |       currstate := pop(myautomata.states)
3329 |       put(myautomata.states, currstate)
3330 |       }
3331 |    put(tempedge.destinations, currstate)
3332 | 
3333 |    put(state2.edges, tempedge)
3334 |    currstate := pop(myautomata.states)
3335 |    put(myautomata.states, currstate)
3336 | 
3337 |    while currstate.label ~= 116 do {
3338 |       currstate := pop(myautomata.states)
3339 |       put(myautomata.states, currstate)
3340 |       }
3341 |    state2 := currstate
3342 | 
3343 |    tempedge := edge("n", [])
3344 |    currstate := pop(myautomata.states)
3345 |    put(myautomata.states, currstate)
3346 | 
3347 |    while currstate.label ~= 128 do {
3348 |       currstate := pop(myautomata.states)
3349 |       put(myautomata.states, currstate)
3350 |       }
3351 |    put(tempedge.destinations, currstate)
3352 | 
3353 |    put(state2.edges, tempedge)
3354 |    currstate := pop(myautomata.states)
3355 |    put(myautomata.states, currstate)
3356 | 
3357 |    while currstate.label ~= 117 do {
3358 |       currstate := pop(myautomata.states)
3359 |       put(myautomata.states, currstate)
3360 |       }
3361 |    state2 := currstate
3362 | 
3363 |    tempedge := edge("i", [])
3364 |    currstate := pop(myautomata.states)
3365 |    put(myautomata.states, currstate)
3366 | 
3367 |    while currstate.label ~= 129 do {
3368 |       currstate := pop(myautomata.states)
3369 |       put(myautomata.states, currstate)
3370 |       }
3371 |    put(tempedge.destinations, currstate)
3372 | 
3373 |    put(state2.edges, tempedge)
3374 |    currstate := pop(myautomata.states)
3375 |    put(myautomata.states, currstate)
3376 | 
3377 |    while currstate.label ~= 118 do {
3378 |       currstate := pop(myautomata.states)
3379 |       put(myautomata.states, currstate)
3380 |       }
3381 |    state2 := currstate
3382 | 
3383 |    tempedge := edge(csetfromrecset("[^*]"), [])
3384 |    currstate := pop(myautomata.states)
3385 |    put(myautomata.states, currstate)
3386 | 
3387 |    while currstate.label ~= 94 do {
3388 |       currstate := pop(myautomata.states)
3389 |       put(myautomata.states, currstate)
3390 |       }
3391 |    put(tempedge.destinations, currstate)
3392 | 
3393 |    put(state2.edges, tempedge)
3394 |    tempedge := edge("*", [])
3395 |    currstate := pop(myautomata.states)
3396 |    put(myautomata.states, currstate)
3397 | 
3398 |    while currstate.label ~= 95 do {
3399 |       currstate := pop(myautomata.states)
3400 |       put(myautomata.states, currstate)
3401 |       }
3402 |    put(tempedge.destinations, currstate)
3403 | 
3404 |    put(state2.edges, tempedge)
3405 |    currstate := pop(myautomata.states)
3406 |    put(myautomata.states, currstate)
3407 | 
3408 |    while currstate.label ~= 119 do {
3409 |       currstate := pop(myautomata.states)
3410 |       put(myautomata.states, currstate)
3411 |       }
3412 |    state2 := currstate
3413 | 
3414 |    currstate := pop(myautomata.states)
3415 |    put(myautomata.states, currstate)
3416 | 
3417 |    while currstate.label ~= 120 do {
3418 |       currstate := pop(myautomata.states)
3419 |       put(myautomata.states, currstate)
3420 |       }
3421 |    state2 := currstate
3422 | 
3423 |    currstate := pop(myautomata.states)
3424 |    put(myautomata.states, currstate)
3425 | 
3426 |    while currstate.label ~= 121 do {
3427 |       currstate := pop(myautomata.states)
3428 |       put(myautomata.states, currstate)
3429 |       }
3430 |    state2 := currstate
3431 | 
3432 |    tempedge := edge("c", [])
3433 |    currstate := pop(myautomata.states)
3434 |    put(myautomata.states, currstate)
3435 | 
3436 |    while currstate.label ~= 130 do {
3437 |       currstate := pop(myautomata.states)
3438 |       put(myautomata.states, currstate)
3439 |       }
3440 |    put(tempedge.destinations, currstate)
3441 | 
3442 |    put(state2.edges, tempedge)
3443 |    currstate := pop(myautomata.states)
3444 |    put(myautomata.states, currstate)
3445 | 
3446 |    while currstate.label ~= 122 do {
3447 |       currstate := pop(myautomata.states)
3448 |       put(myautomata.states, currstate)
3449 |       }
3450 |    state2 := currstate
3451 | 
3452 |    tempedge := edge("n", [])
3453 |    currstate := pop(myautomata.states)
3454 |    put(myautomata.states, currstate)
3455 | 
3456 |    while currstate.label ~= 131 do {
3457 |       currstate := pop(myautomata.states)
3458 |       put(myautomata.states, currstate)
3459 |       }
3460 |    put(tempedge.destinations, currstate)
3461 | 
3462 |    put(state2.edges, tempedge)
3463 |    currstate := pop(myautomata.states)
3464 |    put(myautomata.states, currstate)
3465 | 
3466 |    while currstate.label ~= 123 do {
3467 |       currstate := pop(myautomata.states)
3468 |       put(myautomata.states, currstate)
3469 |       }
3470 |    state2 := currstate
3471 | 
3472 |    currstate := pop(myautomata.states)
3473 |    put(myautomata.states, currstate)
3474 | 
3475 |    while currstate.label ~= 124 do {
3476 |       currstate := pop(myautomata.states)
3477 |       put(myautomata.states, currstate)
3478 |       }
3479 |    state2 := currstate
3480 | 
3481 |    tempedge := edge("\a", [])
3482 |    currstate := pop(myautomata.states)
3483 |    put(myautomata.states, currstate)
3484 | 
3485 |    while currstate.label ~= 132 do {
3486 |       currstate := pop(myautomata.states)
3487 |       put(myautomata.states, currstate)
3488 |       }
3489 |    put(tempedge.destinations, currstate)
3490 | 
3491 |    put(state2.edges, tempedge)
3492 |    currstate := pop(myautomata.states)
3493 |    put(myautomata.states, currstate)
3494 | 
3495 |    while currstate.label ~= 125 do {
3496 |       currstate := pop(myautomata.states)
3497 |       put(myautomata.states, currstate)
3498 |       }
3499 |    state2 := currstate
3500 | 
3501 |    tempedge := edge("e", [])
3502 |    currstate := pop(myautomata.states)
3503 |    put(myautomata.states, currstate)
3504 | 
3505 |    while currstate.label ~= 133 do {
3506 |       currstate := pop(myautomata.states)
3507 |       put(myautomata.states, currstate)
3508 |       }
3509 |    put(tempedge.destinations, currstate)
3510 | 
3511 |    put(state2.edges, tempedge)
3512 |    currstate := pop(myautomata.states)
3513 |    put(myautomata.states, currstate)
3514 | 
3515 |    while currstate.label ~= 126 do {
3516 |       currstate := pop(myautomata.states)
3517 |       put(myautomata.states, currstate)
3518 |       }
3519 |    state2 := currstate
3520 | 
3521 |    currstate := pop(myautomata.states)
3522 |    put(myautomata.states, currstate)
3523 | 
3524 |    while currstate.label ~= 127 do {
3525 |       currstate := pop(myautomata.states)
3526 |       put(myautomata.states, currstate)
3527 |       }
3528 |    state2 := currstate
3529 | 
3530 |    currstate := pop(myautomata.states)
3531 |    put(myautomata.states, currstate)
3532 | 
3533 |    while currstate.label ~= 128 do {
3534 |       currstate := pop(myautomata.states)
3535 |       put(myautomata.states, currstate)
3536 |       }
3537 |    state2 := currstate
3538 | 
3539 |    tempedge := edge("g", [])
3540 |    currstate := pop(myautomata.states)
3541 |    put(myautomata.states, currstate)
3542 | 
3543 |    while currstate.label ~= 134 do {
3544 |       currstate := pop(myautomata.states)
3545 |       put(myautomata.states, currstate)
3546 |       }
3547 |    put(tempedge.destinations, currstate)
3548 | 
3549 |    put(state2.edges, tempedge)
3550 |    currstate := pop(myautomata.states)
3551 |    put(myautomata.states, currstate)
3552 | 
3553 |    while currstate.label ~= 129 do {
3554 |       currstate := pop(myautomata.states)
3555 |       put(myautomata.states, currstate)
3556 |       }
3557 |    state2 := currstate
3558 | 
3559 |    tempedge := edge("c", [])
3560 |    currstate := pop(myautomata.states)
3561 |    put(myautomata.states, currstate)
3562 | 
3563 |    while currstate.label ~= 135 do {
3564 |       currstate := pop(myautomata.states)
3565 |       put(myautomata.states, currstate)
3566 |       }
3567 |    put(tempedge.destinations, currstate)
3568 | 
3569 |    put(state2.edges, tempedge)
3570 |    currstate := pop(myautomata.states)
3571 |    put(myautomata.states, currstate)
3572 | 
3573 |    while currstate.label ~= 130 do {
3574 |       currstate := pop(myautomata.states)
3575 |       put(myautomata.states, currstate)
3576 |       }
3577 |    state2 := currstate
3578 | 
3579 |    currstate := pop(myautomata.states)
3580 |    put(myautomata.states, currstate)
3581 | 
3582 |    while currstate.label ~= 131 do {
3583 |       currstate := pop(myautomata.states)
3584 |       put(myautomata.states, currstate)
3585 |       }
3586 |    state2 := currstate
3587 | 
3588 |    currstate := pop(myautomata.states)
3589 |    put(myautomata.states, currstate)
3590 | 
3591 |    while currstate.label ~= 132 do {
3592 |       currstate := pop(myautomata.states)
3593 |       put(myautomata.states, currstate)
3594 |       }
3595 |    state2 := currstate
3596 | 
3597 |    tempedge := edge("n", [])
3598 |    currstate := pop(myautomata.states)
3599 |    put(myautomata.states, currstate)
3600 | 
3601 |    while currstate.label ~= 136 do {
3602 |       currstate := pop(myautomata.states)
3603 |       put(myautomata.states, currstate)
3604 |       }
3605 |    put(tempedge.destinations, currstate)
3606 | 
3607 |    put(state2.edges, tempedge)
3608 |    currstate := pop(myautomata.states)
3609 |    put(myautomata.states, currstate)
3610 | 
3611 |    while currstate.label ~= 133 do {
3612 |       currstate := pop(myautomata.states)
3613 |       put(myautomata.states, currstate)
3614 |       }
3615 |    state2 := currstate
3616 | 
3617 |    currstate := pop(myautomata.states)
3618 |    put(myautomata.states, currstate)
3619 | 
3620 |    while currstate.label ~= 134 do {
3621 |       currstate := pop(myautomata.states)
3622 |       put(myautomata.states, currstate)
3623 |       }
3624 |    state2 := currstate
3625 | 
3626 |    currstate := pop(myautomata.states)
3627 |    put(myautomata.states, currstate)
3628 | 
3629 |    while currstate.label ~= 135 do {
3630 |       currstate := pop(myautomata.states)
3631 |       put(myautomata.states, currstate)
3632 |       }
3633 |    state2 := currstate
3634 | 
3635 |    currstate := pop(myautomata.states)
3636 |    put(myautomata.states, currstate)
3637 | 
3638 |    while currstate.label ~= 136 do {
3639 |       currstate := pop(myautomata.states)
3640 |       put(myautomata.states, currstate)
3641 |       }
3642 |    state2 := currstate
3643 | 
3644 |    init_semantic_actions()
3645 |    }
3646 | 
3647 |    return yyulex(myautomata)
3648 | 
3649 | end
3650 | 
3651 | procedure init_semantic_actions()
3652 | 
3653 |    semantic_action := table()
3654 |    semantic_action[1] := semantic_action_1
3655 |    semantic_action[2] := semantic_action_2
3656 |    semantic_action[3] := semantic_action_3
3657 |    semantic_action[4] := semantic_action_4
3658 |    semantic_action[5] := semantic_action_5
3659 |    semantic_action[6] := semantic_action_6
3660 |    semantic_action[7] := semantic_action_7
3661 |    semantic_action[8] := semantic_action_8
3662 |    semantic_action[9] := semantic_action_9
3663 |    semantic_action[10] := semantic_action_10
3664 |    semantic_action[11] := semantic_action_11
3665 |    semantic_action[12] := semantic_action_12
3666 |    semantic_action[13] := semantic_action_13
3667 |    semantic_action[14] := semantic_action_14
3668 |    semantic_action[15] := semantic_action_15
3669 |    semantic_action[16] := semantic_action_16
3670 |    semantic_action[17] := semantic_action_17
3671 |    semantic_action[18] := semantic_action_18
3672 |    semantic_action[19] := semantic_action_19
3673 |    semantic_action[20] := semantic_action_20
3674 |    semantic_action[21] := semantic_action_21
3675 |    semantic_action[22] := semantic_action_22
3676 |    semantic_action[23] := semantic_action_23
3677 |    semantic_action[24] := semantic_action_24
3678 |    semantic_action[25] := semantic_action_25
3679 |    semantic_action[26] := semantic_action_26
3680 |    semantic_action[27] := semantic_action_27
3681 |    semantic_action[28] := semantic_action_28
3682 |    semantic_action[29] := semantic_action_29
3683 |    semantic_action[30] := semantic_action_30
3684 |    semantic_action[31] := semantic_action_31
3685 |    semantic_action[32] := semantic_action_32
3686 |    semantic_action[33] := semantic_action_33
3687 |    semantic_action[34] := semantic_action_34
3688 |    semantic_action[35] := semantic_action_35
3689 |    semantic_action[36] := semantic_action_36
3690 |    semantic_action[37] := semantic_action_37
3691 |    semantic_action[38] := semantic_action_38
3692 |    semantic_action[39] := semantic_action_39
3693 |    semantic_action[40] := semantic_action_40
3694 |    semantic_action[41] := semantic_action_41
3695 |    semantic_action[42] := semantic_action_42
3696 |    semantic_action[43] := semantic_action_43
3697 |    semantic_action[44] := semantic_action_44
3698 |    semantic_action[45] := semantic_action_45
3699 |    semantic_action[46] := semantic_action_46
3700 |    semantic_action[47] := semantic_action_47
3701 |    semantic_action[48] := semantic_action_48
3702 |    semantic_action[49] := semantic_action_49
3703 |    semantic_action[50] := semantic_action_50
3704 |    semantic_action[51] := semantic_action_51
3705 |    semantic_action[52] := semantic_action_52
3706 |    semantic_action[53] := semantic_action_53
3707 |    semantic_action[54] := semantic_action_54
3708 |    semantic_action[55] := semantic_action_55
3709 | 
3710 | end
3711 | 
3712 | procedure semantic_action_3()
3713 |    { j0.whitespace(); }
3714 | end
3715 | 
3716 | procedure semantic_action_4()
3717 |    { j0.newline(); }
3718 | end
3719 | 
3720 | procedure semantic_action_23()
3721 |    { return j0.scan(j0.ord("("));}
3722 | end
3723 | 
3724 | procedure semantic_action_24()
3725 |    { return j0.scan(j0.ord(")"));}
3726 | end
3727 | 
3728 | procedure semantic_action_25()
3729 |    { return j0.scan(j0.ord("["));}
3730 | end
3731 | 
3732 | procedure semantic_action_26()
3733 |    { return j0.scan(j0.ord("]"));}
3734 | end
3735 | 
3736 | procedure semantic_action_27()
3737 |    { return j0.scan(j0.ord("{"));}
3738 | end
3739 | 
3740 | procedure semantic_action_28()
3741 |    { return j0.scan(j0.ord("}"));}
3742 | end
3743 | 
3744 | procedure semantic_action_29()
3745 |    { return j0.scan(j0.ord(";"));}
3746 | end
3747 | 
3748 | procedure semantic_action_30()
3749 |    { return j0.scan(j0.ord(":"));}
3750 | end
3751 | 
3752 | procedure semantic_action_32()
3753 |    { return j0.scan(j0.ord("*"));}
3754 | end
3755 | 
3756 | procedure semantic_action_33()
3757 |    { return j0.scan(j0.ord("/"));}
3758 | end
3759 | 
3760 | procedure semantic_action_34()
3761 |    { return j0.scan(j0.ord("%"));}
3762 | end
3763 | 
3764 | procedure semantic_action_37()
3765 |    { return j0.scan(j0.ord("<"));}
3766 | end
3767 | 
3768 | procedure semantic_action_39()
3769 |    { return j0.scan(j0.ord(">"));}
3770 | end
3771 | 
3772 | procedure semantic_action_31()
3773 |    { return j0.scan(j0.ord("!"));}
3774 | end
3775 | 
3776 | procedure semantic_action_35()
3777 |    { return j0.scan(j0.ord("+"));}
3778 | end
3779 | 
3780 | procedure semantic_action_36()
3781 |    { return j0.scan(j0.ord("-"));}
3782 | end
3783 | 
3784 | procedure semantic_action_45()
3785 |    { return j0.scan(j0.ord("=")); }
3786 | end
3787 | 
3788 | procedure semantic_action_48()
3789 |    { return j0.scan(j0.ord(",")); }
3790 | end
3791 | 
3792 | procedure semantic_action_50()
3793 |    { return j0.scan(parser.IDENTIFIER); }
3794 | end
3795 | 
3796 | procedure semantic_action_49()
3797 |    { return j0.scan(j0.ord(".")); }
3798 | end
3799 | 
3800 | procedure semantic_action_51()
3801 |    { return j0.scan(parser.INTLIT); }
3802 | end
3803 | 
3804 | procedure semantic_action_55()
3805 |    { j0.lexErr("unrecognized character"); }
3806 | end
3807 | 
3808 | procedure semantic_action_10()
3809 |    { return j0.scan(parser.IF); }
3810 | end
3811 | 
3812 | procedure semantic_action_38()
3813 |    { return j0.scan(parser.LESSTHANOREQUAL);}
3814 | end
3815 | 
3816 | procedure semantic_action_40()
3817 |    { return j0.scan(parser.GREATERTHANOREQUAL);}
3818 | end
3819 | 
3820 | procedure semantic_action_42()
3821 |    { return j0.scan(parser.NOTEQUALTO);}
3822 | end
3823 | 
3824 | procedure semantic_action_43()
3825 |    { return j0.scan(parser.LOGICALAND);}
3826 | end
3827 | 
3828 | procedure semantic_action_44()
3829 |    { return j0.scan(parser.LOGICALOR);}
3830 | end
3831 | 
3832 | procedure semantic_action_46()
3833 |    { return j0.scan(parser.INCREMENT); }
3834 | end
3835 | 
3836 | procedure semantic_action_47()
3837 |    { return j0.scan(parser.DECREMENT); }
3838 | end
3839 | 
3840 | procedure semantic_action_41()
3841 |    { return j0.scan(parser.ISEQUALTO);}
3842 | end
3843 | 
3844 | procedure semantic_action_54()
3845 |    { return j0.scan(parser.STRINGLIT); }
3846 | end
3847 | 
3848 | procedure semantic_action_9()
3849 |    { return j0.scan(parser.FOR); }
3850 | end
3851 | 
3852 | procedure semantic_action_12()
3853 |    { return j0.scan(parser.NEW); }
3854 | end
3855 | 
3856 | procedure semantic_action_11()
3857 |    { return j0.scan(parser.INT); }
3858 | end
3859 | 
3860 | procedure semantic_action_2()
3861 |    { j0.comment(); }
3862 | end
3863 | 
3864 | procedure semantic_action_52()
3865 |    { return j0.scan(parser.DOUBLELIT); }
3866 | end
3867 | 
3868 | procedure semantic_action_53()
3869 |    { return j0.scan(parser.DOUBLELIT); }
3870 | end
3871 | 
3872 | procedure semantic_action_18()
3873 |    { return j0.scan(parser.BOOLLIT); }
3874 | end
3875 | 
3876 | procedure semantic_action_13()
3877 |    { return j0.scan(parser.NULLVAL); }
3878 | end
3879 | 
3880 | procedure semantic_action_20()
3881 |    { return j0.scan(parser.VOID); }
3882 | end
3883 | 
3884 | procedure semantic_action_7()
3885 |    { return j0.scan(parser.ELSE); }
3886 | end
3887 | 
3888 | procedure semantic_action_1()
3889 |    { j0.comment(); }
3890 | end
3891 | 
3892 | procedure semantic_action_8()
3893 |    { return j0.scan(parser.BOOLLIT); }
3894 | end
3895 | 
3896 | procedure semantic_action_5()
3897 |    { return j0.scan(parser.BREAK); }
3898 | end
3899 | 
3900 | procedure semantic_action_21()
3901 |    { return j0.scan(parser.WHILE); }
3902 | end
3903 | 
3904 | procedure semantic_action_22()
3905 |    { return j0.scan(parser.CLASS); }
3906 | end
3907 | 
3908 | procedure semantic_action_14()
3909 |    { return j0.scan(parser.PUBLIC); }
3910 | end
3911 | 
3912 | procedure semantic_action_15()
3913 |    { return j0.scan(parser.RETURN); }
3914 | end
3915 | 
3916 | procedure semantic_action_6()
3917 |    { return j0.scan(parser.DOUBLE); }
3918 | end
3919 | 
3920 | procedure semantic_action_17()
3921 |    { return j0.scan(parser.STRING); }
3922 | end
3923 | 
3924 | procedure semantic_action_16()
3925 |    { return j0.scan(parser.STATIC); }
3926 | end
3927 | 
3928 | procedure semantic_action_19()
3929 |    { return j0.scan(parser.BOOLEAN); }
3930 | end
3931 | 
3932 | 


--------------------------------------------------------------------------------
/ch9/javalex.l:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | %%
 3 | %int
 4 | id=([a-zA-Z_][a-zA-Z0-9_]*)
 5 | %%
 6 | "/*"([^*]|"*"+[^/*])*"*"+"/" { j0.comment(); }
 7 | "//".*\r?\n                  { j0.comment(); }
 8 | [ \t\r\f]+                   { j0.whitespace(); }
 9 | \n                           { j0.newline(); }
10 | "break"                { return j0.scan(parser.BREAK); }
11 | "double"               { return j0.scan(parser.DOUBLE); } 
12 | "else"                 { return j0.scan(parser.ELSE); }
13 | "false"                { return j0.scan(parser.BOOLLIT); }
14 | "for"                  { return j0.scan(parser.FOR); }
15 | "if"                   { return j0.scan(parser.IF); }
16 | "int"                  { return j0.scan(parser.INT); }
17 | "new"                  { return j0.scan(parser.NEW); }
18 | "null"                 { return j0.scan(parser.NULLVAL); }
19 | "public"               { return j0.scan(parser.PUBLIC); }
20 | "return"               { return j0.scan(parser.RETURN); }
21 | "static"               { return j0.scan(parser.STATIC); }
22 | "string"               { return j0.scan(parser.STRING); }
23 | "true"                 { return j0.scan(parser.BOOLLIT); }
24 | "boolean"              { return j0.scan(parser.BOOLEAN); }
25 | "void"                 { return j0.scan(parser.VOID); }
26 | "while"                { return j0.scan(parser.WHILE); }
27 | "class"                { return j0.scan(parser.CLASS); }
28 | "("                    { return j0.scan(j0.ord("("));}
29 | ")"                    { return j0.scan(j0.ord(")"));}
30 | "["                    { return j0.scan(j0.ord("["));}
31 | "]"                    { return j0.scan(j0.ord("]"));}
32 | "{"                    { return j0.scan(j0.ord("{"));}
33 | "}"                    { return j0.scan(j0.ord("}"));}
34 | ";"                    { return j0.scan(j0.ord(";"));}
35 | ":"                    { return j0.scan(j0.ord(":"));}
36 | "!"                    { return j0.scan(j0.ord("!"));}
37 | "*"                    { return j0.scan(j0.ord("*"));}
38 | "/"                    { return j0.scan(j0.ord("/"));}
39 | "%"                    { return j0.scan(j0.ord("%"));}
40 | "+"                    { return j0.scan(j0.ord("+"));}
41 | "-"                    { return j0.scan(j0.ord("-"));}
42 | "<"                    { return j0.scan(j0.ord("<"));}
43 | "<="                   { return j0.scan(parser.LESSTHANOREQUAL);}
44 | ">"                    { return j0.scan(j0.ord(">"));}
45 | ">="                   { return j0.scan(parser.GREATERTHANOREQUAL);}
46 | "=="                   { return j0.scan(parser.ISEQUALTO);}
47 | "!="                   { return j0.scan(parser.NOTEQUALTO);}
48 | "&&"                   { return j0.scan(parser.LOGICALAND);}
49 | "||"                   { return j0.scan(parser.LOGICALOR);}
50 | "="                    { return j0.scan(j0.ord("=")); }
51 | "+="                   { return j0.scan(parser.INCREMENT); }
52 | "-="                   { return j0.scan(parser.DECREMENT); }
53 | ","                    { return j0.scan(j0.ord(",")); }
54 | "."                    { return j0.scan(j0.ord(".")); }
55 | {id}                   { return j0.scan(parser.IDENTIFIER); }
56 | [0-9]+                 { return j0.scan(parser.INTLIT); }
57 | [0-9]*"."[0-9]*([eE][+-]?[0-9]+)? { return j0.scan(parser.DOUBLELIT); }
58 | ([0-9]+)([eE][+-]?([0-9]+))  { return j0.scan(parser.DOUBLELIT); }
59 | \"([^\"]|(\\.))*\"     { return j0.scan(parser.STRINGLIT); }
60 | .                      { j0.lexErr("unrecognized character"); }
61 | 


--------------------------------------------------------------------------------
/ch9/makefile:
--------------------------------------------------------------------------------
 1 | 
 2 | all: java unicon
 3 | 
 4 | LYU=javalex.u j0gram.u j0gram_tab.u
 5 | STU=symtab.u symtab_entry.u typeinfo.u
 6 | CGU=tac.u address.u
 7 | U=j0.u token.u tree.u serial.u yyerror.u $(LYU) $(STU) $(CGU)
 8 | unicon: j0
 9 | %.u : %.icn
10 | 	unicon -c 
lt;
11 | j0: $(U)
12 | 	unicon $(U)
13 | javalex.icn: javalex.l
14 | 	uflex javalex.l
15 | j0gram.icn j0gram_tab.icn: j0gram.y
16 | 	iyacc -dd j0gram.y
17 | 
18 | # Windows: a typical run might use
19 | # set CLASSPATH=".;c:\users\username\byopl"
20 | # in order to run from c:\users\username\byopl\ch9
21 | LYSRC=Yylex.java parser.java parserVal.java
22 | TPJ=typeinfo.java arraytype.java classtype.java methodtype.java parameter.java
23 | STJ=symtab.java symtab_entry.java $(TPJ)
24 | CGJ=tac.java address.java
25 | JSRC=j0.java token.java yyerror.java tree.java serial.java $(LYSRC) $(STJ) $(CGJ)
26 | BYJOPTS= -Jclass=parser -Jpackage=ch9
27 | BYJIMPS= -Jyylex=ch9.j0.yylex -Jyyerror=ch9.yyerror.yyerror
28 | java: j0.class
29 | 
30 | j: java
31 | 	java ch9.j0 hello.java
32 | 	dot -Tpng hello.java.dot >hello.png
33 | 
34 | j0.class: $(JSRC)
35 | 	javac $(JSRC)
36 | parser.java parserVal.java: j0gram.y
37 | 	yacc $(BYJOPTS) $(BYJIMPS) j0gram.y
38 | Yylex.java: javalex.l
39 | 	jflex javalex.l
40 | 
41 | 


--------------------------------------------------------------------------------
/ch9/methodtype.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class methodtype extends typeinfo {
 3 |    typeinfo [] parameters;
 4 |    typeinfo return_type;
 5 |     public String str() {
 6 | 	String s;
 7 | 	s = "method " + ((return_type!=null)?return_type.str():"undef") + "(";
 8 | 	for(typeinfo p : parameters)
 9 | 	    s = s + p.str() + ",";
10 | 	s = s.substring(0,s.length()-2) + ")";
11 | 	return s;
12 |     }
13 |    methodtype(typeinfo [] p, typeinfo rt){
14 |        parameters = p;
15 |        if (rt !=null) return_type = rt;
16 |        else return_type = new typeinfo("void");
17 |        basetype="method";
18 |    }
19 | }
20 | 


--------------------------------------------------------------------------------
/ch9/parameter.java:
--------------------------------------------------------------------------------
1 | package ch9;
2 | public class parameter {
3 |    String name;
4 |    typeinfo param_type;
5 |    parameter(String s, typeinfo t) { name=s; param_type=t; }
6 | }
7 | 


--------------------------------------------------------------------------------
/ch9/parser.java:
--------------------------------------------------------------------------------
   1 | //### This file created by BYACC 1.8(/Java extension  1.15)
   2 | //### Java capabilities added 7 Jan 97, Bob Jamison
   3 | //### Updated : 27 Nov 97  -- Bob Jamison, Joe Nieten
   4 | //###           01 Jan 98  -- Bob Jamison -- fixed generic semantic constructor
   5 | //###           01 Jun 99  -- Bob Jamison -- added Runnable support
   6 | //###           06 Aug 00  -- Bob Jamison -- made state variables class-global
   7 | //###           03 Jan 01  -- Bob Jamison -- improved flags, tracing
   8 | //###           16 May 01  -- Bob Jamison -- added custom stack sizing
   9 | //###           04 Mar 02  -- Yuval Oren  -- improved java performance, added options
  10 | //###           14 Mar 02  -- Tomas Hurka -- -d support, static initializer workaround
  11 | //### Please send bug reports to tom@hukatronic.cz
  12 | //### static char yysccsid[] = "@(#)yaccpar	1.8 (Berkeley) 01/20/90";
  13 | 
  14 | 
  15 | 
  16 | package ch9;
  17 | import static ch9.j0.yylex;
  18 | import static ch9.yyerror.yyerror;
  19 | 
  20 | 
  21 | 
  22 | 
  23 | 
  24 | 
  25 | 
  26 | public class parser
  27 | {
  28 | 
  29 | boolean yydebug;        //do I want debug output?
  30 | int yynerrs;            //number of errors so far
  31 | int yyerrflag;          //was there an error?
  32 | int yychar;             //the current working character
  33 | 
  34 | //########## MESSAGES ##########
  35 | //###############################################################
  36 | // method: debug
  37 | //###############################################################
  38 | void debug(String msg)
  39 | {
  40 |   if (yydebug)
  41 |     System.out.println(msg);
  42 | }
  43 | 
  44 | //########## STATE STACK ##########
  45 | final static int YYSTACKSIZE = 500;  //maximum stack size
  46 | int statestk[] = new int[YYSTACKSIZE]; //state stack
  47 | int stateptr;
  48 | int stateptrmax;                     //highest index of stackptr
  49 | int statemax;                        //state when highest index reached
  50 | //###############################################################
  51 | // methods: state stack push,pop,drop,peek
  52 | //###############################################################
  53 | final void state_push(int state)
  54 | {
  55 |   try {
  56 | 		stateptr++;
  57 | 		statestk[stateptr]=state;
  58 | 	 }
  59 | 	 catch (ArrayIndexOutOfBoundsException e) {
  60 |      int oldsize = statestk.length;
  61 |      int newsize = oldsize * 2;
  62 |      int[] newstack = new int[newsize];
  63 |      System.arraycopy(statestk,0,newstack,0,oldsize);
  64 |      statestk = newstack;
  65 |      statestk[stateptr]=state;
  66 |   }
  67 | }
  68 | final int state_pop()
  69 | {
  70 |   return statestk[stateptr--];
  71 | }
  72 | final void state_drop(int cnt)
  73 | {
  74 |   stateptr -= cnt; 
  75 | }
  76 | final int state_peek(int relative)
  77 | {
  78 |   return statestk[stateptr-relative];
  79 | }
  80 | //###############################################################
  81 | // method: init_stacks : allocate and prepare stacks
  82 | //###############################################################
  83 | final boolean init_stacks()
  84 | {
  85 |   stateptr = -1;
  86 |   val_init();
  87 |   return true;
  88 | }
  89 | //###############################################################
  90 | // method: dump_stacks : show n levels of the stacks
  91 | //###############################################################
  92 | void dump_stacks(int count)
  93 | {
  94 | int i;
  95 |   System.out.println("=index==state====value=     s:"+stateptr+"  v:"+valptr);
  96 |   for (i=0;i<count;i++)
  97 |     System.out.println(" "+i+"    "+statestk[i]+"      "+valstk[i]);
  98 |   System.out.println("======================");
  99 | }
 100 | 
 101 | 
 102 | //########## SEMANTIC VALUES ##########
 103 | //public class parserVal is defined in parserVal.java
 104 | 
 105 | 
 106 | String   yytext;//user variable to return contextual strings
 107 | parserVal yyval; //used to return semantic vals from action routines
 108 | parserVal yylval;//the 'lval' (result) I got from yylex()
 109 | parserVal valstk[];
 110 | int valptr;
 111 | //###############################################################
 112 | // methods: value stack push,pop,drop,peek.
 113 | //###############################################################
 114 | void val_init()
 115 | {
 116 |   valstk=new parserVal[YYSTACKSIZE];
 117 |   yyval=new parserVal();
 118 |   yylval=new parserVal();
 119 |   valptr=-1;
 120 | }
 121 | void val_push(parserVal val)
 122 | {
 123 |   if (valptr>=YYSTACKSIZE)
 124 |     return;
 125 |   valstk[++valptr]=val;
 126 | }
 127 | parserVal val_pop()
 128 | {
 129 |   if (valptr<0)
 130 |     return new parserVal();
 131 |   return valstk[valptr--];
 132 | }
 133 | void val_drop(int cnt)
 134 | {
 135 | int ptr;
 136 |   ptr=valptr-cnt;
 137 |   if (ptr<0)
 138 |     return;
 139 |   valptr = ptr;
 140 | }
 141 | parserVal val_peek(int relative)
 142 | {
 143 | int ptr;
 144 |   ptr=valptr-relative;
 145 |   if (ptr<0)
 146 |     return new parserVal();
 147 |   return valstk[ptr];
 148 | }
 149 | final parserVal dup_yyval(parserVal val)
 150 | {
 151 |   parserVal dup = new parserVal();
 152 |   dup.ival = val.ival;
 153 |   dup.dval = val.dval;
 154 |   dup.sval = val.sval;
 155 |   dup.obj = val.obj;
 156 |   return dup;
 157 | }
 158 | //#### end semantic value section ####
 159 | public final static short BREAK=257;
 160 | public final static short DOUBLE=258;
 161 | public final static short ELSE=259;
 162 | public final static short FOR=260;
 163 | public final static short IF=261;
 164 | public final static short INT=262;
 165 | public final static short RETURN=263;
 166 | public final static short VOID=264;
 167 | public final static short WHILE=265;
 168 | public final static short IDENTIFIER=266;
 169 | public final static short CLASSNAME=267;
 170 | public final static short CLASS=268;
 171 | public final static short STRING=269;
 172 | public final static short BOOL=270;
 173 | public final static short INTLIT=271;
 174 | public final static short DOUBLELIT=272;
 175 | public final static short STRINGLIT=273;
 176 | public final static short BOOLLIT=274;
 177 | public final static short NULLVAL=275;
 178 | public final static short LESSTHANOREQUAL=276;
 179 | public final static short GREATERTHANOREQUAL=277;
 180 | public final static short ISEQUALTO=278;
 181 | public final static short NOTEQUALTO=279;
 182 | public final static short LOGICALAND=280;
 183 | public final static short LOGICALOR=281;
 184 | public final static short INCREMENT=282;
 185 | public final static short DECREMENT=283;
 186 | public final static short PUBLIC=284;
 187 | public final static short STATIC=285;
 188 | public final static short NEW=286;
 189 | public final static short BOOLEAN=287;
 190 | public final static short YYERRCODE=256;
 191 | final static short yylhs[] = {                           -1,
 192 |     0,    1,    1,    2,    2,    3,    3,    3,    4,    7,
 193 |     7,    7,    7,    7,    9,    9,   10,    8,    8,   11,
 194 |    11,   12,   12,    5,   13,   15,   16,   16,   17,   17,
 195 |    18,    6,   14,   19,   19,   20,   20,   21,   21,   22,
 196 |    24,   23,   23,   23,   23,   23,   23,   23,   23,   23,
 197 |    23,   25,   33,   33,   28,   29,   30,   30,   37,   37,
 198 |    38,   31,   32,   39,   39,   39,   40,   40,   41,   41,
 199 |    42,   42,   26,   26,   27,   43,   43,   43,   43,   43,
 200 |    44,   44,   44,   44,   44,   44,   44,   48,   47,   50,
 201 |    50,   45,   49,   49,   35,   35,   51,   51,   52,   52,
 202 |    52,   53,   53,   53,   53,   54,   54,   54,   55,   55,
 203 |    55,   55,   56,   56,   57,   57,   57,   58,   58,   59,
 204 |    59,   46,   36,   36,   34,   60,   60,   60,   61,   61,
 205 |    61,
 206 | };
 207 | final static short yylen[] = {                            2,
 208 |     4,    3,    2,    1,    2,    1,    1,    1,    3,    1,
 209 |     1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
 210 |     3,    1,    1,    2,    4,    4,    1,    0,    1,    3,
 211 |     2,    2,    3,    1,    0,    1,    2,    1,    1,    2,
 212 |     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 213 |     1,    2,    1,    1,    5,    7,    6,    8,    1,    2,
 214 |     2,    5,    9,    1,    1,    0,    1,    0,    1,    0,
 215 |     1,    3,    2,    3,    3,    1,    1,    1,    1,    1,
 216 |     1,    1,    1,    1,    3,    1,    1,    5,    5,    1,
 217 |     3,    3,    1,    0,    4,    6,    1,    1,    2,    2,
 218 |     1,    1,    3,    3,    3,    1,    3,    3,    1,    1,
 219 |     1,    1,    1,    3,    1,    3,    3,    1,    3,    1,
 220 |     3,    4,    1,    1,    3,    1,    1,    1,    1,    1,
 221 |     1,
 222 | };
 223 | final static short yydefred[] = {                         0,
 224 |     0,    0,    0,    0,    0,    1,   11,   10,    0,   13,
 225 |     0,    3,   12,    0,    4,    6,    7,    8,    0,    0,
 226 |    16,    0,    0,    0,    0,    2,    5,   20,    0,    0,
 227 |     0,    0,   24,   32,   15,    0,    0,    0,   29,   23,
 228 |    22,    0,    9,    0,    0,   17,    0,    0,    0,    0,
 229 |     0,   76,   77,   79,   78,   80,    0,   43,    0,    0,
 230 |     0,   42,    0,    0,   36,   38,   39,    0,   44,   45,
 231 |    46,   47,   48,   49,   50,   51,    0,   53,    0,   81,
 232 |     0,    0,    0,   86,   87,    0,    0,   26,    0,    0,
 233 |    25,    0,   21,    0,   73,    0,    0,    0,    0,    0,
 234 |   124,   83,   67,    0,    0,  101,  102,    0,    0,    0,
 235 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 236 |    33,   37,   40,   52,    0,  130,  131,  129,    0,   30,
 237 |    74,   65,   71,    0,    0,    0,    0,   82,   84,   99,
 238 |   100,   75,    0,    0,    0,    0,    0,  109,  110,  111,
 239 |   112,    0,    0,    0,    0,    0,    0,    0,    0,   85,
 240 |     0,   90,    0,    0,    0,  125,    0,    0,    0,  103,
 241 |   104,  105,    0,    0,    0,    0,    0,    0,    0,    0,
 242 |     0,    0,  122,   95,    0,    0,    0,    0,   72,    0,
 243 |    62,   89,   88,   91,    0,    0,    0,    0,   59,   96,
 244 |     0,    0,    0,   56,   61,    0,   60,    0,    0,   58,
 245 |    63,    0,    0,   55,
 246 | };
 247 | final static short yydgoto[] = {                          2,
 248 |     6,   14,   15,   16,   17,   18,   60,   29,  100,   21,
 249 |    30,   42,   22,   62,   23,   37,   38,   39,   63,   64,
 250 |    65,   66,   67,   68,   69,   70,   71,   72,   73,   74,
 251 |    75,   76,   77,  101,  102,  162,  198,  199,  134,  104,
 252 |   201,  135,   80,  105,   82,   83,   84,   85,  163,  164,
 253 |   106,  107,  108,  109,  152,  110,  111,  112,  113,   86,
 254 |   129,
 255 | };
 256 | final static short yysindex[] = {                      -241,
 257 |  -196,    0, -206,  -46,  204,    0,    0,    0,   44,    0,
 258 |  -194,    0,    0,  304,    0,    0,    0,    0, -177,   52,
 259 |     0,   -2,   -2, -163, -208,    0,    0,    0,  -38,   35,
 260 |  -162,   48,    0,    0,    0, -177,   84,   85,    0,    0,
 261 |     0, -132,    0, -177,   42,    0,  -51,   96,   97,  -33,
 262 |   101,    0,    0,    0,    0,    0, -163,    0,  -33, -177,
 263 |   -36,    0,   20,   48,    0,    0,    0,   87,    0,    0,
 264 |     0,    0,    0,    0,    0,    0,   98,    0,    0,    0,
 265 |   109,    0,    0,    0,    0,  -47,   35,    0, -163,   44,
 266 |     0,   35,    0,   99,    0,   70,  -33,  -33,  -33,  -36,
 267 |     0,    0,    0,  100,  109,    0,    0,   55,   -4,  -57,
 268 |  -227, -124, -121,  -33,   89,  -27,  120,  118,  -33,  -33,
 269 |     0,    0,    0,    0,  -85,    0,    0,    0,  -33,    0,
 270 |     0,    0,    0,  128,  145,  149,  -36,    0,    0,    0,
 271 |     0,    0,  -33,  -33,  -33,  -33,  -33,    0,    0,    0,
 272 |     0,  -33,  -33,  -33,  -33,  -33,  154,  -33,  -33,    0,
 273 |   103,    0,  156,  158,  164,    0,  -33,  130,   -2,    0,
 274 |     0,    0,   55,   55,   -4,  -57,  -57, -227, -124,  104,
 275 |   105,  167,    0,    0,  -33,  -33,  146,  -36,    0,  -50,
 276 |     0,    0,    0,    0,  176,  130, -107,  -41,    0,    0,
 277 |   181,  145,  186,    0,    0, -107,    0,   -2,  -33,    0,
 278 |     0,  189,   -2,    0,
 279 | };
 280 | final static short yyrindex[] = {                         0,
 281 |     0,    0,    0,    0,    0,    0,    0,    0,  -45,    0,
 282 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  -34,
 283 |     0,    0,    0,  196,    0,    0,    0,    0,    0,  -19,
 284 |     0,  125,    0,    0,    0,    0,    0,  213,    0,    0,
 285 |     0,    0,    0,    0,    0,    0,    0,    0,    0,  197,
 286 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 287 |   -59,    0,    0,  151,    0,    0,    0,    0,    0,    0,
 288 |     0,    0,    0,    0,    0,    0,    0,    0,   27,    0,
 289 |     0,  -13,   71,    0,    0,    0,   18,    0,    0,    0,
 290 |     0,  -17,    0,    0,    0,  212,    0,    0,    0,  132,
 291 |     0,    0,    0,    0,  141,    0,    0,  382,  240,   46,
 292 |    79,   26,  -24,    0,    0,  194,    0,  228,    0,  252,
 293 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 294 |     0,    0,    0,    0,  239,    0,  169,    0,    0,    0,
 295 |     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 296 |     0,    0,    0,    0,    0,    0,    0,    0,  252,    0,
 297 |     0,    0,    0,  260,  106,    0,  197,    0,    0,    0,
 298 |     0,    0,  392,  412,  399,  253,  314,  419,   34,    0,
 299 |     0,    0,    0,    0,    0,  252,    0,   13,    0,  -14,
 300 |     0,    0,    0,    0,    0,  275,    0,   17,    0,    0,
 301 |     0,  277,    0,    0,    0,    0,    0,    0,    0,    0,
 302 |     0,    0,    0,    0,
 303 | };
 304 | final static short yygindex[] = {                         0,
 305 |     0,    0,  231,    0,    0,    0,   39,  270,  551,    0,
 306 |   -21,    0,    0,  340,  289,    0,    0,  248,    0,    0,
 307 |   274,    0,  160,  272,    0,    0,    0, -188,    0,    0,
 308 |     0,    0,  -74,  334,  342,  445,    0,  173,    0,  205,
 309 |     0,  184,    0,  400,  473,  568,    0,    0, -148,    0,
 310 |     0,  -62,  -81,  229,    0,  -53,  236,  237,    0,    0,
 311 |     0,
 312 | };
 313 | final static int YYTABLESIZE=747;
 314 | static short yytable[];
 315 | static { yytable();}
 316 | static void yytable(){
 317 | yytable = new short[]{                         99,
 318 |    15,  126,  150,  120,  151,   44,   59,   95,  205,   31,
 319 |   182,   98,  159,  128,   87,   32,  123,  205,   31,  123,
 320 |    43,  133,   92,   82,   18,   55,   19,   82,   82,   82,
 321 |    82,   82,   82,   82,  123,  140,  141,  195,  147,   18,
 322 |   146,   19,    1,   19,   55,   82,   82,  127,   82,    7,
 323 |   153,  154,   19,    8,  119,   40,   57,   35,   31,    4,
 324 |    10,   31,   36,   41,  173,  174,  120,   54,  123,  120,
 325 |    54,    3,   83,  126,  121,   57,    5,  121,   13,   82,
 326 |   170,  171,  172,   24,  120,   54,  115,   59,   28,  115,
 327 |    25,  145,  121,  189,    7,  115,  143,   31,    8,  176,
 328 |   177,  144,   35,   46,  115,   10,   58,   84,   55,   59,
 329 |    55,   84,   84,   84,   84,   84,   84,   84,  120,  118,
 330 |    32,  133,  118,   13,   88,   45,  121,   36,   89,   84,
 331 |    84,  128,   84,   90,   93,   96,   97,  118,  115,   57,
 332 |   114,   57,   92,   59,  121,  123,   92,   92,   92,   92,
 333 |    92,   92,   92,  203,  125,  155,  124,  131,  142,  156,
 334 |   160,   44,   58,   84,   92,   92,   92,   92,   98,   59,
 335 |    32,  118,   98,   98,   98,   98,   98,   97,   98,  158,
 336 |   165,   97,   97,   97,   97,   97,  167,   97,  168,  169,
 337 |    98,   98,  126,   98,  180,  183,  184,  192,   92,   97,
 338 |    97,  185,   97,  186,  196,   98,   14,  193,  197,   98,
 339 |    98,   98,   98,   98,   94,   98,  200,  206,  148,  149,
 340 |    15,  208,  126,  126,   98,  209,   32,   98,   98,  213,
 341 |    98,   14,   35,   97,  126,  127,   28,   52,   53,   54,
 342 |    55,   56,   55,   55,   27,   55,   55,   55,   55,   35,
 343 |    55,   55,   57,   27,   55,   68,   55,   55,   55,   55,
 344 |    55,   98,   82,   82,   82,   82,   82,   82,  127,  127,
 345 |    66,   55,   55,   57,   57,   34,   57,   57,   57,   57,
 346 |   113,   57,   57,  113,   14,   57,   41,   57,   57,   57,
 347 |    57,   57,   94,  116,  126,  126,  116,   64,  113,  113,
 348 |    93,  113,   57,   57,   47,    7,  120,   48,   49,    8,
 349 |    50,  116,   51,   35,  121,   70,   10,   69,   52,   53,
 350 |    54,   55,   56,  115,  115,  115,  115,    7,   12,  118,
 351 |    91,    8,  113,   57,   13,   35,  130,  122,   10,  191,
 352 |    52,   53,   54,   55,   56,  116,   84,   84,   84,   84,
 353 |    84,   84,  128,  128,  117,   57,   13,  117,  118,  118,
 354 |    47,   33,   34,   48,   49,   78,   50,  132,   51,   35,
 355 |   207,  187,  117,   79,   52,   53,   54,   55,   56,  202,
 356 |   175,   92,   92,   92,   92,   92,   92,   92,   92,   57,
 357 |   178,    0,  179,    0,    0,   35,    0,   78,    0,    0,
 358 |    52,   53,   54,   55,   56,   79,  117,   98,   98,   98,
 359 |    98,   98,   98,  126,  126,   57,   97,   97,   97,   97,
 360 |    97,   97,  106,    0,  106,  106,  106,    0,   26,   78,
 361 |     0,   81,  108,    0,  108,  108,  108,   79,    0,  114,
 362 |   106,  106,  114,  106,   98,   98,   98,   98,   98,   98,
 363 |   108,  108,  107,  108,  107,  107,  107,  114,  114,  119,
 364 |   114,    7,  119,   81,    0,    8,    0,    0,    0,    9,
 365 |   107,  107,   10,  107,  106,    0,    0,  119,    0,    0,
 366 |     0,    0,    0,    0,  108,    0,    0,   11,    0,    0,
 367 |    13,  114,    0,    0,  103,   81,    0,    0,    0,    0,
 368 |     0,   78,    0,  117,  107,    0,    0,    0,  190,   79,
 369 |     0,  119,    0,   78,    0,  113,  113,  113,  113,  113,
 370 |   113,   79,    0,    0,    0,    0,    0,    0,    0,   78,
 371 |   116,  116,  116,  116,    0,    0,  204,   79,    0,    0,
 372 |     0,  136,    0,    0,    0,  210,    0,  211,    0,    0,
 373 |     0,    0,  214,    0,    0,   20,    0,    0,  157,    0,
 374 |     0,    7,    0,  161,   20,    8,    0,   81,    0,    9,
 375 |   138,  138,   10,  166,   20,   20,    0,    0,    0,   81,
 376 |     0,    0,   61,    0,    0,    0,    0,   11,    0,    0,
 377 |    13,  117,  117,  117,  117,   81,    0,    0,    0,    0,
 378 |     0,    0,  181,    0,    0,    0,    0,  116,    0,    0,
 379 |     0,  103,    0,    0,   61,  138,  138,  138,  138,  138,
 380 |     0,    0,    0,    0,  138,  138,  138,  138,  138,  194,
 381 |     0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
 382 |     0,    0,    0,    0,    0,    0,   61,    0,  137,  137,
 383 |     0,    0,    0,  212,    0,    0,    0,  106,  106,  106,
 384 |   106,  106,  106,    0,    0,  139,  139,  108,  108,  108,
 385 |   108,  108,  108,    0,  114,  114,  114,  114,  114,  114,
 386 |     0,    0,    0,    0,    0,    0,    0,  107,  107,  107,
 387 |   107,  107,  107,  137,  137,  137,  137,  137,  119,  119,
 388 |     0,    0,  137,  137,  137,  137,  137,    0,    0,    0,
 389 |   139,  139,  139,  139,  139,    0,    0,    0,  188,  139,
 390 |   139,  139,  139,  139,    0,    0,    0,    0,    0,    0,
 391 |   188,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 392 |     0,    0,    0,    0,    0,    0,  188,
 393 | };
 394 | }
 395 | static short yycheck[];
 396 | static { yycheck(); }
 397 | static void yycheck() {
 398 | yycheck = new short[] {                         33,
 399 |    46,   61,   60,   40,   62,   44,   40,   59,  197,   46,
 400 |   159,   45,   40,   61,   36,  123,   41,  206,   46,   44,
 401 |    59,   96,   44,   37,   44,   40,   44,   41,   42,   43,
 402 |    44,   45,   46,   47,   59,   98,   99,  186,   43,   59,
 403 |    45,   59,  284,    5,   59,   59,   60,   61,   62,  258,
 404 |   278,  279,   14,  262,   91,  264,   40,  266,   41,  266,
 405 |   269,   44,   24,   25,  146,  147,   41,   41,   93,   44,
 406 |    44,  268,   46,   61,   41,   59,  123,   44,  287,   93,
 407 |   143,  144,  145,   40,   59,   59,   41,   40,  266,   44,
 408 |   285,   37,   59,  168,  258,   57,   42,   46,  262,  153,
 409 |   154,   47,  266,  266,   59,  269,   59,   37,  123,   40,
 410 |   125,   41,   42,   43,   44,   45,   46,   47,   93,   41,
 411 |   123,  196,   44,  287,   41,   91,   93,   89,   44,   59,
 412 |    60,   61,   62,  266,   93,   40,   40,   59,   93,  123,
 413 |    40,  125,   37,   40,  125,   59,   41,   42,   43,   44,
 414 |    45,   46,   47,  261,   46,  280,   59,   59,   59,  281,
 415 |    41,   44,   59,   93,   59,   60,   61,   62,   37,   40,
 416 |   123,   93,   41,   42,   43,   44,   45,   37,   47,   91,
 417 |   266,   41,   42,   43,   44,   45,   59,   47,   44,   41,
 418 |    59,   60,   61,   62,   41,   93,   41,   93,   93,   59,
 419 |    60,   44,   62,   40,   59,   37,  266,   41,  259,   41,
 420 |    42,   43,   44,   45,  266,   47,   41,  259,  276,  277,
 421 |   266,   41,  282,  283,   93,   40,  123,   59,   60,   41,
 422 |    62,  266,  266,   93,  282,  283,   41,  271,  272,  273,
 423 |   274,  275,  257,  258,   14,  260,  261,  262,  263,  125,
 424 |   265,  266,  286,   41,  269,   59,  271,  272,  273,  274,
 425 |   275,   93,  276,  277,  278,  279,  280,  281,  282,  283,
 426 |    59,  286,  287,  257,  258,  125,  260,  261,  262,  263,
 427 |    41,  265,  266,   44,   91,  269,   59,  271,  272,  273,
 428 |   274,  275,   41,   41,  282,  283,   44,   59,   59,   60,
 429 |    41,   62,  286,  287,  257,  258,  281,  260,  261,  262,
 430 |   263,   59,  265,  266,  281,   41,  269,   41,  271,  272,
 431 |   273,  274,  275,  278,  279,  280,  281,  258,  125,   60,
 432 |    42,  262,   93,  286,  287,  266,   89,   64,  269,  180,
 433 |   271,  272,  273,  274,  275,   93,  276,  277,  278,  279,
 434 |   280,  281,  282,  283,   41,  286,  287,   44,  280,  281,
 435 |   257,   22,   23,  260,  261,   32,  263,   96,  265,  266,
 436 |   198,  167,   59,   32,  271,  272,  273,  274,  275,  196,
 437 |   152,  276,  277,  278,  279,  280,  281,  282,  283,  286,
 438 |   155,   -1,  156,   -1,   -1,  266,   -1,   64,   -1,   -1,
 439 |   271,  272,  273,  274,  275,   64,   93,  276,  277,  278,
 440 |   279,  280,  281,  282,  283,  286,  276,  277,  278,  279,
 441 |   280,  281,   41,   -1,   43,   44,   45,   -1,  125,   96,
 442 |    -1,   32,   41,   -1,   43,   44,   45,   96,   -1,   41,
 443 |    59,   60,   44,   62,  276,  277,  278,  279,  280,  281,
 444 |    59,   60,   41,   62,   43,   44,   45,   59,   60,   41,
 445 |    62,  258,   44,   64,   -1,  262,   -1,   -1,   -1,  266,
 446 |    59,   60,  269,   62,   93,   -1,   -1,   59,   -1,   -1,
 447 |    -1,   -1,   -1,   -1,   93,   -1,   -1,  284,   -1,   -1,
 448 |   287,   93,   -1,   -1,   50,   96,   -1,   -1,   -1,   -1,
 449 |    -1,  168,   -1,   59,   93,   -1,   -1,   -1,  169,  168,
 450 |    -1,   93,   -1,  180,   -1,  276,  277,  278,  279,  280,
 451 |   281,  180,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  196,
 452 |   278,  279,  280,  281,   -1,   -1,  197,  196,   -1,   -1,
 453 |    -1,   97,   -1,   -1,   -1,  206,   -1,  208,   -1,   -1,
 454 |    -1,   -1,  213,   -1,   -1,    5,   -1,   -1,  114,   -1,
 455 |    -1,  258,   -1,  119,   14,  262,   -1,  168,   -1,  266,
 456 |    98,   99,  269,  129,   24,   25,   -1,   -1,   -1,  180,
 457 |    -1,   -1,   32,   -1,   -1,   -1,   -1,  284,   -1,   -1,
 458 |   287,  278,  279,  280,  281,  196,   -1,   -1,   -1,   -1,
 459 |    -1,   -1,  158,   -1,   -1,   -1,   -1,   57,   -1,   -1,
 460 |    -1,  167,   -1,   -1,   64,  143,  144,  145,  146,  147,
 461 |    -1,   -1,   -1,   -1,  152,  153,  154,  155,  156,  185,
 462 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   89,
 463 |    -1,   -1,   -1,   -1,   -1,   -1,   96,   -1,   98,   99,
 464 |    -1,   -1,   -1,  209,   -1,   -1,   -1,  276,  277,  278,
 465 |   279,  280,  281,   -1,   -1,   98,   99,  276,  277,  278,
 466 |   279,  280,  281,   -1,  276,  277,  278,  279,  280,  281,
 467 |    -1,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,  278,
 468 |   279,  280,  281,  143,  144,  145,  146,  147,  280,  281,
 469 |    -1,   -1,  152,  153,  154,  155,  156,   -1,   -1,   -1,
 470 |   143,  144,  145,  146,  147,   -1,   -1,   -1,  168,  152,
 471 |   153,  154,  155,  156,   -1,   -1,   -1,   -1,   -1,   -1,
 472 |   180,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 473 |    -1,   -1,   -1,   -1,   -1,   -1,  196,
 474 | };
 475 | }
 476 | final static short YYFINAL=2;
 477 | final static short YYMAXTOKEN=287;
 478 | final static String yyname[] = {
 479 | "end-of-file",null,null,null,null,null,null,null,null,null,null,null,null,null,
 480 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 481 | null,null,null,"'!'",null,null,null,"'%'",null,null,"'('","')'","'*'","'+'",
 482 | "','","'-'","'.'","'/'",null,null,null,null,null,null,null,null,null,null,null,
 483 | "';'","'<'","'='","'>'",null,null,null,null,null,null,null,null,null,null,null,
 484 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 485 | null,"'['",null,"']'",null,null,null,null,null,null,null,null,null,null,null,
 486 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 487 | null,null,"'{'",null,"'}'",null,null,null,null,null,null,null,null,null,null,
 488 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 489 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 490 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 491 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 492 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 493 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 494 | null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
 495 | null,null,null,null,null,null,null,null,null,"BREAK","DOUBLE","ELSE","FOR","IF",
 496 | "INT","RETURN","VOID","WHILE","IDENTIFIER","CLASSNAME","CLASS","STRING","BOOL",
 497 | "INTLIT","DOUBLELIT","STRINGLIT","BOOLLIT","NULLVAL","LESSTHANOREQUAL",
 498 | "GREATERTHANOREQUAL","ISEQUALTO","NOTEQUALTO","LOGICALAND","LOGICALOR",
 499 | "INCREMENT","DECREMENT","PUBLIC","STATIC","NEW","BOOLEAN",
 500 | };
 501 | final static String yyrule[] = {
 502 | "$accept : ClassDecl",
 503 | "ClassDecl : PUBLIC CLASS IDENTIFIER ClassBody",
 504 | "ClassBody : '{' ClassBodyDecls '}'",
 505 | "ClassBody : '{' '}'",
 506 | "ClassBodyDecls : ClassBodyDecl",
 507 | "ClassBodyDecls : ClassBodyDecls ClassBodyDecl",
 508 | "ClassBodyDecl : FieldDecl",
 509 | "ClassBodyDecl : MethodDecl",
 510 | "ClassBodyDecl : ConstructorDecl",
 511 | "FieldDecl : Type VarDecls ';'",
 512 | "Type : INT",
 513 | "Type : DOUBLE",
 514 | "Type : BOOLEAN",
 515 | "Type : STRING",
 516 | "Type : Name",
 517 | "Name : IDENTIFIER",
 518 | "Name : QualifiedName",
 519 | "QualifiedName : Name '.' IDENTIFIER",
 520 | "VarDecls : VarDeclarator",
 521 | "VarDecls : VarDecls ',' VarDeclarator",
 522 | "VarDeclarator : IDENTIFIER",
 523 | "VarDeclarator : VarDeclarator '[' ']'",
 524 | "MethodReturnVal : Type",
 525 | "MethodReturnVal : VOID",
 526 | "MethodDecl : MethodHeader Block",
 527 | "MethodHeader : PUBLIC STATIC MethodReturnVal MethodDeclarator",
 528 | "MethodDeclarator : IDENTIFIER '(' FormalParmListOpt ')'",
 529 | "FormalParmListOpt : FormalParmList",
 530 | "FormalParmListOpt :",
 531 | "FormalParmList : FormalParm",
 532 | "FormalParmList : FormalParmList ',' FormalParm",
 533 | "FormalParm : Type VarDeclarator",
 534 | "ConstructorDecl : MethodDeclarator Block",
 535 | "Block : '{' BlockStmtsOpt '}'",
 536 | "BlockStmtsOpt : BlockStmts",
 537 | "BlockStmtsOpt :",
 538 | "BlockStmts : BlockStmt",
 539 | "BlockStmts : BlockStmts BlockStmt",
 540 | "BlockStmt : LocalVarDeclStmt",
 541 | "BlockStmt : Stmt",
 542 | "LocalVarDeclStmt : LocalVarDecl ';'",
 543 | "LocalVarDecl : Type VarDecls",
 544 | "Stmt : Block",
 545 | "Stmt : ';'",
 546 | "Stmt : ExprStmt",
 547 | "Stmt : BreakStmt",
 548 | "Stmt : ReturnStmt",
 549 | "Stmt : IfThenStmt",
 550 | "Stmt : IfThenElseStmt",
 551 | "Stmt : IfThenElseIfStmt",
 552 | "Stmt : WhileStmt",
 553 | "Stmt : ForStmt",
 554 | "ExprStmt : StmtExpr ';'",
 555 | "StmtExpr : Assignment",
 556 | "StmtExpr : MethodCall",
 557 | "IfThenStmt : IF '(' Expr ')' Block",
 558 | "IfThenElseStmt : IF '(' Expr ')' Block ELSE Block",
 559 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence",
 560 | "IfThenElseIfStmt : IF '(' Expr ')' Block ElseIfSequence ELSE Block",
 561 | "ElseIfSequence : ElseIfStmt",
 562 | "ElseIfSequence : ElseIfSequence ElseIfStmt",
 563 | "ElseIfStmt : ELSE IfThenStmt",
 564 | "WhileStmt : WHILE '(' Expr ')' Stmt",
 565 | "ForStmt : FOR '(' ForInit ';' ExprOpt ';' ForUpdate ')' Block",
 566 | "ForInit : StmtExprList",
 567 | "ForInit : LocalVarDecl",
 568 | "ForInit :",
 569 | "ExprOpt : Expr",
 570 | "ExprOpt :",
 571 | "ForUpdate : StmtExprList",
 572 | "ForUpdate :",
 573 | "StmtExprList : StmtExpr",
 574 | "StmtExprList : StmtExprList ',' StmtExpr",
 575 | "BreakStmt : BREAK ';'",
 576 | "BreakStmt : BREAK IDENTIFIER ';'",
 577 | "ReturnStmt : RETURN ExprOpt ';'",
 578 | "Literal : INTLIT",
 579 | "Literal : DOUBLELIT",
 580 | "Literal : BOOLLIT",
 581 | "Literal : STRINGLIT",
 582 | "Literal : NULLVAL",
 583 | "Primary : Literal",
 584 | "Primary : FieldAccess",
 585 | "Primary : MethodCall",
 586 | "Primary : ArrayAccess",
 587 | "Primary : '(' Expr ')'",
 588 | "Primary : ArrayCreation",
 589 | "Primary : InstanceCreation",
 590 | "InstanceCreation : NEW Name '(' ArgListOpt ')'",
 591 | "ArrayCreation : NEW Type '[' Expr ']'",
 592 | "ArgList : Expr",
 593 | "ArgList : ArgList ',' Expr",
 594 | "FieldAccess : Primary '.' IDENTIFIER",
 595 | "ArgListOpt : ArgList",
 596 | "ArgListOpt :",
 597 | "MethodCall : Name '(' ArgListOpt ')'",
 598 | "MethodCall : Primary '.' IDENTIFIER '(' ArgListOpt ')'",
 599 | "PostFixExpr : Primary",
 600 | "PostFixExpr : Name",
 601 | "UnaryExpr : '-' UnaryExpr",
 602 | "UnaryExpr : '!' UnaryExpr",
 603 | "UnaryExpr : PostFixExpr",
 604 | "MulExpr : UnaryExpr",
 605 | "MulExpr : MulExpr '*' UnaryExpr",
 606 | "MulExpr : MulExpr '/' UnaryExpr",
 607 | "MulExpr : MulExpr '%' UnaryExpr",
 608 | "AddExpr : MulExpr",
 609 | "AddExpr : AddExpr '+' MulExpr",
 610 | "AddExpr : AddExpr '-' MulExpr",
 611 | "RelOp : LESSTHANOREQUAL",
 612 | "RelOp : GREATERTHANOREQUAL",
 613 | "RelOp : '<'",
 614 | "RelOp : '>'",
 615 | "RelExpr : AddExpr",
 616 | "RelExpr : RelExpr RelOp AddExpr",
 617 | "EqExpr : RelExpr",
 618 | "EqExpr : EqExpr ISEQUALTO RelExpr",
 619 | "EqExpr : EqExpr NOTEQUALTO RelExpr",
 620 | "CondAndExpr : EqExpr",
 621 | "CondAndExpr : CondAndExpr LOGICALAND EqExpr",
 622 | "CondOrExpr : CondAndExpr",
 623 | "CondOrExpr : CondOrExpr LOGICALOR CondAndExpr",
 624 | "ArrayAccess : Name '[' Expr ']'",
 625 | "Expr : CondOrExpr",
 626 | "Expr : Assignment",
 627 | "Assignment : LeftHandSide AssignOp Expr",
 628 | "LeftHandSide : Name",
 629 | "LeftHandSide : FieldAccess",
 630 | "LeftHandSide : ArrayAccess",
 631 | "AssignOp : '='",
 632 | "AssignOp : INCREMENT",
 633 | "AssignOp : DECREMENT",
 634 | };
 635 | 
 636 | //###############################################################
 637 | // method: yylexdebug : check lexer state
 638 | //###############################################################
 639 | void yylexdebug(int state,int ch)
 640 | {
 641 | String s=null;
 642 |   if (ch < 0) ch=0;
 643 |   if (ch <= YYMAXTOKEN) //check index bounds
 644 |      s = yyname[ch];    //now get it
 645 |   if (s==null)
 646 |     s = "illegal-symbol";
 647 |   debug("state "+state+", reading "+ch+" ("+s+")");
 648 | }
 649 | 
 650 | 
 651 | 
 652 | 
 653 | 
 654 | //The following are now global, to aid in error reporting
 655 | int yyn;       //next next thing to do
 656 | int yym;       //
 657 | int yystate;   //current parsing state from state table
 658 | String yys;    //current token string
 659 | 
 660 | 
 661 | //###############################################################
 662 | // method: yyparse : parse input and execute indicated items
 663 | //###############################################################
 664 | int yyparse()
 665 | {
 666 | boolean doaction;
 667 |   init_stacks();
 668 |   yynerrs = 0;
 669 |   yyerrflag = 0;
 670 |   yychar = -1;          //impossible char forces a read
 671 |   yystate=0;            //initial state
 672 |   state_push(yystate);  //save it
 673 |   val_push(yylval);     //save empty value
 674 |   while (true) //until parsing is done, either correctly, or w/error
 675 |     {
 676 |     doaction=true;
 677 |     if (yydebug) debug("loop"); 
 678 |     //#### NEXT ACTION (from reduction table)
 679 |     for (yyn=yydefred[yystate];yyn==0;yyn=yydefred[yystate])
 680 |       {
 681 |       if (yydebug) debug("yyn:"+yyn+"  state:"+yystate+"  yychar:"+yychar);
 682 |       if (yychar < 0)      //we want a char?
 683 |         {
 684 |         yychar = yylex();  //get next token
 685 |         if (yydebug) debug(" next yychar:"+yychar);
 686 |         //#### ERROR CHECK ####
 687 |         if (yychar < 0)    //it it didn't work/error
 688 |           {
 689 |           yychar = 0;      //change it to default string (no -1!)
 690 |           if (yydebug)
 691 |             yylexdebug(yystate,yychar);
 692 |           }
 693 |         }//yychar<0
 694 |       yyn = yysindex[yystate];  //get amount to shift by (shift index)
 695 |       if ((yyn != 0) && (yyn += yychar) >= 0 &&
 696 |           yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
 697 |         {
 698 |         if (yydebug)
 699 |           debug("state "+yystate+", shifting to state "+yytable[yyn]);
 700 |         //#### NEXT STATE ####
 701 |         yystate = yytable[yyn];//we are in a new state
 702 |         state_push(yystate);   //save it
 703 |         val_push(yylval);      //push our lval as the input for next rule
 704 |         yychar = -1;           //since we have 'eaten' a token, say we need another
 705 |         if (yyerrflag > 0)     //have we recovered an error?
 706 |            --yyerrflag;        //give ourselves credit
 707 |         doaction=false;        //but don't process yet
 708 |         break;   //quit the yyn=0 loop
 709 |         }
 710 | 
 711 |     yyn = yyrindex[yystate];  //reduce
 712 |     if ((yyn !=0 ) && (yyn += yychar) >= 0 &&
 713 |             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
 714 |       {   //we reduced!
 715 |       if (yydebug) debug("reduce");
 716 |       yyn = yytable[yyn];
 717 |       doaction=true; //get ready to execute
 718 |       break;         //drop down to actions
 719 |       }
 720 |     else //ERROR RECOVERY
 721 |       {
 722 |       if (yyerrflag==0)
 723 |         {
 724 |         yyerror("syntax error");
 725 |         yynerrs++;
 726 |         }
 727 |       if (yyerrflag < 3) //low error count?
 728 |         {
 729 |         yyerrflag = 3;
 730 |         while (true)   //do until break
 731 |           {
 732 |           if (stateptr<0)   //check for under & overflow here
 733 |             {
 734 |             yyerror("stack underflow. aborting...");  //note lower case 's'
 735 |             return 1;
 736 |             }
 737 |           yyn = yysindex[state_peek(0)];
 738 |           if ((yyn != 0) && (yyn += YYERRCODE) >= 0 &&
 739 |                     yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
 740 |             {
 741 |             if (yydebug)
 742 |               debug("state "+state_peek(0)+", error recovery shifting to state "+yytable[yyn]+" ");
 743 |             yystate = yytable[yyn];
 744 |             state_push(yystate);
 745 |             val_push(yylval);
 746 |             doaction=false;
 747 |             break;
 748 |             }
 749 |           else
 750 |             {
 751 |             if (yydebug)
 752 |               debug("error recovery discarding state "+state_peek(0)+" ");
 753 |             if (stateptr<0)   //check for under & overflow here
 754 |               {
 755 |               yyerror("Stack underflow. aborting...");  //capital 'S'
 756 |               return 1;
 757 |               }
 758 |             state_pop();
 759 |             val_pop();
 760 |             }
 761 |           }
 762 |         }
 763 |       else            //discard this token
 764 |         {
 765 |         if (yychar == 0)
 766 |           return 1; //yyabort
 767 |         if (yydebug)
 768 |           {
 769 |           yys = null;
 770 |           if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
 771 |           if (yys == null) yys = "illegal-symbol";
 772 |           debug("state "+yystate+", error recovery discards token "+yychar+" ("+yys+")");
 773 |           }
 774 |         yychar = -1;  //read another
 775 |         }
 776 |       }//end error recovery
 777 |     }//yyn=0 loop
 778 |     if (!doaction)   //any reason not to proceed?
 779 |       continue;      //skip action
 780 |     yym = yylen[yyn];          //get count of terminals on rhs
 781 |     if (yydebug)
 782 |       debug("state "+yystate+", reducing "+yym+" by rule "+yyn+" ("+yyrule[yyn]+")");
 783 |     if (yym>0)                 //if count of rhs not 'nil'
 784 |       yyval = val_peek(yym-1); //get current semantic value
 785 |     yyval = dup_yyval(yyval); //duplicate yyval if ParserVal is used as semantic value
 786 |     switch(yyn)
 787 |       {
 788 | //########## USER-SUPPLIED ACTIONS ##########
 789 | case 1:
 790 | //#line 8 "j0gram.y"
 791 | {
 792 |   yyval=j0.node("ClassDecl",1000,val_peek(1),val_peek(0));
 793 |   j0.semantic(yyval);
 794 |   j0.gencode(yyval);
 795 |  }
 796 | break;
 797 | case 2:
 798 | //#line 13 "j0gram.y"
 799 | { yyval=j0.node("ClassBody",1010,val_peek(1)); }
 800 | break;
 801 | case 3:
 802 | //#line 14 "j0gram.y"
 803 | { yyval=j0.node("ClassBody",1011); }
 804 | break;
 805 | case 5:
 806 | //#line 16 "j0gram.y"
 807 | {
 808 |   yyval=j0.node("ClassBodyDecls",1020,val_peek(1),val_peek(0)); }
 809 | break;
 810 | case 9:
 811 | //#line 19 "j0gram.y"
 812 | {
 813 |   yyval=j0.node("FieldDecl",1030,val_peek(2),val_peek(1));
 814 |   j0.calctype(yyval);
 815 |   }
 816 | break;
 817 | case 17:
 818 | //#line 26 "j0gram.y"
 819 | {
 820 |   yyval=j0.node("QualifiedName",1040,val_peek(2),val_peek(0));}
 821 | break;
 822 | case 19:
 823 | //#line 29 "j0gram.y"
 824 | {
 825 |   yyval=j0.node("VarDecls",1050,val_peek(2),val_peek(0)); }
 826 | break;
 827 | case 21:
 828 | //#line 31 "j0gram.y"
 829 | {
 830 |   yyval=j0.node("VarDeclarator",1060,val_peek(2)); }
 831 | break;
 832 | case 24:
 833 | //#line 35 "j0gram.y"
 834 | {
 835 |   yyval=j0.node("MethodDecl",1380,val_peek(1),val_peek(0));
 836 |  }
 837 | break;
 838 | case 25:
 839 | //#line 38 "j0gram.y"
 840 | {
 841 |   yyval=j0.node("MethodHeader",1070,val_peek(1),val_peek(0));
 842 |   j0.calctype(yyval);
 843 |   }
 844 | break;
 845 | case 26:
 846 | //#line 42 "j0gram.y"
 847 | {
 848 |   yyval=j0.node("MethodDeclarator",1080,val_peek(3),val_peek(1)); }
 849 | break;
 850 | case 30:
 851 | //#line 46 "j0gram.y"
 852 | {
 853 |   yyval=j0.node("FormalParmList",1090,val_peek(2),val_peek(0)); }
 854 | break;
 855 | case 31:
 856 | //#line 48 "j0gram.y"
 857 | {
 858 |   yyval=j0.node("FormalParm",1100,val_peek(1),val_peek(0));
 859 |   j0.calctype(yyval);
 860 |  }
 861 | break;
 862 | case 32:
 863 | //#line 53 "j0gram.y"
 864 | {
 865 |   yyval=j0.node("ConstructorDecl",1110,val_peek(1),val_peek(0)); }
 866 | break;
 867 | case 33:
 868 | //#line 56 "j0gram.y"
 869 | {yyval=j0.node("Block",1200,val_peek(1));}
 870 | break;
 871 | case 37:
 872 | //#line 58 "j0gram.y"
 873 | {
 874 |   yyval=j0.node("BlockStmts",1130,val_peek(1),val_peek(0)); }
 875 | break;
 876 | case 41:
 877 | //#line 63 "j0gram.y"
 878 | {
 879 |   yyval=j0.node("LocalVarDecl",1140,val_peek(1),val_peek(0));
 880 |   j0.calctype(yyval);
 881 |   }
 882 | break;
 883 | case 55:
 884 | //#line 76 "j0gram.y"
 885 | {
 886 |   yyval=j0.node("IfThenStmt",1150,val_peek(2),val_peek(0)); }
 887 | break;
 888 | case 56:
 889 | //#line 78 "j0gram.y"
 890 | {
 891 |   yyval=j0.node("IfThenElseStmt",1160,val_peek(4),val_peek(2),val_peek(0)); }
 892 | break;
 893 | case 57:
 894 | //#line 80 "j0gram.y"
 895 | {
 896 |   yyval=j0.node("IfThenElseIfStmt",1170,val_peek(3),val_peek(1),val_peek(0)); }
 897 | break;
 898 | case 58:
 899 | //#line 82 "j0gram.y"
 900 | {
 901 |   yyval=j0.node("IfThenElseIfStmt",1171,val_peek(5),val_peek(3),val_peek(2),val_peek(0)); }
 902 | break;
 903 | case 60:
 904 | //#line 85 "j0gram.y"
 905 | {
 906 |   yyval=j0.node("ElseIfSequence",1180,val_peek(1),val_peek(0)); }
 907 | break;
 908 | case 61:
 909 | //#line 87 "j0gram.y"
 910 | {
 911 |   yyval=j0.node("ElseIfStmt",1190,val_peek(0)); }
 912 | break;
 913 | case 62:
 914 | //#line 89 "j0gram.y"
 915 | {
 916 |   yyval=j0.node("WhileStmt",1210,val_peek(2),val_peek(0)); }
 917 | break;
 918 | case 63:
 919 | //#line 92 "j0gram.y"
 920 | {
 921 |   yyval=j0.node("ForStmt",1220,val_peek(6),val_peek(4),val_peek(2),val_peek(0)); }
 922 | break;
 923 | case 72:
 924 | //#line 98 "j0gram.y"
 925 | {
 926 |   yyval=j0.node("StmtExprList",1230,val_peek(2),val_peek(0)); }
 927 | break;
 928 | case 74:
 929 | //#line 101 "j0gram.y"
 930 | {
 931 |   yyval=j0.node("BreakStmt",1240,val_peek(1)); }
 932 | break;
 933 | case 75:
 934 | //#line 103 "j0gram.y"
 935 | {
 936 |   yyval=j0.node("ReturnStmt",1250,val_peek(1)); }
 937 | break;
 938 | case 85:
 939 | //#line 108 "j0gram.y"
 940 | { yyval=val_peek(1);}
 941 | break;
 942 | case 88:
 943 | //#line 109 "j0gram.y"
 944 | {
 945 |   yyval=j0.node("InstanceCreation", 1261, val_peek(3), val_peek(1)); }
 946 | break;
 947 | case 89:
 948 | //#line 111 "j0gram.y"
 949 | {
 950 |   yyval=j0.node("ArrayCreation", 1260, val_peek(3), val_peek(1)); }
 951 | break;
 952 | case 91:
 953 | //#line 114 "j0gram.y"
 954 | {
 955 |   yyval=j0.node("ArgList",1270,val_peek(2),val_peek(0)); }
 956 | break;
 957 | case 92:
 958 | //#line 116 "j0gram.y"
 959 | {
 960 |   yyval=j0.node("FieldAccess",1280,val_peek(2),val_peek(0)); }
 961 | break;
 962 | case 95:
 963 | //#line 120 "j0gram.y"
 964 | {
 965 |   yyval=j0.node("MethodCall",1290,val_peek(3),val_peek(1)); }
 966 | break;
 967 | case 96:
 968 | //#line 122 "j0gram.y"
 969 | {
 970 |     yyval=j0.node("MethodCall",1291,val_peek(5),val_peek(3),val_peek(1)); }
 971 | break;
 972 | case 99:
 973 | //#line 127 "j0gram.y"
 974 | {
 975 |   yyval=j0.node("UnaryExpr",1300,val_peek(1),val_peek(0)); }
 976 | break;
 977 | case 100:
 978 | //#line 129 "j0gram.y"
 979 | {
 980 |   yyval=j0.node("UnaryExpr",1301,val_peek(1),val_peek(0)); }
 981 | break;
 982 | case 103:
 983 | //#line 133 "j0gram.y"
 984 | {
 985 |       yyval=j0.node("MulExpr",1310,val_peek(2),val_peek(0)); }
 986 | break;
 987 | case 104:
 988 | //#line 135 "j0gram.y"
 989 | {
 990 |       yyval=j0.node("MulExpr",1311,val_peek(2),val_peek(0)); }
 991 | break;
 992 | case 105:
 993 | //#line 137 "j0gram.y"
 994 | {
 995 |       yyval=j0.node("MulExpr",1312,val_peek(2),val_peek(0)); }
 996 | break;
 997 | case 107:
 998 | //#line 140 "j0gram.y"
 999 | {
1000 |       yyval=j0.node("AddExpr",1320,val_peek(2),val_peek(0)); }
1001 | break;
1002 | case 108:
1003 | //#line 142 "j0gram.y"
1004 | {
1005 |       yyval=j0.node("AddExpr",1321,val_peek(2),val_peek(0)); }
1006 | break;
1007 | case 114:
1008 | //#line 145 "j0gram.y"
1009 | {
1010 |   yyval=j0.node("RelExpr",1330,val_peek(2),val_peek(1),val_peek(0)); }
1011 | break;
1012 | case 116:
1013 | //#line 149 "j0gram.y"
1014 | {
1015 |   yyval=j0.node("EqExpr",1340,val_peek(2),val_peek(0)); }
1016 | break;
1017 | case 117:
1018 | //#line 151 "j0gram.y"
1019 | {
1020 |   yyval=j0.node("EqExpr",1341,val_peek(2),val_peek(0)); }
1021 | break;
1022 | case 119:
1023 | //#line 153 "j0gram.y"
1024 | {
1025 |   yyval=j0.node("CondAndExpr", 1350, val_peek(2), val_peek(0)); }
1026 | break;
1027 | case 121:
1028 | //#line 155 "j0gram.y"
1029 | {
1030 |   yyval=j0.node("CondOrExpr", 1360, val_peek(2), val_peek(0)); }
1031 | break;
1032 | case 122:
1033 | //#line 158 "j0gram.y"
1034 | { yyval=j0.node("ArrayAccess",1390,val_peek(3),val_peek(1)); }
1035 | break;
1036 | case 125:
1037 | //#line 161 "j0gram.y"
1038 | {
1039 |   yyval=j0.node("Assignment",1370, val_peek(2), val_peek(1), val_peek(0)); }
1040 | break;
1041 | //#line 962 "parser.java"
1042 | //########## END OF USER-SUPPLIED ACTIONS ##########
1043 |     }//switch
1044 |     //#### Now let's reduce... ####
1045 |     if (yydebug) debug("reduce");
1046 |     state_drop(yym);             //we just reduced yylen states
1047 |     yystate = state_peek(0);     //get new state
1048 |     val_drop(yym);               //corresponding value drop
1049 |     yym = yylhs[yyn];            //select next TERMINAL(on lhs)
1050 |     if (yystate == 0 && yym == 0)//done? 'rest' state and at first TERMINAL
1051 |       {
1052 |       if (yydebug) debug("After reduction, shifting from state 0 to state "+YYFINAL+"");
1053 |       yystate = YYFINAL;         //explicitly say we're done
1054 |       state_push(YYFINAL);       //and save it
1055 |       val_push(yyval);           //also save the semantic value of parsing
1056 |       if (yychar < 0)            //we want another character?
1057 |         {
1058 |         yychar = yylex();        //get next character
1059 |         if (yychar<0) yychar=0;  //clean, if necessary
1060 |         if (yydebug)
1061 |           yylexdebug(yystate,yychar);
1062 |         }
1063 |       if (yychar == 0)          //Good exit (if lex returns 0 ;-)
1064 |          break;                 //quit the loop--all DONE
1065 |       }//if yystate
1066 |     else                        //else not done yet
1067 |       {                         //get next state and push, for next yydefred[]
1068 |       yyn = yygindex[yym];      //find out where to go
1069 |       if ((yyn != 0) && (yyn += yystate) >= 0 &&
1070 |             yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
1071 |         yystate = yytable[yyn]; //get new state
1072 |       else
1073 |         yystate = yydgoto[yym]; //else go to new defred
1074 |       if (yydebug) debug("after reduction, shifting from state "+state_peek(0)+" to state "+yystate+"");
1075 |       state_push(yystate);     //going again, so push state & val...
1076 |       val_push(yyval);         //for next action
1077 |       }
1078 |     }//main loop
1079 |   return 0;//yyaccept!!
1080 | }
1081 | //## end of method parse() ######################################
1082 | 
1083 | 
1084 | 
1085 | //## run() --- for Thread #######################################
1086 | /**
1087 |  * A default run method, used for operating this parser
1088 |  * object in the background.  It is intended for extending Thread
1089 |  * or implementing Runnable.  Turn off with -Jnorun .
1090 |  */
1091 | public void run()
1092 | {
1093 |   yyparse();
1094 | }
1095 | //## end of method run() ########################################
1096 | 
1097 | 
1098 | 
1099 | //## Constructors ###############################################
1100 | /**
1101 |  * Default constructor.  Turn off with -Jnoconstruct .
1102 | 
1103 |  */
1104 | public parser()
1105 | {
1106 |   //nothing to do
1107 | }
1108 | 
1109 | 
1110 | /**
1111 |  * Create a parser, setting the debug to true or false.
1112 |  * @param debugMe true for debugging, false for no debug.
1113 |  */
1114 | public parser(boolean debugMe)
1115 | {
1116 |   yydebug=debugMe;
1117 | }
1118 | //###############################################################
1119 | 
1120 | 
1121 | 
1122 | }
1123 | //################### END OF CLASS ##############################
1124 | 


--------------------------------------------------------------------------------
/ch9/parserVal.java:
--------------------------------------------------------------------------------
 1 | //#############################################
 2 | //## file: parser.java
 3 | //## Generated by Byacc/j
 4 | //#############################################
 5 | package ch9;
 6 | 
 7 | /**
 8 |  * BYACC/J Semantic Value for parser: parser
 9 |  * This class provides some of the functionality
10 |  * of the yacc/C 'union' directive
11 |  */
12 | public class parserVal
13 | {
14 | /**
15 |  * integer value of this 'union'
16 |  */
17 | public int ival;
18 | 
19 | /**
20 |  * double value of this 'union'
21 |  */
22 | public double dval;
23 | 
24 | /**
25 |  * string value of this 'union'
26 |  */
27 | public String sval;
28 | 
29 | /**
30 |  * object value of this 'union'
31 |  */
32 | public Object obj;
33 | 
34 | //#############################################
35 | //## C O N S T R U C T O R S
36 | //#############################################
37 | /**
38 |  * Initialize me without a value
39 |  */
40 | public parserVal()
41 | {
42 | }
43 | /**
44 |  * Initialize me as an int
45 |  */
46 | public parserVal(int val)
47 | {
48 |   ival=val;
49 | }
50 | 
51 | /**
52 |  * Initialize me as a double
53 |  */
54 | public parserVal(double val)
55 | {
56 |   dval=val;
57 | }
58 | 
59 | /**
60 |  * Initialize me as a string
61 |  */
62 | public parserVal(String val)
63 | {
64 |   sval=val;
65 | }
66 | 
67 | /**
68 |  * Initialize me as an Object
69 |  */
70 | public parserVal(Object val)
71 | {
72 |   obj=val;
73 | }
74 | }//end class
75 | 
76 | //#############################################
77 | //## E N D    O F    F I L E
78 | //#############################################
79 | 


--------------------------------------------------------------------------------
/ch9/serial.icn:
--------------------------------------------------------------------------------
1 | class serial(serialno)
2 |    method getid()
3 |       serialno +:= 1; return serialno
4 |    end
5 | initially
6 |     serialno := 0
7 | end
8 | 


--------------------------------------------------------------------------------
/ch9/serial.java:
--------------------------------------------------------------------------------
1 | package ch9;
2 | class serial {
3 |     static int serial;
4 |     public static int getid(){ serial++; return serial; }
5 | }
6 | 


--------------------------------------------------------------------------------
/ch9/symtab.icn:
--------------------------------------------------------------------------------
 1 | class symtab(scope, parent, t, count)
 2 |   method lookup(s)
 3 |     return if rv := \ (t[s]) then {
 4 |               rv }
 5 |            else {
 6 |              (\parent).lookup(s)
 7 |              }
 8 |   end
 9 |   method insert(s, isConst, sub, typ)
10 |     if \ (t[s]) then {
11 |       if scope == "strings" then {
12 | #         write("eureka, a duplicate string constant")
13 |          }
14 |       else
15 |          j0.semErr("redeclaration of " || s)
16 |       }
17 |     else {
18 |       (\sub).parent := self
19 |       t[s] := symtab_entry(s, self, sub, isConst, typ,
20 |                            address(scope,count))
21 |       count +:= 8
22 |       }
23 |   end
24 |   method genlocal()
25 |   local s := "__local
quot; || count
26 |     insert(s, false, , typeinfo("int"))
27 |     return t[s].addr
28 |   end
29 |   method print(level:0)
30 |     writes(repl(" ",level))
31 |     write(scope, " - ", *t, " symbols")
32 |     every (!t).print(level+1);
33 |   end
34 | 
35 | initially
36 |   t := table()
37 |   count := 0
38 | end
39 | 


--------------------------------------------------------------------------------
/ch9/symtab.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | import java.util.HashMap;
 3 | public class symtab {
 4 |    String scope;
 5 |    symtab parent;
 6 |    HashMap<String,symtab_entry> t;
 7 |    int count;
 8 |    symtab(String sc) {
 9 |       scope = sc;
10 |       t = new HashMap<String,symtab_entry>();
11 |    }
12 |     symtab(String sc, symtab p) {
13 |       scope = sc; parent = p;
14 |       t = new HashMap<String,symtab_entry>();
15 |    }
16 |    symtab_entry lookup(String s) {
17 |        symtab_entry rv;
18 |        rv = t.get(s);
19 |        if (rv != null) {
20 | 	   return rv;
21 |        }
22 |       if (parent != null) return parent.lookup(s);
23 |       return null;
24 |    }
25 |    void insert(String s, Boolean iC, symtab sub, typeinfo typ) {
26 |       if (t.containsKey(s)) {
27 |          j0.semErr("redeclaration of " + s);
28 |       } else {
29 |          if (sub != null)
30 |             sub.parent = this;
31 |          t.put(s, new symtab_entry(s, this, iC, sub, typ,
32 | 				   new address(scope,count)));
33 | 	 count += 8;
34 |       }
35 |    }
36 |    address genlocal() {
37 |       String s = "__local
quot; + count;
38 |       insert(s, false, null, new typeinfo("int"));
39 |       return t.get(s).addr;
40 |    }
41 |    void insert(String s, Boolean iC) {
42 |       if (t.containsKey(s)) {
43 |          j0.semErr("redeclaration of " + s);
44 |       } else {
45 |          t.put(s, new symtab_entry(s, this, iC));
46 |       }
47 |    }
48 |    void print() { print(0); }
49 |    void print(int level) {
50 |       for(int i=0; i<level; i++)
51 |         System.out.print(" ");
52 |       System.out.println(scope + " - " + t.size() + " symbols");
53 |       for(symtab_entry se : t.values()) se.print(level+1);
54 |    }
55 | }
56 | 


--------------------------------------------------------------------------------
/ch9/symtab_entry.icn:
--------------------------------------------------------------------------------
 1 | class symtab_entry(sym,parent_st,st,isConst,typ,addr)
 2 |   method print(level:0)
 3 |     writes(repl(" ",level), sym)
 4 |     if \isconst then writes(" (const)")
 5 |     if \typ then writes(" ", typ.str())
 6 |     write()
 7 |     (\st).print(level+1);
 8 |   end
 9 | end
10 | 


--------------------------------------------------------------------------------
/ch9/symtab_entry.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class symtab_entry {
 3 |    String sym;
 4 |    symtab parent_st, st;
 5 |    boolean isConst;
 6 |    typeinfo typ;
 7 |    address addr;
 8 |    void print(int level) {
 9 |       for(int i=0; i<level; i++) System.out.print(" ");
10 |       System.out.print(sym);
11 |       if (isConst) System.out.print(" (const)");
12 |       System.out.println("");
13 |       if (st != null) st.print(level+1);
14 |    }
15 |    symtab_entry(String s, symtab p, boolean iC) {
16 |        sym = s; parent_st = p; isConst = iC; }
17 |    symtab_entry(String s, symtab p, boolean iC,
18 | 		symtab t, typeinfo ti, address a) {
19 |       sym = s; parent_st = p; isConst = iC;
20 |       st = t; typ = ti; addr = a;
21 |  }
22 | }
23 | 


--------------------------------------------------------------------------------
/ch9/tac.icn:
--------------------------------------------------------------------------------
 1 | class tac(op, op1, op2, op3)
 2 |    method print()
 3 |       case op of {
 4 |       "proc": write(op || "\t" || op1.region || ",0,0")
 5 | 			     # || op2.str() || "," || op3.str());
 6 |       "end"|".code"|".global"|".string": write(op)
 7 |       "LAB": write("L",op1.offset,":")
 8 |       default: {
 9 | 	  writes("\t" || op)
10 | 	  if \op1 then {
11 |              writes("\t")
12 |              if string(op1) then {
13 |                 if ste := stringtab.lookup(op1) then writes("str:", ste.addr.offset)
14 |                 else writes(op1)
15 |                 }
16 |              else
17 | 	        writes(op1.str())
18 | 	     if \op2 then
19 | 	        writes("," || (string(op2)|op2.str()))
20 | 	     if \op3 then
21 | 	        writes("," || op3.str())
22 | 	     }
23 | 	  write()
24 | 	  }
25 |       }
26 |    end
27 | end
28 | 


--------------------------------------------------------------------------------
/ch9/tac.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class tac {
 3 |    String op;
 4 |    address op1, op2, op3;
 5 |    public void print() {
 6 |       switch (op) {
 7 |       case "proc":
 8 | 	  System.out.println(op + "\t" + op1.region + ",0,0");
 9 | 			     // + op2.str() + "," + op3.str());
10 | 	  break;
11 |       case "end":
12 |       case ".code":
13 |       case ".global":
14 |       case ".string":
15 | 	  System.out.println(op);
16 | 	  break;
17 |       case "LAB": System.out.println("L" + op1.offset + ":");
18 | 	  break;
19 |       default:
20 | 	  System.out.print("\t" + op + "\t");
21 | 	  if (op1 != null)
22 | 	     System.out.print(op1.str());
23 | 	  if (op2 != null)
24 | 	      System.out.print("," + op2.str());
25 | 	  if (op3 != null)
26 | 	      System.out.print("," + op3.str());
27 | 	  System.out.println("");
28 |       }
29 |    }
30 |    tac(String s) { op = s; }
31 |    tac(String s, address o) { op = s; op1 = o; }
32 |    tac(String s, address o1, address o2) {
33 |       op = s; op1 = o1; op2 = o2; }
34 |    tac(String s, address o1, address o2, address o3) {
35 |       op = s; op1 = o1; op2 = o2; op3 = o3; }
36 | }
37 | 


--------------------------------------------------------------------------------
/ch9/token.icn:
--------------------------------------------------------------------------------
 1 | class token(cat, text, lineno, colno, ival, dval, sval, typ, isPublic, isStatic)
 2 |    method deEscape(sin)
 3 |       local sout := ""
 4 |       sin := sin[2:-1]
 5 |       sin ? {
 6 |          while c := move(1) do {
 7 |             if c == "\\" then {
 8 |                if not (c := move(1)) then
 9 |                   j0.lexErr("malformed string literal")
10 |                else case c of {
11 |                   "t":{ sout ||:= "\t" }
12 |                   "n":{ sout ||:= "\n" }
13 |                   }
14 |             }
15 |             else sout ||:= c
16 |          }
17 |       }
18 |       return sout
19 |    end
20 | method type(stab)
21 |   if \typ then return typ
22 |   if cat === parser.IDENTIFIER then
23 |     if rv := stab.lookup(text) then return typ := rv.typ
24 |     else stop("line ", lineno ,": cannot check type of undeclared ", image(text))
25 | end
26 | initially
27 |    case cat of {
28 |      parser.INT:     typ := typeinfo("int")
29 |      parser.DOUBLE:  typ := typeinfo("double")
30 |      parser.BOOLEAN: typ := typeinfo("boolean")
31 |      parser.VOID:    typ := typeinfo("void")
32 |      parser.INTLIT: { ival := integer(text); typ:=typeinfo("int") }
33 |      parser.DOUBLELIT: { dval := real(text); typ:=typeinfo("double") }
34 |      parser.STRINGLIT: { sval := deEscape(text); typ:=classtype("String") }
35 |      parser.BOOLLIT: { typ := typeinfo("boolean") }
36 |      parser.NULLVAL: { typ := typeinfo("null") }
37 |      ord("="|"+"|"-"): { typ := typeinfo("n/a") }
38 |    }
39 | end
40 | 


--------------------------------------------------------------------------------
/ch9/token.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class token {
 3 |   public int id;
 4 |   public int cat;
 5 |   public String text;
 6 |   public int lineno;
 7 |   public typeinfo typ;
 8 |   public token(int c, String s, int l) {
 9 |     cat = c; text = s; lineno = l;
10 |     id = serial.getid();
11 |     switch (cat) {
12 |     case parser.INT: typ = new typeinfo("int"); break;
13 |     case parser.DOUBLE: typ = new typeinfo("double"); break;
14 |     case parser.BOOLEAN: typ = new typeinfo("boolean"); break;
15 |     case parser.VOID: typ = new typeinfo("void"); break;
16 |     case parser.INTLIT: typ = new typeinfo("int"); break;
17 |     case parser.DOUBLELIT: typ = new typeinfo("double"); break;
18 |     case parser.STRINGLIT: typ = new typeinfo("String"); break;
19 |     case parser.BOOLLIT: typ = new typeinfo("boolean"); break;
20 |     case parser.NULLVAL: typ = new typeinfo("null"); break;
21 |     case '=': case '+': case '-': typ = new typeinfo("n/a"); break;
22 |     }
23 |    }
24 | public typeinfo type(symtab stab) {
25 |   symtab_entry rv;
26 |   if (typ != null) return typ;
27 |   if (cat == parser.IDENTIFIER)
28 |       if ((rv = stab.lookup(text)) != null) return typ=rv.typ;
29 |   j0.semErr("cannot check the type of " + text);
30 |   return null;
31 | }
32 | }
33 | 


--------------------------------------------------------------------------------
/ch9/tree.icn:
--------------------------------------------------------------------------------
  1 | class tree (id,sym,rule,nkids,tok,kids,isConst,stab,
  2 | 	    typ,icode,addr,first,follow,onTrue,onFalse)
  3 |   method print(level:0)
  4 |     writes(repl(" ",level))
  5 |     if \tok then {
  6 |       write(id, "  ", tok.text, " (",tok.cat, "): ",tok.lineno)
  7 |       }
  8 |     else {
  9 |        write(id, "   ", sym, " (", rule, "): ", nkids)
 10 |        every (!kids).print(level+1)
 11 |        }
 12 |   end
 13 |   method print_graph(fw)
 14 |     if type(filename) == "string" then {
 15 |       fw := open(filename,  "w") |
 16 |         stop("can't open ", image(filename), " for writing")
 17 |       write(fw, "digraph {")
 18 |       print_graph(fw)
 19 |       write(fw, "}")
 20 |       close(fw)
 21 |     }
 22 |     else if \tok then print_leaf(fw)
 23 |     else { 
 24 |       print_branch(fw)
 25 |       every i := 1 to nkids do
 26 |         if \kids[i] then {
 27 |           write(fw, "N",id," -> N",kids[i].id,";")
 28 |           kids[i].print_graph(fw)
 29 |         } else {
 30 |           write(fw, "N",id," -> N",id,"_",j,";")
 31 |           write(fw, "N", id, "_", j,
 32 |                     " [label=\"Empty rule\"];")
 33 |           j +:= 1
 34 |         }
 35 |     }
 36 |   end
 37 |   method print_leaf(pw)
 38 |     local s := parser.yyname[tok.cat]
 39 |     print_branch(pw)
 40 |     write(pw,"N",id,
 41 |           " [shape=box style=dotted label=\" ",s," \\n ")
 42 |     write(pw,"text = ",escape(tok.text)," \\l lineno = ",
 43 |              tok.lineno," \\l\"];\n")
 44 |   end
 45 |   method print_branch(pw)
 46 |     write(pw, "N",id," [shape=box label=\"",
 47 |           pretty_print_name(),"\"];\n");
 48 |   end
 49 |   method escape(s)
 50 |     if s[1] == "\"" then
 51 |       return "\\" || s[1:-1] || "\\\""
 52 |     else return s
 53 |   end
 54 |   method pretty_print_name()
 55 |     if /tok then return sym || "#" || (rule%10)
 56 |     else return escape(tok.text) || ":" || tok.cat
 57 |   end
 58 |   method mkSymTables(curr)
 59 |     stab := curr
 60 |     case sym of {
 61 |       "ClassDecl": { curr := symtab("class",curr) }
 62 |       "MethodDecl": { curr := symtab("method",curr) }
 63 |     }
 64 |     every (!\kids).mkSymTables(curr)
 65 |   end
 66 |   method populateSymTables()
 67 |   case sym of {
 68 |     "ClassDecl": {
 69 |        stab.insert(kids[1].tok.text, , kids[1].stab) # new classtype() ?
 70 |        }
 71 |     "FieldDecl" | "LocalVarDecl" : {
 72 |        k := kids[2]
 73 |        while \k & k.sym=="VarDecls" do {
 74 |          insert_vardeclarator(k.kids[2])
 75 |          k := k.kids[1]
 76 |          }
 77 |        insert_vardeclarator(k); return
 78 |        }
 79 |     "MethodDecl": {
 80 |       stab.insert(kids[1].kids[2].kids[1].tok.text, ,kids[1].stab,
 81 | 	          kids[1].kids[2].typ)
 82 |       kids[1].stab.insert("return", , , kids[1].kids[1].typ)
 83 |       }
 84 |     "FormalParm": { insert_vardeclarator(kids[2]); return }
 85 |     }
 86 |     every (!\kids).populateSymTables()
 87 |   end
 88 |   method insert_vardeclarator(vd)
 89 |     if \vd.tok then stab.insert(vd.tok.text,&null,&null,vd.typ)
 90 |     else insert_vardeclarator(vd.kids[1])
 91 |   end
 92 |   method calc_isConst()
 93 |    every (!\kids).calc_isConst()
 94 |    case sym of {
 95 |       "INTLIT" | "DOUBLELIT" | "STRINGLIT" |
 96 |       "BOOLFALSE" | "BOOLTRUE": isConst := "true"
 97 |       "UnaryExpr": isConst := \kid[2].isConst
 98 |       "RelExpr": isConst := \kid[1].isConst & \kid[3].isConst
 99 |       "CondOrExpr" | "CondAndExpr" | "EqExpr" |
100 |       "MULEXPR"|
101 |       "ADDEXPR": isConst := \kid[1].isConst & \kid[2].isConst
102 |       default: isConst := &null
103 |    }
104 |   end
105 |   # after symbol table population, we have enough information to fill in
106 |   # correct class type information.
107 |   method mkcls()
108 |     if sym == "ClassDecl" then {
109 |         rv := stab.lookup(kids[1].tok.text)
110 |         flds := []; methds := []; constrs := []
111 |         every k := key(rv.st.t) do
112 |            if match("method ", rv.st.t[k].typ.str()) then
113 |              put(methds, parameter(k, rv.st.t[k].typ))
114 |            else
115 |              put(flds, parameter(k, rv.st.t[k].typ))
116 |         (/(rv.typ) := classtype(kids[1].tok.text, rv.st, flds, methds, constrs))
117 |     }
118 |     else every k := !kids do
119 |       if k.nkids>0 then k.mkcls()
120 |   end
121 |   method checkSymTables()
122 |     check_codeblocks()
123 |   end
124 |   # this looks for undeclareds
125 |   method check_codeblocks()
126 |    if sym == "MethodDecl" then { kids[2].check_block() }
127 |    else every k := !kids do
128 |          if k.nkids>0 then k.check_codeblocks()
129 |   end
130 |   method check_block()
131 |    case sym of {
132 |    "IDENTIFIER": {
133 |      if not (stab.lookup(tok.text)) then
134 |         j0.semErr("undeclared variable "||tok.text)
135 |      }
136 |    "FieldAccess" | "QualifiedName": kids[1].check_block()
137 |    "MethodCall": {
138 |       kids[1].check_block()
139 |       if rule = 1290 then
140 |          kids[2].check_block()
141 |       else kids[3].check_block()
142 |      }
143 |    "LocalVarDecl": { } # skip
144 |    default:  {
145 |       every k := !\kids do {
146 |             k.check_block()
147 |          }
148 |       }
149 |    }
150 |   end
151 |   # calctype - synthesize the type of a variable declaration
152 |   method calctype()
153 |     every (!\kids).calctype()
154 |     case sym of {
155 |       "FieldDecl": typ := kids[1].typ
156 |       "token": {
157 |          if typ := \ (tok.typ) then return
158 |          case tok.cat of {
159 |          parser.IDENTIFIER:{
160 |            if \ (rv := (\stab).lookup(tok.text)) then {
161 |               if typ := \ (rv.typ) then
162 |                  return typ
163 |               }
164 |            return typ := classtype(tok.text)
165 |            }
166 |          default:
167 |            j0.semErr("can't grok the type of " || image(tok.text) ||
168 | 		     " cat " || tok.cat)
169 |          }
170 |       }
171 |     default:
172 |        j0.semErr("don't know how to calctype " || image(sym))
173 |     }
174 |   end
175 | 
176 |    # check a call against a signature
177 |    method cksig(sig)
178 |    local i:=*sig.parameters, nactual := 1, t := kids[2]
179 |      if /t then {
180 |        if i ~= 0 then stop("0 parameters, expected ", i)
181 |        }
182 |      else {
183 |        while t.sym == "ArgList" do { nactual +:= 1; t:=t.kids[1] }
184 |        if nactual ~= i then
185 |          stop(nactual, " parameters, expected ", i)
186 |        t := kids[2]
187 |        while t.sym == "ArgList" do {
188 |          check_types(t.kids[-1].typ, sig.parameters[i])
189 |          t := t.kids[1]; i-:=1
190 |          }
191 |        check_types(t.typ, sig.parameters[1])
192 |      }
193 |      typ := sig.return_type
194 |    end
195 | 
196 |   # return a list of types corresponding to a syntax subtree parameter list
197 |   method mksig()
198 |      case sym of {
199 |         "FormalParm": return [kids[1].typ]
200 |         "FormalParmList": return kids[1].mksig() ||| kids[2].mksig()
201 |         }
202 |   end
203 | 
204 |   # assigntype - inherit a type, typically into a variable declaration list
205 |   method assigntype(t)
206 |   local parmList
207 |     typ := t
208 |     case sym of {
209 |     "VarDeclarator": { # we have an ARRAY of whatever type t was
210 |       kids[1].assigntype(arraytype(t))
211 |       return
212 |     }
213 |     "MethodDeclarator": { # pass a return type into a method
214 |        parmList := (\ (kids[2]).mksig()) | []
215 |        kids[1].typ := typ := methodtype(parmList , t)
216 |        return
217 |     }
218 |     "token": {
219 |       case tok.cat of {
220 |          parser.IDENTIFIER: return
221 |          default: stop("eh? ", image(tok.cat))
222 |       }
223 |     }
224 |     default:
225 |        stop("don't know how to assign the type of ", image(sym))
226 |     }
227 |     every (!\kids).assigntype(t)
228 |   end
229 | 
230 | method checkkids(in_codeblock)
231 |     case sym of {
232 |        # turn on in executable StmtBlock
233 |        "MethodDecl": { kids[2].checktype(1); return }
234 |        # turn off in LocalVarDecl list...(back on in initializers, if any)
235 |        "LocalVarDecl": { kids[2].checktype(); return }
236 |        "FieldAccess": { kids[1].checktype(in_codeblock);
237 |           return }
238 |        "QualifiedName": { # has to be a type you can . on
239 |            kids[1].checktype(in_codeblock);
240 |        }
241 |        "RelExpr": {
242 |            kids[1].checktype(in_codeblock);
243 |            kids[3].checktype(in_codeblock);
244 |        }
245 |        default: { every (!\kids).checktype(in_codeblock) }
246 |        }
247 | end
248 | 
249 |   # given a qualifiedname, return its type
250 |   method dequalify()
251 |   local rv, ste
252 |     if kids[1].sym == "QualifiedName" then
253 |       rv := kids[1].dequalify()
254 |     else if kids[1].sym=="token" &
255 |             kids[1].tok.cat=parser.IDENTIFIER then {
256 |       if not \ (rv := stab.lookup(kids[1].tok.text)) then
257 |          j0.semErr("unknown symbol " || kids[1].tok.text)
258 |       rv := rv.typ
259 |     }
260 |     else j0.semErr("can't dequalify " || sym)
261 |     if rv.basetype ~== "class" then
262 |       j0.semErr("can't dequalify " || rv.basetype)
263 |     if \ (ste := rv.st.lookup(kids[2].tok.text)) then
264 |       return ste.typ
265 |     else j0.semErr("couldn't lookup " || kids[2].tok.text ||
266 | 		   " in " || rv.str())
267 | end
268 | 
269 |   # checktype - check, and determine, the type of each expression
270 |   method checktype(in_codeblock)
271 |     if checkkids(in_codeblock) then return
272 |     if /in_codeblock then return
273 |     case sym of {
274 |     "Assignment": typ := check_types(kids[1].typ, kids[3].typ)
275 |     "AddExpr": typ := check_types(kids[1].typ, kids[2].typ)
276 |     "RelExpr": typ := check_types(kids[1].typ, kids[3].typ)
277 |     "ArgList"|"Block" | "BlockStmts": { typ := &null }
278 |     "MethodCall": {
279 |       if rule = 1290 then {
280 |         if kids[1].sym == "QualifiedName" then {
281 |           rv := kids[1].dequalify()
282 |           cksig(rv)
283 |           }
284 |         else {
285 |            if kids[1].sym ~== "token" then
286 |               stop("can't check type of Name ", kids[1].sym)
287 |            if (\ (kids[1].tok)).cat == parser.IDENTIFIER then {
288 |               write("checking the type of a call to ", kids[1].tok.text)
289 |               if ( \ (rv := stab.lookup(kids[1].tok.text))) then {
290 |                  rv := rv.typ
291 | #make sure it is actually a method
292 |                  if not match("method ", rv.str()) then
293 |                    stop("method expected, got ", rv.str())
294 |                  cksig(rv)
295 | 		}
296 |               }
297 |            else stop("can't check the type of token ", kids[1].tok.cat)
298 | }
299 |            }
300 |         else stop("Jzero does not handle complex calls")
301 |     }
302 |     "QualifiedName": {
303 |        # get my type by look up kid #2 within kid #1
304 |        if type(kids[1].typ) == "classtype__state" then {
305 |          typ := (kids[1].typ.st.lookup(kids[2].tok.text)).typ
306 |        } else if type(kids[1].typ) == "arraytype__state" &
307 |                  kids[2].tok.text=="length" then {
308 |          typ := typeinfo("int")
309 |        } else stop("illegal . operator on ",kids[1].typ.str())
310 |       }
311 |     "InstanceCreation": {
312 |       if not (rv := stab.lookup(kids[1].tok.text)) then
313 |         stop("unknown type ",kids[1].tok.text)
314 |       if not (typ := \ (rv.typ)) then
315 |         stop(kids[1].tok.text, " has unknown type")
316 |     }
317 |     "ArrayCreation": typ := arraytype(kids[1].typ)
318 |     "ArrayAccess": {
319 |        if match("array ", kids[1].typ.str()) then {
320 |           if kids[2].typ.str()=="int" then
321 |              typ := kids[1].typ.element_type
322 |           else stop("subscripting array with ",kids[2].typ.str())
323 |           }
324 |        else stop("illegal subscript on type ", kids[1].typ.str())
325 |        }
326 |     "ReturnStmt": {
327 |       # check the return type against the current function
328 |       if not (rt := ( \ (stab.lookup("return")).typ)) then
329 |          stop("stab did not find a returntype")
330 |       if \ (kids[1].typ) then
331 |           typ := check_types(rt, kids[1].typ)
332 |        else { # return; check that return type is void
333 |           if rt.str() ~== "void" then
334 |              stop("void return from non-void method")
335 |           typ := rt
336 |        }
337 |     }
338 |     "token": typ := tok.type(stab)
339 |     "IfThenStmt"|"WhileStmt": { # no checks for j0 statements
340 |     }
341 |     default: { stop("cannot check the type of: ", image(sym)) }
342 |     }
343 |   end
344 |    method get_op()
345 |       return case sym of {
346 |           "ReturnStmt" : "return"
347 |           "MethodCall" : "param"
348 |           "Assignment" : "="
349 |           "AddExpr": if rule=1320 then "+" else "-"
350 |           "RelExpr": {
351 |             if kids[2].sym === "token" then return kids[2].tok.text
352 |             }
353 |           default: fail
354 |       }
355 |    end
356 | 
357 |    method check_types(op1, op2)
358 |       operator := get_op()
359 |       tok := findatoken()
360 |       case operator of {
361 |          "param"|"return"|"="|"+"|"-" : {
362 |             if op1.str() === op2.str() ===
363 |                    ("int"|"double"|"String") then {
364 |                # write("typecheck ",operator," on a ", op1.str(),
365 |                #      " and a ", op2.str(), " -> OK")
366 |                return op1
367 |                }
368 |             else if (op1.basetype===op2.basetype==="array") & operator==="=" &
369 |                     check_types(op1.element_type,op2.element_type) then {
370 |                return op1
371 |                }
372 |             else if (op1.str() == op2.str()) & operator ==="=" then {
373 |                return op1
374 |                }
375 |             else {
376 |                writes(&errout, "line ", (\tok).tok.lineno, ": ")
377 |                j0.semErr("typecheck "||operator||" on a "||
378 | 		      op1.str()|| " and a "|| op2.str()|| " -> FAIL")
379 |               }
380 |             }
381 |          "<"|">": {
382 |             if op1.str() === op2.str() === ("int"|"double") then {
383 |                # write("typecheck ",operator," on a ", op1.str(),
384 |                #      " and a ", op2.str(), " -> OK")
385 |                return typeinfo("bool")
386 |                }
387 |             }
388 |          default: {
389 |             writes(&errout, "line ", (\tok).tok.lineno, ": ")
390 |             j0.semErr("don't know how to check " || image(operator))
391 |             }
392 |         }
393 |    end
394 |   method findatoken()
395 |     if sym==="token" then return self
396 |     return (!kids).findatoken()
397 |   end
398 | method genlabel()
399 |    return address("lab", serial.getid())
400 | end
401 | method genlocal()
402 |    return stab.genlocal()
403 | end
404 | method genfirst()
405 |   every (!\kids).genfirst()
406 |   case sym of {
407 |   "UnaryExpr": first := \kids[2].first | genlabel()
408 |   "AddExpr"|"MulExpr"|"RelExpr": {
409 |      first := (\ (kids[1|2].first)) | genlabel()
410 |      }
411 |   "Block"|"WhileStmt": {
412 |     first := \ (kids[1].first) | genlabel()
413 |   }
414 |   "BlockStmts": {
415 |     / (kids[2].first) := genlabel()
416 |     first := \ (kids[1|2].first) | genlabel()
417 |   }
418 |   # ...
419 |   default: first := (!\kids).first
420 |   }
421 | end
422 | method genfollow()
423 |    case sym of {
424 |    "MethodDecl": {
425 |      kids[2].follow := follow := genlabel()
426 |      }
427 |    "BlockStmts": {
428 |       kids[1].follow := kids[2].first
429 |       kids[2].follow := follow
430 |       }
431 |    "Block": {
432 |       kids[1].follow := follow
433 |       }
434 |    # ...
435 |    }
436 |    every (!\kids).genfollow()
437 | end
438 | 
439 | method gencode()
440 |   every (!\kids).gencode()
441 |   case sym of {
442 |     "ClassDecl": { genClassDecl() }
443 |     "AddExpr": { genAddExpr() }
444 |     "MulExpr": { genMulExpr() }
445 |     "RelExpr": { genRelExpr() }
446 |     "WhileStmt": { genWhileStmt() }
447 |     "IfThenStmt": { genIfThenStmt() }
448 |     "Assignment": { genAssignment() }
449 |     "MethodCall": { genMethodCall() }
450 |     "MethodDecl": { genMethodDecl() }
451 |     "QualifiedName": { genQualifiedName() }
452 |     # ...
453 |     "token":   { gentoken() }
454 |     default: {
455 |        icode := []
456 |        every icode |||:= (!\kids).icode
457 |        }
458 |    }
459 | end
460 | 
461 | method genClassDecl()
462 |   icode := []
463 |   # emit string constants
464 |   if *(stringtab.t)>0 then {
465 |     icode |||:= gen(".string")
466 |     every k := key(stringtab.t) do {
467 |       x := stringtab.lookup(k)
468 | if / (x.addr) then stop("null label in stringtab")
469 |       icode |||:= gen("LAB", x.addr)
470 |       icode |||:= gen("string", address(k))
471 |       }
472 |     }
473 | 
474 |     # emit the globals 
475 |     every k := key(global_st.t) do {
476 |       x := global_st.lookup(k)
477 |       # if type is not a proc...or class or something
478 |       if /first_global then { icode |||:= gen(".global"); first_global := 1 }
479 |       icode |||:= gen("global", x.addr, k)
480 |       }
481 |   icode |||:= gen(".code")
482 |   every icode |||:= (!kids).icode
483 | end
484 | 
485 | method genAssignment()
486 |   addr := kids[1].addr
487 |   icode := [ ]
488 |   every icode |||:= kids[1|3].icode
489 |   icode |||:= gen("ASN", addr, kids[3].addr)
490 | end
491 | 
492 | method genAddExpr()
493 |       addr := genlocal()
494 |       icode := kids[1].icode ||| kids[2].icode |||
495 |               gen(if rule=1320 then "ADD" else "SUB",
496 |                   addr, kids[1].addr, kids[2].addr)
497 | end
498 | 
499 | method genMulExpr()
500 |   addr := genlocal()
501 |   icode := [ ]
502 |   every icode |||:= (!kids).icode
503 |   if rule=1310 then
504 |     icode |||:= gen("MUL", addr, kids[1].addr, kids[2].addr)
505 |   else if rule=1311 then
506 |     icode |||:= gen("DIV", addr, kids[1].addr, kids[2].addr)
507 |   else
508 |     icode |||:= gen("MOD", addr, kids[1].addr, kids[2].addr)
509 | end
510 | 
511 | method genMethodDecl()
512 |    icode := [ ]
513 | 
514 |    icode |||:= gen("proc", address(kids[1].kids[2].kids[1].tok.text, 0))
515 |    every icode |||:= (!kids).icode
516 |    icode |||:= gen("LAB", follow)
517 |    icode |||:= gen("RET")
518 |    icode |||:= gen("end")
519 | end
520 | 
521 | method gentoken()
522 |   icode := []
523 |   case tok.cat of {
524 |     parser.IDENTIFIER: {
525 |        addr := stab.lookup(tok.text).addr }
526 |     parser.INTLIT: { addr := address("imm", tok.ival) }
527 |     parser.STRINGLIT: {
528 |       stringtab.insert(tok.text, 1, &null, typeinfo("string"))
529 |       addr := stringtab.lookup(tok.text).addr
530 |       }
531 |     # ...
532 |     }
533 | end
534 | 
535 | method gentargets()
536 |    case sym of {
537 |    "IfThenStmt"|"WhileStmt": {
538 |       kids[1].onTrue := kids[2].first
539 |       kids[1].onFalse := follow
540 |       }
541 |    "CondAndExpr": {
542 |       kids[1].onTrue := kids[2].first
543 |       kids[1].onFalse := onFalse
544 |       kids[2].onTrue := onTrue
545 |       kids[2].onFalse := onFalse
546 |       }    
547 |    # ...
548 |    }
549 |    every (!\kids).gentargets()
550 | end
551 | 
552 | method genRelExpr()
553 |   op :=  case kids[2].tok.cat of {
554 |     ord("<"): "BLT"; ord(">"): "BGT";
555 |     parser.LESSTHANOREQUAL: "BLE"
556 |     parser.GREATERTHANOREQUAL: "BGT" }
557 |   icode := kids[1].icode ||| kids[3].icode |||
558 |             gen(op, onTrue, kids[1].addr, kids[3].addr) |||
559 |             gen("GOTO", onFalse)
560 | end
561 | 
562 | method genIfThenStmt()
563 | if / (kids[1].first) then stop("null first lab in ifthen")
564 | if / (kids[1].onTrue) then stop("null onTrue lab in ifthen")
565 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
566 |            gen("LAB", kids[1].onTrue) |||
567 |            kids[2].icode
568 | end
569 | 
570 | method genWhileStmt()
571 |   icode := gen("LAB", kids[1].first) ||| kids[1].icode |||
572 |            gen("LAB", kids[1].onTrue) |||
573 |            kids[2].icode ||| gen("GOTO", kids[1].first)
574 | end
575 | 
576 | #  class.member
577 | method genQualifiedName()
578 |    icode := [ ]
579 |    icode |||:= kids[1].icode
580 |    if match("method ",((\ typ).str())) then { # no icode, compile-time method resolution
581 |       addr := kids[1].typ.str() || "__" || kids[2].tok.text
582 |       }
583 |    else {
584 |       addr := genlocal()
585 |       if match("array ", (\ (kids[1].typ)).str()) then { # array.length
586 |          icode |||:= gen("ASIZE", addr, kids[1].addr)
587 |          }
588 |       else if \ (ste := (\ (kids[1].typ)).st.lookup(kids[2].tok.text)) then {
589 |          # lookup address within class
590 |          /(kids[2].addr) := ste.addr
591 |          icode |||:= gen("FIELD", addr, kids[1].addr, kids[2].addr)
592 |       }
593 |    }
594 | end
595 | 
596 | method genMethodCall()
597 |   local nparms := 0
598 |   if k := \ kids[2] then {
599 |     icode := k.icode
600 |     while k.sym === "ArgList" do {
601 |        icode |||:= gen("PARM", k.kids[2].addr)
602 |        k := k.kids[1]; nparms +:= 1
603 |        }
604 |     icode |||:= gen("PARM", k.addr); nparms +:= 1
605 |     }
606 |   else icode := [ ]
607 | 
608 |   # after all parameters, extra parameter for the object.
609 | 
610 |   if kids[1].sym === "QualifiedName" then {
611 |     # icode for a qualifiedname will be non-empty
612 |     icode |||:= kids[1].icode
613 |     # addr for a qualified name will be new temp var
614 |     icode |||:= gen("PARM", kids[1].kids[1].addr)
615 |     }
616 |   else {
617 |     icode |||:= gen("PARM", "self")
618 |     }
619 |   icode |||:= gen("CALL", kids[1].addr, nparms)
620 | end
621 | 
622 | 
623 | method gen(o, o1, o2, o3)
624 |    return [ tac(o, o1, o2, o3) ]
625 | end
626 | 
627 | initially (s,r,x[])
628 |    id := serial.getid(); sym := s; rule := r
629 |    if type(x[1]) == "token__state" then {
630 |       nkids := 0; tok := x[1]
631 |       typ := (\tok).typ
632 |    } else {
633 |       nkids := *x;
634 |       kids := x
635 |    }
636 | end
637 | 


--------------------------------------------------------------------------------
/ch9/tree.java:
--------------------------------------------------------------------------------
  1 | package ch9;
  2 | import java.util.ArrayList;
  3 | import java.io.PrintWriter;
  4 | import java.io.BufferedWriter;
  5 | import java.io.FileWriter;
  6 | class tree {
  7 |   int id, rule, nkids;
  8 |   String sym;
  9 |   token tok;
 10 |   tree kids[];
 11 |   Boolean isConst;
 12 |   symtab stab;
 13 |   typeinfo typ;
 14 |   ArrayList<tac> icode;
 15 |   address addr, first, follow, onTrue, onFalse;
 16 | 
 17 |   public String escape(String s) {
 18 |       if (s.charAt(0) == '\"')
 19 |         return "\\"+s.substring(0, s.length()-1)+"\\\"";
 20 |       else return s;
 21 |   }
 22 | 
 23 |   public String pretty_print_name() {
 24 |     if (tok == null) return sym +"#"+(rule%10);
 25 |     else {
 26 | 	return escape(tok.text)+":"+tok.cat;
 27 | 	}
 28 |     }
 29 | 
 30 |   void print_graph(String filename){
 31 |     try {
 32 |       PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
 33 |       pw.printf("digraph {\n");
 34 |       j = 0;
 35 |       print_graph(pw);
 36 |       pw.printf("}\n");
 37 |       pw.close();
 38 |       }
 39 |     catch (java.io.IOException ioException) {
 40 |       System.err.println("printgraph exception");
 41 |       System.exit(1);
 42 |       }
 43 |     }
 44 | 
 45 |   int j;
 46 |   void print_graph(PrintWriter pw) {
 47 |   int i;
 48 |     if (tok != null) {
 49 | 	print_leaf(pw);
 50 |         return;
 51 |     }
 52 |     // from here on out, we know we are not a leaf
 53 |     print_branch(pw);
 54 |     
 55 |     for(i=0; i<nkids; i++) {
 56 |         if (kids[i] != null) {
 57 |             pw.printf("N%d -> N%d;\n", id, kids[i].id);
 58 | 	    kids[i].print_graph(pw);
 59 |         } else {
 60 | 	    pw.printf("N%d -> N%d_%d;\n", id, id, j);
 61 | 	    pw.printf("N%d%d [label=\"%s\"];\n", id, j, "Empty rule");
 62 | 	    j++;
 63 |         }
 64 |     }
 65 |   }
 66 | 
 67 |   void print_leaf(PrintWriter pw) {
 68 |     String s = parser.yyname[tok.cat];
 69 |     print_branch(pw);
 70 |     pw.printf("N%d [shape=box style=dotted label=\" %s \\n ", id, s, tok.cat);
 71 |     pw.printf("text = %s \\l lineno = %d \\l\"];\n",
 72 | 	      escape(tok.text), tok.lineno);
 73 |   }
 74 | 
 75 |   void print_branch(PrintWriter pw) {
 76 |     pw.printf("N%d ",id);
 77 |     pw.printf("[shape=box label=\"%s",pretty_print_name());
 78 |     if (tok != null)
 79 | 	pw.printf("struct token* leaf %d", tok.id);
 80 |     pw.printf("\"];\n");
 81 |   }
 82 | 
 83 |   public void print(int level) {
 84 |     int i;
 85 |     for(i=0;i<level;i++) System.out.print(" ");
 86 |     if (tok != null) {
 87 |       System.out.println(id + "   " + tok.text +
 88 |                          " (" + tok.cat + "): "+tok.lineno);
 89 |     }
 90 |     else {
 91 |       System.out.println(id + "   " + sym +
 92 | 			 " (" + rule + "): "+nkids);
 93 |     }
 94 |     for(i=0; i<nkids; i++)
 95 |       kids[i].print(level+1);
 96 |   }
 97 |   public void print() {
 98 |     print(0);
 99 |   }
100 | 
101 |   void mkSymTables(symtab curr) {
102 |    stab = curr;
103 |    switch (sym) {
104 |    case "ClassDecl": curr = new symtab("class", curr); break;
105 |    case "MethodDecl": curr = new symtab("method", curr); break;
106 |    }
107 |    for (int i=0; i<nkids; i++) kids[i].mkSymTables(curr);
108 |   }
109 | 
110 |   void populateSymTables() {
111 |     switch(sym) {
112 |     case "ClassDecl":
113 | 	stab.insert(kids[0].tok.text, false, kids[0].stab, null);
114 | 	//		    new classtype(kids[0].tok.text, kids[0].stab));
115 |        break;
116 |     case "FieldDecl": case "LocalVarDecl":
117 |        tree k = kids[1];
118 |        while ((k != null) && k.sym.equals("VarDecls")) {
119 |          insert_vardeclarator(k.kids[1]);
120 |          k = k.kids[0];
121 |          }
122 |        insert_vardeclarator(k); return;
123 |     case "MethodDecl":
124 | 	String s = kids[0].kids[1].kids[0].tok.text;
125 | 	stab.insert(s, false, kids[0].stab, kids[0].kids[1].typ);
126 | 	kids[0].stab.insert("return", false, null, kids[0].kids[0].typ);
127 | 	break;
128 |     case "FormalParm":
129 |       insert_vardeclarator(kids[1]); return;
130 |     }
131 |     if (kids!=null)
132 | 	for(tree k : kids)
133 | 	   if (k!=null)
134 | 	      k.populateSymTables();
135 |   }
136 | 
137 |   void insert_vardeclarator(tree vd) {
138 |     if (vd.tok != null) {
139 |       stab.insert(vd.tok.text, false, null, vd.typ);
140 |       }
141 |     else insert_vardeclarator(vd.kids[0]);
142 |   }
143 | 
144 |   void calc_isConst() {
145 |    for(int i=0; i <nkids; i++)
146 |       kids[i].calc_isConst();
147 |    switch(sym) {
148 |    case "INTLIT": case "DOUBLELIT": case "STRINGLIT":
149 |    case "BOOLFALSE": case "BOOLTRUE": isConst = true; break;
150 |    case "UnaryExpr": isConst = kids[1].isConst; break;
151 |    case "RelExpr":
152 |       isConst = kids[0].isConst && kids[2].isConst; break;
153 |    case "CondOrExpr": case "CondAndExpr":
154 |    case "EqExpr": case "MULEXPR": case "ADDEXPR":
155 |       isConst = kids[0].isConst && kids[1].isConst; break;
156 |    default: isConst = false;
157 |    }
158 |   }
159 | 
160 |   void mkcls() {
161 |     symtab_entry rv;
162 |     if (sym.equals("ClassDecl")) {
163 |       int ms=0, fs=0;
164 |       rv = stab.lookup(kids[0].tok.text);
165 |       for(String k : rv.st.t.keySet()) {
166 | 	  symtab_entry ste = rv.st.t.get(k);
167 | 	  if ((ste.typ.str()).startsWith("method ")) ms++;
168 | 	  else fs++;
169 |       }
170 |       parameter flds[] = new parameter[fs];
171 |       parameter methds[] = new parameter[ms];
172 |       fs=0; ms=0;
173 |       for(String k : rv.st.t.keySet()) {
174 | 	  symtab_entry ste = rv.st.t.get(k);
175 | 	  if ((ste.typ.str()).startsWith("method "))
176 | 	      methds[ms++] = new parameter(k, ste.typ);
177 | 	  else flds[fs++] = new parameter(k, ste.typ);
178 |       }
179 |       rv.typ = new classtype(kids[0].tok.text, rv.st,
180 | 			       flds, methds, new typeinfo[0]);
181 |     }
182 |     else for(int i = 0; i<nkids; i++)
183 |       if (kids[i].nkids>0) kids[i].mkcls();
184 |   }
185 | 
186 |   void checkSymTables() { check_codeblocks(); }
187 |   void check_codeblocks() {
188 |   tree k;
189 |    if (sym.equals("MethodDecl")) { kids[1].check_block(); }
190 |    else {
191 |       for(int i = 0; i<nkids; i++){
192 |          k = kids[i];
193 |          if (k.nkids>0) k.check_codeblocks();
194 |       }
195 |    }
196 |   }
197 | void check_block() {
198 |    switch (sym) {
199 |    case "IDENTIFIER":
200 |      if (stab.lookup(tok.text) == null)
201 |         j0.semErr("undeclared variable " + tok.text);
202 |      break;
203 |    case "FieldAccess": case "QualifiedName":
204 |      kids[0].check_block();
205 |      break;
206 |   case "MethodCall":
207 |       kids[0].check_block();
208 |       if (rule == 1290)
209 |          kids[1].check_block();
210 |       else kids[2].check_block();
211 |       break;
212 |    case "LocalVarDecl": break;
213 |    default:
214 |       for(int i=0;i<nkids;i++)
215 |          kids[i].check_block();
216 |    }
217 |   }
218 | 
219 |   void calctype() {
220 |     for(int i=0; i<nkids; i++) kids[i].calctype();
221 |     switch (sym) {
222 |     case "FieldDecl": typ = kids[0].typ; return;
223 |     case "token":
224 | 	if ((typ = tok.typ) != null) return;
225 | 	switch (tok.cat) {
226 | 	case parser.IDENTIFIER:
227 | 	    if (stab != null) {
228 | 		symtab_entry rv = stab.lookup(tok.text);
229 | 		if (rv != null)
230 | 		    if ((typ = rv.typ) != null) return;
231 | 	    }
232 | 	    typ = new classtype(tok.text);
233 | 	    return;
234 | 	default:
235 | 	  j0.semErr("can't grok the type of " + tok.text + " cat " + tok.cat);
236 | 	}
237 | 	break;
238 |     default: j0.semErr("don't know how to calctype " + sym);
239 |     }
240 |   }
241 | 
242 |   void cksig(methodtype sig) {
243 |     int i = sig.parameters.length, nactual = 1;
244 |     tree t = kids[1];
245 |       if (t == null) {
246 |         if (i != 0) j0.semErr("0 params, expected " + i);
247 |       }
248 |       else {
249 |         while (t.sym.equals("ArgList")) { nactual++; t=t.kids[0]; }
250 | 	if (nactual != i)
251 | 	    j0.semErr(nactual + " parameters, expected "+ i);
252 | 	t = kids[1];
253 | 	i--;
254 | 	while (t.sym.equals("ArgList")) {
255 | 	    check_types(t.kids[1].typ, sig.parameters[i]);
256 | 	    t = t.kids[0];
257 | 	    i--;
258 | 	}
259 | 	check_types(t.typ, sig.parameters[0]);
260 |       }
261 |       typ = sig.return_type;
262 |     }
263 | 
264 |   typeinfo [] mksig() {
265 |   switch (sym) {
266 |     case "FormalParm": return new typeinfo[]{kids[0].typ};
267 |     case "FormalParmList":
268 |       typeinfo ta1[] = kids[0].mksig();
269 |       typeinfo ta2[] = kids[1].mksig();
270 |       typeinfo ta[] = new typeinfo[ta1.length + ta2.length];
271 |       for(int i=0; i<ta1.length; i++) ta[i]=ta1[i];
272 |       for(int j=0; j<ta2.length; j++)
273 | 	ta[ta1.length+j]=ta1[j];
274 |       return ta;
275 |       }
276 |     return null;
277 |   }
278 | 
279 |   void assigntype(typeinfo t) {
280 |     typ = t;
281 |     switch (sym) {
282 |     case "VarDeclarator":
283 |       kids[0].assigntype(new arraytype(t));
284 |       return;
285 |     case "MethodDeclarator": // pass a return type into a method
286 | 	typeinfo parmList[];
287 | 	if (kids[1] != null) parmList = kids[1].mksig();
288 | 	else parmList = new typeinfo [0];
289 | 	kids[0].typ = typ = new methodtype(parmList , t);
290 | 	return;
291 |     case "token":
292 |       switch (tok.cat) {
293 |         case parser.IDENTIFIER: return;
294 |         default: j0.semErr("eh? " + tok.cat);
295 |       }
296 |       break;
297 |       default: j0.semErr("don't know how to assigntype " + sym);
298 |     }
299 |     if(kids!=null) for(tree k : kids) k.assigntype(t);
300 |   }
301 | 
302 |   public boolean checkkids(boolean in_codeblock) {
303 |     switch (sym) {
304 |     case "MethodDecl": { kids[1].checktype(true); return true; }
305 |     case "LocalVarDecl": { kids[1].checktype(false); return true; }
306 |     case "FieldAccess": { kids[0].checktype(in_codeblock);
307 |                           return true; }
308 |     case "QualifiedName":
309 |        kids[0].checktype(in_codeblock); break;
310 |     case "RelExpr": kids[0].checktype(in_codeblock); kids[2].checktype(in_codeblock); break;
311 |     default: if (kids != null) for (tree k : kids)
312 | 	       k.checktype(in_codeblock);
313 |     }
314 |     return false;
315 |   }
316 |     
317 |   public typeinfo dequalify() {
318 |       typeinfo rv = null;
319 |       symtab_entry ste;
320 |       if (kids[0].sym.equals("QualifiedName"))
321 | 	  rv = kids[0].dequalify();
322 |       else if (kids[0].sym.equals("token") &
323 | 	       (kids[0].tok.cat==parser.IDENTIFIER)) {
324 | 	  if ((ste = stab.lookup(kids[0].tok.text)) == null)
325 | 	      j0.semErr("unknown symbol " + kids[0].tok.text);
326 | 	  rv = ste.typ;
327 |       }
328 |       else j0.semErr("can't dequalify " + sym);
329 |       if (!rv.basetype.equals("class"))
330 | 	  j0.semErr("can't dequalify " + rv.basetype);
331 |       ste = ((classtype)rv).st.lookup(kids[1].tok.text);
332 |       if (ste != null) return ste.typ;
333 |       j0.semErr("couldn't lookup " + kids[1].tok.text +
334 | 		  " in " + rv.str());
335 |       return null;
336 |   }
337 | 
338 |   void checktype(boolean in_codeblock) {
339 |     if (checkkids(in_codeblock)) return;
340 |     if (! in_codeblock) return;
341 |     switch (sym) {
342 |     case "Assignment": typ = check_types(kids[0].typ, kids[2].typ); break;
343 |     case "AddExpr": typ = check_types(kids[0].typ, kids[1].typ); break;
344 |     case "RelExpr": typ = check_types(kids[0].typ, kids[2].typ); break;
345 |     case "ArgList": case "Block": case "BlockStmts": typ = null; break;
346 |     case "MethodCall":
347 |       if (rule == 1290) {
348 |         symtab_entry rve;
349 |         methodtype rv;
350 |         if (kids[0].sym.equals("QualifiedName")) {
351 |           rv = (methodtype)(kids[0].dequalify());
352 |           cksig(rv);
353 |           }
354 |         else {
355 |           if (!kids[0].sym.equals("token"))
356 |             j0.semErr("can't check type of " + kids[0].sym);
357 |           if (kids[0].tok.cat == parser.IDENTIFIER) {
358 |             System.out.println("checking the type of a call to " +
359 |                                kids[0].tok.text);
360 |             if ((rve = stab.lookup(kids[0].tok.text)) != null) {
361 |   	    if (! (rve.typ instanceof methodtype))
362 |               j0.semErr("method expected, got " + rve.typ.str());
363 | 	    rv = (methodtype)rve.typ;
364 |             cksig(rv);
365 |             }
366 |           }
367 |           else j0.semErr("can't typecheck token " + kids[0].tok.cat);
368 |           }
369 |         }
370 |       else j0.semErr("Jzero does not handle complex calls");
371 |       break;
372 |     case "QualifiedName":
373 | 	if (kids[0].typ instanceof classtype) {
374 | 	  classtype ct = (classtype)(kids[0].typ);
375 |           typ = (ct.st.lookup(kids[1].tok.text)).typ;
376 | 	  }
377 |         else if (kids[0].typ instanceof arraytype) {
378 |           typ = new typeinfo("int");
379 |           }
380 |         else j0.semErr("illegal . on  " + kids[0].typ.str());
381 | 	break;
382 |     case "InstanceCreation": {
383 |       symtab_entry rv;
384 |       if ((rv = stab.lookup(kids[0].tok.text))==null)
385 |         j0.semErr("unknown type " + kids[0].tok.text);
386 |       if ((typ = rv.typ) == null)
387 |         j0.semErr(kids[0].tok.text + " has unknown type");
388 |       break;
389 |     }
390 |     case "ArrayCreation":
391 | 	typ = new arraytype(kids[0].typ); break;
392 |     case "ArrayAccess":
393 | 	if (kids[0].typ.str().startsWith("array ")) {
394 | 	    if (kids[1].typ.str().equals("int"))
395 | 		typ = ((arraytype)(kids[0].typ)).element_type;
396 | 	    else j0.semErr("subscripting array with "+kids[1].typ.str());
397 |           }
398 | 	else j0.semErr("illegal subscript on type "+ kids[0].typ.str());
399 | 	break;
400 |     case "ReturnStmt":
401 |       symtab_entry ste;
402 |       if ((ste=stab.lookup("return")) == null)
403 |          j0.semErr("stab did not find a returntype");
404 |       typeinfo rt = ste.typ;
405 |       if (kids[0].typ != null)
406 |           typ = check_types(rt, kids[0].typ);
407 |       else { // return; check that return type is void
408 |           if (!rt.str().equals("void"))
409 | 	      j0.semErr("void return from non-void method");
410 | 	  typ = rt;		    
411 |           }
412 |       break;
413 |     case "token": typ = tok.type(stab); break;
414 |     case "IfThenStmt": case "WhileStmt": { // no checks for j0 statements
415 | 	break;
416 |     }
417 |     default: j0.semErr("cannot check type of " + sym);
418 |     }
419 |   }
420 | 
421 |    public String get_op() {
422 |      switch (sym) {
423 |      case "ReturnStmt" : return "return";
424 |      case "MethodCall" : return "param";
425 |      case "Assignment" : return "=";
426 |      case "AddExpr": if (rule==1320) return "+"; else return "-";
427 |      case "RelExpr": {
428 |         if (kids[1].sym.equals("token")) return kids[1].tok.text;
429 |         }
430 |      default: return null;
431 |      }
432 |    }
433 | 
434 |    public typeinfo check_types(typeinfo op1, typeinfo op2) {
435 |      String operator = get_op();
436 |      switch (operator) {
437 |      case "param": case "return": case "=": case "+": case"-": {
438 |        tree tk;
439 |        tk = findatoken();
440 |        if (op1.str().equals(op2.str()) &&
441 | 	   (op1.str().equals("int") ||
442 | 	    op1.str().equals("double") ||
443 | 	    op1.str().equals("String"))) {
444 | 	   // System.out.println("typecheck "+operator+" on a "+ op1.str()+
445 | 	   //		    " and a "+ op2.str()+ " -> OK");
446 | 	 return op1;
447 | 	 }
448 |        else if (op1.basetype.equals("array") &&
449 |                 op2.basetype.equals("array") &&
450 |                 operator.equals("=") &&
451 |                 (check_types(((arraytype)op1).element_type,
452 | 			     ((arraytype)op2).element_type) != null)) {
453 |                 return op1;
454 |                }
455 |        else if (op1.str().equals(op2.str()) & operator.equals("=")) {
456 | 	  return op1;
457 |                }
458 |        else {
459 | 	  if (tk!=null) System.err.print("line " + tk.tok.lineno + ": ");
460 | 	  j0.semErr("typecheck "+operator+" on a "+ op2.str()+
461 | 		     " and a "+ op1.str()+ " -> FAIL");
462 |        }
463 |        break;
464 |        }
465 |        case "<": case ">": {
466 | 	   if (op1.str().equals(op2.str()) &&
467 | 	       (op1.str().equals("int") ||
468 | 		op1.str().equals("double"))) {
469 | 		    return new typeinfo("bool");
470 |                }
471 |         }
472 |      default: j0.semErr("don't know how to check " + operator);
473 |      }
474 |    return null;
475 |    }
476 |    public tree findatoken() {
477 |      tree rv;
478 |      if (sym=="token") return this;
479 |      if (kids != null)
480 |      for (tree t : kids) if ((rv=t.findatoken()) != null) return rv;
481 |      return null;
482 |    }
483 |   address genlabel() {
484 |     return new address("lab", serial.getid());
485 |   }
486 |   address genlocal() {
487 | 	return stab.genlocal();
488 |   }
489 | void genfirst() {
490 |   if (kids != null) for(tree k : kids) k.genfirst();
491 |   switch (sym) {
492 |   case "UnaryExpr": {
493 |       if (kids[1].first != null) first = kids[1].first;
494 |       else first = genlabel();
495 |       break;
496 |   }
497 |   case "AddExpr": case "MulExpr": case "RelExpr": {
498 |       if (kids[0].first != null) first = kids[0].first;
499 |       else if (kids[1].first != null) first = kids[1].first;
500 |       else first = genlabel();
501 |       break;
502 |       }
503 |   case "Block": case "WhileStmt": {
504 |       if (kids[0].first != null) first = kids[0].first;
505 |       else first = genlabel();
506 |       break;
507 |       }
508 |   case "BlockStmts": {
509 |     if (kids[1].first == null) kids[1].first = genlabel();
510 |     if (kids[0].first != null) first = kids[0].first;
511 |     else first = kids[1].first;
512 |     break;
513 |   }
514 |     // ...
515 |   default: {
516 |       if (kids != null)
517 | 	  for(tree k : kids)
518 | 	      if (k.first != null) { first = k.first; break; }
519 |       }
520 |    }
521 | }
522 | 
523 | void genfollow() {
524 |   switch (sym) {
525 |    case "MethodDecl": {
526 |      kids[1].follow = follow = genlabel();
527 |      break;
528 |      }
529 |    case "BlockStmts": {
530 |       kids[0].follow = kids[1].first;
531 |       kids[1].follow = follow;
532 |       break;
533 |       }
534 |    case "Block": {
535 |       kids[0].follow = follow;
536 |       }
537 |    // ...
538 |    }
539 |   if (kids != null) for(tree k : kids) k.genfollow();
540 | }
541 | 
542 | void gencode() {
543 |   if (kids != null) for(tree k : kids) k.gencode();
544 |   switch (sym) {
545 |   case "ClassDecl": { genClassDecl(); break; }
546 |   case "AddExpr": { genAddExpr(); break; }
547 |   case "MulExpr": { genMulExpr(); break; }
548 |   case "RelExpr": { genRelExpr(); break; }
549 |   case "WhileStmt": { genWhileStmt(); break; }
550 |   case "IfThenStmt": { genIfThenStmt(); break; }
551 |   case "Assignment": { genAssignment(); break; }
552 |   case "MethodCall": { genMethodCall(); break; }
553 |   case "MethodDecl": { genMethodDecl(); break; }
554 |   case "QualifiedName": { genQualifiedName(); break; }
555 |   // ...
556 |   case "token": { gentoken(); break; }
557 |   default: {
558 |     icode = new ArrayList<tac>();
559 |     if (kids != null) for(tree k : kids) icode.addAll(k.icode);
560 |     }
561 |   }
562 | }
563 | 
564 | void genClassDecl() {
565 |   int first_global;
566 |   first_global = 0;
567 |   icode = new ArrayList<tac>();
568 |   // emit string constants
569 |   if (j0.stringtab.t.size()>0) {
570 |      icode.addAll( gen(".string") );
571 |      for(String k : j0.stringtab.t.keySet()) {
572 | 	 symtab_entry ste = j0.stringtab.t.get(k);
573 | 	 if (ste.addr == null) {
574 | 	     System.err.println("null label in stringtab");
575 | 	     System.exit(1);
576 | 	 }
577 |          icode.addAll( gen("LAB", ste.addr));
578 |          icode.addAll( gen("string", new address(k, 0)) );
579 |         }
580 |       }
581 | 
582 |   // emit the globals 
583 |   for(String k : j0.global_st.t.keySet()) {
584 |       symtab_entry ste = j0.global_st.t.get(k);
585 |       // if type is not a proc...or class or something
586 |       if (first_global == 0) {
587 | 	  icode.addAll( gen(".global") ); first_global = 1; }
588 |           icode.addAll( gen("global", ste.addr, new address(k,0)) );
589 |         }
590 |   icode.addAll( gen(".code") );
591 |   if (kids != null) for(tree k: kids) icode.addAll(k.icode);
592 | }
593 | 
594 | void genAssignment() {
595 |   addr = kids[0].addr;
596 |   icode = new ArrayList<tac>();
597 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
598 |   icode.addAll(gen("ASN", addr, kids[2].addr));
599 | }
600 | 
601 | void genAddExpr() {
602 |   addr = genlocal();
603 |   icode = new ArrayList<tac>();
604 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
605 |   icode.addAll(gen(((rule==1320)?"ADD":"SUB"), addr,
606 |                    kids[0].addr, kids[1].addr));
607 | }
608 | 
609 | void genMulExpr() {
610 |   addr = genlocal();
611 |   icode = new ArrayList<tac>();
612 |   icode.addAll(kids[0].icode); icode.addAll(kids[1].icode);
613 |   if (rule==1310)
614 |     icode.addAll(gen("MUL", addr, kids[0].addr, kids[1].addr));
615 |   else if (rule==1311)
616 |     icode.addAll(gen("DIV", addr, kids[0].addr, kids[1].addr));
617 |   else
618 |     icode.addAll(gen("MOD", addr, kids[0].addr, kids[1].addr));
619 | }
620 | 
621 | void genMethodDecl() {
622 |     icode = new ArrayList<tac>();
623 |     icode.addAll(gen("proc", new address(kids[0].kids[1].kids[0].tok.text, 0)));
624 |     for(tree k : kids) icode.addAll(k.icode);
625 |     icode.addAll(gen("LAB", follow));
626 |     icode.addAll(gen("RET"));
627 |     icode.addAll(gen("end"));
628 | }
629 | 
630 | void gentoken() {
631 |   icode = new ArrayList<tac>();
632 |   switch (tok.cat) {
633 |     case parser.IDENTIFIER: {
634 |       symtab_entry ste;
635 |       ste = stab.lookup(tok.text);
636 |       if (ste != null) {
637 | 	  addr = ste.addr;
638 |       }
639 |       break;
640 |       }
641 |     case parser.INTLIT: {
642 |       addr = new address("imm", Integer.parseInt(tok.text)); break; }
643 |     case parser.STRINGLIT: {
644 |       j0.stringtab.insert(tok.text, true, null, new typeinfo("string"));
645 |       addr = j0.stringtab.lookup(tok.text).addr;
646 |       }
647 |     // ...
648 |     }
649 | }
650 | 
651 | void gentargets() {
652 |    switch (sym) {
653 |    case "IfThenStmt": case "WhileStmt": {
654 |       kids[0].onTrue = kids[1].first;
655 |       kids[0].onFalse = follow;
656 |       break;
657 |       }
658 |    case "CondAndExpr": {
659 |       kids[0].onTrue = kids[1].first;
660 |       kids[0].onFalse = onFalse;
661 |       kids[1].onTrue = onTrue;
662 |       kids[1].onFalse = onFalse;
663 |       break;
664 |       }    
665 |    // ...
666 |    }
667 |    if (kids!=null) for (tree k:kids) k.gentargets();
668 | }
669 | 
670 | void genRelExpr() {
671 |   String op = "ERROR";
672 |   switch (kids[1].tok.cat) {
673 |     case '<': op="BLT"; break; case '>': op="BGT"; break;
674 |     case parser.LESSTHANOREQUAL: op="BLE"; break;
675 |     case parser.GREATERTHANOREQUAL: op="BGE";
676 |     }
677 |   icode = new ArrayList<tac>();
678 |   icode.addAll(kids[0].icode); icode.addAll(kids[2].icode);
679 |   icode.addAll(gen(op, onTrue, kids[0].addr, kids[2].addr));
680 |   icode.addAll(gen("GOTO", onFalse));
681 | }
682 | 
683 | void genIfThenStmt() {
684 |   icode = new ArrayList<tac>();
685 |   icode.addAll(kids[0].icode);
686 |   icode.addAll(gen("LAB", kids[0].onTrue));
687 |   icode.addAll(kids[1].icode);
688 | }
689 | 
690 | void genWhileStmt() {
691 |   icode = new ArrayList<tac>();
692 |   icode.addAll(gen("LAB", kids[0].first));
693 |   icode.addAll(kids[0].icode);
694 |   icode.addAll(gen("LAB", kids[0].onTrue));
695 |   icode.addAll(kids[1].icode);
696 |   icode.addAll(gen("GOTO", kids[0].first));
697 | }
698 | 
699 | void genQualifiedName() {
700 |   symtab_entry ste;
701 |   classtype ct;
702 |   icode = new ArrayList<tac>();
703 |   icode.addAll( kids[0].icode );
704 |   if (typ != null && typ instanceof methodtype) {// no icode, compile-time method resolution
705 |       addr = new address(kids[0].typ.str() + "__" + kids[1].tok.text, 0);
706 |       }
707 |    else {
708 |       addr = genlocal();
709 |       if (kids[0].typ instanceof arraytype) { // array.length
710 | 	  icode.addAll( gen("ASIZE", addr, kids[0].addr) );
711 |       }
712 |       else if ((kids[0].typ != null) && (kids[0].typ instanceof classtype) &&
713 | 	       ((ct = (classtype)(kids[0].typ)) != null) &&
714 | 	       ((ste=ct.st.lookup(kids[1].tok.text)) != null)) {
715 | 	  // lookup address within class
716 | 	  if (kids[1].addr == null) kids[1].addr = ste.addr;
717 | 	  icode.addAll( gen("FIELD", addr, kids[0].addr, kids[1].addr));
718 |       }
719 |    }
720 | }
721 | 
722 | void genMethodCall() {
723 |   int nparms = 0;
724 |   icode = new ArrayList<tac>();
725 |   if (kids[1] != null) {
726 |     icode.addAll(kids[1].icode);
727 |     tree k = kids[1];
728 |     while (k.sym.equals("ArgList")) {
729 |       icode.addAll(gen("PARM", k.kids[1].addr));
730 |       k = k.kids[0]; nparms++; }
731 |     icode.addAll(gen("PARM", k.addr)); nparms++;
732 |     }
733 |   if (kids[0].sym.equals("QualifiedName")) {
734 |     icode.addAll(kids[0].icode);
735 |     icode.addAll(gen("PARM", kids[0].kids[0].addr));
736 |   }
737 |   else icode.addAll(gen("PARM", new address("self",0)));
738 |   icode.addAll(gen("CALL", kids[0].addr, new address("imm",nparms)));
739 | }
740 | 
741 | 
742 | ArrayList<tac> gen(String o, address ... a) {
743 |   ArrayList<tac> L = new ArrayList<tac>();
744 |   tac t = null;
745 |   switch(a.length) {
746 |     case 3: t = new tac(o, a[0], a[1], a[2]); break;
747 |     case 2: t = new tac(o, a[0], a[1]); break;
748 |     case 1: t = new tac(o, a[0]); break;
749 |     case 0: t = new tac(o); break;
750 |     default: j0.semErr("gen(): wrong # of arguments");
751 |   }
752 |   L.add(t);
753 |   return L;
754 | }
755 | 
756 |    public tree(String s, int r, token t) {
757 | 	id = serial.getid();
758 |         sym = s; rule = r; tok = t; if (tok!=null) typ = tok.typ; }
759 | 
760 |     public tree(String s, int r, tree[] t) {
761 | 	id = serial.getid();
762 | 	//	System.out.println("id " + id + " goes to " + s + "(" +r+")");
763 | 	sym = s; rule = r; nkids = t.length;
764 | 	kids = t;
765 |     }
766 | }
767 | 


--------------------------------------------------------------------------------
/ch9/typeinfo.icn:
--------------------------------------------------------------------------------
 1 | class typeinfo(basetype)
 2 |    method str()
 3 |       return string(basetype)|"unknown"
 4 |    end
 5 | end
 6 | class arraytype : typeinfo(element_type)
 7 |    method str()
 8 |       return "array of " || (\element_type).str()
 9 |    end
10 | initially
11 |    basetype := "array"
12 | end
13 | class methodtype : typeinfo(parameters,return_type)
14 |    method str()
15 |       s := "method " || ((\return_type).str()|"undef") || "("
16 |       every s ||:= (!parameters).str() do s ||:= ","
17 |       s[-1] := ")"
18 |       return s
19 |    end
20 | initially
21 |    basetype := "method"
22 |    /parameters := []
23 |    /return_type := typeinfo("void")
24 | end
25 | class classtype : typeinfo(name, st, fields, methods, constrs)
26 |    method str()
27 |       return name
28 |    end
29 | initially
30 |    basetype := "class"
31 |    /st := symtab("class",global_st)
32 |    /fields := []
33 |    /methods := []
34 |    /constrs := []
35 | end
36 | class parameter(name, element_type)
37 | end
38 | 


--------------------------------------------------------------------------------
/ch9/typeinfo.java:
--------------------------------------------------------------------------------
1 | package ch9;
2 | public class typeinfo {
3 |    String basetype;
4 |    public typeinfo() { basetype = "unknown"; }
5 |    public typeinfo(String s) { basetype = s; }
6 |    public String str() { return basetype; }
7 | }
8 | 


--------------------------------------------------------------------------------
/ch9/xy5.java:
--------------------------------------------------------------------------------
1 | public class xy5 {
2 |    static double y = 5.0;
3 |    public static void main(String argv[]) {
4 |        int x;
5 |        x = (int)y + 5;
6 |       System.out.println("y + 5 = " + x);
7 |    }
8 | }
9 | 


--------------------------------------------------------------------------------
/ch9/yyerror.icn:
--------------------------------------------------------------------------------
1 | procedure yyerror(s)
2 |     writes(&errout, yylineno, ": ", image(yytext),": ")
3 |     stop(s)
4 | end
5 | 


--------------------------------------------------------------------------------
/ch9/yyerror.java:
--------------------------------------------------------------------------------
 1 | package ch9;
 2 | public class yyerror {
 3 |     static int yyerror_isinitialized;
 4 |     static int yymaxstate = 1;
 5 |     static yyerror singleton;
 6 |     class errortable {
 7 | 	// i == # of entries
 8 | 	// if i == 1 then use msg else use p[j].msg where p[j].i == yychar
 9 | 	public int i; public String msg; public errortable p[];
10 | 	errortable(int ii, String m) {
11 | 	    i = ii; msg = m;
12 | 	}
13 | 	errortable(int ii, String m, int n) {
14 | 	    i = ii; msg = m; p = new errortable[n];
15 | 	}
16 |     }
17 |     static errortable errtab[];
18 |     static int __merr_errors;
19 |     public yyerror() {
20 | 	System.out.println("yyerror called, yystate is " + j0.par.yystate);
21 | 	errtab = new errortable[1];
22 | 	errtab[0] = new errortable(1, "semi-colon expected");
23 |     }
24 |     public static void yyerror(String s) {
25 | 	//      if (singleton == null) singleton = new yyerror();
26 | 	//      if (s.indexOf("stack") != -1) {
27 |          System.err.println(s);
28 |          System.exit(1);
29 | 	 //      }
30 |       if (__merr_errors++ > 10) {
31 | 	  System.err.println("too many errors, aborting");
32 | 	  System.exit(__merr_errors);
33 |       }
34 |       if (j0.yyfilename != null) {
35 |       	  System.err.print(j0.yyfilename+":");
36 |       }
37 |       int state = j0.par.yystate;
38 |       if (state > yymaxstate) {
39 | 	  int j;
40 | 	  errortable et[] = new errortable[state+1];
41 | 	  for (j = 0; j < yymaxstate; j++)
42 | 	      et[j] = errtab[j];
43 | 	  //	  for (; j <= state; j++) {
44 | 	  //	      et[j] = new errortable(1, "syntax error");
45 | 	  //	  }
46 | 	  errtab = et;
47 | 	  yymaxstate = state;
48 |       }
49 | 
50 |       if ((s.equals("syntax error") || s.equals("parse error")) &&
51 |       	  (state >= 0) && (state <= yymaxstate)) {
52 | 	  if (errtab[state].i == 1) {
53 |       	      s = errtab[state].msg;
54 |       	  }
55 |       	  else {
56 | 	      int i;
57 |       	      for(i=1;i<=errtab[state].i;i++)
58 |       		  if (j0.par.yychar == errtab[state].p[i].i) {
59 |              	      s=errtab[state].p[i].msg; break;
60 |       		  }
61 | 	      if (i>errtab[state].i && errtab[state].i > 0)
62 | 		  s = errtab[state].p[0].msg;
63 | 	  }
64 |       }
65 |       if (s.equals("syntax error") || s.equals("parse error")) {
66 |       	  s = s+" ("+state+";"+j0.par.yychar+")";
67 |       }
68 |       System.err.println(j0.yylineno+": # \\\"" + j0.yytext() + "\\\": "+s);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------